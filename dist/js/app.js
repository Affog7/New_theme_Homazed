/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@barba/core/dist/barba.umd.js":
/*!****************************************************!*\
  !*** ./node_modules/@barba/core/dist/barba.umd.js ***!
  \****************************************************/
/***/ (function(module) {

eval("!function(t,n){ true?module.exports=n():0}(this,function(){function t(t,n){for(var r=0;r<n.length;r++){var i=n[r];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,\"symbol\"==typeof(e=function(t,n){if(\"object\"!=typeof t||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var i=r.call(t,\"string\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(t)}(i.key))?e:String(e),i)}var e}function n(n,r,i){return r&&t(n.prototype,r),i&&t(n,i),Object.defineProperty(n,\"prototype\",{writable:!1}),n}function r(){return r=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t},r.apply(this,arguments)}function i(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,o(t,n)}function e(t){return e=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},e(t)}function o(t,n){return o=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,n){return t.__proto__=n,t},o(t,n)}function u(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(t){return!1}}function s(t,n,r){return s=u()?Reflect.construct.bind():function(t,n,r){var i=[null];i.push.apply(i,n);var e=new(Function.bind.apply(t,i));return r&&o(e,r.prototype),e},s.apply(null,arguments)}function f(t){var n=\"function\"==typeof Map?new Map:void 0;return f=function(t){if(null===t||-1===Function.toString.call(t).indexOf(\"[native code]\"))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==n){if(n.has(t))return n.get(t);n.set(t,r)}function r(){return s(t,arguments,e(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),o(r,t)},f(t)}function c(t){if(void 0===t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return t}var a,h=function(){this.before=void 0,this.beforeLeave=void 0,this.leave=void 0,this.afterLeave=void 0,this.beforeEnter=void 0,this.enter=void 0,this.afterEnter=void 0,this.after=void 0};!function(t){t[t.off=0]=\"off\",t[t.error=1]=\"error\",t[t.warning=2]=\"warning\",t[t.info=3]=\"info\",t[t.debug=4]=\"debug\"}(a||(a={}));var v=a.off,d=/*#__PURE__*/function(){function t(t){this.t=void 0,this.t=t}t.getLevel=function(){return v},t.setLevel=function(t){return v=a[t]};var n=t.prototype;return n.error=function(){this.i(console.error,a.error,[].slice.call(arguments))},n.warn=function(){this.i(console.warn,a.warning,[].slice.call(arguments))},n.info=function(){this.i(console.info,a.info,[].slice.call(arguments))},n.debug=function(){this.i(console.log,a.debug,[].slice.call(arguments))},n.i=function(n,r,i){r<=t.getLevel()&&n.apply(console,[\"[\"+this.t+\"] \"].concat(i))},t}();function l(t){return t.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g,\"\\\\$1\")}function p(t){return t&&t.sensitive?\"\":\"i\"}var m={container:\"container\",history:\"history\",namespace:\"namespace\",prefix:\"data-barba\",prevent:\"prevent\",wrapper:\"wrapper\"},w=/*#__PURE__*/function(){function t(){this.o=m,this.u=void 0,this.h={after:null,before:null,parent:null}}var n=t.prototype;return n.toString=function(t){return t.outerHTML},n.toDocument=function(t){return this.u||(this.u=new DOMParser),this.u.parseFromString(t,\"text/html\")},n.toElement=function(t){var n=document.createElement(\"div\");return n.innerHTML=t,n},n.getHtml=function(t){return void 0===t&&(t=document),this.toString(t.documentElement)},n.getWrapper=function(t){return void 0===t&&(t=document),t.querySelector(\"[\"+this.o.prefix+'=\"'+this.o.wrapper+'\"]')},n.getContainer=function(t){return void 0===t&&(t=document),t.querySelector(\"[\"+this.o.prefix+'=\"'+this.o.container+'\"]')},n.removeContainer=function(t){document.body.contains(t)&&(this.v(t),t.parentNode.removeChild(t))},n.addContainer=function(t,n){var r=this.getContainer()||this.h.before;r?this.l(t,r):this.h.after?this.h.after.parentNode.insertBefore(t,this.h.after):this.h.parent?this.h.parent.appendChild(t):n.appendChild(t)},n.getSibling=function(){return this.h},n.getNamespace=function(t){void 0===t&&(t=document);var n=t.querySelector(\"[\"+this.o.prefix+\"-\"+this.o.namespace+\"]\");return n?n.getAttribute(this.o.prefix+\"-\"+this.o.namespace):null},n.getHref=function(t){if(t.tagName&&\"a\"===t.tagName.toLowerCase()){if(\"string\"==typeof t.href)return t.href;var n=t.getAttribute(\"href\")||t.getAttribute(\"xlink:href\");if(n)return this.resolveUrl(n.baseVal||n)}return null},n.resolveUrl=function(){var t=[].slice.call(arguments).length;if(0===t)throw new Error(\"resolveUrl requires at least one argument; got none.\");var n=document.createElement(\"base\");if(n.href=arguments[0],1===t)return n.href;var r=document.getElementsByTagName(\"head\")[0];r.insertBefore(n,r.firstChild);for(var i,e=document.createElement(\"a\"),o=1;o<t;o++)e.href=arguments[o],n.href=i=e.href;return r.removeChild(n),i},n.l=function(t,n){n.parentNode.insertBefore(t,n.nextSibling)},n.v=function(t){return this.h={after:t.nextElementSibling,before:t.previousElementSibling,parent:t.parentElement},this.h},t}(),b=new w,y=/*#__PURE__*/function(){function t(){this.p=void 0,this.m=[],this.P=-1}var i=t.prototype;return i.init=function(t,n){this.p=\"barba\";var r={data:{},ns:n,scroll:{x:window.scrollX,y:window.scrollY},url:t};this.P=0,this.m.push(r);var i={from:this.p,index:this.P,states:[].concat(this.m)};window.history&&window.history.replaceState(i,\"\",t)},i.change=function(t,n,r){if(r&&r.state){var i=r.state,e=i.index;n=this.g(this.P-e),this.replace(i.states),this.P=e}else this.add(t,n);return n},i.add=function(t,n,r,i){var e=null!=r?r:this.R(n),o={data:null!=i?i:{},ns:\"tmp\",scroll:{x:window.scrollX,y:window.scrollY},url:t};switch(e){case\"push\":this.P=this.size,this.m.push(o);break;case\"replace\":this.set(this.P,o)}var u={from:this.p,index:this.P,states:[].concat(this.m)};switch(e){case\"push\":window.history&&window.history.pushState(u,\"\",t);break;case\"replace\":window.history&&window.history.replaceState(u,\"\",t)}},i.store=function(t,n){var i=n||this.P,e=this.get(i);e.data=r({},e.data,t),this.set(i,e);var o={from:this.p,index:this.P,states:[].concat(this.m)};window.history.replaceState(o,\"\")},i.update=function(t,n){var i=n||this.P,e=r({},this.get(i),t);this.set(i,e)},i.remove=function(t){t?this.m.splice(t,1):this.m.pop(),this.P--},i.clear=function(){this.m=[],this.P=-1},i.replace=function(t){this.m=t},i.get=function(t){return this.m[t]},i.set=function(t,n){return this.m[t]=n},i.R=function(t){var n=\"push\",r=t,i=m.prefix+\"-\"+m.history;return r.hasAttribute&&r.hasAttribute(i)&&(n=r.getAttribute(i)),n},i.g=function(t){return Math.abs(t)>1?t>0?\"forward\":\"back\":0===t?\"popstate\":t>0?\"back\":\"forward\"},n(t,[{key:\"current\",get:function(){return this.m[this.P]}},{key:\"previous\",get:function(){return this.P<1?null:this.m[this.P-1]}},{key:\"size\",get:function(){return this.m.length}}]),t}(),P=new y,g=function(t,n){try{var r=function(){if(!n.next.html)return Promise.resolve(t).then(function(t){var r=n.next;if(t){var i=b.toElement(t.html);r.namespace=b.getNamespace(i),r.container=b.getContainer(i),r.url=t.url,r.html=t.html,P.update({ns:r.namespace});var e=b.toDocument(t.html);document.title=e.title}})}();return Promise.resolve(r&&r.then?r.then(function(){}):void 0)}catch(t){return Promise.reject(t)}},E=function t(n,r,i){return n instanceof RegExp?function(t,n){if(!n)return t;for(var r=/\\((?:\\?<(.*?)>)?(?!\\?)/g,i=0,e=r.exec(t.source);e;)n.push({name:e[1]||i++,prefix:\"\",suffix:\"\",modifier:\"\",pattern:\"\"}),e=r.exec(t.source);return t}(n,r):Array.isArray(n)?function(n,r,i){var e=n.map(function(n){return t(n,r,i).source});return new RegExp(\"(?:\".concat(e.join(\"|\"),\")\"),p(i))}(n,r,i):function(t,n,r){return function(t,n,r){void 0===r&&(r={});for(var i=r.strict,e=void 0!==i&&i,o=r.start,u=void 0===o||o,s=r.end,f=void 0===s||s,c=r.encode,a=void 0===c?function(t){return t}:c,h=r.delimiter,v=void 0===h?\"/#?\":h,d=r.endsWith,m=\"[\".concat(l(void 0===d?\"\":d),\"]|$\"),w=\"[\".concat(l(v),\"]\"),b=u?\"^\":\"\",y=0,P=t;y<P.length;y++){var g=P[y];if(\"string\"==typeof g)b+=l(a(g));else{var E=l(a(g.prefix)),x=l(a(g.suffix));if(g.pattern)if(n&&n.push(g),E||x)if(\"+\"===g.modifier||\"*\"===g.modifier){var R=\"*\"===g.modifier?\"?\":\"\";b+=\"(?:\".concat(E,\"((?:\").concat(g.pattern,\")(?:\").concat(x).concat(E,\"(?:\").concat(g.pattern,\"))*)\").concat(x,\")\").concat(R)}else b+=\"(?:\".concat(E,\"(\").concat(g.pattern,\")\").concat(x,\")\").concat(g.modifier);else b+=\"+\"===g.modifier||\"*\"===g.modifier?\"((?:\".concat(g.pattern,\")\").concat(g.modifier,\")\"):\"(\".concat(g.pattern,\")\").concat(g.modifier);else b+=\"(?:\".concat(E).concat(x,\")\").concat(g.modifier)}}if(f)e||(b+=\"\".concat(w,\"?\")),b+=r.endsWith?\"(?=\".concat(m,\")\"):\"$\";else{var k=t[t.length-1],O=\"string\"==typeof k?w.indexOf(k[k.length-1])>-1:void 0===k;e||(b+=\"(?:\".concat(w,\"(?=\").concat(m,\"))?\")),O||(b+=\"(?=\".concat(w,\"|\").concat(m,\")\"))}return new RegExp(b,p(r))}(function(t,n){void 0===n&&(n={});for(var r=function(t){for(var n=[],r=0;r<t.length;){var i=t[r];if(\"*\"!==i&&\"+\"!==i&&\"?\"!==i)if(\"\\\\\"!==i)if(\"{\"!==i)if(\"}\"!==i)if(\":\"!==i)if(\"(\"!==i)n.push({type:\"CHAR\",index:r,value:t[r++]});else{var e=1,o=\"\";if(\"?\"===t[s=r+1])throw new TypeError('Pattern cannot start with \"?\" at '.concat(s));for(;s<t.length;)if(\"\\\\\"!==t[s]){if(\")\"===t[s]){if(0==--e){s++;break}}else if(\"(\"===t[s]&&(e++,\"?\"!==t[s+1]))throw new TypeError(\"Capturing groups are not allowed at \".concat(s));o+=t[s++]}else o+=t[s++]+t[s++];if(e)throw new TypeError(\"Unbalanced pattern at \".concat(r));if(!o)throw new TypeError(\"Missing pattern at \".concat(r));n.push({type:\"PATTERN\",index:r,value:o}),r=s}else{for(var u=\"\",s=r+1;s<t.length;){var f=t.charCodeAt(s);if(!(f>=48&&f<=57||f>=65&&f<=90||f>=97&&f<=122||95===f))break;u+=t[s++]}if(!u)throw new TypeError(\"Missing parameter name at \".concat(r));n.push({type:\"NAME\",index:r,value:u}),r=s}else n.push({type:\"CLOSE\",index:r,value:t[r++]});else n.push({type:\"OPEN\",index:r,value:t[r++]});else n.push({type:\"ESCAPED_CHAR\",index:r++,value:t[r++]});else n.push({type:\"MODIFIER\",index:r,value:t[r++]})}return n.push({type:\"END\",index:r,value:\"\"}),n}(t),i=n.prefixes,e=void 0===i?\"./\":i,o=\"[^\".concat(l(n.delimiter||\"/#?\"),\"]+?\"),u=[],s=0,f=0,c=\"\",a=function(t){if(f<r.length&&r[f].type===t)return r[f++].value},h=function(t){var n=a(t);if(void 0!==n)return n;var i=r[f],e=i.index;throw new TypeError(\"Unexpected \".concat(i.type,\" at \").concat(e,\", expected \").concat(t))},v=function(){for(var t,n=\"\";t=a(\"CHAR\")||a(\"ESCAPED_CHAR\");)n+=t;return n};f<r.length;){var d=a(\"CHAR\"),p=a(\"NAME\"),m=a(\"PATTERN\");if(p||m)-1===e.indexOf(b=d||\"\")&&(c+=b,b=\"\"),c&&(u.push(c),c=\"\"),u.push({name:p||s++,prefix:b,suffix:\"\",pattern:m||o,modifier:a(\"MODIFIER\")||\"\"});else{var w=d||a(\"ESCAPED_CHAR\");if(w)c+=w;else if(c&&(u.push(c),c=\"\"),a(\"OPEN\")){var b=v(),y=a(\"NAME\")||\"\",P=a(\"PATTERN\")||\"\",g=v();h(\"CLOSE\"),u.push({name:y||(P?s++:\"\"),pattern:y&&!P?o:P,prefix:b,suffix:g,modifier:a(\"MODIFIER\")||\"\"})}else h(\"END\")}}return u}(t,r),n,r)}(n,r,i)},x={__proto__:null,update:g,nextTick:function(){return new Promise(function(t){window.requestAnimationFrame(t)})},pathToRegexp:E},R=function(){return window.location.origin},k=function(t){return void 0===t&&(t=window.location.href),O(t).port},O=function(t){var n,r=t.match(/:\\d+/);if(null===r)/^http/.test(t)&&(n=80),/^https/.test(t)&&(n=443);else{var i=r[0].substring(1);n=parseInt(i,10)}var e,o=t.replace(R(),\"\"),u={},s=o.indexOf(\"#\");s>=0&&(e=o.slice(s+1),o=o.slice(0,s));var f=o.indexOf(\"?\");return f>=0&&(u=T(o.slice(f+1)),o=o.slice(0,f)),{hash:e,path:o,port:n,query:u}},T=function(t){return t.split(\"&\").reduce(function(t,n){var r=n.split(\"=\");return t[r[0]]=r[1],t},{})},A=function(t){return void 0===t&&(t=window.location.href),t.replace(/(\\/#.*|\\/|#.*)$/,\"\")},j={__proto__:null,getHref:function(){return window.location.href},getAbsoluteHref:function(t,n){return void 0===n&&(n=document.baseURI),new URL(t,n).href},getOrigin:R,getPort:k,getPath:function(t){return void 0===t&&(t=window.location.href),O(t).path},getQuery:function(t,n){return void 0===n&&(n=!1),n?JSON.stringify(O(t).query):O(t).query},getHash:function(t){return O(t).hash},parse:O,parseQuery:T,clean:A};function M(t,n,i,e,o){return void 0===n&&(n=2e3),new Promise(function(u,s){var f=new XMLHttpRequest;f.onreadystatechange=function(){if(f.readyState===XMLHttpRequest.DONE)if(200===f.status){var n=\"\"!==f.responseURL&&f.responseURL!==t?f.responseURL:t;u({html:f.responseText,url:r({href:n},O(n))}),e.update(t,{status:\"fulfilled\",target:n})}else if(f.status){var o={status:f.status,statusText:f.statusText};i(t,o),s(o),e.update(t,{status:\"rejected\"})}},f.ontimeout=function(){var r=new Error(\"Timeout error [\"+n+\"]\");i(t,r),s(r),e.update(t,{status:\"rejected\"})},f.onerror=function(){var n=new Error(\"Fetch error\");i(t,n),s(n),e.update(t,{status:\"rejected\"})},f.open(\"GET\",t),f.timeout=n,f.setRequestHeader(\"Accept\",\"text/html,application/xhtml+xml,application/xml\"),f.setRequestHeader(\"x-barba\",\"yes\"),o.all().forEach(function(t,n){f.setRequestHeader(n,t)}),f.send()})}function N(t){return!!t&&(\"object\"==typeof t||\"function\"==typeof t)&&\"function\"==typeof t.then}function S(t,n){return void 0===n&&(n={}),function(){var r=arguments,i=!1,e=new Promise(function(e,o){n.async=function(){return i=!0,function(t,n){t?o(t):e(n)}};var u=t.apply(n,[].slice.call(r));i||(N(u)?u.then(e,o):e(u))});return e}}var C=/*#__PURE__*/function(t){function n(){var n;return(n=t.call(this)||this).logger=new d(\"@barba/core\"),n.all=[\"ready\",\"page\",\"reset\",\"currentAdded\",\"currentRemoved\",\"nextAdded\",\"nextRemoved\",\"beforeOnce\",\"once\",\"afterOnce\",\"before\",\"beforeLeave\",\"leave\",\"afterLeave\",\"beforeEnter\",\"enter\",\"afterEnter\",\"after\"],n.registered=new Map,n.init(),n}i(n,t);var r=n.prototype;return r.init=function(){var t=this;this.registered.clear(),this.all.forEach(function(n){t[n]||(t[n]=function(r,i){t.registered.has(n)||t.registered.set(n,new Set),t.registered.get(n).add({ctx:i||{},fn:r})})})},r.do=function(t){var n=arguments,r=this;if(this.registered.has(t)){var i=Promise.resolve();return this.registered.get(t).forEach(function(t){i=i.then(function(){return S(t.fn,t.ctx).apply(void 0,[].slice.call(n,1))})}),i.catch(function(n){r.logger.debug(\"Hook error [\"+t+\"]\"),r.logger.error(n)})}return Promise.resolve()},r.clear=function(){var t=this;this.all.forEach(function(n){delete t[n]}),this.init()},r.help=function(){this.logger.info(\"Available hooks: \"+this.all.join(\",\"));var t=[];this.registered.forEach(function(n,r){return t.push(r)}),this.logger.info(\"Registered hooks: \"+t.join(\",\"))},n}(h),L=new C,H=/*#__PURE__*/function(){function t(t){if(this.k=void 0,this.O=[],\"boolean\"==typeof t)this.k=t;else{var n=Array.isArray(t)?t:[t];this.O=n.map(function(t){return E(t)})}}return t.prototype.checkHref=function(t){if(\"boolean\"==typeof this.k)return this.k;var n=O(t).path;return this.O.some(function(t){return null!==t.exec(n)})},t}(),_=/*#__PURE__*/function(t){function n(n){var r;return(r=t.call(this,n)||this).T=new Map,r}i(n,t);var e=n.prototype;return e.set=function(t,n,r,i,e){return this.T.set(t,{action:r,request:n,status:i,target:null!=e?e:t}),{action:r,request:n,status:i,target:e}},e.get=function(t){return this.T.get(t)},e.getRequest=function(t){return this.T.get(t).request},e.getAction=function(t){return this.T.get(t).action},e.getStatus=function(t){return this.T.get(t).status},e.getTarget=function(t){return this.T.get(t).target},e.has=function(t){return!this.checkHref(t)&&this.T.has(t)},e.delete=function(t){return this.T.delete(t)},e.update=function(t,n){var i=r({},this.T.get(t),n);return this.T.set(t,i),i},n}(H),D=/*#__PURE__*/function(){function t(){this.A=new Map}var n=t.prototype;return n.set=function(t,n){return this.A.set(t,n),{name:n}},n.get=function(t){return this.A.get(t)},n.all=function(){return this.A},n.has=function(t){return this.A.has(t)},n.delete=function(t){return this.A.delete(t)},n.clear=function(){return this.A.clear()},t}(),B=function(){return!window.history.pushState},q=function(t){return!t.el||!t.href},F=function(t){var n=t.event;return n.which>1||n.metaKey||n.ctrlKey||n.shiftKey||n.altKey},I=function(t){var n=t.el;return n.hasAttribute(\"target\")&&\"_blank\"===n.target},U=function(t){var n=t.el;return void 0!==n.protocol&&window.location.protocol!==n.protocol||void 0!==n.hostname&&window.location.hostname!==n.hostname},$=function(t){var n=t.el;return void 0!==n.port&&k()!==k(n.href)},Q=function(t){var n=t.el;return n.getAttribute&&\"string\"==typeof n.getAttribute(\"download\")},X=function(t){return t.el.hasAttribute(m.prefix+\"-\"+m.prevent)},z=function(t){return Boolean(t.el.closest(\"[\"+m.prefix+\"-\"+m.prevent+'=\"all\"]'))},G=function(t){var n=t.href;return A(n)===A()&&k(n)===k()},J=/*#__PURE__*/function(t){function n(n){var r;return(r=t.call(this,n)||this).suite=[],r.tests=new Map,r.init(),r}i(n,t);var r=n.prototype;return r.init=function(){this.add(\"pushState\",B),this.add(\"exists\",q),this.add(\"newTab\",F),this.add(\"blank\",I),this.add(\"corsDomain\",U),this.add(\"corsPort\",$),this.add(\"download\",Q),this.add(\"preventSelf\",X),this.add(\"preventAll\",z),this.add(\"sameUrl\",G,!1)},r.add=function(t,n,r){void 0===r&&(r=!0),this.tests.set(t,n),r&&this.suite.push(t)},r.run=function(t,n,r,i){return this.tests.get(t)({el:n,event:r,href:i})},r.checkLink=function(t,n,r){var i=this;return this.suite.some(function(e){return i.run(e,t,n,r)})},n}(H),W=/*#__PURE__*/function(t){function n(r,i){var e;return void 0===i&&(i=\"Barba error\"),(e=t.call.apply(t,[this].concat([].slice.call(arguments,2)))||this).error=void 0,e.label=void 0,e.error=r,e.label=i,Error.captureStackTrace&&Error.captureStackTrace(c(e),n),e.name=\"BarbaError\",e}return i(n,t),n}(/*#__PURE__*/f(Error)),K=/*#__PURE__*/function(){function t(t){void 0===t&&(t=[]),this.logger=new d(\"@barba/core\"),this.all=[],this.page=[],this.once=[],this.j=[{name:\"namespace\",type:\"strings\"},{name:\"custom\",type:\"function\"}],t&&(this.all=this.all.concat(t)),this.update()}var n=t.prototype;return n.add=function(t,n){\"rule\"===t?this.j.splice(n.position||0,0,n.value):this.all.push(n),this.update()},n.resolve=function(t,n){var r=this;void 0===n&&(n={});var i=n.once?this.once:this.page;i=i.filter(n.self?function(t){return t.name&&\"self\"===t.name}:function(t){return!t.name||\"self\"!==t.name});var e=new Map,o=i.find(function(i){var o=!0,u={};return n.self&&\"self\"===i.name?(e.set(i,u),!0):(r.j.reverse().forEach(function(n){o&&(o=r.M(i,n,t,u),i.from&&i.to&&(o=r.M(i,n,t,u,\"from\")&&r.M(i,n,t,u,\"to\")),i.from&&!i.to&&(o=r.M(i,n,t,u,\"from\")),!i.from&&i.to&&(o=r.M(i,n,t,u,\"to\")))}),e.set(i,u),o)}),u=e.get(o),s=[];if(s.push(n.once?\"once\":\"page\"),n.self&&s.push(\"self\"),u){var f,c=[o];Object.keys(u).length>0&&c.push(u),(f=this.logger).info.apply(f,[\"Transition found [\"+s.join(\",\")+\"]\"].concat(c))}else this.logger.info(\"No transition found [\"+s.join(\",\")+\"]\");return o},n.update=function(){var t=this;this.all=this.all.map(function(n){return t.N(n)}).sort(function(t,n){return t.priority-n.priority}).reverse().map(function(t){return delete t.priority,t}),this.page=this.all.filter(function(t){return void 0!==t.leave||void 0!==t.enter}),this.once=this.all.filter(function(t){return void 0!==t.once})},n.M=function(t,n,r,i,e){var o=!0,u=!1,s=t,f=n.name,c=f,a=f,h=f,v=e?s[e]:s,d=\"to\"===e?r.next:r.current;if(e?v&&v[f]:v[f]){switch(n.type){case\"strings\":default:var l=Array.isArray(v[c])?v[c]:[v[c]];d[c]&&-1!==l.indexOf(d[c])&&(u=!0),-1===l.indexOf(d[c])&&(o=!1);break;case\"object\":var p=Array.isArray(v[a])?v[a]:[v[a]];d[a]?(d[a].name&&-1!==p.indexOf(d[a].name)&&(u=!0),-1===p.indexOf(d[a].name)&&(o=!1)):o=!1;break;case\"function\":v[h](r)?u=!0:o=!1}u&&(e?(i[e]=i[e]||{},i[e][f]=s[e][f]):i[f]=s[f])}return o},n.S=function(t,n,r){var i=0;return(t[n]||t.from&&t.from[n]||t.to&&t.to[n])&&(i+=Math.pow(10,r),t.from&&t.from[n]&&(i+=1),t.to&&t.to[n]&&(i+=2)),i},n.N=function(t){var n=this;t.priority=0;var r=0;return this.j.forEach(function(i,e){r+=n.S(t,i.name,e+1)}),t.priority=r,t},t}();function V(t,n){try{var r=t()}catch(t){return n(t)}return r&&r.then?r.then(void 0,n):r}var Y=/*#__PURE__*/function(){function t(t){void 0===t&&(t=[]),this.logger=new d(\"@barba/core\"),this.store=void 0,this.C=!1,this.store=new K(t)}var r=t.prototype;return r.get=function(t,n){return this.store.resolve(t,n)},r.doOnce=function(t){var n=t.data,r=t.transition;try{var i=function(){e.C=!1},e=this,o=r||{};e.C=!0;var u=V(function(){return Promise.resolve(e.L(\"beforeOnce\",n,o)).then(function(){return Promise.resolve(e.once(n,o)).then(function(){return Promise.resolve(e.L(\"afterOnce\",n,o)).then(function(){})})})},function(t){e.C=!1,e.logger.debug(\"Transition error [before/after/once]\"),e.logger.error(t)});return Promise.resolve(u&&u.then?u.then(i):i())}catch(t){return Promise.reject(t)}},r.doPage=function(t){var n=t.data,r=t.transition,i=t.page,e=t.wrapper;try{var o=function(t){u.C=!1},u=this,s=r||{},f=!0===s.sync||!1;u.C=!0;var c=V(function(){function t(){return Promise.resolve(u.L(\"before\",n,s)).then(function(){function t(t){return Promise.resolve(u.remove(n)).then(function(){return Promise.resolve(u.L(\"after\",n,s)).then(function(){})})}var r=function(){if(f)return V(function(){return Promise.resolve(u.add(n,e)).then(function(){return Promise.resolve(u.L(\"beforeLeave\",n,s)).then(function(){return Promise.resolve(u.L(\"beforeEnter\",n,s)).then(function(){return Promise.resolve(Promise.all([u.leave(n,s),u.enter(n,s)])).then(function(){return Promise.resolve(u.L(\"afterLeave\",n,s)).then(function(){return Promise.resolve(u.L(\"afterEnter\",n,s)).then(function(){})})})})})})},function(t){if(u.H(t))throw new W(t,\"Transition error [sync]\")});var t=function(t){return V(function(){var t=function(){if(!1!==r)return Promise.resolve(u.add(n,e)).then(function(){return Promise.resolve(u.L(\"beforeEnter\",n,s)).then(function(){return Promise.resolve(u.enter(n,s,r)).then(function(){return Promise.resolve(u.L(\"afterEnter\",n,s)).then(function(){})})})})}();if(t&&t.then)return t.then(function(){})},function(t){if(u.H(t))throw new W(t,\"Transition error [before/after/enter]\")})},r=!1,o=V(function(){return Promise.resolve(u.L(\"beforeLeave\",n,s)).then(function(){return Promise.resolve(Promise.all([u.leave(n,s),g(i,n)]).then(function(t){return t[0]})).then(function(t){return r=t,Promise.resolve(u.L(\"afterLeave\",n,s)).then(function(){})})})},function(t){if(u.H(t))throw new W(t,\"Transition error [before/after/leave]\")});return o&&o.then?o.then(t):t()}();return r&&r.then?r.then(t):t()})}var r=function(){if(f)return Promise.resolve(g(i,n)).then(function(){})}();return r&&r.then?r.then(t):t()},function(t){if(u.C=!1,t.name&&\"BarbaError\"===t.name)throw u.logger.debug(t.label),u.logger.error(t.error),t;throw u.logger.debug(\"Transition error [page]\"),u.logger.error(t),t});return Promise.resolve(c&&c.then?c.then(o):o())}catch(t){return Promise.reject(t)}},r.once=function(t,n){try{return Promise.resolve(L.do(\"once\",t,n)).then(function(){return n.once?S(n.once,n)(t):Promise.resolve()})}catch(t){return Promise.reject(t)}},r.leave=function(t,n){try{return Promise.resolve(L.do(\"leave\",t,n)).then(function(){return n.leave?S(n.leave,n)(t):Promise.resolve()})}catch(t){return Promise.reject(t)}},r.enter=function(t,n,r){try{return Promise.resolve(L.do(\"enter\",t,n)).then(function(){return n.enter?S(n.enter,n)(t,r):Promise.resolve()})}catch(t){return Promise.reject(t)}},r.add=function(t,n){try{return b.addContainer(t.next.container,n),L.do(\"nextAdded\",t),Promise.resolve()}catch(t){return Promise.reject(t)}},r.remove=function(t){try{return b.removeContainer(t.current.container),L.do(\"currentRemoved\",t),Promise.resolve()}catch(t){return Promise.reject(t)}},r.H=function(t){return t.message?!/Timeout error|Fetch error/.test(t.message):!t.status},r.L=function(t,n,r){try{return Promise.resolve(L.do(t,n,r)).then(function(){return r[t]?S(r[t],r)(n):Promise.resolve()})}catch(t){return Promise.reject(t)}},n(t,[{key:\"isRunning\",get:function(){return this.C},set:function(t){this.C=t}},{key:\"hasOnce\",get:function(){return this.store.once.length>0}},{key:\"hasSelf\",get:function(){return this.store.all.some(function(t){return\"self\"===t.name})}},{key:\"shouldWait\",get:function(){return this.store.all.some(function(t){return t.to&&!t.to.route||t.sync})}}]),t}(),Z=/*#__PURE__*/function(){function t(t){var n=this;this.names=[\"beforeLeave\",\"afterLeave\",\"beforeEnter\",\"afterEnter\"],this.byNamespace=new Map,0!==t.length&&(t.forEach(function(t){n.byNamespace.set(t.namespace,t)}),this.names.forEach(function(t){L[t](n._(t))}))}return t.prototype._=function(t){var n=this;return function(r){var i=t.match(/enter/i)?r.next:r.current,e=n.byNamespace.get(i.namespace);return e&&e[t]?S(e[t],e)(r):Promise.resolve()}},t}();Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector),Element.prototype.closest||(Element.prototype.closest=function(t){var n=this;do{if(n.matches(t))return n;n=n.parentElement||n.parentNode}while(null!==n&&1===n.nodeType);return null});var tt={container:null,html:\"\",namespace:\"\",url:{hash:\"\",href:\"\",path:\"\",port:null,query:{}}},nt=/*#__PURE__*/function(){function t(){this.version=\"2.10.3\",this.schemaPage=tt,this.Logger=d,this.logger=new d(\"@barba/core\"),this.plugins=[],this.timeout=void 0,this.cacheIgnore=void 0,this.cacheFirstPage=void 0,this.prefetchIgnore=void 0,this.preventRunning=void 0,this.hooks=L,this.cache=void 0,this.headers=void 0,this.prevent=void 0,this.transitions=void 0,this.views=void 0,this.dom=b,this.helpers=x,this.history=P,this.request=M,this.url=j,this.D=void 0,this.B=void 0,this.q=void 0,this.F=void 0}var i=t.prototype;return i.use=function(t,n){var r=this.plugins;r.indexOf(t)>-1?this.logger.warn(\"Plugin [\"+t.name+\"] already installed.\"):\"function\"==typeof t.install?(t.install(this,n),r.push(t)):this.logger.warn(\"Plugin [\"+t.name+'] has no \"install\" method.')},i.init=function(t){var n=void 0===t?{}:t,i=n.transitions,e=void 0===i?[]:i,o=n.views,u=void 0===o?[]:o,s=n.schema,f=void 0===s?m:s,c=n.requestError,a=n.timeout,h=void 0===a?2e3:a,v=n.cacheIgnore,l=void 0!==v&&v,p=n.cacheFirstPage,w=void 0!==p&&p,b=n.prefetchIgnore,y=void 0!==b&&b,P=n.preventRunning,g=void 0!==P&&P,E=n.prevent,x=void 0===E?null:E,R=n.debug,k=n.logLevel;if(d.setLevel(!0===(void 0!==R&&R)?\"debug\":void 0===k?\"off\":k),this.logger.info(this.version),Object.keys(f).forEach(function(t){m[t]&&(m[t]=f[t])}),this.B=c,this.timeout=h,this.cacheIgnore=l,this.cacheFirstPage=w,this.prefetchIgnore=y,this.preventRunning=g,this.q=this.dom.getWrapper(),!this.q)throw new Error(\"[@barba/core] No Barba wrapper found\");this.I();var O=this.data.current;if(!O.container)throw new Error(\"[@barba/core] No Barba container found\");if(this.cache=new _(l),this.headers=new D,this.prevent=new J(y),this.transitions=new Y(e),this.views=new Z(u),null!==x){if(\"function\"!=typeof x)throw new Error(\"[@barba/core] Prevent should be a function\");this.prevent.add(\"preventCustom\",x)}this.history.init(O.url.href,O.namespace),w&&this.cache.set(O.url.href,Promise.resolve({html:O.html,url:O.url}),\"init\",\"fulfilled\"),this.U=this.U.bind(this),this.$=this.$.bind(this),this.X=this.X.bind(this),this.G(),this.plugins.forEach(function(t){return t.init()});var T=this.data;T.trigger=\"barba\",T.next=T.current,T.current=r({},this.schemaPage),this.hooks.do(\"ready\",T),this.once(T),this.I()},i.destroy=function(){this.I(),this.J(),this.history.clear(),this.hooks.clear(),this.plugins=[]},i.force=function(t){window.location.assign(t)},i.go=function(t,n,r){var i;if(void 0===n&&(n=\"barba\"),this.F=null,this.transitions.isRunning)this.force(t);else if(!(i=\"popstate\"===n?this.history.current&&this.url.getPath(this.history.current.url)===this.url.getPath(t)&&this.url.getQuery(this.history.current.url,!0)===this.url.getQuery(t,!0):this.prevent.run(\"sameUrl\",null,null,t))||this.transitions.hasSelf)return n=this.history.change(this.cache.has(t)?this.cache.get(t).target:t,n,r),r&&(r.stopPropagation(),r.preventDefault()),this.page(t,n,null!=r?r:void 0,i)},i.once=function(t){try{var n=this;return Promise.resolve(n.hooks.do(\"beforeEnter\",t)).then(function(){function r(){return Promise.resolve(n.hooks.do(\"afterEnter\",t)).then(function(){})}var i=function(){if(n.transitions.hasOnce){var r=n.transitions.get(t,{once:!0});return Promise.resolve(n.transitions.doOnce({transition:r,data:t})).then(function(){})}}();return i&&i.then?i.then(r):r()})}catch(t){return Promise.reject(t)}},i.page=function(t,n,i,e){try{var o,u=function(){var t=s.data;return Promise.resolve(s.hooks.do(\"page\",t)).then(function(){var n=function(n,r){try{var i=(u=s.transitions.get(t,{once:!1,self:e}),Promise.resolve(s.transitions.doPage({data:t,page:o,transition:u,wrapper:s.q})).then(function(){s.I()}))}catch(t){return r()}var u;return i&&i.then?i.then(void 0,r):i}(0,function(){0===d.getLevel()&&s.force(t.next.url.href)});if(n&&n.then)return n.then(function(){})})},s=this;if(s.data.next.url=r({href:t},s.url.parse(t)),s.data.trigger=n,s.data.event=i,s.cache.has(t))o=s.cache.update(t,{action:\"click\"}).request;else{var f=s.request(t,s.timeout,s.onRequestError.bind(s,n),s.cache,s.headers);f.then(function(r){r.url.href!==t&&s.history.add(r.url.href,n,\"replace\")}),o=s.cache.set(t,f,\"click\",\"pending\").request}var c=function(){if(s.transitions.shouldWait)return Promise.resolve(g(o,s.data)).then(function(){})}();return Promise.resolve(c&&c.then?c.then(u):u())}catch(t){return Promise.reject(t)}},i.onRequestError=function(t){this.transitions.isRunning=!1;var n=[].slice.call(arguments,1),r=n[0],i=n[1],e=this.cache.getAction(r);return this.cache.delete(r),this.B&&!1===this.B(t,e,r,i)||\"click\"===e&&this.force(r),!1},i.prefetch=function(t){var n=this;t=this.url.getAbsoluteHref(t),this.cache.has(t)||this.cache.set(t,this.request(t,this.timeout,this.onRequestError.bind(this,\"barba\"),this.cache,this.headers).catch(function(t){n.logger.error(t)}),\"prefetch\",\"pending\")},i.G=function(){!0!==this.prefetchIgnore&&(document.addEventListener(\"mouseover\",this.U),document.addEventListener(\"touchstart\",this.U)),document.addEventListener(\"click\",this.$),window.addEventListener(\"popstate\",this.X)},i.J=function(){!0!==this.prefetchIgnore&&(document.removeEventListener(\"mouseover\",this.U),document.removeEventListener(\"touchstart\",this.U)),document.removeEventListener(\"click\",this.$),window.removeEventListener(\"popstate\",this.X)},i.U=function(t){var n=this,r=this.W(t);if(r){var i=this.url.getAbsoluteHref(this.dom.getHref(r));this.prevent.checkHref(i)||this.cache.has(i)||this.cache.set(i,this.request(i,this.timeout,this.onRequestError.bind(this,r),this.cache,this.headers).catch(function(t){n.logger.error(t)}),\"enter\",\"pending\")}},i.$=function(t){var n=this.W(t);if(n){if(this.transitions.isRunning&&this.preventRunning)return t.preventDefault(),void t.stopPropagation();this.F=t,this.go(this.dom.getHref(n),n,t)}},i.X=function(t){this.go(this.url.getHref(),\"popstate\",t)},i.W=function(t){for(var n=t.target;n&&!this.dom.getHref(n);)n=n.parentNode;if(n&&!this.prevent.checkLink(n,t,this.dom.getHref(n)))return n},i.I=function(){var t=this.url.getHref(),n={container:this.dom.getContainer(),html:this.dom.getHtml(),namespace:this.dom.getNamespace(),url:r({href:t},this.url.parse(t))};this.D={current:n,event:void 0,next:r({},this.schemaPage),trigger:void 0},this.hooks.do(\"reset\",this.data)},n(t,[{key:\"data\",get:function(){return this.D}},{key:\"wrapper\",get:function(){return this.q}}]),t}();return new nt});\n//# sourceMappingURL=barba.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhcmJhL2NvcmUvZGlzdC9iYXJiYS51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxLQUFvRCxvQkFBb0IsQ0FBbUUsQ0FBQyxpQkFBaUIsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsc0lBQXNJLHlDQUF5Qyw0QkFBNEIsZUFBZSx5QkFBeUIsK0JBQStCLG9FQUFvRSxpQkFBaUIsd0JBQXdCLE1BQU0sa0JBQWtCLDBFQUEwRSxZQUFZLElBQUksYUFBYSx3REFBd0QsWUFBWSxtQkFBbUIsS0FBSyxtQkFBbUIsc0VBQXNFLFNBQVMseUJBQXlCLGdCQUFnQix3RUFBd0UsY0FBYyx3RUFBd0UsNkNBQTZDLE1BQU0sZ0JBQWdCLDBFQUEwRSx1QkFBdUIsUUFBUSxhQUFhLDREQUE0RCxtQ0FBbUMscUNBQXFDLElBQUksK0VBQStFLE1BQU0sU0FBUyxVQUFVLGtCQUFrQixzREFBc0QsYUFBYSxrQkFBa0Isb0NBQW9DLDZCQUE2Qix5QkFBeUIsY0FBYyw0Q0FBNEMscUJBQXFCLDhFQUE4RSxrR0FBa0csZUFBZSw0QkFBNEIsV0FBVyxhQUFhLDBDQUEwQyw4Q0FBOEMsYUFBYSxtREFBbUQsU0FBUyxNQUFNLGNBQWMsb0dBQW9HLFNBQVMsbUJBQW1CLHdLQUF3SyxhQUFhLHVHQUF1RyxTQUFTLEdBQUcsc0NBQXNDLGNBQWMsdUJBQXVCLHNCQUFzQixTQUFTLHdCQUF3QixlQUFlLGtCQUFrQiwwQkFBMEIsdURBQXVELG1CQUFtQix3REFBd0QsbUJBQW1CLHFEQUFxRCxvQkFBb0IscURBQXFELHFCQUFxQiw4REFBOEQsR0FBRyxHQUFHLGNBQWMsK0JBQStCLHNCQUFzQixjQUFjLDZCQUE2QixPQUFPLHNIQUFzSCwyQkFBMkIsYUFBYSwrQkFBK0Isb0NBQW9DLGtCQUFrQiw4QkFBOEIsbUJBQW1CLDBCQUEwQiw0RUFBNEUseUJBQXlCLG9DQUFvQyx1QkFBdUIsdUJBQXVCLGlFQUFpRSwwQkFBMEIsNEZBQTRGLDRCQUE0Qiw4RkFBOEYsK0JB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QkFBZ0IsOE1BQThNLGdCQUFnQiwwTkFBME4saUJBQWlCLHVCQUF1QixNQUFNLG9EQUFvRCx1S0FBdUssa0JBQWtCLHNCQUFzQixpQkFBaUIsZ0JBQWdCLE1BQU0sc0dBQXNHLDJDQUEyQyxpQkFBaUIseUNBQXlDLGlCQUFpQixtQkFBbUIsd0JBQXdCLGdCQUFnQixnRUFBZ0UsZ0JBQWdCLDRCQUE0QixtR0FBbUcsT0FBTyxxQkFBcUIsUUFBUSxnQ0FBZ0MsaUNBQWlDLGtDQUFrQyxPQUFPLDBCQUEwQixlQUFlLEVBQUUsNkJBQTZCLGVBQWUsS0FBSyxHQUFHLGNBQWM7QUFDaGkrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL25vZGVfbW9kdWxlcy9AYmFyYmEvY29yZS9kaXN0L2JhcmJhLnVtZC5qcz9iYWY2Il0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0LG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4oKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKG4pOih0fHxzZWxmKS5iYXJiYT1uKCl9KHRoaXMsZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsbil7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic3ltYm9sXCI9PXR5cGVvZihlPWZ1bmN0aW9uKHQsbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVybiB0O3ZhciByPXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtpZih2b2lkIDAhPT1yKXt2YXIgaT1yLmNhbGwodCxcInN0cmluZ1wiKTtpZihcIm9iamVjdFwiIT10eXBlb2YgaSlyZXR1cm4gaTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIil9cmV0dXJuIFN0cmluZyh0KX0oaS5rZXkpKT9lOlN0cmluZyhlKSxpKX12YXIgZX1mdW5jdGlvbiBuKG4scixpKXtyZXR1cm4gciYmdChuLnByb3RvdHlwZSxyKSxpJiZ0KG4saSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxufWZ1bmN0aW9uIHIoKXtyZXR1cm4gcj1PYmplY3QuYXNzaWduP09iamVjdC5hc3NpZ24uYmluZCgpOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3ZhciByPWFyZ3VtZW50c1tuXTtmb3IodmFyIGkgaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixpKSYmKHRbaV09cltpXSl9cmV0dXJuIHR9LHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGkodCxuKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG4ucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LG8odCxuKX1mdW5jdGlvbiBlKHQpe3JldHVybiBlPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSxlKHQpfWZ1bmN0aW9uIG8odCxuKXtyZXR1cm4gbz1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKTpmdW5jdGlvbih0LG4pe3JldHVybiB0Ll9fcHJvdG9fXz1uLHR9LG8odCxuKX1mdW5jdGlvbiB1KCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sZnVuY3Rpb24oKXt9KSksITB9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIHModCxuLHIpe3JldHVybiBzPXUoKT9SZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk6ZnVuY3Rpb24odCxuLHIpe3ZhciBpPVtudWxsXTtpLnB1c2guYXBwbHkoaSxuKTt2YXIgZT1uZXcoRnVuY3Rpb24uYmluZC5hcHBseSh0LGkpKTtyZXR1cm4gciYmbyhlLHIucHJvdG90eXBlKSxlfSxzLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBmKHQpe3ZhciBuPVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4gZj1mdW5jdGlvbih0KXtpZihudWxsPT09dHx8LTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKXJldHVybiB0O2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKHZvaWQgMCE9PW4pe2lmKG4uaGFzKHQpKXJldHVybiBuLmdldCh0KTtuLnNldCh0LHIpfWZ1bmN0aW9uIHIoKXtyZXR1cm4gcyh0LGFyZ3VtZW50cyxlKHRoaXMpLmNvbnN0cnVjdG9yKX1yZXR1cm4gci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnIsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksbyhyLHQpfSxmKHQpfWZ1bmN0aW9uIGModCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9dmFyIGEsaD1mdW5jdGlvbigpe3RoaXMuYmVmb3JlPXZvaWQgMCx0aGlzLmJlZm9yZUxlYXZlPXZvaWQgMCx0aGlzLmxlYXZlPXZvaWQgMCx0aGlzLmFmdGVyTGVhdmU9dm9pZCAwLHRoaXMuYmVmb3JlRW50ZXI9dm9pZCAwLHRoaXMuZW50ZXI9dm9pZCAwLHRoaXMuYWZ0ZXJFbnRlcj12b2lkIDAsdGhpcy5hZnRlcj12b2lkIDB9OyFmdW5jdGlvbih0KXt0W3Qub2ZmPTBdPVwib2ZmXCIsdFt0LmVycm9yPTFdPVwiZXJyb3JcIix0W3Qud2FybmluZz0yXT1cIndhcm5pbmdcIix0W3QuaW5mbz0zXT1cImluZm9cIix0W3QuZGVidWc9NF09XCJkZWJ1Z1wifShhfHwoYT17fSkpO3ZhciB2PWEub2ZmLGQ9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnQ9dm9pZCAwLHRoaXMudD10fXQuZ2V0TGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdn0sdC5zZXRMZXZlbD1mdW5jdGlvbih0KXtyZXR1cm4gdj1hW3RdfTt2YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi5lcnJvcj1mdW5jdGlvbigpe3RoaXMuaShjb25zb2xlLmVycm9yLGEuZXJyb3IsW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKX0sbi53YXJuPWZ1bmN0aW9uKCl7dGhpcy5pKGNvbnNvbGUud2FybixhLndhcm5pbmcsW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKX0sbi5pbmZvPWZ1bmN0aW9uKCl7dGhpcy5pKGNvbnNvbGUuaW5mbyxhLmluZm8sW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKX0sbi5kZWJ1Zz1mdW5jdGlvbigpe3RoaXMuaShjb25zb2xlLmxvZyxhLmRlYnVnLFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSl9LG4uaT1mdW5jdGlvbihuLHIsaSl7cjw9dC5nZXRMZXZlbCgpJiZuLmFwcGx5KGNvbnNvbGUsW1wiW1wiK3RoaXMudCtcIl0gXCJdLmNvbmNhdChpKSl9LHR9KCk7ZnVuY3Rpb24gbCh0KXtyZXR1cm4gdC5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfC9cXFxcXSkvZyxcIlxcXFwkMVwiKX1mdW5jdGlvbiBwKHQpe3JldHVybiB0JiZ0LnNlbnNpdGl2ZT9cIlwiOlwiaVwifXZhciBtPXtjb250YWluZXI6XCJjb250YWluZXJcIixoaXN0b3J5OlwiaGlzdG9yeVwiLG5hbWVzcGFjZTpcIm5hbWVzcGFjZVwiLHByZWZpeDpcImRhdGEtYmFyYmFcIixwcmV2ZW50OlwicHJldmVudFwiLHdyYXBwZXI6XCJ3cmFwcGVyXCJ9LHc9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMubz1tLHRoaXMudT12b2lkIDAsdGhpcy5oPXthZnRlcjpudWxsLGJlZm9yZTpudWxsLHBhcmVudDpudWxsfX12YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdC5vdXRlckhUTUx9LG4udG9Eb2N1bWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy51fHwodGhpcy51PW5ldyBET01QYXJzZXIpLHRoaXMudS5wYXJzZUZyb21TdHJpbmcodCxcInRleHQvaHRtbFwiKX0sbi50b0VsZW1lbnQ9ZnVuY3Rpb24odCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gbi5pbm5lckhUTUw9dCxufSxuLmdldEh0bWw9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PWRvY3VtZW50KSx0aGlzLnRvU3RyaW5nKHQuZG9jdW1lbnRFbGVtZW50KX0sbi5nZXRXcmFwcGVyPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1kb2N1bWVudCksdC5xdWVyeVNlbGVjdG9yKFwiW1wiK3RoaXMuby5wcmVmaXgrJz1cIicrdGhpcy5vLndyYXBwZXIrJ1wiXScpfSxuLmdldENvbnRhaW5lcj1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ZG9jdW1lbnQpLHQucXVlcnlTZWxlY3RvcihcIltcIit0aGlzLm8ucHJlZml4Kyc9XCInK3RoaXMuby5jb250YWluZXIrJ1wiXScpfSxuLnJlbW92ZUNvbnRhaW5lcj1mdW5jdGlvbih0KXtkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHQpJiYodGhpcy52KHQpLHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSl9LG4uYWRkQ29udGFpbmVyPWZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5nZXRDb250YWluZXIoKXx8dGhpcy5oLmJlZm9yZTtyP3RoaXMubCh0LHIpOnRoaXMuaC5hZnRlcj90aGlzLmguYWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodCx0aGlzLmguYWZ0ZXIpOnRoaXMuaC5wYXJlbnQ/dGhpcy5oLnBhcmVudC5hcHBlbmRDaGlsZCh0KTpuLmFwcGVuZENoaWxkKHQpfSxuLmdldFNpYmxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ofSxuLmdldE5hbWVzcGFjZT1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD1kb2N1bWVudCk7dmFyIG49dC5xdWVyeVNlbGVjdG9yKFwiW1wiK3RoaXMuby5wcmVmaXgrXCItXCIrdGhpcy5vLm5hbWVzcGFjZStcIl1cIik7cmV0dXJuIG4/bi5nZXRBdHRyaWJ1dGUodGhpcy5vLnByZWZpeCtcIi1cIit0aGlzLm8ubmFtZXNwYWNlKTpudWxsfSxuLmdldEhyZWY9ZnVuY3Rpb24odCl7aWYodC50YWdOYW1lJiZcImFcIj09PXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtpZihcInN0cmluZ1wiPT10eXBlb2YgdC5ocmVmKXJldHVybiB0LmhyZWY7dmFyIG49dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpfHx0LmdldEF0dHJpYnV0ZShcInhsaW5rOmhyZWZcIik7aWYobilyZXR1cm4gdGhpcy5yZXNvbHZlVXJsKG4uYmFzZVZhbHx8bil9cmV0dXJuIG51bGx9LG4ucmVzb2x2ZVVybD1mdW5jdGlvbigpe3ZhciB0PVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5sZW5ndGg7aWYoMD09PXQpdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZVVybCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ7IGdvdCBub25lLlwiKTt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKTtpZihuLmhyZWY9YXJndW1lbnRzWzBdLDE9PT10KXJldHVybiBuLmhyZWY7dmFyIHI9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO3IuaW5zZXJ0QmVmb3JlKG4sci5maXJzdENoaWxkKTtmb3IodmFyIGksZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxvPTE7bzx0O28rKyllLmhyZWY9YXJndW1lbnRzW29dLG4uaHJlZj1pPWUuaHJlZjtyZXR1cm4gci5yZW1vdmVDaGlsZChuKSxpfSxuLmw9ZnVuY3Rpb24odCxuKXtuLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsbi5uZXh0U2libGluZyl9LG4udj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oPXthZnRlcjp0Lm5leHRFbGVtZW50U2libGluZyxiZWZvcmU6dC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLHBhcmVudDp0LnBhcmVudEVsZW1lbnR9LHRoaXMuaH0sdH0oKSxiPW5ldyB3LHk9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMucD12b2lkIDAsdGhpcy5tPVtdLHRoaXMuUD0tMX12YXIgaT10LnByb3RvdHlwZTtyZXR1cm4gaS5pbml0PWZ1bmN0aW9uKHQsbil7dGhpcy5wPVwiYmFyYmFcIjt2YXIgcj17ZGF0YTp7fSxuczpuLHNjcm9sbDp7eDp3aW5kb3cuc2Nyb2xsWCx5OndpbmRvdy5zY3JvbGxZfSx1cmw6dH07dGhpcy5QPTAsdGhpcy5tLnB1c2gocik7dmFyIGk9e2Zyb206dGhpcy5wLGluZGV4OnRoaXMuUCxzdGF0ZXM6W10uY29uY2F0KHRoaXMubSl9O3dpbmRvdy5oaXN0b3J5JiZ3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaSxcIlwiLHQpfSxpLmNoYW5nZT1mdW5jdGlvbih0LG4scil7aWYociYmci5zdGF0ZSl7dmFyIGk9ci5zdGF0ZSxlPWkuaW5kZXg7bj10aGlzLmcodGhpcy5QLWUpLHRoaXMucmVwbGFjZShpLnN0YXRlcyksdGhpcy5QPWV9ZWxzZSB0aGlzLmFkZCh0LG4pO3JldHVybiBufSxpLmFkZD1mdW5jdGlvbih0LG4scixpKXt2YXIgZT1udWxsIT1yP3I6dGhpcy5SKG4pLG89e2RhdGE6bnVsbCE9aT9pOnt9LG5zOlwidG1wXCIsc2Nyb2xsOnt4OndpbmRvdy5zY3JvbGxYLHk6d2luZG93LnNjcm9sbFl9LHVybDp0fTtzd2l0Y2goZSl7Y2FzZVwicHVzaFwiOnRoaXMuUD10aGlzLnNpemUsdGhpcy5tLnB1c2gobyk7YnJlYWs7Y2FzZVwicmVwbGFjZVwiOnRoaXMuc2V0KHRoaXMuUCxvKX12YXIgdT17ZnJvbTp0aGlzLnAsaW5kZXg6dGhpcy5QLHN0YXRlczpbXS5jb25jYXQodGhpcy5tKX07c3dpdGNoKGUpe2Nhc2VcInB1c2hcIjp3aW5kb3cuaGlzdG9yeSYmd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHUsXCJcIix0KTticmVhaztjYXNlXCJyZXBsYWNlXCI6d2luZG93Lmhpc3RvcnkmJndpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh1LFwiXCIsdCl9fSxpLnN0b3JlPWZ1bmN0aW9uKHQsbil7dmFyIGk9bnx8dGhpcy5QLGU9dGhpcy5nZXQoaSk7ZS5kYXRhPXIoe30sZS5kYXRhLHQpLHRoaXMuc2V0KGksZSk7dmFyIG89e2Zyb206dGhpcy5wLGluZGV4OnRoaXMuUCxzdGF0ZXM6W10uY29uY2F0KHRoaXMubSl9O3dpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShvLFwiXCIpfSxpLnVwZGF0ZT1mdW5jdGlvbih0LG4pe3ZhciBpPW58fHRoaXMuUCxlPXIoe30sdGhpcy5nZXQoaSksdCk7dGhpcy5zZXQoaSxlKX0saS5yZW1vdmU9ZnVuY3Rpb24odCl7dD90aGlzLm0uc3BsaWNlKHQsMSk6dGhpcy5tLnBvcCgpLHRoaXMuUC0tfSxpLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5tPVtdLHRoaXMuUD0tMX0saS5yZXBsYWNlPWZ1bmN0aW9uKHQpe3RoaXMubT10fSxpLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5tW3RdfSxpLnNldD1mdW5jdGlvbih0LG4pe3JldHVybiB0aGlzLm1bdF09bn0saS5SPWZ1bmN0aW9uKHQpe3ZhciBuPVwicHVzaFwiLHI9dCxpPW0ucHJlZml4K1wiLVwiK20uaGlzdG9yeTtyZXR1cm4gci5oYXNBdHRyaWJ1dGUmJnIuaGFzQXR0cmlidXRlKGkpJiYobj1yLmdldEF0dHJpYnV0ZShpKSksbn0saS5nPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmFicyh0KT4xP3Q+MD9cImZvcndhcmRcIjpcImJhY2tcIjowPT09dD9cInBvcHN0YXRlXCI6dD4wP1wiYmFja1wiOlwiZm9yd2FyZFwifSxuKHQsW3trZXk6XCJjdXJyZW50XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubVt0aGlzLlBdfX0se2tleTpcInByZXZpb3VzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUDwxP251bGw6dGhpcy5tW3RoaXMuUC0xXX19LHtrZXk6XCJzaXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubS5sZW5ndGh9fV0pLHR9KCksUD1uZXcgeSxnPWZ1bmN0aW9uKHQsbil7dHJ5e3ZhciByPWZ1bmN0aW9uKCl7aWYoIW4ubmV4dC5odG1sKXJldHVybiBQcm9taXNlLnJlc29sdmUodCkudGhlbihmdW5jdGlvbih0KXt2YXIgcj1uLm5leHQ7aWYodCl7dmFyIGk9Yi50b0VsZW1lbnQodC5odG1sKTtyLm5hbWVzcGFjZT1iLmdldE5hbWVzcGFjZShpKSxyLmNvbnRhaW5lcj1iLmdldENvbnRhaW5lcihpKSxyLnVybD10LnVybCxyLmh0bWw9dC5odG1sLFAudXBkYXRlKHtuczpyLm5hbWVzcGFjZX0pO3ZhciBlPWIudG9Eb2N1bWVudCh0Lmh0bWwpO2RvY3VtZW50LnRpdGxlPWUudGl0bGV9fSl9KCk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShyJiZyLnRoZW4/ci50aGVuKGZ1bmN0aW9uKCl7fSk6dm9pZCAwKX1jYXRjaCh0KXtyZXR1cm4gUHJvbWlzZS5yZWplY3QodCl9fSxFPWZ1bmN0aW9uIHQobixyLGkpe3JldHVybiBuIGluc3RhbmNlb2YgUmVnRXhwP2Z1bmN0aW9uKHQsbil7aWYoIW4pcmV0dXJuIHQ7Zm9yKHZhciByPS9cXCgoPzpcXD88KC4qPyk+KT8oPyFcXD8pL2csaT0wLGU9ci5leGVjKHQuc291cmNlKTtlOyluLnB1c2goe25hbWU6ZVsxXXx8aSsrLHByZWZpeDpcIlwiLHN1ZmZpeDpcIlwiLG1vZGlmaWVyOlwiXCIscGF0dGVybjpcIlwifSksZT1yLmV4ZWModC5zb3VyY2UpO3JldHVybiB0fShuLHIpOkFycmF5LmlzQXJyYXkobik/ZnVuY3Rpb24obixyLGkpe3ZhciBlPW4ubWFwKGZ1bmN0aW9uKG4pe3JldHVybiB0KG4scixpKS5zb3VyY2V9KTtyZXR1cm4gbmV3IFJlZ0V4cChcIig/OlwiLmNvbmNhdChlLmpvaW4oXCJ8XCIpLFwiKVwiKSxwKGkpKX0obixyLGkpOmZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gZnVuY3Rpb24odCxuLHIpe3ZvaWQgMD09PXImJihyPXt9KTtmb3IodmFyIGk9ci5zdHJpY3QsZT12b2lkIDAhPT1pJiZpLG89ci5zdGFydCx1PXZvaWQgMD09PW98fG8scz1yLmVuZCxmPXZvaWQgMD09PXN8fHMsYz1yLmVuY29kZSxhPXZvaWQgMD09PWM/ZnVuY3Rpb24odCl7cmV0dXJuIHR9OmMsaD1yLmRlbGltaXRlcix2PXZvaWQgMD09PWg/XCIvIz9cIjpoLGQ9ci5lbmRzV2l0aCxtPVwiW1wiLmNvbmNhdChsKHZvaWQgMD09PWQ/XCJcIjpkKSxcIl18JFwiKSx3PVwiW1wiLmNvbmNhdChsKHYpLFwiXVwiKSxiPXU/XCJeXCI6XCJcIix5PTAsUD10O3k8UC5sZW5ndGg7eSsrKXt2YXIgZz1QW3ldO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBnKWIrPWwoYShnKSk7ZWxzZXt2YXIgRT1sKGEoZy5wcmVmaXgpKSx4PWwoYShnLnN1ZmZpeCkpO2lmKGcucGF0dGVybilpZihuJiZuLnB1c2goZyksRXx8eClpZihcIitcIj09PWcubW9kaWZpZXJ8fFwiKlwiPT09Zy5tb2RpZmllcil7dmFyIFI9XCIqXCI9PT1nLm1vZGlmaWVyP1wiP1wiOlwiXCI7Yis9XCIoPzpcIi5jb25jYXQoRSxcIigoPzpcIikuY29uY2F0KGcucGF0dGVybixcIikoPzpcIikuY29uY2F0KHgpLmNvbmNhdChFLFwiKD86XCIpLmNvbmNhdChnLnBhdHRlcm4sXCIpKSopXCIpLmNvbmNhdCh4LFwiKVwiKS5jb25jYXQoUil9ZWxzZSBiKz1cIig/OlwiLmNvbmNhdChFLFwiKFwiKS5jb25jYXQoZy5wYXR0ZXJuLFwiKVwiKS5jb25jYXQoeCxcIilcIikuY29uY2F0KGcubW9kaWZpZXIpO2Vsc2UgYis9XCIrXCI9PT1nLm1vZGlmaWVyfHxcIipcIj09PWcubW9kaWZpZXI/XCIoKD86XCIuY29uY2F0KGcucGF0dGVybixcIilcIikuY29uY2F0KGcubW9kaWZpZXIsXCIpXCIpOlwiKFwiLmNvbmNhdChnLnBhdHRlcm4sXCIpXCIpLmNvbmNhdChnLm1vZGlmaWVyKTtlbHNlIGIrPVwiKD86XCIuY29uY2F0KEUpLmNvbmNhdCh4LFwiKVwiKS5jb25jYXQoZy5tb2RpZmllcil9fWlmKGYpZXx8KGIrPVwiXCIuY29uY2F0KHcsXCI/XCIpKSxiKz1yLmVuZHNXaXRoP1wiKD89XCIuY29uY2F0KG0sXCIpXCIpOlwiJFwiO2Vsc2V7dmFyIGs9dFt0Lmxlbmd0aC0xXSxPPVwic3RyaW5nXCI9PXR5cGVvZiBrP3cuaW5kZXhPZihrW2subGVuZ3RoLTFdKT4tMTp2b2lkIDA9PT1rO2V8fChiKz1cIig/OlwiLmNvbmNhdCh3LFwiKD89XCIpLmNvbmNhdChtLFwiKSk/XCIpKSxPfHwoYis9XCIoPz1cIi5jb25jYXQodyxcInxcIikuY29uY2F0KG0sXCIpXCIpKX1yZXR1cm4gbmV3IFJlZ0V4cChiLHAocikpfShmdW5jdGlvbih0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTtmb3IodmFyIHI9ZnVuY3Rpb24odCl7Zm9yKHZhciBuPVtdLHI9MDtyPHQubGVuZ3RoOyl7dmFyIGk9dFtyXTtpZihcIipcIiE9PWkmJlwiK1wiIT09aSYmXCI/XCIhPT1pKWlmKFwiXFxcXFwiIT09aSlpZihcIntcIiE9PWkpaWYoXCJ9XCIhPT1pKWlmKFwiOlwiIT09aSlpZihcIihcIiE9PWkpbi5wdXNoKHt0eXBlOlwiQ0hBUlwiLGluZGV4OnIsdmFsdWU6dFtyKytdfSk7ZWxzZXt2YXIgZT0xLG89XCJcIjtpZihcIj9cIj09PXRbcz1yKzFdKXRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXCI/XCIgYXQgJy5jb25jYXQocykpO2Zvcig7czx0Lmxlbmd0aDspaWYoXCJcXFxcXCIhPT10W3NdKXtpZihcIilcIj09PXRbc10pe2lmKDA9PS0tZSl7cysrO2JyZWFrfX1lbHNlIGlmKFwiKFwiPT09dFtzXSYmKGUrKyxcIj9cIiE9PXRbcysxXSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhcHR1cmluZyBncm91cHMgYXJlIG5vdCBhbGxvd2VkIGF0IFwiLmNvbmNhdChzKSk7bys9dFtzKytdfWVsc2Ugbys9dFtzKytdK3RbcysrXTtpZihlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIuY29uY2F0KHIpKTtpZighbyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiLmNvbmNhdChyKSk7bi5wdXNoKHt0eXBlOlwiUEFUVEVSTlwiLGluZGV4OnIsdmFsdWU6b30pLHI9c31lbHNle2Zvcih2YXIgdT1cIlwiLHM9cisxO3M8dC5sZW5ndGg7KXt2YXIgZj10LmNoYXJDb2RlQXQocyk7aWYoIShmPj00OCYmZjw9NTd8fGY+PTY1JiZmPD05MHx8Zj49OTcmJmY8PTEyMnx8OTU9PT1mKSlicmVhazt1Kz10W3MrK119aWYoIXUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIuY29uY2F0KHIpKTtuLnB1c2goe3R5cGU6XCJOQU1FXCIsaW5kZXg6cix2YWx1ZTp1fSkscj1zfWVsc2Ugbi5wdXNoKHt0eXBlOlwiQ0xPU0VcIixpbmRleDpyLHZhbHVlOnRbcisrXX0pO2Vsc2Ugbi5wdXNoKHt0eXBlOlwiT1BFTlwiLGluZGV4OnIsdmFsdWU6dFtyKytdfSk7ZWxzZSBuLnB1c2goe3R5cGU6XCJFU0NBUEVEX0NIQVJcIixpbmRleDpyKyssdmFsdWU6dFtyKytdfSk7ZWxzZSBuLnB1c2goe3R5cGU6XCJNT0RJRklFUlwiLGluZGV4OnIsdmFsdWU6dFtyKytdfSl9cmV0dXJuIG4ucHVzaCh7dHlwZTpcIkVORFwiLGluZGV4OnIsdmFsdWU6XCJcIn0pLG59KHQpLGk9bi5wcmVmaXhlcyxlPXZvaWQgMD09PWk/XCIuL1wiOmksbz1cIlteXCIuY29uY2F0KGwobi5kZWxpbWl0ZXJ8fFwiLyM/XCIpLFwiXSs/XCIpLHU9W10scz0wLGY9MCxjPVwiXCIsYT1mdW5jdGlvbih0KXtpZihmPHIubGVuZ3RoJiZyW2ZdLnR5cGU9PT10KXJldHVybiByW2YrK10udmFsdWV9LGg9ZnVuY3Rpb24odCl7dmFyIG49YSh0KTtpZih2b2lkIDAhPT1uKXJldHVybiBuO3ZhciBpPXJbZl0sZT1pLmluZGV4O3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIFwiLmNvbmNhdChpLnR5cGUsXCIgYXQgXCIpLmNvbmNhdChlLFwiLCBleHBlY3RlZCBcIikuY29uY2F0KHQpKX0sdj1mdW5jdGlvbigpe2Zvcih2YXIgdCxuPVwiXCI7dD1hKFwiQ0hBUlwiKXx8YShcIkVTQ0FQRURfQ0hBUlwiKTspbis9dDtyZXR1cm4gbn07ZjxyLmxlbmd0aDspe3ZhciBkPWEoXCJDSEFSXCIpLHA9YShcIk5BTUVcIiksbT1hKFwiUEFUVEVSTlwiKTtpZihwfHxtKS0xPT09ZS5pbmRleE9mKGI9ZHx8XCJcIikmJihjKz1iLGI9XCJcIiksYyYmKHUucHVzaChjKSxjPVwiXCIpLHUucHVzaCh7bmFtZTpwfHxzKysscHJlZml4OmIsc3VmZml4OlwiXCIscGF0dGVybjptfHxvLG1vZGlmaWVyOmEoXCJNT0RJRklFUlwiKXx8XCJcIn0pO2Vsc2V7dmFyIHc9ZHx8YShcIkVTQ0FQRURfQ0hBUlwiKTtpZih3KWMrPXc7ZWxzZSBpZihjJiYodS5wdXNoKGMpLGM9XCJcIiksYShcIk9QRU5cIikpe3ZhciBiPXYoKSx5PWEoXCJOQU1FXCIpfHxcIlwiLFA9YShcIlBBVFRFUk5cIil8fFwiXCIsZz12KCk7aChcIkNMT1NFXCIpLHUucHVzaCh7bmFtZTp5fHwoUD9zKys6XCJcIikscGF0dGVybjp5JiYhUD9vOlAscHJlZml4OmIsc3VmZml4OmcsbW9kaWZpZXI6YShcIk1PRElGSUVSXCIpfHxcIlwifSl9ZWxzZSBoKFwiRU5EXCIpfX1yZXR1cm4gdX0odCxyKSxuLHIpfShuLHIsaSl9LHg9e19fcHJvdG9fXzpudWxsLHVwZGF0ZTpnLG5leHRUaWNrOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCl9KX0scGF0aFRvUmVnZXhwOkV9LFI9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbn0saz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9d2luZG93LmxvY2F0aW9uLmhyZWYpLE8odCkucG9ydH0sTz1mdW5jdGlvbih0KXt2YXIgbixyPXQubWF0Y2goLzpcXGQrLyk7aWYobnVsbD09PXIpL15odHRwLy50ZXN0KHQpJiYobj04MCksL15odHRwcy8udGVzdCh0KSYmKG49NDQzKTtlbHNle3ZhciBpPXJbMF0uc3Vic3RyaW5nKDEpO249cGFyc2VJbnQoaSwxMCl9dmFyIGUsbz10LnJlcGxhY2UoUigpLFwiXCIpLHU9e30scz1vLmluZGV4T2YoXCIjXCIpO3M+PTAmJihlPW8uc2xpY2UocysxKSxvPW8uc2xpY2UoMCxzKSk7dmFyIGY9by5pbmRleE9mKFwiP1wiKTtyZXR1cm4gZj49MCYmKHU9VChvLnNsaWNlKGYrMSkpLG89by5zbGljZSgwLGYpKSx7aGFzaDplLHBhdGg6byxwb3J0Om4scXVlcnk6dX19LFQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BsaXQoXCImXCIpLnJlZHVjZShmdW5jdGlvbih0LG4pe3ZhciByPW4uc3BsaXQoXCI9XCIpO3JldHVybiB0W3JbMF1dPXJbMV0sdH0se30pfSxBPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD13aW5kb3cubG9jYXRpb24uaHJlZiksdC5yZXBsYWNlKC8oXFwvIy4qfFxcL3wjLiopJC8sXCJcIil9LGo9e19fcHJvdG9fXzpudWxsLGdldEhyZWY6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLmhyZWZ9LGdldEFic29sdXRlSHJlZjpmdW5jdGlvbih0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj1kb2N1bWVudC5iYXNlVVJJKSxuZXcgVVJMKHQsbikuaHJlZn0sZ2V0T3JpZ2luOlIsZ2V0UG9ydDprLGdldFBhdGg6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXdpbmRvdy5sb2NhdGlvbi5ocmVmKSxPKHQpLnBhdGh9LGdldFF1ZXJ5OmZ1bmN0aW9uKHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxuP0pTT04uc3RyaW5naWZ5KE8odCkucXVlcnkpOk8odCkucXVlcnl9LGdldEhhc2g6ZnVuY3Rpb24odCl7cmV0dXJuIE8odCkuaGFzaH0scGFyc2U6TyxwYXJzZVF1ZXJ5OlQsY2xlYW46QX07ZnVuY3Rpb24gTSh0LG4saSxlLG8pe3JldHVybiB2b2lkIDA9PT1uJiYobj0yZTMpLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHUscyl7dmFyIGY9bmV3IFhNTEh0dHBSZXF1ZXN0O2Yub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZi5yZWFkeVN0YXRlPT09WE1MSHR0cFJlcXVlc3QuRE9ORSlpZigyMDA9PT1mLnN0YXR1cyl7dmFyIG49XCJcIiE9PWYucmVzcG9uc2VVUkwmJmYucmVzcG9uc2VVUkwhPT10P2YucmVzcG9uc2VVUkw6dDt1KHtodG1sOmYucmVzcG9uc2VUZXh0LHVybDpyKHtocmVmOm59LE8obikpfSksZS51cGRhdGUodCx7c3RhdHVzOlwiZnVsZmlsbGVkXCIsdGFyZ2V0Om59KX1lbHNlIGlmKGYuc3RhdHVzKXt2YXIgbz17c3RhdHVzOmYuc3RhdHVzLHN0YXR1c1RleHQ6Zi5zdGF0dXNUZXh0fTtpKHQsbykscyhvKSxlLnVwZGF0ZSh0LHtzdGF0dXM6XCJyZWplY3RlZFwifSl9fSxmLm9udGltZW91dD1mdW5jdGlvbigpe3ZhciByPW5ldyBFcnJvcihcIlRpbWVvdXQgZXJyb3IgW1wiK24rXCJdXCIpO2kodCxyKSxzKHIpLGUudXBkYXRlKHQse3N0YXR1czpcInJlamVjdGVkXCJ9KX0sZi5vbmVycm9yPWZ1bmN0aW9uKCl7dmFyIG49bmV3IEVycm9yKFwiRmV0Y2ggZXJyb3JcIik7aSh0LG4pLHMobiksZS51cGRhdGUodCx7c3RhdHVzOlwicmVqZWN0ZWRcIn0pfSxmLm9wZW4oXCJHRVRcIix0KSxmLnRpbWVvdXQ9bixmLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixcInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sXCIpLGYuc2V0UmVxdWVzdEhlYWRlcihcIngtYmFyYmFcIixcInllc1wiKSxvLmFsbCgpLmZvckVhY2goZnVuY3Rpb24odCxuKXtmLnNldFJlcXVlc3RIZWFkZXIobix0KX0pLGYuc2VuZCgpfSl9ZnVuY3Rpb24gTih0KXtyZXR1cm4hIXQmJihcIm9iamVjdFwiPT10eXBlb2YgdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGhlbn1mdW5jdGlvbiBTKHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSxmdW5jdGlvbigpe3ZhciByPWFyZ3VtZW50cyxpPSExLGU9bmV3IFByb21pc2UoZnVuY3Rpb24oZSxvKXtuLmFzeW5jPWZ1bmN0aW9uKCl7cmV0dXJuIGk9ITAsZnVuY3Rpb24odCxuKXt0P28odCk6ZShuKX19O3ZhciB1PXQuYXBwbHkobixbXS5zbGljZS5jYWxsKHIpKTtpfHwoTih1KT91LnRoZW4oZSxvKTplKHUpKX0pO3JldHVybiBlfX12YXIgQz0vKiNfX1BVUkVfXyovZnVuY3Rpb24odCl7ZnVuY3Rpb24gbigpe3ZhciBuO3JldHVybihuPXQuY2FsbCh0aGlzKXx8dGhpcykubG9nZ2VyPW5ldyBkKFwiQGJhcmJhL2NvcmVcIiksbi5hbGw9W1wicmVhZHlcIixcInBhZ2VcIixcInJlc2V0XCIsXCJjdXJyZW50QWRkZWRcIixcImN1cnJlbnRSZW1vdmVkXCIsXCJuZXh0QWRkZWRcIixcIm5leHRSZW1vdmVkXCIsXCJiZWZvcmVPbmNlXCIsXCJvbmNlXCIsXCJhZnRlck9uY2VcIixcImJlZm9yZVwiLFwiYmVmb3JlTGVhdmVcIixcImxlYXZlXCIsXCJhZnRlckxlYXZlXCIsXCJiZWZvcmVFbnRlclwiLFwiZW50ZXJcIixcImFmdGVyRW50ZXJcIixcImFmdGVyXCJdLG4ucmVnaXN0ZXJlZD1uZXcgTWFwLG4uaW5pdCgpLG59aShuLHQpO3ZhciByPW4ucHJvdG90eXBlO3JldHVybiByLmluaXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMucmVnaXN0ZXJlZC5jbGVhcigpLHRoaXMuYWxsLmZvckVhY2goZnVuY3Rpb24obil7dFtuXXx8KHRbbl09ZnVuY3Rpb24ocixpKXt0LnJlZ2lzdGVyZWQuaGFzKG4pfHx0LnJlZ2lzdGVyZWQuc2V0KG4sbmV3IFNldCksdC5yZWdpc3RlcmVkLmdldChuKS5hZGQoe2N0eDppfHx7fSxmbjpyfSl9KX0pfSxyLmRvPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cyxyPXRoaXM7aWYodGhpcy5yZWdpc3RlcmVkLmhhcyh0KSl7dmFyIGk9UHJvbWlzZS5yZXNvbHZlKCk7cmV0dXJuIHRoaXMucmVnaXN0ZXJlZC5nZXQodCkuZm9yRWFjaChmdW5jdGlvbih0KXtpPWkudGhlbihmdW5jdGlvbigpe3JldHVybiBTKHQuZm4sdC5jdHgpLmFwcGx5KHZvaWQgMCxbXS5zbGljZS5jYWxsKG4sMSkpfSl9KSxpLmNhdGNoKGZ1bmN0aW9uKG4pe3IubG9nZ2VyLmRlYnVnKFwiSG9vayBlcnJvciBbXCIrdCtcIl1cIiksci5sb2dnZXIuZXJyb3Iobil9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9LHIuY2xlYXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYWxsLmZvckVhY2goZnVuY3Rpb24obil7ZGVsZXRlIHRbbl19KSx0aGlzLmluaXQoKX0sci5oZWxwPWZ1bmN0aW9uKCl7dGhpcy5sb2dnZXIuaW5mbyhcIkF2YWlsYWJsZSBob29rczogXCIrdGhpcy5hbGwuam9pbihcIixcIikpO3ZhciB0PVtdO3RoaXMucmVnaXN0ZXJlZC5mb3JFYWNoKGZ1bmN0aW9uKG4scil7cmV0dXJuIHQucHVzaChyKX0pLHRoaXMubG9nZ2VyLmluZm8oXCJSZWdpc3RlcmVkIGhvb2tzOiBcIit0LmpvaW4oXCIsXCIpKX0sbn0oaCksTD1uZXcgQyxIPS8qI19fUFVSRV9fKi9mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5rPXZvaWQgMCx0aGlzLk89W10sXCJib29sZWFuXCI9PXR5cGVvZiB0KXRoaXMuaz10O2Vsc2V7dmFyIG49QXJyYXkuaXNBcnJheSh0KT90Olt0XTt0aGlzLk89bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIEUodCl9KX19cmV0dXJuIHQucHJvdG90eXBlLmNoZWNrSHJlZj1mdW5jdGlvbih0KXtpZihcImJvb2xlYW5cIj09dHlwZW9mIHRoaXMuaylyZXR1cm4gdGhpcy5rO3ZhciBuPU8odCkucGF0aDtyZXR1cm4gdGhpcy5PLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10LmV4ZWMobil9KX0sdH0oKSxfPS8qI19fUFVSRV9fKi9mdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4pe3ZhciByO3JldHVybihyPXQuY2FsbCh0aGlzLG4pfHx0aGlzKS5UPW5ldyBNYXAscn1pKG4sdCk7dmFyIGU9bi5wcm90b3R5cGU7cmV0dXJuIGUuc2V0PWZ1bmN0aW9uKHQsbixyLGksZSl7cmV0dXJuIHRoaXMuVC5zZXQodCx7YWN0aW9uOnIscmVxdWVzdDpuLHN0YXR1czppLHRhcmdldDpudWxsIT1lP2U6dH0pLHthY3Rpb246cixyZXF1ZXN0Om4sc3RhdHVzOmksdGFyZ2V0OmV9fSxlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ULmdldCh0KX0sZS5nZXRSZXF1ZXN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLlQuZ2V0KHQpLnJlcXVlc3R9LGUuZ2V0QWN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLlQuZ2V0KHQpLmFjdGlvbn0sZS5nZXRTdGF0dXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuVC5nZXQodCkuc3RhdHVzfSxlLmdldFRhcmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ULmdldCh0KS50YXJnZXR9LGUuaGFzPWZ1bmN0aW9uKHQpe3JldHVybiF0aGlzLmNoZWNrSHJlZih0KSYmdGhpcy5ULmhhcyh0KX0sZS5kZWxldGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuVC5kZWxldGUodCl9LGUudXBkYXRlPWZ1bmN0aW9uKHQsbil7dmFyIGk9cih7fSx0aGlzLlQuZ2V0KHQpLG4pO3JldHVybiB0aGlzLlQuc2V0KHQsaSksaX0sbn0oSCksRD0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5BPW5ldyBNYXB9dmFyIG49dC5wcm90b3R5cGU7cmV0dXJuIG4uc2V0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRoaXMuQS5zZXQodCxuKSx7bmFtZTpufX0sbi5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuQS5nZXQodCl9LG4uYWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQX0sbi5oYXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuQS5oYXModCl9LG4uZGVsZXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLkEuZGVsZXRlKHQpfSxuLmNsZWFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQS5jbGVhcigpfSx0fSgpLEI9ZnVuY3Rpb24oKXtyZXR1cm4hd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlfSxxPWZ1bmN0aW9uKHQpe3JldHVybiF0LmVsfHwhdC5ocmVmfSxGPWZ1bmN0aW9uKHQpe3ZhciBuPXQuZXZlbnQ7cmV0dXJuIG4ud2hpY2g+MXx8bi5tZXRhS2V5fHxuLmN0cmxLZXl8fG4uc2hpZnRLZXl8fG4uYWx0S2V5fSxJPWZ1bmN0aW9uKHQpe3ZhciBuPXQuZWw7cmV0dXJuIG4uaGFzQXR0cmlidXRlKFwidGFyZ2V0XCIpJiZcIl9ibGFua1wiPT09bi50YXJnZXR9LFU9ZnVuY3Rpb24odCl7dmFyIG49dC5lbDtyZXR1cm4gdm9pZCAwIT09bi5wcm90b2NvbCYmd2luZG93LmxvY2F0aW9uLnByb3RvY29sIT09bi5wcm90b2NvbHx8dm9pZCAwIT09bi5ob3N0bmFtZSYmd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIT09bi5ob3N0bmFtZX0sJD1mdW5jdGlvbih0KXt2YXIgbj10LmVsO3JldHVybiB2b2lkIDAhPT1uLnBvcnQmJmsoKSE9PWsobi5ocmVmKX0sUT1mdW5jdGlvbih0KXt2YXIgbj10LmVsO3JldHVybiBuLmdldEF0dHJpYnV0ZSYmXCJzdHJpbmdcIj09dHlwZW9mIG4uZ2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIil9LFg9ZnVuY3Rpb24odCl7cmV0dXJuIHQuZWwuaGFzQXR0cmlidXRlKG0ucHJlZml4K1wiLVwiK20ucHJldmVudCl9LHo9ZnVuY3Rpb24odCl7cmV0dXJuIEJvb2xlYW4odC5lbC5jbG9zZXN0KFwiW1wiK20ucHJlZml4K1wiLVwiK20ucHJldmVudCsnPVwiYWxsXCJdJykpfSxHPWZ1bmN0aW9uKHQpe3ZhciBuPXQuaHJlZjtyZXR1cm4gQShuKT09PUEoKSYmayhuKT09PWsoKX0sSj0vKiNfX1BVUkVfXyovZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihuKXt2YXIgcjtyZXR1cm4ocj10LmNhbGwodGhpcyxuKXx8dGhpcykuc3VpdGU9W10sci50ZXN0cz1uZXcgTWFwLHIuaW5pdCgpLHJ9aShuLHQpO3ZhciByPW4ucHJvdG90eXBlO3JldHVybiByLmluaXQ9ZnVuY3Rpb24oKXt0aGlzLmFkZChcInB1c2hTdGF0ZVwiLEIpLHRoaXMuYWRkKFwiZXhpc3RzXCIscSksdGhpcy5hZGQoXCJuZXdUYWJcIixGKSx0aGlzLmFkZChcImJsYW5rXCIsSSksdGhpcy5hZGQoXCJjb3JzRG9tYWluXCIsVSksdGhpcy5hZGQoXCJjb3JzUG9ydFwiLCQpLHRoaXMuYWRkKFwiZG93bmxvYWRcIixRKSx0aGlzLmFkZChcInByZXZlbnRTZWxmXCIsWCksdGhpcy5hZGQoXCJwcmV2ZW50QWxsXCIseiksdGhpcy5hZGQoXCJzYW1lVXJsXCIsRywhMSl9LHIuYWRkPWZ1bmN0aW9uKHQsbixyKXt2b2lkIDA9PT1yJiYocj0hMCksdGhpcy50ZXN0cy5zZXQodCxuKSxyJiZ0aGlzLnN1aXRlLnB1c2godCl9LHIucnVuPWZ1bmN0aW9uKHQsbixyLGkpe3JldHVybiB0aGlzLnRlc3RzLmdldCh0KSh7ZWw6bixldmVudDpyLGhyZWY6aX0pfSxyLmNoZWNrTGluaz1mdW5jdGlvbih0LG4scil7dmFyIGk9dGhpcztyZXR1cm4gdGhpcy5zdWl0ZS5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBpLnJ1bihlLHQsbixyKX0pfSxufShIKSxXPS8qI19fUFVSRV9fKi9mdW5jdGlvbih0KXtmdW5jdGlvbiBuKHIsaSl7dmFyIGU7cmV0dXJuIHZvaWQgMD09PWkmJihpPVwiQmFyYmEgZXJyb3JcIiksKGU9dC5jYWxsLmFwcGx5KHQsW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSkpfHx0aGlzKS5lcnJvcj12b2lkIDAsZS5sYWJlbD12b2lkIDAsZS5lcnJvcj1yLGUubGFiZWw9aSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoYyhlKSxuKSxlLm5hbWU9XCJCYXJiYUVycm9yXCIsZX1yZXR1cm4gaShuLHQpLG59KC8qI19fUFVSRV9fKi9mKEVycm9yKSksSz0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZvaWQgMD09PXQmJih0PVtdKSx0aGlzLmxvZ2dlcj1uZXcgZChcIkBiYXJiYS9jb3JlXCIpLHRoaXMuYWxsPVtdLHRoaXMucGFnZT1bXSx0aGlzLm9uY2U9W10sdGhpcy5qPVt7bmFtZTpcIm5hbWVzcGFjZVwiLHR5cGU6XCJzdHJpbmdzXCJ9LHtuYW1lOlwiY3VzdG9tXCIsdHlwZTpcImZ1bmN0aW9uXCJ9XSx0JiYodGhpcy5hbGw9dGhpcy5hbGwuY29uY2F0KHQpKSx0aGlzLnVwZGF0ZSgpfXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLmFkZD1mdW5jdGlvbih0LG4pe1wicnVsZVwiPT09dD90aGlzLmouc3BsaWNlKG4ucG9zaXRpb258fDAsMCxuLnZhbHVlKTp0aGlzLmFsbC5wdXNoKG4pLHRoaXMudXBkYXRlKCl9LG4ucmVzb2x2ZT1mdW5jdGlvbih0LG4pe3ZhciByPXRoaXM7dm9pZCAwPT09biYmKG49e30pO3ZhciBpPW4ub25jZT90aGlzLm9uY2U6dGhpcy5wYWdlO2k9aS5maWx0ZXIobi5zZWxmP2Z1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWUmJlwic2VsZlwiPT09dC5uYW1lfTpmdW5jdGlvbih0KXtyZXR1cm4hdC5uYW1lfHxcInNlbGZcIiE9PXQubmFtZX0pO3ZhciBlPW5ldyBNYXAsbz1pLmZpbmQoZnVuY3Rpb24oaSl7dmFyIG89ITAsdT17fTtyZXR1cm4gbi5zZWxmJiZcInNlbGZcIj09PWkubmFtZT8oZS5zZXQoaSx1KSwhMCk6KHIuai5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbihuKXtvJiYobz1yLk0oaSxuLHQsdSksaS5mcm9tJiZpLnRvJiYobz1yLk0oaSxuLHQsdSxcImZyb21cIikmJnIuTShpLG4sdCx1LFwidG9cIikpLGkuZnJvbSYmIWkudG8mJihvPXIuTShpLG4sdCx1LFwiZnJvbVwiKSksIWkuZnJvbSYmaS50byYmKG89ci5NKGksbix0LHUsXCJ0b1wiKSkpfSksZS5zZXQoaSx1KSxvKX0pLHU9ZS5nZXQobykscz1bXTtpZihzLnB1c2gobi5vbmNlP1wib25jZVwiOlwicGFnZVwiKSxuLnNlbGYmJnMucHVzaChcInNlbGZcIiksdSl7dmFyIGYsYz1bb107T2JqZWN0LmtleXModSkubGVuZ3RoPjAmJmMucHVzaCh1KSwoZj10aGlzLmxvZ2dlcikuaW5mby5hcHBseShmLFtcIlRyYW5zaXRpb24gZm91bmQgW1wiK3Muam9pbihcIixcIikrXCJdXCJdLmNvbmNhdChjKSl9ZWxzZSB0aGlzLmxvZ2dlci5pbmZvKFwiTm8gdHJhbnNpdGlvbiBmb3VuZCBbXCIrcy5qb2luKFwiLFwiKStcIl1cIik7cmV0dXJuIG99LG4udXBkYXRlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmFsbD10aGlzLmFsbC5tYXAoZnVuY3Rpb24obil7cmV0dXJuIHQuTihuKX0pLnNvcnQoZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5wcmlvcml0eS1uLnByaW9yaXR5fSkucmV2ZXJzZSgpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIHQucHJpb3JpdHksdH0pLHRoaXMucGFnZT10aGlzLmFsbC5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQubGVhdmV8fHZvaWQgMCE9PXQuZW50ZXJ9KSx0aGlzLm9uY2U9dGhpcy5hbGwuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10Lm9uY2V9KX0sbi5NPWZ1bmN0aW9uKHQsbixyLGksZSl7dmFyIG89ITAsdT0hMSxzPXQsZj1uLm5hbWUsYz1mLGE9ZixoPWYsdj1lP3NbZV06cyxkPVwidG9cIj09PWU/ci5uZXh0OnIuY3VycmVudDtpZihlP3YmJnZbZl06dltmXSl7c3dpdGNoKG4udHlwZSl7Y2FzZVwic3RyaW5nc1wiOmRlZmF1bHQ6dmFyIGw9QXJyYXkuaXNBcnJheSh2W2NdKT92W2NdOlt2W2NdXTtkW2NdJiYtMSE9PWwuaW5kZXhPZihkW2NdKSYmKHU9ITApLC0xPT09bC5pbmRleE9mKGRbY10pJiYobz0hMSk7YnJlYWs7Y2FzZVwib2JqZWN0XCI6dmFyIHA9QXJyYXkuaXNBcnJheSh2W2FdKT92W2FdOlt2W2FdXTtkW2FdPyhkW2FdLm5hbWUmJi0xIT09cC5pbmRleE9mKGRbYV0ubmFtZSkmJih1PSEwKSwtMT09PXAuaW5kZXhPZihkW2FdLm5hbWUpJiYobz0hMSkpOm89ITE7YnJlYWs7Y2FzZVwiZnVuY3Rpb25cIjp2W2hdKHIpP3U9ITA6bz0hMX11JiYoZT8oaVtlXT1pW2VdfHx7fSxpW2VdW2ZdPXNbZV1bZl0pOmlbZl09c1tmXSl9cmV0dXJuIG99LG4uUz1mdW5jdGlvbih0LG4scil7dmFyIGk9MDtyZXR1cm4odFtuXXx8dC5mcm9tJiZ0LmZyb21bbl18fHQudG8mJnQudG9bbl0pJiYoaSs9TWF0aC5wb3coMTAsciksdC5mcm9tJiZ0LmZyb21bbl0mJihpKz0xKSx0LnRvJiZ0LnRvW25dJiYoaSs9MikpLGl9LG4uTj1mdW5jdGlvbih0KXt2YXIgbj10aGlzO3QucHJpb3JpdHk9MDt2YXIgcj0wO3JldHVybiB0aGlzLmouZm9yRWFjaChmdW5jdGlvbihpLGUpe3IrPW4uUyh0LGkubmFtZSxlKzEpfSksdC5wcmlvcml0eT1yLHR9LHR9KCk7ZnVuY3Rpb24gVih0LG4pe3RyeXt2YXIgcj10KCl9Y2F0Y2godCl7cmV0dXJuIG4odCl9cmV0dXJuIHImJnIudGhlbj9yLnRoZW4odm9pZCAwLG4pOnJ9dmFyIFk9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2b2lkIDA9PT10JiYodD1bXSksdGhpcy5sb2dnZXI9bmV3IGQoXCJAYmFyYmEvY29yZVwiKSx0aGlzLnN0b3JlPXZvaWQgMCx0aGlzLkM9ITEsdGhpcy5zdG9yZT1uZXcgSyh0KX12YXIgcj10LnByb3RvdHlwZTtyZXR1cm4gci5nZXQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdGhpcy5zdG9yZS5yZXNvbHZlKHQsbil9LHIuZG9PbmNlPWZ1bmN0aW9uKHQpe3ZhciBuPXQuZGF0YSxyPXQudHJhbnNpdGlvbjt0cnl7dmFyIGk9ZnVuY3Rpb24oKXtlLkM9ITF9LGU9dGhpcyxvPXJ8fHt9O2UuQz0hMDt2YXIgdT1WKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShlLkwoXCJiZWZvcmVPbmNlXCIsbixvKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoZS5vbmNlKG4sbykpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUuTChcImFmdGVyT25jZVwiLG4sbykpLnRoZW4oZnVuY3Rpb24oKXt9KX0pfSl9LGZ1bmN0aW9uKHQpe2UuQz0hMSxlLmxvZ2dlci5kZWJ1ZyhcIlRyYW5zaXRpb24gZXJyb3IgW2JlZm9yZS9hZnRlci9vbmNlXVwiKSxlLmxvZ2dlci5lcnJvcih0KX0pO3JldHVybiBQcm9taXNlLnJlc29sdmUodSYmdS50aGVuP3UudGhlbihpKTppKCkpfWNhdGNoKHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX19LHIuZG9QYWdlPWZ1bmN0aW9uKHQpe3ZhciBuPXQuZGF0YSxyPXQudHJhbnNpdGlvbixpPXQucGFnZSxlPXQud3JhcHBlcjt0cnl7dmFyIG89ZnVuY3Rpb24odCl7dS5DPSExfSx1PXRoaXMscz1yfHx7fSxmPSEwPT09cy5zeW5jfHwhMTt1LkM9ITA7dmFyIGM9VihmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUuTChcImJlZm9yZVwiLG4scykpLnRoZW4oZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3JldHVybiBQcm9taXNlLnJlc29sdmUodS5yZW1vdmUobikpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUuTChcImFmdGVyXCIsbixzKSkudGhlbihmdW5jdGlvbigpe30pfSl9dmFyIHI9ZnVuY3Rpb24oKXtpZihmKXJldHVybiBWKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh1LmFkZChuLGUpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh1LkwoXCJiZWZvcmVMZWF2ZVwiLG4scykpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUuTChcImJlZm9yZUVudGVyXCIsbixzKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoUHJvbWlzZS5hbGwoW3UubGVhdmUobixzKSx1LmVudGVyKG4scyldKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUodS5MKFwiYWZ0ZXJMZWF2ZVwiLG4scykpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUuTChcImFmdGVyRW50ZXJcIixuLHMpKS50aGVuKGZ1bmN0aW9uKCl7fSl9KX0pfSl9KX0pfSxmdW5jdGlvbih0KXtpZih1LkgodCkpdGhyb3cgbmV3IFcodCxcIlRyYW5zaXRpb24gZXJyb3IgW3N5bmNdXCIpfSk7dmFyIHQ9ZnVuY3Rpb24odCl7cmV0dXJuIFYoZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbigpe2lmKCExIT09cilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUuYWRkKG4sZSkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUuTChcImJlZm9yZUVudGVyXCIsbixzKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUodS5lbnRlcihuLHMscikpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUuTChcImFmdGVyRW50ZXJcIixuLHMpKS50aGVuKGZ1bmN0aW9uKCl7fSl9KX0pfSl9KCk7aWYodCYmdC50aGVuKXJldHVybiB0LnRoZW4oZnVuY3Rpb24oKXt9KX0sZnVuY3Rpb24odCl7aWYodS5IKHQpKXRocm93IG5ldyBXKHQsXCJUcmFuc2l0aW9uIGVycm9yIFtiZWZvcmUvYWZ0ZXIvZW50ZXJdXCIpfSl9LHI9ITEsbz1WKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh1LkwoXCJiZWZvcmVMZWF2ZVwiLG4scykpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFByb21pc2UuYWxsKFt1LmxlYXZlKG4scyksZyhpLG4pXSkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiByPXQsUHJvbWlzZS5yZXNvbHZlKHUuTChcImFmdGVyTGVhdmVcIixuLHMpKS50aGVuKGZ1bmN0aW9uKCl7fSl9KX0pfSxmdW5jdGlvbih0KXtpZih1LkgodCkpdGhyb3cgbmV3IFcodCxcIlRyYW5zaXRpb24gZXJyb3IgW2JlZm9yZS9hZnRlci9sZWF2ZV1cIil9KTtyZXR1cm4gbyYmby50aGVuP28udGhlbih0KTp0KCl9KCk7cmV0dXJuIHImJnIudGhlbj9yLnRoZW4odCk6dCgpfSl9dmFyIHI9ZnVuY3Rpb24oKXtpZihmKXJldHVybiBQcm9taXNlLnJlc29sdmUoZyhpLG4pKS50aGVuKGZ1bmN0aW9uKCl7fSl9KCk7cmV0dXJuIHImJnIudGhlbj9yLnRoZW4odCk6dCgpfSxmdW5jdGlvbih0KXtpZih1LkM9ITEsdC5uYW1lJiZcIkJhcmJhRXJyb3JcIj09PXQubmFtZSl0aHJvdyB1LmxvZ2dlci5kZWJ1Zyh0LmxhYmVsKSx1LmxvZ2dlci5lcnJvcih0LmVycm9yKSx0O3Rocm93IHUubG9nZ2VyLmRlYnVnKFwiVHJhbnNpdGlvbiBlcnJvciBbcGFnZV1cIiksdS5sb2dnZXIuZXJyb3IodCksdH0pO3JldHVybiBQcm9taXNlLnJlc29sdmUoYyYmYy50aGVuP2MudGhlbihvKTpvKCkpfWNhdGNoKHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX19LHIub25jZT1mdW5jdGlvbih0LG4pe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEwuZG8oXCJvbmNlXCIsdCxuKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBuLm9uY2U/UyhuLm9uY2UsbikodCk6UHJvbWlzZS5yZXNvbHZlKCl9KX1jYXRjaCh0KXtyZXR1cm4gUHJvbWlzZS5yZWplY3QodCl9fSxyLmxlYXZlPWZ1bmN0aW9uKHQsbil7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoTC5kbyhcImxlYXZlXCIsdCxuKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBuLmxlYXZlP1Mobi5sZWF2ZSxuKSh0KTpQcm9taXNlLnJlc29sdmUoKX0pfWNhdGNoKHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX19LHIuZW50ZXI9ZnVuY3Rpb24odCxuLHIpe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEwuZG8oXCJlbnRlclwiLHQsbikpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbi5lbnRlcj9TKG4uZW50ZXIsbikodCxyKTpQcm9taXNlLnJlc29sdmUoKX0pfWNhdGNoKHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX19LHIuYWRkPWZ1bmN0aW9uKHQsbil7dHJ5e3JldHVybiBiLmFkZENvbnRhaW5lcih0Lm5leHQuY29udGFpbmVyLG4pLEwuZG8oXCJuZXh0QWRkZWRcIix0KSxQcm9taXNlLnJlc29sdmUoKX1jYXRjaCh0KXtyZXR1cm4gUHJvbWlzZS5yZWplY3QodCl9fSxyLnJlbW92ZT1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIGIucmVtb3ZlQ29udGFpbmVyKHQuY3VycmVudC5jb250YWluZXIpLEwuZG8oXCJjdXJyZW50UmVtb3ZlZFwiLHQpLFByb21pc2UucmVzb2x2ZSgpfWNhdGNoKHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX19LHIuSD1mdW5jdGlvbih0KXtyZXR1cm4gdC5tZXNzYWdlPyEvVGltZW91dCBlcnJvcnxGZXRjaCBlcnJvci8udGVzdCh0Lm1lc3NhZ2UpOiF0LnN0YXR1c30sci5MPWZ1bmN0aW9uKHQsbixyKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShMLmRvKHQsbixyKSkudGhlbihmdW5jdGlvbigpe3JldHVybiByW3RdP1Moclt0XSxyKShuKTpQcm9taXNlLnJlc29sdmUoKX0pfWNhdGNoKHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX19LG4odCxbe2tleTpcImlzUnVubmluZ1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLkN9LHNldDpmdW5jdGlvbih0KXt0aGlzLkM9dH19LHtrZXk6XCJoYXNPbmNlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RvcmUub25jZS5sZW5ndGg+MH19LHtrZXk6XCJoYXNTZWxmXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RvcmUuYWxsLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuXCJzZWxmXCI9PT10Lm5hbWV9KX19LHtrZXk6XCJzaG91bGRXYWl0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RvcmUuYWxsLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQudG8mJiF0LnRvLnJvdXRlfHx0LnN5bmN9KX19XSksdH0oKSxaPS8qI19fUFVSRV9fKi9mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIG49dGhpczt0aGlzLm5hbWVzPVtcImJlZm9yZUxlYXZlXCIsXCJhZnRlckxlYXZlXCIsXCJiZWZvcmVFbnRlclwiLFwiYWZ0ZXJFbnRlclwiXSx0aGlzLmJ5TmFtZXNwYWNlPW5ldyBNYXAsMCE9PXQubGVuZ3RoJiYodC5mb3JFYWNoKGZ1bmN0aW9uKHQpe24uYnlOYW1lc3BhY2Uuc2V0KHQubmFtZXNwYWNlLHQpfSksdGhpcy5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe0xbdF0obi5fKHQpKX0pKX1yZXR1cm4gdC5wcm90b3R5cGUuXz1mdW5jdGlvbih0KXt2YXIgbj10aGlzO3JldHVybiBmdW5jdGlvbihyKXt2YXIgaT10Lm1hdGNoKC9lbnRlci9pKT9yLm5leHQ6ci5jdXJyZW50LGU9bi5ieU5hbWVzcGFjZS5nZXQoaS5uYW1lc3BhY2UpO3JldHVybiBlJiZlW3RdP1MoZVt0XSxlKShyKTpQcm9taXNlLnJlc29sdmUoKX19LHR9KCk7RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc3x8KEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXM9RWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3J8fEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciksRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdHx8KEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3Q9ZnVuY3Rpb24odCl7dmFyIG49dGhpcztkb3tpZihuLm1hdGNoZXModCkpcmV0dXJuIG47bj1uLnBhcmVudEVsZW1lbnR8fG4ucGFyZW50Tm9kZX13aGlsZShudWxsIT09biYmMT09PW4ubm9kZVR5cGUpO3JldHVybiBudWxsfSk7dmFyIHR0PXtjb250YWluZXI6bnVsbCxodG1sOlwiXCIsbmFtZXNwYWNlOlwiXCIsdXJsOntoYXNoOlwiXCIsaHJlZjpcIlwiLHBhdGg6XCJcIixwb3J0Om51bGwscXVlcnk6e319fSxudD0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy52ZXJzaW9uPVwiMi4xMC4zXCIsdGhpcy5zY2hlbWFQYWdlPXR0LHRoaXMuTG9nZ2VyPWQsdGhpcy5sb2dnZXI9bmV3IGQoXCJAYmFyYmEvY29yZVwiKSx0aGlzLnBsdWdpbnM9W10sdGhpcy50aW1lb3V0PXZvaWQgMCx0aGlzLmNhY2hlSWdub3JlPXZvaWQgMCx0aGlzLmNhY2hlRmlyc3RQYWdlPXZvaWQgMCx0aGlzLnByZWZldGNoSWdub3JlPXZvaWQgMCx0aGlzLnByZXZlbnRSdW5uaW5nPXZvaWQgMCx0aGlzLmhvb2tzPUwsdGhpcy5jYWNoZT12b2lkIDAsdGhpcy5oZWFkZXJzPXZvaWQgMCx0aGlzLnByZXZlbnQ9dm9pZCAwLHRoaXMudHJhbnNpdGlvbnM9dm9pZCAwLHRoaXMudmlld3M9dm9pZCAwLHRoaXMuZG9tPWIsdGhpcy5oZWxwZXJzPXgsdGhpcy5oaXN0b3J5PVAsdGhpcy5yZXF1ZXN0PU0sdGhpcy51cmw9aix0aGlzLkQ9dm9pZCAwLHRoaXMuQj12b2lkIDAsdGhpcy5xPXZvaWQgMCx0aGlzLkY9dm9pZCAwfXZhciBpPXQucHJvdG90eXBlO3JldHVybiBpLnVzZT1mdW5jdGlvbih0LG4pe3ZhciByPXRoaXMucGx1Z2lucztyLmluZGV4T2YodCk+LTE/dGhpcy5sb2dnZXIud2FybihcIlBsdWdpbiBbXCIrdC5uYW1lK1wiXSBhbHJlYWR5IGluc3RhbGxlZC5cIik6XCJmdW5jdGlvblwiPT10eXBlb2YgdC5pbnN0YWxsPyh0Lmluc3RhbGwodGhpcyxuKSxyLnB1c2godCkpOnRoaXMubG9nZ2VyLndhcm4oXCJQbHVnaW4gW1wiK3QubmFtZSsnXSBoYXMgbm8gXCJpbnN0YWxsXCIgbWV0aG9kLicpfSxpLmluaXQ9ZnVuY3Rpb24odCl7dmFyIG49dm9pZCAwPT09dD97fTp0LGk9bi50cmFuc2l0aW9ucyxlPXZvaWQgMD09PWk/W106aSxvPW4udmlld3MsdT12b2lkIDA9PT1vP1tdOm8scz1uLnNjaGVtYSxmPXZvaWQgMD09PXM/bTpzLGM9bi5yZXF1ZXN0RXJyb3IsYT1uLnRpbWVvdXQsaD12b2lkIDA9PT1hPzJlMzphLHY9bi5jYWNoZUlnbm9yZSxsPXZvaWQgMCE9PXYmJnYscD1uLmNhY2hlRmlyc3RQYWdlLHc9dm9pZCAwIT09cCYmcCxiPW4ucHJlZmV0Y2hJZ25vcmUseT12b2lkIDAhPT1iJiZiLFA9bi5wcmV2ZW50UnVubmluZyxnPXZvaWQgMCE9PVAmJlAsRT1uLnByZXZlbnQseD12b2lkIDA9PT1FP251bGw6RSxSPW4uZGVidWcsaz1uLmxvZ0xldmVsO2lmKGQuc2V0TGV2ZWwoITA9PT0odm9pZCAwIT09UiYmUik/XCJkZWJ1Z1wiOnZvaWQgMD09PWs/XCJvZmZcIjprKSx0aGlzLmxvZ2dlci5pbmZvKHRoaXMudmVyc2lvbiksT2JqZWN0LmtleXMoZikuZm9yRWFjaChmdW5jdGlvbih0KXttW3RdJiYobVt0XT1mW3RdKX0pLHRoaXMuQj1jLHRoaXMudGltZW91dD1oLHRoaXMuY2FjaGVJZ25vcmU9bCx0aGlzLmNhY2hlRmlyc3RQYWdlPXcsdGhpcy5wcmVmZXRjaElnbm9yZT15LHRoaXMucHJldmVudFJ1bm5pbmc9Zyx0aGlzLnE9dGhpcy5kb20uZ2V0V3JhcHBlcigpLCF0aGlzLnEpdGhyb3cgbmV3IEVycm9yKFwiW0BiYXJiYS9jb3JlXSBObyBCYXJiYSB3cmFwcGVyIGZvdW5kXCIpO3RoaXMuSSgpO3ZhciBPPXRoaXMuZGF0YS5jdXJyZW50O2lmKCFPLmNvbnRhaW5lcil0aHJvdyBuZXcgRXJyb3IoXCJbQGJhcmJhL2NvcmVdIE5vIEJhcmJhIGNvbnRhaW5lciBmb3VuZFwiKTtpZih0aGlzLmNhY2hlPW5ldyBfKGwpLHRoaXMuaGVhZGVycz1uZXcgRCx0aGlzLnByZXZlbnQ9bmV3IEooeSksdGhpcy50cmFuc2l0aW9ucz1uZXcgWShlKSx0aGlzLnZpZXdzPW5ldyBaKHUpLG51bGwhPT14KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB4KXRocm93IG5ldyBFcnJvcihcIltAYmFyYmEvY29yZV0gUHJldmVudCBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTt0aGlzLnByZXZlbnQuYWRkKFwicHJldmVudEN1c3RvbVwiLHgpfXRoaXMuaGlzdG9yeS5pbml0KE8udXJsLmhyZWYsTy5uYW1lc3BhY2UpLHcmJnRoaXMuY2FjaGUuc2V0KE8udXJsLmhyZWYsUHJvbWlzZS5yZXNvbHZlKHtodG1sOk8uaHRtbCx1cmw6Ty51cmx9KSxcImluaXRcIixcImZ1bGZpbGxlZFwiKSx0aGlzLlU9dGhpcy5VLmJpbmQodGhpcyksdGhpcy4kPXRoaXMuJC5iaW5kKHRoaXMpLHRoaXMuWD10aGlzLlguYmluZCh0aGlzKSx0aGlzLkcoKSx0aGlzLnBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5pbml0KCl9KTt2YXIgVD10aGlzLmRhdGE7VC50cmlnZ2VyPVwiYmFyYmFcIixULm5leHQ9VC5jdXJyZW50LFQuY3VycmVudD1yKHt9LHRoaXMuc2NoZW1hUGFnZSksdGhpcy5ob29rcy5kbyhcInJlYWR5XCIsVCksdGhpcy5vbmNlKFQpLHRoaXMuSSgpfSxpLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLkkoKSx0aGlzLkooKSx0aGlzLmhpc3RvcnkuY2xlYXIoKSx0aGlzLmhvb2tzLmNsZWFyKCksdGhpcy5wbHVnaW5zPVtdfSxpLmZvcmNlPWZ1bmN0aW9uKHQpe3dpbmRvdy5sb2NhdGlvbi5hc3NpZ24odCl9LGkuZ289ZnVuY3Rpb24odCxuLHIpe3ZhciBpO2lmKHZvaWQgMD09PW4mJihuPVwiYmFyYmFcIiksdGhpcy5GPW51bGwsdGhpcy50cmFuc2l0aW9ucy5pc1J1bm5pbmcpdGhpcy5mb3JjZSh0KTtlbHNlIGlmKCEoaT1cInBvcHN0YXRlXCI9PT1uP3RoaXMuaGlzdG9yeS5jdXJyZW50JiZ0aGlzLnVybC5nZXRQYXRoKHRoaXMuaGlzdG9yeS5jdXJyZW50LnVybCk9PT10aGlzLnVybC5nZXRQYXRoKHQpJiZ0aGlzLnVybC5nZXRRdWVyeSh0aGlzLmhpc3RvcnkuY3VycmVudC51cmwsITApPT09dGhpcy51cmwuZ2V0UXVlcnkodCwhMCk6dGhpcy5wcmV2ZW50LnJ1bihcInNhbWVVcmxcIixudWxsLG51bGwsdCkpfHx0aGlzLnRyYW5zaXRpb25zLmhhc1NlbGYpcmV0dXJuIG49dGhpcy5oaXN0b3J5LmNoYW5nZSh0aGlzLmNhY2hlLmhhcyh0KT90aGlzLmNhY2hlLmdldCh0KS50YXJnZXQ6dCxuLHIpLHImJihyLnN0b3BQcm9wYWdhdGlvbigpLHIucHJldmVudERlZmF1bHQoKSksdGhpcy5wYWdlKHQsbixudWxsIT1yP3I6dm9pZCAwLGkpfSxpLm9uY2U9ZnVuY3Rpb24odCl7dHJ5e3ZhciBuPXRoaXM7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuLmhvb2tzLmRvKFwiYmVmb3JlRW50ZXJcIix0KSkudGhlbihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4uaG9va3MuZG8oXCJhZnRlckVudGVyXCIsdCkpLnRoZW4oZnVuY3Rpb24oKXt9KX12YXIgaT1mdW5jdGlvbigpe2lmKG4udHJhbnNpdGlvbnMuaGFzT25jZSl7dmFyIHI9bi50cmFuc2l0aW9ucy5nZXQodCx7b25jZTohMH0pO3JldHVybiBQcm9taXNlLnJlc29sdmUobi50cmFuc2l0aW9ucy5kb09uY2Uoe3RyYW5zaXRpb246cixkYXRhOnR9KSkudGhlbihmdW5jdGlvbigpe30pfX0oKTtyZXR1cm4gaSYmaS50aGVuP2kudGhlbihyKTpyKCl9KX1jYXRjaCh0KXtyZXR1cm4gUHJvbWlzZS5yZWplY3QodCl9fSxpLnBhZ2U9ZnVuY3Rpb24odCxuLGksZSl7dHJ5e3ZhciBvLHU9ZnVuY3Rpb24oKXt2YXIgdD1zLmRhdGE7cmV0dXJuIFByb21pc2UucmVzb2x2ZShzLmhvb2tzLmRvKFwicGFnZVwiLHQpKS50aGVuKGZ1bmN0aW9uKCl7dmFyIG49ZnVuY3Rpb24obixyKXt0cnl7dmFyIGk9KHU9cy50cmFuc2l0aW9ucy5nZXQodCx7b25jZTohMSxzZWxmOmV9KSxQcm9taXNlLnJlc29sdmUocy50cmFuc2l0aW9ucy5kb1BhZ2Uoe2RhdGE6dCxwYWdlOm8sdHJhbnNpdGlvbjp1LHdyYXBwZXI6cy5xfSkpLnRoZW4oZnVuY3Rpb24oKXtzLkkoKX0pKX1jYXRjaCh0KXtyZXR1cm4gcigpfXZhciB1O3JldHVybiBpJiZpLnRoZW4/aS50aGVuKHZvaWQgMCxyKTppfSgwLGZ1bmN0aW9uKCl7MD09PWQuZ2V0TGV2ZWwoKSYmcy5mb3JjZSh0Lm5leHQudXJsLmhyZWYpfSk7aWYobiYmbi50aGVuKXJldHVybiBuLnRoZW4oZnVuY3Rpb24oKXt9KX0pfSxzPXRoaXM7aWYocy5kYXRhLm5leHQudXJsPXIoe2hyZWY6dH0scy51cmwucGFyc2UodCkpLHMuZGF0YS50cmlnZ2VyPW4scy5kYXRhLmV2ZW50PWkscy5jYWNoZS5oYXModCkpbz1zLmNhY2hlLnVwZGF0ZSh0LHthY3Rpb246XCJjbGlja1wifSkucmVxdWVzdDtlbHNle3ZhciBmPXMucmVxdWVzdCh0LHMudGltZW91dCxzLm9uUmVxdWVzdEVycm9yLmJpbmQocyxuKSxzLmNhY2hlLHMuaGVhZGVycyk7Zi50aGVuKGZ1bmN0aW9uKHIpe3IudXJsLmhyZWYhPT10JiZzLmhpc3RvcnkuYWRkKHIudXJsLmhyZWYsbixcInJlcGxhY2VcIil9KSxvPXMuY2FjaGUuc2V0KHQsZixcImNsaWNrXCIsXCJwZW5kaW5nXCIpLnJlcXVlc3R9dmFyIGM9ZnVuY3Rpb24oKXtpZihzLnRyYW5zaXRpb25zLnNob3VsZFdhaXQpcmV0dXJuIFByb21pc2UucmVzb2x2ZShnKG8scy5kYXRhKSkudGhlbihmdW5jdGlvbigpe30pfSgpO3JldHVybiBQcm9taXNlLnJlc29sdmUoYyYmYy50aGVuP2MudGhlbih1KTp1KCkpfWNhdGNoKHQpe3JldHVybiBQcm9taXNlLnJlamVjdCh0KX19LGkub25SZXF1ZXN0RXJyb3I9ZnVuY3Rpb24odCl7dGhpcy50cmFuc2l0aW9ucy5pc1J1bm5pbmc9ITE7dmFyIG49W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkscj1uWzBdLGk9blsxXSxlPXRoaXMuY2FjaGUuZ2V0QWN0aW9uKHIpO3JldHVybiB0aGlzLmNhY2hlLmRlbGV0ZShyKSx0aGlzLkImJiExPT09dGhpcy5CKHQsZSxyLGkpfHxcImNsaWNrXCI9PT1lJiZ0aGlzLmZvcmNlKHIpLCExfSxpLnByZWZldGNoPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7dD10aGlzLnVybC5nZXRBYnNvbHV0ZUhyZWYodCksdGhpcy5jYWNoZS5oYXModCl8fHRoaXMuY2FjaGUuc2V0KHQsdGhpcy5yZXF1ZXN0KHQsdGhpcy50aW1lb3V0LHRoaXMub25SZXF1ZXN0RXJyb3IuYmluZCh0aGlzLFwiYmFyYmFcIiksdGhpcy5jYWNoZSx0aGlzLmhlYWRlcnMpLmNhdGNoKGZ1bmN0aW9uKHQpe24ubG9nZ2VyLmVycm9yKHQpfSksXCJwcmVmZXRjaFwiLFwicGVuZGluZ1wiKX0saS5HPWZ1bmN0aW9uKCl7ITAhPT10aGlzLnByZWZldGNoSWdub3JlJiYoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLHRoaXMuVSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLlUpKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLiQpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIix0aGlzLlgpfSxpLko9ZnVuY3Rpb24oKXshMCE9PXRoaXMucHJlZmV0Y2hJZ25vcmUmJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsdGhpcy5VKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMuVSkpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuJCksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLHRoaXMuWCl9LGkuVT1mdW5jdGlvbih0KXt2YXIgbj10aGlzLHI9dGhpcy5XKHQpO2lmKHIpe3ZhciBpPXRoaXMudXJsLmdldEFic29sdXRlSHJlZih0aGlzLmRvbS5nZXRIcmVmKHIpKTt0aGlzLnByZXZlbnQuY2hlY2tIcmVmKGkpfHx0aGlzLmNhY2hlLmhhcyhpKXx8dGhpcy5jYWNoZS5zZXQoaSx0aGlzLnJlcXVlc3QoaSx0aGlzLnRpbWVvdXQsdGhpcy5vblJlcXVlc3RFcnJvci5iaW5kKHRoaXMsciksdGhpcy5jYWNoZSx0aGlzLmhlYWRlcnMpLmNhdGNoKGZ1bmN0aW9uKHQpe24ubG9nZ2VyLmVycm9yKHQpfSksXCJlbnRlclwiLFwicGVuZGluZ1wiKX19LGkuJD1mdW5jdGlvbih0KXt2YXIgbj10aGlzLlcodCk7aWYobil7aWYodGhpcy50cmFuc2l0aW9ucy5pc1J1bm5pbmcmJnRoaXMucHJldmVudFJ1bm5pbmcpcmV0dXJuIHQucHJldmVudERlZmF1bHQoKSx2b2lkIHQuc3RvcFByb3BhZ2F0aW9uKCk7dGhpcy5GPXQsdGhpcy5nbyh0aGlzLmRvbS5nZXRIcmVmKG4pLG4sdCl9fSxpLlg9ZnVuY3Rpb24odCl7dGhpcy5nbyh0aGlzLnVybC5nZXRIcmVmKCksXCJwb3BzdGF0ZVwiLHQpfSxpLlc9ZnVuY3Rpb24odCl7Zm9yKHZhciBuPXQudGFyZ2V0O24mJiF0aGlzLmRvbS5nZXRIcmVmKG4pOyluPW4ucGFyZW50Tm9kZTtpZihuJiYhdGhpcy5wcmV2ZW50LmNoZWNrTGluayhuLHQsdGhpcy5kb20uZ2V0SHJlZihuKSkpcmV0dXJuIG59LGkuST1mdW5jdGlvbigpe3ZhciB0PXRoaXMudXJsLmdldEhyZWYoKSxuPXtjb250YWluZXI6dGhpcy5kb20uZ2V0Q29udGFpbmVyKCksaHRtbDp0aGlzLmRvbS5nZXRIdG1sKCksbmFtZXNwYWNlOnRoaXMuZG9tLmdldE5hbWVzcGFjZSgpLHVybDpyKHtocmVmOnR9LHRoaXMudXJsLnBhcnNlKHQpKX07dGhpcy5EPXtjdXJyZW50Om4sZXZlbnQ6dm9pZCAwLG5leHQ6cih7fSx0aGlzLnNjaGVtYVBhZ2UpLHRyaWdnZXI6dm9pZCAwfSx0aGlzLmhvb2tzLmRvKFwicmVzZXRcIix0aGlzLmRhdGEpfSxuKHQsW3trZXk6XCJkYXRhXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuRH19LHtrZXk6XCJ3cmFwcGVyXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucX19XSksdH0oKTtyZXR1cm4gbmV3IG50fSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXJiYS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@barba/core/dist/barba.umd.js\n");

/***/ }),

/***/ "./src/js/animations/animationEnter.js":
/*!*********************************************!*\
  !*** ./src/js/animations/animationEnter.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nconst animationEnter = container => {\n  // console.log(\"animationEnter\");\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (animationEnter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYW5pbWF0aW9ucy9hbmltYXRpb25FbnRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXdCO0FBRXhCLE1BQU1DLGNBQWMsR0FBSUMsU0FBUyxJQUFLO0VBQ3JDO0FBQUEsQ0FDQTtBQUVELGlFQUFlRCxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2FuaW1hdGlvbnMvYW5pbWF0aW9uRW50ZXIuanM/NmI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcclxuXHJcbmNvbnN0IGFuaW1hdGlvbkVudGVyID0gKGNvbnRhaW5lcikgPT4ge1xyXG5cdC8vIGNvbnNvbGUubG9nKFwiYW5pbWF0aW9uRW50ZXJcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFuaW1hdGlvbkVudGVyOyJdLCJuYW1lcyI6WyJnc2FwIiwiYW5pbWF0aW9uRW50ZXIiLCJjb250YWluZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/animations/animationEnter.js\n");

/***/ }),

/***/ "./src/js/animations/animationLeave.js":
/*!*********************************************!*\
  !*** ./src/js/animations/animationLeave.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nconst animationLeave = container => {\n  // console.log(\"animationLeave\");\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (animationLeave);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYW5pbWF0aW9ucy9hbmltYXRpb25MZWF2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXdCO0FBRXhCLE1BQU1DLGNBQWMsR0FBSUMsU0FBUyxJQUFLO0VBQ3JDO0FBQUEsQ0FDQTtBQUVELGlFQUFlRCxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2FuaW1hdGlvbnMvYW5pbWF0aW9uTGVhdmUuanM/ZGE3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcclxuXHJcbmNvbnN0IGFuaW1hdGlvbkxlYXZlID0gKGNvbnRhaW5lcikgPT4ge1xyXG5cdC8vIGNvbnNvbGUubG9nKFwiYW5pbWF0aW9uTGVhdmVcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFuaW1hdGlvbkxlYXZlOyJdLCJuYW1lcyI6WyJnc2FwIiwiYW5pbWF0aW9uTGVhdmUiLCJjb250YWluZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/animations/animationLeave.js\n");

/***/ }),

/***/ "./src/js/animations/index.js":
/*!************************************!*\
  !*** ./src/js/animations/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animationEnter: () => (/* reexport safe */ _animationEnter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   animationLeave: () => (/* reexport safe */ _animationLeave_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _animationEnter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animationEnter.js */ \"./src/js/animations/animationEnter.js\");\n/* harmony import */ var _animationLeave_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animationLeave.js */ \"./src/js/animations/animationLeave.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYW5pbWF0aW9ucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2FuaW1hdGlvbnMvaW5kZXguanM/NmMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIGFuaW1hdGlvbkVudGVyIH0gZnJvbSAnLi9hbmltYXRpb25FbnRlci5qcyc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYW5pbWF0aW9uTGVhdmUgfSBmcm9tICcuL2FuaW1hdGlvbkxlYXZlLmpzJzsiXSwibmFtZXMiOlsiZGVmYXVsdCIsImFuaW1hdGlvbkVudGVyIiwiYW5pbWF0aW9uTGVhdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/animations/index.js\n");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scss_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scss/app.scss */ \"./src/scss/app.scss\");\n/* harmony import */ var _updateBodyClasses_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./updateBodyClasses.js */ \"./src/js/updateBodyClasses.js\");\n/* harmony import */ var _barba_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./barba.js */ \"./src/js/barba.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvYXBwLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBMEI7QUFJTSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9hcHAuanM/OTBlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3Njc3MvYXBwLnNjc3MnO1xyXG5cclxuXHJcblxyXG5pbXBvcnQgJy4vdXBkYXRlQm9keUNsYXNzZXMuanMnO1xyXG5cclxuaW1wb3J0ICcuL2JhcmJhLmpzJztcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/app.js\n");

/***/ }),

/***/ "./src/js/assets/cards.js":
/*!********************************!*\
  !*** ./src/js/assets/cards.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _functional_relations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functional/relations */ \"./src/js/functional/relations.js\");\n\nconst Cards_Init = () => {\n  class Card {\n    constructor(el) {\n      this.el = el;\n      this.current_user_id = document.querySelector(\".current_user_id\");\n      this.relationBtns = this.el.querySelectorAll(\".relation_btn__posts\");\n      this.relationUsersBtns = this.el.querySelectorAll(\".relation_btn.relation_btn--contact-list\");\n      this.a_in_el = this.el.querySelectorAll(\"a\");\n      this.card__img__grid = this.el.querySelector(\".card__img__grid\");\n      this.handleEvents();\n    }\n    handleEvents() {\n      if (this.relationUsersBtns) {\n        this.relationUsersBtns.forEach(relationUserBtn => {\n          relationUserBtn.addEventListener(\"click\", e => {\n            e.preventDefault();\n            e.stopPropagation();\n            console.log(\"do relation user\");\n            console.log(this.current_user_id.getAttribute(\"data-u-id\"));\n            console.log(e.currentTarget.getAttribute(\"data-relation-him\"));\n            console.log(e.currentTarget.getAttribute(\"data-relation-type\"));\n            (0,_functional_relations__WEBPACK_IMPORTED_MODULE_0__.makeRelationBtw)(this.current_user_id.getAttribute(\"data-u-id\"), e.currentTarget.getAttribute(\"data-relation-him\"), e.currentTarget.getAttribute(\"data-relation-type\"), e.currentTarget);\n          });\n        });\n      }\n      this.relationBtns.forEach(relationBtn => {\n        relationBtn.addEventListener(\"click\", e => {\n          e.preventDefault();\n          e.stopPropagation();\n          // console.log(e.currentTarget.getAttribute(\"data-relation-type\"));\n          (0,_functional_relations__WEBPACK_IMPORTED_MODULE_0__.makeRelationBtw)(this.current_user_id.getAttribute(\"data-u-id\"), this.el.getAttribute(\"data-h-id\"), this.el.getAttribute(\"data-post-type\"), e.currentTarget);\n        });\n      });\n      this.el.addEventListener(\"mouseover\", e => {\n        this.el.classList.add(\"mouseover\");\n      });\n      this.a_in_el.forEach(link => {\n        link.addEventListener(\"mouseover\", e => {\n          this.el.classList.add(\"mouseover--link\");\n        });\n        link.addEventListener(\"mouseleave\", e => {\n          this.el.classList.remove(\"mouseover--link\");\n        });\n      });\n      if (this.card__img__grid) {\n        this.card__img__grid.addEventListener(\"mouseover\", e => {\n          this.el.classList.add(\"mouseover--img-link\");\n        });\n        this.card__img__grid.addEventListener(\"mouseleave\", e => {\n          this.el.classList.remove(\"mouseover--img-link\");\n        });\n      }\n      this.el.addEventListener(\"mouseleave\", e => {\n        this.el.classList.remove(\"mouseover\");\n      });\n    }\n  }\n  const cards = document.querySelectorAll(\".card\");\n  if (cards.length) {\n    [...cards].map(card => new Card(card));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Cards_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEdBQUdELEtBQUssQ0FBQyxDQUFDRSxHQUFHLENBQUVDLElBQUksSUFBSyxJQUFJOUIsSUFBSSxDQUFDOEIsSUFBSSxDQUFDLENBQUM7RUFDekM7QUFDRCxDQUFDO0FBRUQsaUVBQWUvQixVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2Fzc2V0cy9jYXJkcy5qcz85NmVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1ha2VSZWxhdGlvbkJ0dyB9IGZyb20gJy4uL2Z1bmN0aW9uYWwvcmVsYXRpb25zJztcclxuXHJcbmNvbnN0IENhcmRzX0luaXQgPSAoKSA9PiB7XHJcblx0Y2xhc3MgQ2FyZCB7XHJcblx0XHRjb25zdHJ1Y3RvcihlbCkge1xyXG5cdFx0XHR0aGlzLmVsID0gZWw7XHJcblx0XHRcdHRoaXMuY3VycmVudF91c2VyX2lkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5jdXJyZW50X3VzZXJfaWRcIik7XHJcblx0XHRcdHRoaXMucmVsYXRpb25CdG5zID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiLnJlbGF0aW9uX2J0bl9fcG9zdHNcIik7XHJcblx0XHRcdHRoaXMucmVsYXRpb25Vc2Vyc0J0bnMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIucmVsYXRpb25fYnRuLnJlbGF0aW9uX2J0bi0tY29udGFjdC1saXN0XCIpO1xyXG5cdFx0XHR0aGlzLmFfaW5fZWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhXCIpO1xyXG5cdFx0XHR0aGlzLmNhcmRfX2ltZ19fZ3JpZCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5jYXJkX19pbWdfX2dyaWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnRzKCk7XHJcblx0XHR9XHJcblxyXG4gICAgICAgIGhhbmRsZUV2ZW50cygpIHtcclxuXHRcdFx0aWYodGhpcy5yZWxhdGlvblVzZXJzQnRucyl7XHJcblx0XHRcdFx0dGhpcy5yZWxhdGlvblVzZXJzQnRucy5mb3JFYWNoKHJlbGF0aW9uVXNlckJ0biA9PiB7XHJcblx0XHRcdFx0XHRyZWxhdGlvblVzZXJCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XHJcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJkbyByZWxhdGlvbiB1c2VyXCIpO1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyh0aGlzLmN1cnJlbnRfdXNlcl9pZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXUtaWRcIikpO1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi1oaW1cIikpO1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi10eXBlXCIpKTtcclxuXHRcdFx0XHRcdFx0bWFrZVJlbGF0aW9uQnR3KHRoaXMuY3VycmVudF91c2VyX2lkLmdldEF0dHJpYnV0ZShcImRhdGEtdS1pZFwiKSwgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVsYXRpb24taGltXCIpLCBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi10eXBlXCIpLCBlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5yZWxhdGlvbkJ0bnMuZm9yRWFjaChyZWxhdGlvbkJ0biA9PiB7XHJcblx0XHRcdFx0cmVsYXRpb25CdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XHJcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVsYXRpb24tdHlwZVwiKSk7XHJcblx0XHRcdFx0XHRtYWtlUmVsYXRpb25CdHcodGhpcy5jdXJyZW50X3VzZXJfaWQuZ2V0QXR0cmlidXRlKFwiZGF0YS11LWlkXCIpLCB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtaC1pZFwiKSwgdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBvc3QtdHlwZVwiKSwgZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoZSkgPT4ge1xyXG5cdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcIm1vdXNlb3ZlclwiKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuYV9pbl9lbC5mb3JFYWNoKGxpbmsgPT4ge1xyXG5cdFx0XHRcdGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoZSkgPT4ge1xyXG5cdFx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwibW91c2VvdmVyLS1saW5rXCIpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKGUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcIm1vdXNlb3Zlci0tbGlua1wiKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmKHRoaXMuY2FyZF9faW1nX19ncmlkKXtcclxuXHRcdFx0XHR0aGlzLmNhcmRfX2ltZ19fZ3JpZC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIChlKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJtb3VzZW92ZXItLWltZy1saW5rXCIpO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0dGhpcy5jYXJkX19pbWdfX2dyaWQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKGUpID0+IHtcclxuXHRcdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcIm1vdXNlb3Zlci0taW1nLWxpbmtcIik7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIChlKSA9PiB7XHJcblx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwibW91c2VvdmVyXCIpO1xyXG5cdFx0XHR9KTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuXHRjb25zdCBjYXJkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2FyZFwiKTtcclxuXHJcblx0aWYgKGNhcmRzLmxlbmd0aCkge1xyXG5cdFx0Wy4uLmNhcmRzXS5tYXAoKGNhcmQpID0+IG5ldyBDYXJkKGNhcmQpKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRzX0luaXQ7XHJcbiJdLCJuYW1lcyI6WyJtYWtlUmVsYXRpb25CdHciLCJDYXJkc19Jbml0IiwiQ2FyZCIsImNvbnN0cnVjdG9yIiwiZWwiLCJjdXJyZW50X3VzZXJfaWQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJyZWxhdGlvbkJ0bnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVsYXRpb25Vc2Vyc0J0bnMiLCJhX2luX2VsIiwiY2FyZF9faW1nX19ncmlkIiwiaGFuZGxlRXZlbnRzIiwiZm9yRWFjaCIsInJlbGF0aW9uVXNlckJ0biIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjb25zb2xlIiwibG9nIiwiZ2V0QXR0cmlidXRlIiwiY3VycmVudFRhcmdldCIsInJlbGF0aW9uQnRuIiwiY2xhc3NMaXN0IiwiYWRkIiwibGluayIsInJlbW92ZSIsImNhcmRzIiwibGVuZ3RoIiwibWFwIiwiY2FyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/assets/cards.js\n");

/***/ }),

/***/ "./src/js/barba.js":
/*!*************************!*\
  !*** ./src/js/barba.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _barba_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @barba/core */ \"./node_modules/@barba/core/dist/barba.umd.js\");\n/* harmony import */ var _barba_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_barba_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var glightbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! glightbox */ \"./node_modules/glightbox/dist/js/glightbox.min.js\");\n/* harmony import */ var glightbox__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(glightbox__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updateBodyClasses */ \"./src/js/updateBodyClasses.js\");\n/* harmony import */ var _pages_home__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/home */ \"./src/js/pages/home.js\");\n/* harmony import */ var _pages_user__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pages/user */ \"./src/js/pages/user.js\");\n/* harmony import */ var _pages_post__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages/post */ \"./src/js/pages/post.js\");\n/* harmony import */ var _signatureInConsole__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./signatureInConsole */ \"./src/js/signatureInConsole.js\");\n/* harmony import */ var _components_header__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/header */ \"./src/js/components/header.js\");\n/* harmony import */ var _components_checkbox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/checkbox */ \"./src/js/components/checkbox.js\");\n/* harmony import */ var _components_scrollTo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/scrollTo */ \"./src/js/components/scrollTo.js\");\n/* harmony import */ var _components_maps__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/maps */ \"./src/js/components/maps.js\");\n/* harmony import */ var _components_tabs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/tabs */ \"./src/js/components/tabs.js\");\n/* harmony import */ var _components_carrousel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/carrousel */ \"./src/js/components/carrousel.js\");\n/* harmony import */ var _components_tags__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/tags */ \"./src/js/components/tags.js\");\n/* harmony import */ var _components_modal__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/modal */ \"./src/js/components/modal.js\");\n/* harmony import */ var _components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/card-popup-links */ \"./src/js/components/card-popup-links.js\");\n/* harmony import */ var _components_navigation__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/navigation */ \"./src/js/components/navigation.js\");\n/* harmony import */ var _components_tooltip__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/tooltip */ \"./src/js/components/tooltip.js\");\n/* harmony import */ var _components_copy_paste__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/copy-paste */ \"./src/js/components/copy-paste.js\");\n/* harmony import */ var _components_map_functions__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/map-functions */ \"./src/js/components/map-functions.js\");\n/* harmony import */ var _assets_cards__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./assets/cards */ \"./src/js/assets/cards.js\");\n/* harmony import */ var _components_dropzone__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/dropzone */ \"./src/js/components/dropzone.js\");\n/* harmony import */ var _animations__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./animations */ \"./src/js/animations/index.js\");\n\n\n\n\n\n\n\n\n// Components\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// import FilePond from \"./components/filepond\";\n\n\n_barba_core__WEBPACK_IMPORTED_MODULE_0___default().hooks.once(data => {\n  //signatureInConsole();\n  (0,_components_navigation__WEBPACK_IMPORTED_MODULE_16__[\"default\"])();\n  var lightboxDefault = new (glightbox__WEBPACK_IMPORTED_MODULE_1___default())({\n    selector: '.glightbox'\n  });\n  var lightboxSingle = new (glightbox__WEBPACK_IMPORTED_MODULE_1___default())({\n    selector: '.glightbox-single'\n  });\n});\n_barba_core__WEBPACK_IMPORTED_MODULE_0___default().hooks.enter(() => {\n  window.scrollTo(0, 0);\n  (0,_components_navigation__WEBPACK_IMPORTED_MODULE_16__[\"default\"])();\n});\nif ('scrollRestoration' in history) {\n  history.scrollRestoration = 'manual';\n}\n_barba_core__WEBPACK_IMPORTED_MODULE_0___default().init({\n  debug: true,\n  views: [_pages_home__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _pages_user__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _pages_post__WEBPACK_IMPORTED_MODULE_5__[\"default\"]],\n  transitions: [{\n    name: 'general-transition',\n    once: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n    },\n    leave: ({\n      current\n    }) => (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationLeave)(current.container),\n    enter: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n    }\n  },\n  // todo_augustin\n  // {\n  // \tname: 'fade-transition',\n  // \tto: {\n  // \t\tnamespace: ['post']\n  // \t},\n  // \tonce(data) {\n  // \t\t// Initialisation des expanders de contenu\n  // \t\tinitContentExpanders();\n  // \t},\n  // \tleave(data) {\n  // \t\treturn new Promise((resolve) => {\n  // \t\t\tdata.current.container.classList.add(\"fade-out\");\n  // \t\t\tsetTimeout(resolve, 500); // Dure de l'animation de sortie\n  // \t\t});\n  // \t},\n  // \tenter(data) {\n  // \t\treturn new Promise((resolve) => {\n  // \t\t\t// Rinitialise et applique la classe ContentExpander  chaque nouvel lment\n  // \t\t\tinitContentExpanders();\n  // \t\t\tdata.next.container.classList.add(\"fade-in\");\n  // \t\t\tsetTimeout(resolve, 500); // Dure de l'animation d'entre\n  // \t\t});\n  // \t}\n  // }, // end\n  {\n    name: 'home',\n    to: {\n      namespace: ['home']\n    },\n    once: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_assets_cards__WEBPACK_IMPORTED_MODULE_20__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n    },\n    leave: ({\n      current\n    }) => (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationLeave)(current.container),\n    enter: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_assets_cards__WEBPACK_IMPORTED_MODULE_20__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n    }\n  }, {\n    name: 'wall',\n    to: {\n      namespace: ['wall']\n    },\n    once: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_assets_cards__WEBPACK_IMPORTED_MODULE_20__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_maps__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_dropzone__WEBPACK_IMPORTED_MODULE_21__[\"default\"])();\n    },\n    leave: ({\n      current\n    }) => (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationLeave)(current.container),\n    enter: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_assets_cards__WEBPACK_IMPORTED_MODULE_20__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_maps__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_dropzone__WEBPACK_IMPORTED_MODULE_21__[\"default\"])();\n    },\n    afterEnter: ({\n      next\n    }) => {\n      (0,_components_scrollTo__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(next);\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n    }\n  }, {\n    name: 'wall--map',\n    to: {\n      namespace: ['wall--map']\n    },\n    once: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_assets_cards__WEBPACK_IMPORTED_MODULE_20__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_map_functions__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(next.container);\n    },\n    leave: ({\n      current\n    }) => (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationLeave)(current.container),\n    enter: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_assets_cards__WEBPACK_IMPORTED_MODULE_20__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_map_functions__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(next.container);\n    }\n  }, {\n    name: 'user',\n    to: {\n      namespace: ['user']\n    },\n    once: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_tabs__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(next);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_map_functions__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(next.container);\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_header__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n    },\n    leave: ({\n      current\n    }) => (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationLeave)(current.container),\n    enter: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_tabs__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(next);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_card_popup_links__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(next);\n      (0,_components_map_functions__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(next.container);\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_header__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n    }\n  }, {\n    name: 'post',\n    to: {\n      namespace: ['post']\n    },\n    once: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_tabs__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(next);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n\n      // Card_popup_link_Init(next);\n      (0,_components_map_functions__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(next.container);\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_header__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    },\n    leave: ({\n      current\n    }) => (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationLeave)(current.container),\n    enter: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_tabs__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(next);\n      (0,_components_carrousel__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(next);\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n\n      // Card_popup_link_Init(next);\n      (0,_components_map_functions__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(next.container);\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_header__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    }\n  }, {\n    name: 'form',\n    to: {\n      namespace: ['form']\n    },\n    once: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_scrollTo__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(next);\n      (0,_components_dropzone__WEBPACK_IMPORTED_MODULE_21__[\"default\"])();\n      (0,_components_maps__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      // FilePond();\n    },\n    leave: ({\n      current\n    }) => (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationLeave)(current.container),\n    enter: ({\n      next\n    }) => {\n      (0,_updateBodyClasses__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(next);\n      (0,_animations__WEBPACK_IMPORTED_MODULE_22__.animationEnter)(next.container);\n      (0,_components_checkbox__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n      (0,_components_dropzone__WEBPACK_IMPORTED_MODULE_21__[\"default\"])();\n      (0,_components_maps__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n      (0,_components_tags__WEBPACK_IMPORTED_MODULE_13__[\"default\"])();\n      (0,_components_copy_paste__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      (0,_components_tooltip__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(next);\n      (0,_components_modal__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(next);\n      // FilePond();\n    },\n    after: ({\n      next\n    }) => {\n      (0,_components_scrollTo__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(next);\n    }\n  }]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLENBQUM7TUFDWEcsNkRBQVMsQ0FBQyxDQUFDO01BQ1hLLG1FQUFZLENBQUMsQ0FBQztNQUNkRCxnRUFBWSxDQUFDdUIsSUFBSSxDQUFDO01BQ2xCMUIsOERBQVcsQ0FBQzBCLElBQUksQ0FBQztNQUNqQjtJQUVELENBQUM7SUFDREUsS0FBSyxFQUFFQSxDQUFDO01BQUVDO0lBQVEsQ0FBQyxLQUFLcEIsNERBQWMsQ0FBQ29CLE9BQU8sQ0FBQ0YsU0FBUyxDQUFDO0lBQ2hEWCxLQUFLLEVBQUVBLENBQUM7TUFBRVU7SUFBSyxDQUFDLEtBQUs7TUFDN0J0Qyw4REFBaUIsQ0FBQ3NDLElBQUksQ0FBQztNQUNYbEIsNERBQWMsQ0FBQ2tCLElBQUksQ0FBQ0MsU0FBUyxDQUFDO01BQzFDakMsZ0VBQXdCLENBQUMsQ0FBQztNQUMxQmEsaUVBQWMsQ0FBQyxDQUFDO01BQ2hCWCw2REFBUyxDQUFDLENBQUM7TUFDWEcsNkRBQVMsQ0FBQyxDQUFDO01BQ1hLLG1FQUFZLENBQUMsQ0FBQztNQUNkRCxnRUFBWSxDQUFDdUIsSUFBSSxDQUFDO01BQ2xCMUIsOERBQVcsQ0FBQzBCLElBQUksQ0FBQztNQUNqQjtJQUVELENBQUM7SUFDUU8sS0FBSyxFQUFFQSxDQUFDO01BQUVQO0lBQUssQ0FBQyxLQUFLO01BQzdCL0IsZ0VBQVEsQ0FBQytCLElBQUksQ0FBQztJQUNmO0VBQ0ssQ0FBQztBQUVULENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9iYXJiYS5qcz9iZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgYmFyYmEgZnJvbSAnQGJhcmJhL2NvcmUnO1xyXG5pbXBvcnQgR0xpZ2h0Ym94IGZyb20gJ2dsaWdodGJveCc7XHJcblxyXG5pbXBvcnQgdXBkYXRlQm9keUNsYXNzZXMgZnJvbSAnLi91cGRhdGVCb2R5Q2xhc3Nlcyc7XHJcblxyXG5pbXBvcnQgSG9tZSBmcm9tICcuL3BhZ2VzL2hvbWUnO1xyXG5pbXBvcnQgVXNlciBmcm9tICcuL3BhZ2VzL3VzZXInO1xyXG5pbXBvcnQgUG9zdCBmcm9tICcuL3BhZ2VzL3Bvc3QnO1xyXG5pbXBvcnQgc2lnbmF0dXJlSW5Db25zb2xlIGZyb20gJy4vc2lnbmF0dXJlSW5Db25zb2xlJztcclxuXHJcbi8vIENvbXBvbmVudHNcclxuaW1wb3J0IEluaXRfSGVhZGVyIGZyb20gJy4vY29tcG9uZW50cy9oZWFkZXInO1xyXG5pbXBvcnQgQ2hlY2tib3hfQW5kX1JhZGlvc19Jbml0IGZyb20gJy4vY29tcG9uZW50cy9jaGVja2JveCc7XHJcbmltcG9ydCBTY3JvbGxUbyBmcm9tICcuL2NvbXBvbmVudHMvc2Nyb2xsVG8nO1xyXG5pbXBvcnQgTWFwc19Jbml0IGZyb20gJy4vY29tcG9uZW50cy9tYXBzJztcclxuaW1wb3J0IFRhYnNfSW5pdCBmcm9tICcuL2NvbXBvbmVudHMvdGFicyc7XHJcbmltcG9ydCBDYXJyb3VzZWxfSW5pdCBmcm9tICcuL2NvbXBvbmVudHMvY2Fycm91c2VsJztcclxuaW1wb3J0IFRhZ3NfSW5pdCBmcm9tICcuL2NvbXBvbmVudHMvdGFncyc7XHJcbmltcG9ydCBNb2RhbHNfSW5pdCBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwnO1xyXG5pbXBvcnQgQ2FyZF9wb3B1cF9saW5rX0luaXQgZnJvbSAnLi9jb21wb25lbnRzL2NhcmQtcG9wdXAtbGlua3MnO1xyXG5pbXBvcnQgTmF2aWdhdGlvbl9Jbml0IGZyb20gJy4vY29tcG9uZW50cy9uYXZpZ2F0aW9uJztcclxuaW1wb3J0IFRvb2x0aXBfSW5pdCBmcm9tICcuL2NvbXBvbmVudHMvdG9vbHRpcCc7XHJcbmltcG9ydCBDb3B5QnRuX0luaXQgZnJvbSAnLi9jb21wb25lbnRzL2NvcHktcGFzdGUnO1xyXG5pbXBvcnQgTWFwTGF1bmNoIGZyb20gJy4vY29tcG9uZW50cy9tYXAtZnVuY3Rpb25zJztcclxuXHJcbmltcG9ydCBDYXJkc19Jbml0IGZyb20gJy4vYXNzZXRzL2NhcmRzJzsgXHJcbiBcclxuXHJcbi8vIGltcG9ydCBGaWxlUG9uZCBmcm9tIFwiLi9jb21wb25lbnRzL2ZpbGVwb25kXCI7XHJcbmltcG9ydCBGaWxlVXBsb2FkSW5pdCBmcm9tIFwiLi9jb21wb25lbnRzL2Ryb3B6b25lXCI7XHJcblxyXG5pbXBvcnQgeyAgYW5pbWF0aW9uRW50ZXIsIGFuaW1hdGlvbkxlYXZlIH0gZnJvbSAnLi9hbmltYXRpb25zJztcclxuXHJcbmJhcmJhLmhvb2tzLm9uY2UoKGRhdGEpID0+IHtcclxuXHQvL3NpZ25hdHVyZUluQ29uc29sZSgpO1xyXG5cdE5hdmlnYXRpb25fSW5pdCgpO1xyXG4gICAgdmFyIGxpZ2h0Ym94RGVmYXVsdCA9IG5ldyBHTGlnaHRib3goe1xyXG4gICAgICAgIHNlbGVjdG9yOiAnLmdsaWdodGJveCdcclxuICAgIH0pO1xyXG4gICAgdmFyIGxpZ2h0Ym94U2luZ2xlID0gbmV3IEdMaWdodGJveCh7XHJcbiAgICAgICAgc2VsZWN0b3I6ICcuZ2xpZ2h0Ym94LXNpbmdsZSdcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbmJhcmJhLmhvb2tzLmVudGVyKCgpID0+IHtcclxuXHR3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XHJcblx0TmF2aWdhdGlvbl9Jbml0KCk7XHJcbn0pO1xyXG5cclxuaWYgKCdzY3JvbGxSZXN0b3JhdGlvbicgaW4gaGlzdG9yeSkge1xyXG5cdGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcclxufVxyXG5cclxuYmFyYmEuaW5pdCh7XHJcblx0ZGVidWc6IHRydWUsXHJcblx0dmlld3M6IFtIb21lLCBVc2VyLCBQb3N0XSxcclxuXHR0cmFuc2l0aW9uczogW1xyXG5cdFx0e1xyXG5cdFx0XHRuYW1lOiAnZ2VuZXJhbC10cmFuc2l0aW9uJyxcclxuXHRcdFx0b25jZTogKHsgbmV4dCB9KSA9PiB7XHJcblx0XHRcdFx0dXBkYXRlQm9keUNsYXNzZXMobmV4dCk7XHJcblx0XHRcdFx0YW5pbWF0aW9uRW50ZXIobmV4dC5jb250YWluZXIpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsZWF2ZTogKHsgY3VycmVudCB9KSA9PiBhbmltYXRpb25MZWF2ZShjdXJyZW50LmNvbnRhaW5lciksXHJcblx0XHRcdGVudGVyOiAoeyBuZXh0IH0pID0+IHtcclxuXHRcdFx0XHR1cGRhdGVCb2R5Q2xhc3NlcyhuZXh0KTtcclxuXHRcdFx0XHRhbmltYXRpb25FbnRlcihuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvLyB0b2RvX2F1Z3VzdGluXHJcblx0XHQvLyB7XHJcblx0XHQvLyBcdG5hbWU6ICdmYWRlLXRyYW5zaXRpb24nLFxyXG5cdFx0Ly8gXHR0bzoge1xyXG5cdFx0Ly8gXHRcdG5hbWVzcGFjZTogWydwb3N0J11cclxuXHRcdC8vIFx0fSxcclxuXHRcdC8vIFx0b25jZShkYXRhKSB7XHJcblx0XHQvLyBcdFx0Ly8gSW5pdGlhbGlzYXRpb24gZGVzIGV4cGFuZGVycyBkZSBjb250ZW51XHJcblx0XHQvLyBcdFx0aW5pdENvbnRlbnRFeHBhbmRlcnMoKTtcclxuXHRcdC8vIFx0fSxcclxuXHRcdC8vIFx0bGVhdmUoZGF0YSkge1xyXG5cdFx0Ly8gXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG5cdFx0Ly8gXHRcdFx0ZGF0YS5jdXJyZW50LmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmFkZS1vdXRcIik7XHJcblx0XHQvLyBcdFx0XHRzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCk7IC8vIER1csOpZSBkZSBsJ2FuaW1hdGlvbiBkZSBzb3J0aWVcclxuXHRcdC8vIFx0XHR9KTtcclxuXHRcdC8vIFx0fSxcclxuXHRcdC8vIFx0ZW50ZXIoZGF0YSkge1xyXG5cdFx0Ly8gXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG5cdFx0Ly8gXHRcdFx0Ly8gUsOpaW5pdGlhbGlzZSBldCBhcHBsaXF1ZSBsYSBjbGFzc2UgQ29udGVudEV4cGFuZGVyIMOgIGNoYXF1ZSBub3V2ZWwgw6lsw6ltZW50XHJcblx0XHQvLyBcdFx0XHRpbml0Q29udGVudEV4cGFuZGVycygpO1xyXG5cdFx0Ly8gXHRcdFx0ZGF0YS5uZXh0LmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmFkZS1pblwiKTtcclxuXHRcdC8vIFx0XHRcdHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKTsgLy8gRHVyw6llIGRlIGwnYW5pbWF0aW9uIGQnZW50csOpZVxyXG5cdFx0Ly8gXHRcdH0pO1xyXG5cdFx0Ly8gXHR9XHJcblx0XHQvLyB9LCAvLyBlbmRcclxuXHRcdHtcclxuICAgICAgICAgICAgbmFtZTogJ2hvbWUnLFxyXG4gICAgICAgICAgICB0bzoge1xyXG5cdFx0XHRcdG5hbWVzcGFjZTogWydob21lJ11cclxuXHRcdFx0fSxcclxuICAgICAgICAgICAgb25jZTogKHsgbmV4dCB9KSA9PiB7XHJcbiBcdFx0XHRcdHVwZGF0ZUJvZHlDbGFzc2VzKG5leHQpO1xyXG5cdFx0XHRcdGFuaW1hdGlvbkVudGVyKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0XHRDYXJyb3VzZWxfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDYXJkX3BvcHVwX2xpbmtfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDaGVja2JveF9BbmRfUmFkaW9zX0luaXQoKTtcclxuXHRcdFx0XHRNb2RhbHNfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDYXJkc19Jbml0KCk7XHJcblx0XHRcdFx0VGFnc19Jbml0KCk7XHJcblx0XHRcdFx0Q29weUJ0bl9Jbml0KCk7XHJcblx0XHRcdFx0VG9vbHRpcF9Jbml0KG5leHQpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsZWF2ZTogKHsgY3VycmVudCB9KSA9PiBhbmltYXRpb25MZWF2ZShjdXJyZW50LmNvbnRhaW5lciksXHJcbiAgICAgICAgICAgIGVudGVyOiAoeyBuZXh0IH0pID0+IHtcclxuIFx0XHRcdFx0dXBkYXRlQm9keUNsYXNzZXMobmV4dCk7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FbnRlcihuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdFx0Q2Fycm91c2VsX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2FyZF9wb3B1cF9saW5rX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2hlY2tib3hfQW5kX1JhZGlvc19Jbml0KCk7XHJcblx0XHRcdFx0TW9kYWxzX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2FyZHNfSW5pdCgpO1xyXG5cdFx0XHRcdFRhZ3NfSW5pdCgpO1xyXG5cdFx0XHRcdENvcHlCdG5fSW5pdCgpO1xyXG5cdFx0XHRcdFRvb2x0aXBfSW5pdChuZXh0KTtcclxuXHRcdFx0fSxcclxuICAgICAgICB9LFxyXG5cdFx0e1xyXG4gICAgICAgICAgICBuYW1lOiAnd2FsbCcsXHJcbiAgICAgICAgICAgIHRvOiB7XHJcblx0XHRcdFx0bmFtZXNwYWNlOiBbJ3dhbGwnXVxyXG5cdFx0XHR9LFxyXG4gICAgICAgICAgICBvbmNlOiAoeyBuZXh0IH0pID0+IHtcclxuXHRcdFx0XHR1cGRhdGVCb2R5Q2xhc3NlcyhuZXh0KTtcclxuXHRcdFx0XHRhbmltYXRpb25FbnRlcihuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdFx0Q2Fycm91c2VsX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2FyZF9wb3B1cF9saW5rX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2hlY2tib3hfQW5kX1JhZGlvc19Jbml0KCk7XHJcblx0XHRcdFx0TW9kYWxzX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2FyZHNfSW5pdCgpO1xyXG5cdFx0XHRcdFRhZ3NfSW5pdCgpO1xyXG5cdFx0XHRcdENvcHlCdG5fSW5pdCgpO1xyXG5cdFx0XHRcdE1hcHNfSW5pdCgpO1xyXG5cdFx0XHRcdFRvb2x0aXBfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRGaWxlVXBsb2FkSW5pdCgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRsZWF2ZTogKHsgY3VycmVudCB9KSA9PiBhbmltYXRpb25MZWF2ZShjdXJyZW50LmNvbnRhaW5lciksXHJcbiAgICAgICAgICAgIGVudGVyOiAoeyBuZXh0IH0pID0+IHtcclxuXHRcdFx0XHR1cGRhdGVCb2R5Q2xhc3NlcyhuZXh0KTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVudGVyKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0XHRDYXJyb3VzZWxfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDYXJkX3BvcHVwX2xpbmtfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDaGVja2JveF9BbmRfUmFkaW9zX0luaXQoKTtcclxuXHRcdFx0XHRNb2RhbHNfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDYXJkc19Jbml0KCk7XHJcblx0XHRcdFx0Q29weUJ0bl9Jbml0KCk7XHJcblx0XHRcdFx0TWFwc19Jbml0KCk7XHJcblx0XHRcdFx0VG9vbHRpcF9Jbml0KG5leHQpO1xyXG5cdFx0XHRcdEZpbGVVcGxvYWRJbml0KCk7XHJcblx0XHRcdH0sXHJcblx0XHRcdGFmdGVyRW50ZXI6ICh7IG5leHQgfSkgPT4ge1xyXG5cdFx0XHRcdFNjcm9sbFRvKG5leHQpO1xyXG5cdFx0XHRcdFRhZ3NfSW5pdCgpO1xyXG5cdFx0XHR9XHJcbiAgICAgICAgfSxcclxuXHRcdHtcclxuICAgICAgICAgICAgbmFtZTogJ3dhbGwtLW1hcCcsXHJcbiAgICAgICAgICAgIHRvOiB7XHJcblx0XHRcdFx0bmFtZXNwYWNlOiBbJ3dhbGwtLW1hcCddXHJcblx0XHRcdH0sXHJcbiAgICAgICAgICAgIG9uY2U6ICh7IG5leHQgfSkgPT4ge1xyXG5cdFx0XHRcdHVwZGF0ZUJvZHlDbGFzc2VzKG5leHQpO1xyXG5cdFx0XHRcdGFuaW1hdGlvbkVudGVyKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0XHRDYXJyb3VzZWxfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDYXJkX3BvcHVwX2xpbmtfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDaGVja2JveF9BbmRfUmFkaW9zX0luaXQoKTtcclxuXHRcdFx0XHRNb2RhbHNfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDYXJkc19Jbml0KCk7XHJcblx0XHRcdFx0VGFnc19Jbml0KCk7XHJcblx0XHRcdFx0Q29weUJ0bl9Jbml0KCk7XHJcblx0XHRcdFx0VG9vbHRpcF9Jbml0KG5leHQpO1xyXG5cdFx0XHRcdE1hcExhdW5jaChuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdH0sXHJcblx0XHRcdGxlYXZlOiAoeyBjdXJyZW50IH0pID0+IGFuaW1hdGlvbkxlYXZlKGN1cnJlbnQuY29udGFpbmVyKSxcclxuICAgICAgICAgICAgZW50ZXI6ICh7IG5leHQgfSkgPT4ge1xyXG5cdFx0XHRcdHVwZGF0ZUJvZHlDbGFzc2VzKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRW50ZXIobmV4dC5jb250YWluZXIpO1xyXG5cdFx0XHRcdENhcnJvdXNlbF9Jbml0KG5leHQpO1xyXG5cdFx0XHRcdENhcmRfcG9wdXBfbGlua19Jbml0KG5leHQpO1xyXG5cdFx0XHRcdENoZWNrYm94X0FuZF9SYWRpb3NfSW5pdCgpO1xyXG5cdFx0XHRcdE1vZGFsc19Jbml0KG5leHQpO1xyXG5cdFx0XHRcdENhcmRzX0luaXQoKTtcclxuXHRcdFx0XHRUYWdzX0luaXQoKTtcclxuXHRcdFx0XHRDb3B5QnRuX0luaXQoKTtcclxuXHRcdFx0XHRUb29sdGlwX0luaXQobmV4dCk7XHJcblx0XHRcdFx0TWFwTGF1bmNoKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0fSxcclxuICAgICAgICB9LFxyXG5cdFx0e1xyXG4gICAgICAgICAgICBuYW1lOiAndXNlcicsXHJcbiAgICAgICAgICAgIHRvOiB7XHJcblx0XHRcdFx0bmFtZXNwYWNlOiBbJ3VzZXInXVxyXG5cdFx0XHR9LFxyXG4gICAgICAgICAgICBvbmNlOiAoeyBuZXh0IH0pID0+IHtcclxuXHRcdFx0XHR1cGRhdGVCb2R5Q2xhc3NlcyhuZXh0KTtcclxuXHRcdFx0XHRhbmltYXRpb25FbnRlcihuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdFx0VGFic19Jbml0KG5leHQpO1xyXG5cdFx0XHRcdENhcnJvdXNlbF9Jbml0KG5leHQpO1xyXG5cdFx0XHRcdENhcmRfcG9wdXBfbGlua19Jbml0KG5leHQpO1xyXG5cdFx0XHRcdE1hcExhdW5jaChuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdFx0TW9kYWxzX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q29weUJ0bl9Jbml0KCk7XHJcblx0XHRcdFx0VG9vbHRpcF9Jbml0KG5leHQpO1xyXG5cdFx0XHRcdEluaXRfSGVhZGVyKCk7XHJcblx0XHRcdFx0VGFnc19Jbml0KCk7XHJcblx0XHRcdFx0Q2hlY2tib3hfQW5kX1JhZGlvc19Jbml0KCk7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRsZWF2ZTogKHsgY3VycmVudCB9KSA9PiBhbmltYXRpb25MZWF2ZShjdXJyZW50LmNvbnRhaW5lciksXHJcbiAgICAgICAgICAgIGVudGVyOiAoeyBuZXh0IH0pID0+IHtcclxuXHRcdFx0XHR1cGRhdGVCb2R5Q2xhc3NlcyhuZXh0KTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkVudGVyKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0XHRUYWJzX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2Fycm91c2VsX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Q2FyZF9wb3B1cF9saW5rX0luaXQobmV4dCk7XHJcblx0XHRcdFx0TWFwTGF1bmNoKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0XHRNb2RhbHNfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDb3B5QnRuX0luaXQoKTtcclxuXHRcdFx0XHRUb29sdGlwX0luaXQobmV4dCk7XHJcblx0XHRcdFx0SW5pdF9IZWFkZXIoKTtcclxuXHRcdFx0XHRUYWdzX0luaXQoKTtcclxuXHRcdFx0XHRDaGVja2JveF9BbmRfUmFkaW9zX0luaXQoKTtcclxuXHJcblx0XHRcdH0sXHJcbiAgICAgICAgfSxcclxuXHRcdHtcclxuICAgICAgICAgICAgbmFtZTogJ3Bvc3QnLFxyXG4gICAgICAgICAgICB0bzoge1xyXG5cdFx0XHRcdG5hbWVzcGFjZTogWydwb3N0J11cclxuXHRcdFx0fSxcclxuICAgICAgICAgICAgb25jZTogKHsgbmV4dCB9KSA9PiB7XHJcblx0XHRcdFx0dXBkYXRlQm9keUNsYXNzZXMobmV4dCk7XHJcblx0XHRcdFx0YW5pbWF0aW9uRW50ZXIobmV4dC5jb250YWluZXIpO1xyXG5cdFx0XHRcdFRhYnNfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDYXJyb3VzZWxfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRUYWdzX0luaXQoKTtcclxuXHRcdFx0XHRDaGVja2JveF9BbmRfUmFkaW9zX0luaXQoKTtcclxuXHJcblx0XHRcdFx0Ly8gQ2FyZF9wb3B1cF9saW5rX0luaXQobmV4dCk7XHJcblx0XHRcdFx0TWFwTGF1bmNoKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0XHRNb2RhbHNfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRDb3B5QnRuX0luaXQoKTtcclxuXHRcdFx0XHRUb29sdGlwX0luaXQobmV4dCk7XHJcblx0XHRcdFx0SW5pdF9IZWFkZXIoKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0bGVhdmU6ICh7IGN1cnJlbnQgfSkgPT4gYW5pbWF0aW9uTGVhdmUoY3VycmVudC5jb250YWluZXIpLFxyXG4gICAgICAgICAgICBlbnRlcjogKHsgbmV4dCB9KSA9PiB7XHJcblx0XHRcdFx0dXBkYXRlQm9keUNsYXNzZXMobmV4dCk7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FbnRlcihuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdFx0VGFic19Jbml0KG5leHQpO1xyXG5cdFx0XHRcdENhcnJvdXNlbF9Jbml0KG5leHQpO1xyXG5cdFx0XHRcdFRhZ3NfSW5pdCgpO1xyXG5cdFx0XHRcdENoZWNrYm94X0FuZF9SYWRpb3NfSW5pdCgpO1xyXG5cclxuXHRcdFx0XHQvLyBDYXJkX3BvcHVwX2xpbmtfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRNYXBMYXVuY2gobmV4dC5jb250YWluZXIpO1xyXG5cdFx0XHRcdE1vZGFsc19Jbml0KG5leHQpO1xyXG5cdFx0XHRcdENvcHlCdG5fSW5pdCgpO1xyXG5cdFx0XHRcdFRvb2x0aXBfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRJbml0X0hlYWRlcigpO1xyXG5cdFx0XHR9LFxyXG4gICAgICAgIH0sXHJcblx0XHR7XHJcbiAgICAgICAgICAgIG5hbWU6ICdmb3JtJyxcclxuICAgICAgICAgICAgdG86IHtcclxuXHRcdFx0XHRuYW1lc3BhY2U6IFsnZm9ybSddXHJcblx0XHRcdH0sXHJcbiAgICAgICAgICAgIG9uY2U6ICh7IG5leHQgfSkgPT4ge1xyXG5cdFx0XHRcdHVwZGF0ZUJvZHlDbGFzc2VzKG5leHQpO1xyXG5cdFx0XHRcdGFuaW1hdGlvbkVudGVyKG5leHQuY29udGFpbmVyKTtcclxuXHRcdFx0XHRDaGVja2JveF9BbmRfUmFkaW9zX0luaXQoKTtcclxuXHRcdFx0XHRTY3JvbGxUbyhuZXh0KTtcclxuXHRcdFx0XHRGaWxlVXBsb2FkSW5pdCgpO1xyXG5cdFx0XHRcdE1hcHNfSW5pdCgpO1xyXG5cdFx0XHRcdFRhZ3NfSW5pdCgpO1xyXG5cdFx0XHRcdENvcHlCdG5fSW5pdCgpO1xyXG5cdFx0XHRcdFRvb2x0aXBfSW5pdChuZXh0KTtcclxuXHRcdFx0XHRNb2RhbHNfSW5pdChuZXh0KTtcclxuXHRcdFx0XHQvLyBGaWxlUG9uZCgpO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0bGVhdmU6ICh7IGN1cnJlbnQgfSkgPT4gYW5pbWF0aW9uTGVhdmUoY3VycmVudC5jb250YWluZXIpLFxyXG4gICAgICAgICAgICBlbnRlcjogKHsgbmV4dCB9KSA9PiB7XHJcblx0XHRcdFx0dXBkYXRlQm9keUNsYXNzZXMobmV4dCk7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FbnRlcihuZXh0LmNvbnRhaW5lcik7XHJcblx0XHRcdFx0Q2hlY2tib3hfQW5kX1JhZGlvc19Jbml0KCk7XHJcblx0XHRcdFx0RmlsZVVwbG9hZEluaXQoKTtcclxuXHRcdFx0XHRNYXBzX0luaXQoKTtcclxuXHRcdFx0XHRUYWdzX0luaXQoKTtcclxuXHRcdFx0XHRDb3B5QnRuX0luaXQoKTtcclxuXHRcdFx0XHRUb29sdGlwX0luaXQobmV4dCk7XHJcblx0XHRcdFx0TW9kYWxzX0luaXQobmV4dCk7XHJcblx0XHRcdFx0Ly8gRmlsZVBvbmQoKTtcclxuXHJcblx0XHRcdH0sXHJcbiAgICAgICAgICAgIGFmdGVyOiAoeyBuZXh0IH0pID0+IHtcclxuXHRcdFx0XHRTY3JvbGxUbyhuZXh0KTtcclxuXHRcdFx0fSxcclxuICAgICAgICB9XHJcblx0XVxyXG59KTtcclxuXHJcbiJdLCJuYW1lcyI6WyJiYXJiYSIsIkdMaWdodGJveCIsInVwZGF0ZUJvZHlDbGFzc2VzIiwiSG9tZSIsIlVzZXIiLCJQb3N0Iiwic2lnbmF0dXJlSW5Db25zb2xlIiwiSW5pdF9IZWFkZXIiLCJDaGVja2JveF9BbmRfUmFkaW9zX0luaXQiLCJTY3JvbGxUbyIsIk1hcHNfSW5pdCIsIlRhYnNfSW5pdCIsIkNhcnJvdXNlbF9Jbml0IiwiVGFnc19Jbml0IiwiTW9kYWxzX0luaXQiLCJDYXJkX3BvcHVwX2xpbmtfSW5pdCIsIk5hdmlnYXRpb25fSW5pdCIsIlRvb2x0aXBfSW5pdCIsIkNvcHlCdG5fSW5pdCIsIk1hcExhdW5jaCIsIkNhcmRzX0luaXQiLCJGaWxlVXBsb2FkSW5pdCIsImFuaW1hdGlvbkVudGVyIiwiYW5pbWF0aW9uTGVhdmUiLCJob29rcyIsIm9uY2UiLCJkYXRhIiwibGlnaHRib3hEZWZhdWx0Iiwic2VsZWN0b3IiLCJsaWdodGJveFNpbmdsZSIsImVudGVyIiwid2luZG93Iiwic2Nyb2xsVG8iLCJoaXN0b3J5Iiwic2Nyb2xsUmVzdG9yYXRpb24iLCJpbml0IiwiZGVidWciLCJ2aWV3cyIsInRyYW5zaXRpb25zIiwibmFtZSIsIm5leHQiLCJjb250YWluZXIiLCJsZWF2ZSIsImN1cnJlbnQiLCJ0byIsIm5hbWVzcGFjZSIsImFmdGVyRW50ZXIiLCJhZnRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/barba.js\n");

/***/ }),

/***/ "./src/js/components/card-popup-links.js":
/*!***********************************************!*\
  !*** ./src/js/components/card-popup-links.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/index.js\");\n\nconst Card_popup_link_Init = data => {\n  class CardPopup {\n    constructor(el) {\n      this.el = el;\n      this.data_id = this.el.getAttribute(\"data-card-popup-id\");\n      this.data_id_splitted = this.data_id.split(\"-\");\n      this.post_id = this.data_id_splitted[this.data_id_splitted.length - 1];\n      this.slate_id = \"slate-\" + this.post_id;\n      this.ctx_slate = document.getElementById(this.slate_id);\n      this.cards_popups = document.querySelectorAll(\".card-popup\");\n      this.cards = document.querySelectorAll(\".card\");\n      this.card_popup_target = document.getElementById(this.data_id);\n      this.card_popup_targets = document.querySelectorAll(\".card-popup\");\n      this.card_popup_target_close = this.card_popup_target.querySelector(\".card-popup-close\");\n      this.tl = gsap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].timeline({\n        defaults: {\n          duration: 0.2,\n          ease: 'power2.inOut'\n        }\n      });\n      this.el.addEventListener(\"click\", event => {\n        event.preventDefault();\n        event.stopPropagation();\n        this.toggle();\n      });\n      this.card_popup_target_close.addEventListener(\"click\", e => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.close();\n      });\n      window.addEventListener(\"scroll\", () => {\n        this.close();\n      });\n      this.tl.set(this.card_popup_target, {\n        autoAlpha: 0,\n        opacity: 0,\n        y: 50\n      });\n    }\n    toggle() {\n      if (this.card_popup_target.classList.contains(\"card-popup--hidden\")) {\n        this.cards_popups.forEach(cards_popup => {\n          cards_popup.classList.add(\"card-popup--hidden\");\n          this.tl.to(cards_popup, {\n            autoAlpha: 0,\n            opacity: 0,\n            y: 50,\n            duration: .1\n          }, 0);\n        });\n        this.card_popup_target.classList.remove(\"card-popup--hidden\");\n        this.ctx_slate.classList.add(\"active\");\n        this.tl.to(this.card_popup_target, {\n          autoAlpha: 1,\n          opacity: 1,\n          y: 0,\n          duration: .1\n        }, 0);\n      } else {\n        this.close(this.card_popup_target);\n      }\n      return this.tl;\n    }\n    close() {\n      this.card_popup_target.classList.add(\"card-popup--hidden\");\n      this.cards.forEach(card => {\n        card.classList.remove(\"active\");\n      });\n      this.ctx_slate.classList.remove(\"active\");\n      this.tl.to(this.card_popup_target, {\n        autoAlpha: 0,\n        opacity: 0,\n        y: 50,\n        duration: .1\n      }, 0);\n      return this.tl;\n    }\n  }\n  const card_popups_fires = data.container.querySelectorAll(\".card-popup-fire\");\n  if (card_popups_fires.length) {\n    [...card_popups_fires].map(card_popups_fire => new CardPopup(card_popups_fire));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Card_popup_link_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRSxDQUFDO1FBQUVDLE9BQU8sRUFBRSxDQUFDO1FBQUVDLENBQUMsRUFBRSxFQUFFO1FBQUViLFFBQVEsRUFBRTtNQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7TUFDdEYsT0FBTyxJQUFJLENBQUNILEVBQUU7SUFDZjtFQUNEO0VBRUEsTUFBTXlCLGlCQUFpQixHQUFHOUMsSUFBSSxDQUFDK0MsU0FBUyxDQUFDaEMsZ0JBQWdCLENBQUMsa0JBQWtCLENBQUM7RUFFN0UsSUFBSStCLGlCQUFpQixDQUFDckMsTUFBTSxFQUFFO0lBQzdCLENBQUMsR0FBR3FDLGlCQUFpQixDQUFDLENBQUNFLEdBQUcsQ0FBRUMsZ0JBQWdCLElBQUssSUFBSWhELFNBQVMsQ0FBQ2dELGdCQUFnQixDQUFDLENBQUM7RUFDbEY7QUFDRCxDQUFDO0FBRUQsaUVBQWVsRCxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9zcmMvanMvY29tcG9uZW50cy9jYXJkLXBvcHVwLWxpbmtzLmpzPzUyYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XHJcblxyXG5jb25zdCBDYXJkX3BvcHVwX2xpbmtfSW5pdCA9IChkYXRhKSA9PiB7XHJcblx0Y2xhc3MgQ2FyZFBvcHVwIHtcclxuXHRcdGNvbnN0cnVjdG9yKGVsKSB7XHJcblx0XHRcdHRoaXMuZWwgPSBlbDtcclxuXHRcdFx0dGhpcy5kYXRhX2lkID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcmQtcG9wdXAtaWRcIik7XHJcblx0XHRcdHRoaXMuZGF0YV9pZF9zcGxpdHRlZCA9IHRoaXMuZGF0YV9pZC5zcGxpdChcIi1cIik7XHJcblx0XHRcdHRoaXMucG9zdF9pZCA9IHRoaXMuZGF0YV9pZF9zcGxpdHRlZFt0aGlzLmRhdGFfaWRfc3BsaXR0ZWQubGVuZ3RoIC0gMV07XHJcblx0XHRcdHRoaXMuc2xhdGVfaWQgPSBcInNsYXRlLVwiICsgdGhpcy5wb3N0X2lkO1xyXG5cdFx0XHR0aGlzLmN0eF9zbGF0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc2xhdGVfaWQpO1xyXG5cdFx0XHR0aGlzLmNhcmRzX3BvcHVwcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2FyZC1wb3B1cFwiKTtcclxuXHRcdFx0dGhpcy5jYXJkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2FyZFwiKTtcclxuXHRcdFx0dGhpcy5jYXJkX3BvcHVwX3RhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZGF0YV9pZCk7XHJcblx0XHRcdHRoaXMuY2FyZF9wb3B1cF90YXJnZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5jYXJkLXBvcHVwXCIpO1xyXG5cdFx0XHR0aGlzLmNhcmRfcG9wdXBfdGFyZ2V0X2Nsb3NlID0gdGhpcy5jYXJkX3BvcHVwX3RhcmdldC5xdWVyeVNlbGVjdG9yKFwiLmNhcmQtcG9wdXAtY2xvc2VcIik7XHJcblxyXG5cdFx0XHR0aGlzLnRsID0gZ3NhcC50aW1lbGluZSh7XHJcblx0XHRcdFx0ZGVmYXVsdHM6IHtcclxuXHRcdFx0XHQgIGR1cmF0aW9uOiAwLjIsXHJcblx0XHRcdFx0ICBlYXNlOiAncG93ZXIyLmluT3V0JyxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHR9KTtcclxuXHJcblxyXG5cdFx0XHR0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcclxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdHRoaXMudG9nZ2xlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLmNhcmRfcG9wdXBfdGFyZ2V0X2Nsb3NlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xyXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy50bC5zZXQodGhpcy5jYXJkX3BvcHVwX3RhcmdldCwge2F1dG9BbHBoYTogMCwgb3BhY2l0eTogMCwgeTogNTB9KTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHR0b2dnbGUoKSB7XHJcblx0XHRcdGlmKHRoaXMuY2FyZF9wb3B1cF90YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2FyZC1wb3B1cC0taGlkZGVuXCIpKXtcclxuXHRcdFx0XHR0aGlzLmNhcmRzX3BvcHVwcy5mb3JFYWNoKGNhcmRzX3BvcHVwID0+IHtcclxuXHRcdFx0XHRcdGNhcmRzX3BvcHVwLmNsYXNzTGlzdC5hZGQoXCJjYXJkLXBvcHVwLS1oaWRkZW5cIik7XHJcblx0XHRcdFx0XHR0aGlzLnRsLnRvKGNhcmRzX3BvcHVwLCB7YXV0b0FscGhhOiAwLCBvcGFjaXR5OiAwLCB5OiA1MCwgZHVyYXRpb246IC4xfSwgMCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0dGhpcy5jYXJkX3BvcHVwX3RhcmdldC5jbGFzc0xpc3QucmVtb3ZlKFwiY2FyZC1wb3B1cC0taGlkZGVuXCIpO1xyXG5cdFx0XHRcdHRoaXMuY3R4X3NsYXRlLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XHJcbiAgXHRcdFx0XHR0aGlzLnRsLnRvKHRoaXMuY2FyZF9wb3B1cF90YXJnZXQsIHthdXRvQWxwaGE6IDEsIG9wYWNpdHk6IDEsIHk6IDAsIGR1cmF0aW9uOiAuMX0sIDApO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHR0aGlzLmNsb3NlKHRoaXMuY2FyZF9wb3B1cF90YXJnZXQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzLnRsO1xyXG5cdFx0fVxyXG5cdFx0Y2xvc2UoKSB7XHJcblx0XHRcdHRoaXMuY2FyZF9wb3B1cF90YXJnZXQuY2xhc3NMaXN0LmFkZChcImNhcmQtcG9wdXAtLWhpZGRlblwiKTtcclxuXHRcdFx0dGhpcy5jYXJkcy5mb3JFYWNoKGNhcmQgPT4ge1xyXG5cdFx0XHRcdGNhcmQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuY3R4X3NsYXRlLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XHJcblx0XHRcdHRoaXMudGwudG8odGhpcy5jYXJkX3BvcHVwX3RhcmdldCwge2F1dG9BbHBoYTogMCwgb3BhY2l0eTogMCwgeTogNTAsIGR1cmF0aW9uOiAuMX0sIDApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50bDtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Y29uc3QgY2FyZF9wb3B1cHNfZmlyZXMgPSBkYXRhLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmNhcmQtcG9wdXAtZmlyZVwiKTtcclxuXHRcclxuXHRpZiAoY2FyZF9wb3B1cHNfZmlyZXMubGVuZ3RoKSB7XHJcblx0XHRbLi4uY2FyZF9wb3B1cHNfZmlyZXNdLm1hcCgoY2FyZF9wb3B1cHNfZmlyZSkgPT4gbmV3IENhcmRQb3B1cChjYXJkX3BvcHVwc19maXJlKSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJkX3BvcHVwX2xpbmtfSW5pdDtcclxuIl0sIm5hbWVzIjpbImdzYXAiLCJDYXJkX3BvcHVwX2xpbmtfSW5pdCIsImRhdGEiLCJDYXJkUG9wdXAiLCJjb25zdHJ1Y3RvciIsImVsIiwiZGF0YV9pZCIsImdldEF0dHJpYnV0ZSIsImRhdGFfaWRfc3BsaXR0ZWQiLCJzcGxpdCIsInBvc3RfaWQiLCJsZW5ndGgiLCJzbGF0ZV9pZCIsImN0eF9zbGF0ZSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjYXJkc19wb3B1cHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2FyZHMiLCJjYXJkX3BvcHVwX3RhcmdldCIsImNhcmRfcG9wdXBfdGFyZ2V0cyIsImNhcmRfcG9wdXBfdGFyZ2V0X2Nsb3NlIiwicXVlcnlTZWxlY3RvciIsInRsIiwidGltZWxpbmUiLCJkZWZhdWx0cyIsImR1cmF0aW9uIiwiZWFzZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidG9nZ2xlIiwiZSIsImNsb3NlIiwid2luZG93Iiwic2V0IiwiYXV0b0FscGhhIiwib3BhY2l0eSIsInkiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImZvckVhY2giLCJjYXJkc19wb3B1cCIsImFkZCIsInRvIiwicmVtb3ZlIiwiY2FyZCIsImNhcmRfcG9wdXBzX2ZpcmVzIiwiY29udGFpbmVyIiwibWFwIiwiY2FyZF9wb3B1cHNfZmlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/components/card-popup-links.js\n");

/***/ }),

/***/ "./src/js/components/carrousel.js":
/*!****************************************!*\
  !*** ./src/js/components/carrousel.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _glidejs_glide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @glidejs/glide */ \"./node_modules/@glidejs/glide/dist/glide.esm.js\");\n\nconst Carrousel_Init = data => {\n  class Caroussel {\n    constructor(el) {\n      this.el = el;\n      this.glide = null;\n      console.log(this.el);\n      this.glide__track = this.el.querySelector(\".glide__track\");\n      var glide_el = this.el;\n      var mainArgs = {\n        type: 'carousel',\n        hoverpause: false,\n        autoplay: false,\n        animationDuration: 550,\n        bound: true,\n        perTouch: 1,\n        heightRatio: 0.5625\n        // classes: {\n        // \tdirection: {\n        // \t\tltr: 'carrousel--ltr',\n        // \t\trtl: 'carrousel--rtl'\n        // \t},\n        // \tslider: 'carrousel--slider',\n        // \tcarousel: 'carrousel--carousel',\n        // \tswipeable: 'carrousel--swipeable',\n        // \tdragging: 'carrousel--dragging',\n        // \tcloneSlide: 'carrousel__slide--clone',\n        // \tactiveNav: 'carrousel__bullet--active',\n        // \tactive: 'carrousel__bullet--active',\n        // \tactiveSlide: 'carrousel__slide--active',\n        // \tdisabledArrow: 'carrousel__arrow--disabled'\n        // }\n      };\n      var SpecificArgs = {\n        startAt: 0,\n        perView: 1\n      };\n      var args = {};\n      args = jsonConcat(args, mainArgs);\n      args = jsonConcat(args, SpecificArgs);\n      this.glide = new _glidejs_glide__WEBPACK_IMPORTED_MODULE_0__[\"default\"](glide_el, args);\n      this.glide.mount();\n      const observer = new IntersectionObserver((entries, _observer) => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            this.glide.on('build.after', function () {\n              var slideHeight = glide_el.querySelector(\".glide__slide--active\").getBoundingClientRect().height;\n              var glideTrack = glide_el.querySelector(\".glide__track\").getBoundingClientRect().height;\n              if (slideHeight != glideTrack) {\n                var newHeight = slideHeight;\n                glide_el.querySelector(\".glide__track\").style.height = newHeight + 'px';\n              }\n            });\n            this.glide.on('run.after', function () {\n              var slideHeight = glide_el.querySelector(\".glide__slide--active\").getBoundingClientRect().height;\n              var glideTrack = glide_el.querySelector(\".glide__track\").getBoundingClientRect().height;\n              if (slideHeight != glideTrack) {\n                var newHeight = slideHeight;\n                glide_el.querySelector(\".glide__track\").style.height = newHeight + 'px';\n              }\n            });\n            this.glide.update();\n          }\n        });\n      });\n      observer.observe(glide_el);\n      function jsonConcat(o1, o2) {\n        for (var key in o2) {\n          o1[key] = o2[key];\n        }\n        return o1;\n      }\n    }\n  }\n  const caroussels = data.container.querySelectorAll(\".carrousel\");\n  if (caroussels.length) {\n    [...caroussels].map(caroussel => new Caroussel(caroussel));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Carrousel_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRCxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUM2QixLQUFLLENBQUNILE1BQU0sR0FBSUUsU0FBUyxHQUFJLElBQUk7Y0FDMUU7WUFDRCxDQUFDLENBQUM7WUFDRixJQUFJLENBQUNoQyxLQUFLLENBQUNrQyxNQUFNLENBQUMsQ0FBQztVQUNwQjtRQUNELENBQUMsQ0FBQztNQUNILENBQUMsQ0FBQztNQUVGZCxRQUFRLENBQUNlLE9BQU8sQ0FBQzlCLFFBQVEsQ0FBQztNQUUxQixTQUFTYSxVQUFVQSxDQUFDa0IsRUFBRSxFQUFFQyxFQUFFLEVBQUU7UUFDM0IsS0FBSyxJQUFJQyxHQUFHLElBQUlELEVBQUUsRUFBRTtVQUNuQkQsRUFBRSxDQUFDRSxHQUFHLENBQUMsR0FBR0QsRUFBRSxDQUFDQyxHQUFHLENBQUM7UUFDbEI7UUFDQSxPQUFPRixFQUFFO01BQ1Y7SUFDRDtFQUNEO0VBRUEsTUFBTUcsVUFBVSxHQUFHM0MsSUFBSSxDQUFDNEMsU0FBUyxDQUFDQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUM7RUFFaEUsSUFBSUYsVUFBVSxDQUFDRyxNQUFNLEVBQUU7SUFDckIsQ0FBQyxHQUFHSCxVQUFVLENBQUMsQ0FBQ0ksR0FBRyxDQUFFQyxTQUFTLElBQUssSUFBSS9DLFNBQVMsQ0FBQytDLFNBQVMsQ0FBQyxDQUFDO0VBQzlEO0FBQ0QsQ0FBQztBQUVELGlFQUFlakQsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL2NhcnJvdXNlbC5qcz9iZjljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHbGlkZSBmcm9tICdAZ2xpZGVqcy9nbGlkZSdcclxuXHJcbmNvbnN0IENhcnJvdXNlbF9Jbml0ID0gKGRhdGEpID0+IHtcclxuXHRjbGFzcyBDYXJvdXNzZWwge1xyXG5cdFx0Y29uc3RydWN0b3IoZWwpIHtcclxuXHRcdFx0dGhpcy5lbCA9IGVsO1xyXG5cdFx0XHR0aGlzLmdsaWRlID0gbnVsbDtcclxuXHRcdFx0Y29uc29sZS5sb2codGhpcy5lbCk7XHJcblx0XHRcdHRoaXMuZ2xpZGVfX3RyYWNrID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmdsaWRlX190cmFja1wiKTtcclxuXHRcdFx0dmFyIGdsaWRlX2VsID0gdGhpcy5lbDtcclxuXHRcdFx0dmFyIG1haW5BcmdzID0ge1xyXG5cdFx0XHRcdHR5cGU6ICdjYXJvdXNlbCcsXHJcblx0XHRcdFx0aG92ZXJwYXVzZTogZmFsc2UsXHJcblx0XHRcdFx0YXV0b3BsYXk6IGZhbHNlLFxyXG5cdFx0XHRcdGFuaW1hdGlvbkR1cmF0aW9uOiA1NTAsXHJcblx0XHRcdFx0Ym91bmQ6IHRydWUsXHJcblx0XHRcdFx0cGVyVG91Y2g6IDEsXHJcblx0XHRcdFx0aGVpZ2h0UmF0aW8gOiAwLjU2MjVcclxuXHRcdFx0XHQvLyBjbGFzc2VzOiB7XHJcblx0XHRcdFx0Ly8gXHRkaXJlY3Rpb246IHtcclxuXHRcdFx0XHQvLyBcdFx0bHRyOiAnY2Fycm91c2VsLS1sdHInLFxyXG5cdFx0XHRcdC8vIFx0XHRydGw6ICdjYXJyb3VzZWwtLXJ0bCdcclxuXHRcdFx0XHQvLyBcdH0sXHJcblx0XHRcdFx0Ly8gXHRzbGlkZXI6ICdjYXJyb3VzZWwtLXNsaWRlcicsXHJcblx0XHRcdFx0Ly8gXHRjYXJvdXNlbDogJ2NhcnJvdXNlbC0tY2Fyb3VzZWwnLFxyXG5cdFx0XHRcdC8vIFx0c3dpcGVhYmxlOiAnY2Fycm91c2VsLS1zd2lwZWFibGUnLFxyXG5cdFx0XHRcdC8vIFx0ZHJhZ2dpbmc6ICdjYXJyb3VzZWwtLWRyYWdnaW5nJyxcclxuXHRcdFx0XHQvLyBcdGNsb25lU2xpZGU6ICdjYXJyb3VzZWxfX3NsaWRlLS1jbG9uZScsXHJcblx0XHRcdFx0Ly8gXHRhY3RpdmVOYXY6ICdjYXJyb3VzZWxfX2J1bGxldC0tYWN0aXZlJyxcclxuXHRcdFx0XHQvLyBcdGFjdGl2ZTogJ2NhcnJvdXNlbF9fYnVsbGV0LS1hY3RpdmUnLFxyXG5cdFx0XHRcdC8vIFx0YWN0aXZlU2xpZGU6ICdjYXJyb3VzZWxfX3NsaWRlLS1hY3RpdmUnLFxyXG5cdFx0XHRcdC8vIFx0ZGlzYWJsZWRBcnJvdzogJ2NhcnJvdXNlbF9fYXJyb3ctLWRpc2FibGVkJ1xyXG5cdFx0XHRcdC8vIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIFNwZWNpZmljQXJncyA9IHtcclxuXHRcdFx0XHRzdGFydEF0OiAwLFxyXG5cdFx0XHRcdHBlclZpZXc6IDEsXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBhcmdzID0ge307XHJcblx0XHRcdGFyZ3MgPSBqc29uQ29uY2F0KGFyZ3MsIG1haW5BcmdzKTtcclxuXHRcdFx0YXJncyA9IGpzb25Db25jYXQoYXJncywgU3BlY2lmaWNBcmdzKTtcclxuXHJcblx0XHRcdHRoaXMuZ2xpZGUgPSBuZXcgR2xpZGUoZ2xpZGVfZWwsIGFyZ3MgKTtcclxuXHRcclxuXHRcdFx0dGhpcy5nbGlkZS5tb3VudCgpO1xyXG5cclxuXHRcdFx0Y29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMsIF9vYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7ICAgIFxyXG5cdFx0XHRcdFx0aWYoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5nbGlkZS5vbignYnVpbGQuYWZ0ZXInLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc2xpZGVIZWlnaHQgPSBnbGlkZV9lbC5xdWVyeVNlbGVjdG9yKFwiLmdsaWRlX19zbGlkZS0tYWN0aXZlXCIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZ2xpZGVUcmFjayA9IGdsaWRlX2VsLnF1ZXJ5U2VsZWN0b3IoXCIuZ2xpZGVfX3RyYWNrXCIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc2xpZGVIZWlnaHQgIT0gZ2xpZGVUcmFjaykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG5ld0hlaWdodCA9IHNsaWRlSGVpZ2h0O1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2xpZGVfZWwucXVlcnlTZWxlY3RvcihcIi5nbGlkZV9fdHJhY2tcIikuc3R5bGUuaGVpZ2h0ICA9IG5ld0hlaWdodCAgKyAncHgnO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHR0aGlzLmdsaWRlLm9uKCdydW4uYWZ0ZXInLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc2xpZGVIZWlnaHQgPSBnbGlkZV9lbC5xdWVyeVNlbGVjdG9yKFwiLmdsaWRlX19zbGlkZS0tYWN0aXZlXCIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZ2xpZGVUcmFjayA9IGdsaWRlX2VsLnF1ZXJ5U2VsZWN0b3IoXCIuZ2xpZGVfX3RyYWNrXCIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc2xpZGVIZWlnaHQgIT0gZ2xpZGVUcmFjaykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG5ld0hlaWdodCA9IHNsaWRlSGVpZ2h0O1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2xpZGVfZWwucXVlcnlTZWxlY3RvcihcIi5nbGlkZV9fdHJhY2tcIikuc3R5bGUuaGVpZ2h0ICA9IG5ld0hlaWdodCAgKyAncHgnO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdFx0dGhpcy5nbGlkZS51cGRhdGUoKTtcclxuXHRcdFx0XHRcdH0gIFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRvYnNlcnZlci5vYnNlcnZlKGdsaWRlX2VsKTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGpzb25Db25jYXQobzEsIG8yKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG8yKSB7XHJcblx0XHRcdFx0IG8xW2tleV0gPSBvMltrZXldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbzE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Y29uc3QgY2Fyb3Vzc2VscyA9IGRhdGEuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2Fycm91c2VsXCIpO1xyXG5cclxuXHRpZiAoY2Fyb3Vzc2Vscy5sZW5ndGgpIHtcclxuXHQgIFsuLi5jYXJvdXNzZWxzXS5tYXAoKGNhcm91c3NlbCkgPT4gbmV3IENhcm91c3NlbChjYXJvdXNzZWwpKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcnJvdXNlbF9Jbml0OyJdLCJuYW1lcyI6WyJHbGlkZSIsIkNhcnJvdXNlbF9Jbml0IiwiZGF0YSIsIkNhcm91c3NlbCIsImNvbnN0cnVjdG9yIiwiZWwiLCJnbGlkZSIsImNvbnNvbGUiLCJsb2ciLCJnbGlkZV9fdHJhY2siLCJxdWVyeVNlbGVjdG9yIiwiZ2xpZGVfZWwiLCJtYWluQXJncyIsInR5cGUiLCJob3ZlcnBhdXNlIiwiYXV0b3BsYXkiLCJhbmltYXRpb25EdXJhdGlvbiIsImJvdW5kIiwicGVyVG91Y2giLCJoZWlnaHRSYXRpbyIsIlNwZWNpZmljQXJncyIsInN0YXJ0QXQiLCJwZXJWaWV3IiwiYXJncyIsImpzb25Db25jYXQiLCJtb3VudCIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiX29ic2VydmVyIiwiZm9yRWFjaCIsImVudHJ5IiwiaXNJbnRlcnNlY3RpbmciLCJvbiIsInNsaWRlSGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGVpZ2h0IiwiZ2xpZGVUcmFjayIsIm5ld0hlaWdodCIsInN0eWxlIiwidXBkYXRlIiwib2JzZXJ2ZSIsIm8xIiwibzIiLCJrZXkiLCJjYXJvdXNzZWxzIiwiY29udGFpbmVyIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIm1hcCIsImNhcm91c3NlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/components/carrousel.js\n");

/***/ }),

/***/ "./src/js/components/checkbox.js":
/*!***************************************!*\
  !*** ./src/js/components/checkbox.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Checkbox_And_Radios_Init = () => {\n  class Checkbox {\n    constructor(el) {\n      this.el = el;\n      this.checkbox_label = this.el.querySelector(\"label\");\n      this.checkbox_input = this.checkbox_label.querySelector(\"input\");\n      this.init();\n    }\n    init() {\n      const svg_content = \"<svg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'><path d='M18.4375 1.56177L7.1185 17.731C6.81554 18.1664 6.32177 18.4295 5.79145 18.4383C5.26114 18.4471 4.75894 18.2004 4.44175 17.7753L1.5625 13.9368' stroke='black' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/></svg>\";\n      const tempElement = document.createElement('div');\n      tempElement.classList.add(\"svg_wrapper\");\n      tempElement.innerHTML = svg_content;\n      this.checkbox_label.appendChild(tempElement);\n    }\n  }\n  const checkboxes = document.querySelectorAll(\".acf-checkbox-list li\");\n  const checkbox_outside_plugin = document.querySelectorAll(\".login-remember\");\n  const merged_elements = [...checkboxes, ...checkbox_outside_plugin];\n  if (merged_elements.length) {\n    [...merged_elements].map(checkbox => new Checkbox(checkbox));\n  }\n  var radios = document.querySelectorAll(\".gchoice\");\n  if (radios.length) {\n    [...radios].map(radio => new Checkbox(radio));\n  }\n  document.addEventListener('DOMContentLoaded', function () {\n    if (window.jQuery) {\n      jQuery(document).on('gform_page_loaded', function (event, form_id, current_page) {\n        const checkboxes = document.querySelectorAll(\".acf-checkbox-list li\");\n        const checkbox_outside_plugin = document.querySelectorAll(\".login-remember\");\n        const merged_elements = [...checkboxes, ...checkbox_outside_plugin];\n        if (merged_elements.length) {\n          [...merged_elements].map(checkbox => new Checkbox(checkbox));\n        }\n        var radios = document.querySelectorAll(\".gchoice\");\n        if (radios.length) {\n          [...radios].map(radio => new Checkbox(radio));\n        }\n      });\n    }\n  });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Checkbox_And_Radios_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztBQUVELGlFQUFleEIsd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2NvbXBvbmVudHMvY2hlY2tib3guanM/OTk0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDaGVja2JveF9BbmRfUmFkaW9zX0luaXQgPSAoKSA9PiB7XHJcblx0Y2xhc3MgQ2hlY2tib3gge1xyXG5cdFx0Y29uc3RydWN0b3IoZWwpIHtcclxuXHRcdFx0dGhpcy5lbCA9IGVsO1xyXG5cdFx0XHR0aGlzLmNoZWNrYm94X2xhYmVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwibGFiZWxcIik7XHJcblx0XHRcdHRoaXMuY2hlY2tib3hfaW5wdXQgPSB0aGlzLmNoZWNrYm94X2xhYmVsLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuaW5pdCgpO1xyXG5cdFx0fVxyXG5cdFx0aW5pdCgpIHtcclxuXHRcdFx0Y29uc3Qgc3ZnX2NvbnRlbnQgPSBcIjxzdmcgd2lkdGg9JzIwJyBoZWlnaHQ9JzIwJyB2aWV3Qm94PScwIDAgMjAgMjAnIGZpbGw9J25vbmUnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZD0nTTE4LjQzNzUgMS41NjE3N0w3LjExODUgMTcuNzMxQzYuODE1NTQgMTguMTY2NCA2LjMyMTc3IDE4LjQyOTUgNS43OTE0NSAxOC40MzgzQzUuMjYxMTQgMTguNDQ3MSA0Ljc1ODk0IDE4LjIwMDQgNC40NDE3NSAxNy43NzUzTDEuNTYyNSAxMy45MzY4JyBzdHJva2U9J2JsYWNrJyBzdHJva2Utd2lkdGg9JzEuNScgc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJy8+PC9zdmc+XCI7XHJcblx0XHRcdGNvbnN0IHRlbXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRcdHRlbXBFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzdmdfd3JhcHBlclwiKTtcclxuXHJcblx0XHRcdHRlbXBFbGVtZW50LmlubmVySFRNTCA9IHN2Z19jb250ZW50O1xyXG5cclxuXHRcdFx0dGhpcy5jaGVja2JveF9sYWJlbC5hcHBlbmRDaGlsZCh0ZW1wRWxlbWVudCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGNvbnN0IGNoZWNrYm94ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFjZi1jaGVja2JveC1saXN0IGxpXCIpO1xyXG5cdGNvbnN0IGNoZWNrYm94X291dHNpZGVfcGx1Z2luID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5sb2dpbi1yZW1lbWJlclwiKTtcclxuXHRjb25zdCBtZXJnZWRfZWxlbWVudHMgPSBbLi4uY2hlY2tib3hlcywgLi4uY2hlY2tib3hfb3V0c2lkZV9wbHVnaW5dO1xyXG5cdFxyXG5cdGlmIChtZXJnZWRfZWxlbWVudHMubGVuZ3RoKSB7XHJcblx0XHRbLi4ubWVyZ2VkX2VsZW1lbnRzXS5tYXAoKGNoZWNrYm94KSA9PiBuZXcgQ2hlY2tib3goY2hlY2tib3gpKTtcclxuXHR9XHJcblxyXG5cdHZhciByYWRpb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmdjaG9pY2VcIik7XHJcblx0XHJcblx0aWYgKHJhZGlvcy5sZW5ndGgpIHtcclxuXHRcdFsuLi5yYWRpb3NdLm1hcCgocmFkaW8pID0+IG5ldyBDaGVja2JveChyYWRpbykpO1xyXG5cdH1cclxuXHJcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKHdpbmRvdy5qUXVlcnkpIHsgIFxyXG5cdFx0XHRqUXVlcnkoZG9jdW1lbnQpLm9uKCdnZm9ybV9wYWdlX2xvYWRlZCcsIGZ1bmN0aW9uKGV2ZW50LCBmb3JtX2lkLCBjdXJyZW50X3BhZ2Upe1xyXG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFjZi1jaGVja2JveC1saXN0IGxpXCIpO1xyXG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94X291dHNpZGVfcGx1Z2luID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5sb2dpbi1yZW1lbWJlclwiKTtcclxuXHRcdFx0XHRjb25zdCBtZXJnZWRfZWxlbWVudHMgPSBbLi4uY2hlY2tib3hlcywgLi4uY2hlY2tib3hfb3V0c2lkZV9wbHVnaW5dO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChtZXJnZWRfZWxlbWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRbLi4ubWVyZ2VkX2VsZW1lbnRzXS5tYXAoKGNoZWNrYm94KSA9PiBuZXcgQ2hlY2tib3goY2hlY2tib3gpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciByYWRpb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmdjaG9pY2VcIik7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHJhZGlvcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFsuLi5yYWRpb3NdLm1hcCgocmFkaW8pID0+IG5ldyBDaGVja2JveChyYWRpbykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94X0FuZF9SYWRpb3NfSW5pdDtcclxuIl0sIm5hbWVzIjpbIkNoZWNrYm94X0FuZF9SYWRpb3NfSW5pdCIsIkNoZWNrYm94IiwiY29uc3RydWN0b3IiLCJlbCIsImNoZWNrYm94X2xhYmVsIiwicXVlcnlTZWxlY3RvciIsImNoZWNrYm94X2lucHV0IiwiaW5pdCIsInN2Z19jb250ZW50IiwidGVtcEVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsImNoZWNrYm94ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2hlY2tib3hfb3V0c2lkZV9wbHVnaW4iLCJtZXJnZWRfZWxlbWVudHMiLCJsZW5ndGgiLCJtYXAiLCJjaGVja2JveCIsInJhZGlvcyIsInJhZGlvIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndpbmRvdyIsImpRdWVyeSIsIm9uIiwiZXZlbnQiLCJmb3JtX2lkIiwiY3VycmVudF9wYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/checkbox.js\n");

/***/ }),

/***/ "./src/js/components/copy-paste.js":
/*!*****************************************!*\
  !*** ./src/js/components/copy-paste.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst CopyBtn_Init = data => {\n  class CopyBtn {\n    constructor(btn) {\n      this.btn = btn;\n      this.copy_trad_action = this.btn.querySelector('.u-sr-accessible').innerHTML;\n      this.copied_trad = this.btn.getAttribute('data-action-trad');\n      this.copied_value = this.btn.previousElementSibling.innerHTML;\n      this.target__el = document.querySelector(this.btn.getAttribute('data-copy-content'));\n      this.target__el__content = this.target__el.innerHTML;\n      this.tooltipContent = this.btn.nextElementSibling.querySelector(\"span\");\n      this.tooltipContent.innerHTML = this.copy_trad_action;\n      this.btn.addEventListener('click', e => {\n        this.copyToClipboard(e);\n      });\n      this.btn.addEventListener('mouseleave', e => {\n        this.resetTooltipContent();\n      });\n    }\n    copyToClipboard(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log(this.tooltipContent.innerHTML);\n      navigator.clipboard.writeText(this.copied_value);\n      this.tooltipContent.innerHTML = this.copied_value + \" \" + this.copied_trad;\n    }\n    resetTooltipContent() {\n      this.tooltipContent.innerHTML = this.copy_trad_action;\n    }\n  }\n  const copyBtns = document.querySelectorAll(\"[data-action='copy']\");\n  if (copyBtns.length) {\n    [...copyBtns].map(copyBtnsWithClick => new CopyBtn(copyBtnsWithClick));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CopyBtn_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy9jb3B5LXBhc3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxZQUFZLEdBQUlDLElBQUksSUFBSztFQUM5QixNQUFNQyxPQUFPLENBQUM7SUFDYkMsV0FBV0EsQ0FBQ0MsR0FBRyxFQUFFO01BQ2pCLElBQUksQ0FBQ0EsR0FBRyxHQUFHQSxHQUFHO01BQ2QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUNELEdBQUcsQ0FBQ0UsYUFBYSxDQUFDLGtCQUFrQixDQUFDLENBQUNDLFNBQVM7TUFDNUUsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDSixHQUFHLENBQUNLLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQztNQUM1RCxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUNOLEdBQUcsQ0FBQ08sc0JBQXNCLENBQUNKLFNBQVM7TUFDN0QsSUFBSSxDQUFDSyxVQUFVLEdBQUdDLFFBQVEsQ0FBQ1AsYUFBYSxDQUFDLElBQUksQ0FBQ0YsR0FBRyxDQUFDSyxZQUFZLENBQUMsbUJBQW1CLENBQUMsQ0FBQztNQUNwRixJQUFJLENBQUNLLG1CQUFtQixHQUFHLElBQUksQ0FBQ0YsVUFBVSxDQUFDTCxTQUFTO01BQ3BELElBQUksQ0FBQ1EsY0FBYyxHQUFHLElBQUksQ0FBQ1gsR0FBRyxDQUFDWSxrQkFBa0IsQ0FBQ1YsYUFBYSxDQUFDLE1BQU0sQ0FBQztNQUN2RSxJQUFJLENBQUNTLGNBQWMsQ0FBQ1IsU0FBUyxHQUFHLElBQUksQ0FBQ0YsZ0JBQWdCO01BRXJELElBQUksQ0FBQ0QsR0FBRyxDQUFDYSxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUdDLENBQUMsSUFBSztRQUN6QyxJQUFJLENBQUNDLGVBQWUsQ0FBQ0QsQ0FBQyxDQUFDO01BQ3hCLENBQUMsQ0FBQztNQUNGLElBQUksQ0FBQ2QsR0FBRyxDQUFDYSxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUdDLENBQUMsSUFBSztRQUM5QyxJQUFJLENBQUNFLG1CQUFtQixDQUFDLENBQUM7TUFDM0IsQ0FBQyxDQUFDO0lBRUY7SUFDQUQsZUFBZUEsQ0FBQ0QsQ0FBQyxFQUFDO01BQ2pCQSxDQUFDLENBQUNHLGNBQWMsQ0FBQyxDQUFDO01BQ2xCSCxDQUFDLENBQUNJLGVBQWUsQ0FBQyxDQUFDO01BQ25CQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxJQUFJLENBQUNULGNBQWMsQ0FBQ1IsU0FBUyxDQUFDO01BQzFDa0IsU0FBUyxDQUFDQyxTQUFTLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUNqQixZQUFZLENBQUM7TUFDaEQsSUFBSSxDQUFDSyxjQUFjLENBQUNSLFNBQVMsR0FBRyxJQUFJLENBQUNHLFlBQVksR0FBRyxHQUFHLEdBQUksSUFBSSxDQUFDRixXQUFXO0lBQzVFO0lBQ0FZLG1CQUFtQkEsQ0FBQSxFQUFFO01BQ3BCLElBQUksQ0FBQ0wsY0FBYyxDQUFDUixTQUFTLEdBQUcsSUFBSSxDQUFDRixnQkFBZ0I7SUFDdEQ7RUFDRDtFQUVBLE1BQU11QixRQUFRLEdBQUdmLFFBQVEsQ0FBQ2dCLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDO0VBRWxFLElBQUlELFFBQVEsQ0FBQ0UsTUFBTSxFQUFFO0lBQ3BCLENBQUMsR0FBR0YsUUFBUSxDQUFDLENBQUNHLEdBQUcsQ0FBRUMsaUJBQWlCLElBQUssSUFBSTlCLE9BQU8sQ0FBQzhCLGlCQUFpQixDQUFDLENBQUM7RUFDekU7QUFDRCxDQUFDO0FBRUQsaUVBQWVoQyxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2NvbXBvbmVudHMvY29weS1wYXN0ZS5qcz9mOGI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENvcHlCdG5fSW5pdCA9IChkYXRhKSA9PiB7XHJcblx0Y2xhc3MgQ29weUJ0biB7XHJcblx0XHRjb25zdHJ1Y3RvcihidG4pIHtcclxuXHRcdHRoaXMuYnRuID0gYnRuO1xyXG5cdFx0dGhpcy5jb3B5X3RyYWRfYWN0aW9uID0gdGhpcy5idG4ucXVlcnlTZWxlY3RvcignLnUtc3ItYWNjZXNzaWJsZScpLmlubmVySFRNTDtcclxuXHRcdHRoaXMuY29waWVkX3RyYWQgPSB0aGlzLmJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9uLXRyYWQnKTtcclxuXHRcdHRoaXMuY29waWVkX3ZhbHVlID0gdGhpcy5idG4ucHJldmlvdXNFbGVtZW50U2libGluZy5pbm5lckhUTUw7XHJcblx0XHR0aGlzLnRhcmdldF9fZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuYnRuLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3B5LWNvbnRlbnQnKSk7XHJcblx0XHR0aGlzLnRhcmdldF9fZWxfX2NvbnRlbnQgPSB0aGlzLnRhcmdldF9fZWwuaW5uZXJIVE1MO1xyXG5cdFx0dGhpcy50b29sdGlwQ29udGVudCA9IHRoaXMuYnRuLm5leHRFbGVtZW50U2libGluZy5xdWVyeVNlbGVjdG9yKFwic3BhblwiKTtcclxuXHRcdHRoaXMudG9vbHRpcENvbnRlbnQuaW5uZXJIVE1MID0gdGhpcy5jb3B5X3RyYWRfYWN0aW9uO1xyXG5cclxuXHRcdHRoaXMuYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuXHRcdFx0dGhpcy5jb3B5VG9DbGlwYm9hcmQoZSk7XHJcblx0XHR9KTtcclxuXHRcdHRoaXMuYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoZSkgPT4ge1xyXG5cdFx0XHR0aGlzLnJlc2V0VG9vbHRpcENvbnRlbnQoKTtcclxuXHRcdH0pO1xyXG5cdFxyXG5cdFx0fVxyXG5cdFx0Y29weVRvQ2xpcGJvYXJkKGUpe1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdGNvbnNvbGUubG9nKHRoaXMudG9vbHRpcENvbnRlbnQuaW5uZXJIVE1MKTtcclxuXHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhpcy5jb3BpZWRfdmFsdWUpO1xyXG5cdFx0XHR0aGlzLnRvb2x0aXBDb250ZW50LmlubmVySFRNTCA9IHRoaXMuY29waWVkX3ZhbHVlICsgXCIgXCIgICsgdGhpcy5jb3BpZWRfdHJhZDtcclxuXHRcdH1cclxuXHRcdHJlc2V0VG9vbHRpcENvbnRlbnQoKXtcclxuXHRcdFx0dGhpcy50b29sdGlwQ29udGVudC5pbm5lckhUTUwgPSB0aGlzLmNvcHlfdHJhZF9hY3Rpb247XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdGNvbnN0IGNvcHlCdG5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWFjdGlvbj0nY29weSddXCIpO1xyXG5cclxuXHRpZiAoY29weUJ0bnMubGVuZ3RoKSB7XHJcblx0XHRbLi4uY29weUJ0bnNdLm1hcCgoY29weUJ0bnNXaXRoQ2xpY2spID0+IG5ldyBDb3B5QnRuKGNvcHlCdG5zV2l0aENsaWNrKSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb3B5QnRuX0luaXQ7Il0sIm5hbWVzIjpbIkNvcHlCdG5fSW5pdCIsImRhdGEiLCJDb3B5QnRuIiwiY29uc3RydWN0b3IiLCJidG4iLCJjb3B5X3RyYWRfYWN0aW9uIiwicXVlcnlTZWxlY3RvciIsImlubmVySFRNTCIsImNvcGllZF90cmFkIiwiZ2V0QXR0cmlidXRlIiwiY29waWVkX3ZhbHVlIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInRhcmdldF9fZWwiLCJkb2N1bWVudCIsInRhcmdldF9fZWxfX2NvbnRlbnQiLCJ0b29sdGlwQ29udGVudCIsIm5leHRFbGVtZW50U2libGluZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY29weVRvQ2xpcGJvYXJkIiwicmVzZXRUb29sdGlwQ29udGVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY29uc29sZSIsImxvZyIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsImNvcHlCdG5zIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIm1hcCIsImNvcHlCdG5zV2l0aENsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/copy-paste.js\n");

/***/ }),

/***/ "./src/js/components/dropzone.js":
/*!***************************************!*\
  !*** ./src/js/components/dropzone.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst FileUploadInit = () => {\n  class FileUpload {\n    constructor(el) {\n      this.el = el;\n      // this.el.style.backgroundColor = \"red\";\n      this.inputElement = this.el.querySelector(\"input[type=file]\");\n      this.existingImage = this.el.querySelector(\".show-if-value img\");\n      this.inputElement.addEventListener('change', this.previewPhoto);\n    }\n    previewPhoto = () => {\n      const file = this.inputElement.files;\n      console.log(\"preview photo\");\n      console.log(file);\n      if (file) {\n        const fileReader = new FileReader();\n        // const preview = document.querySelector('show-if-value image-wrap');\n        fileReader.onload = event => {\n          this.existingImage.setAttribute('src', event.target.result);\n          this.el.classList.add(\"has-value\");\n        };\n        fileReader.readAsDataURL(file[0]);\n      }\n    };\n    emptyUpload() {}\n  }\n  const AddGalleryRow = document.querySelector(\".acf-repeater-add-row\");\n  if (AddGalleryRow) {\n    AddGalleryRow.addEventListener(\"click\", function (e) {\n      console.log(\"Add instance\");\n      var Parent = e.currentTarget.parentNode.parentNode;\n      var NewTrRows = Parent.querySelectorAll(\".acf-row\");\n      console.log(NewTrRows.length);\n      if (NewTrRows.length) {\n        setTimeout(function () {\n          console.log(NewTrRows[NewTrRows.length - 1]);\n          console.log(NewTrRows[NewTrRows.length - 1].previousSibling);\n          var NewFileUploader = NewTrRows[NewTrRows.length - 1].previousSibling.querySelector(\".acf-image-uploader\");\n          console.log(NewFileUploader);\n          new FileUpload(NewFileUploader);\n        }, 100);\n      }\n    });\n  }\n  const FileUploaders = document.querySelectorAll(\".acf-image-uploader\");\n  if (FileUploaders.length) {\n    [...FileUploaders].map(FileUploader => new FileUpload(FileUploader));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileUploadInit);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLEVBQUU7SUFDekIsQ0FBQyxHQUFHSSxhQUFhLENBQUMsQ0FBQ0MsR0FBRyxDQUFFQyxZQUFZLElBQUssSUFBSXJDLFVBQVUsQ0FBQ3FDLFlBQVksQ0FBQyxDQUFDO0VBQ3ZFO0FBQ0QsQ0FBQztBQUVELGlFQUFldEMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL2Ryb3B6b25lLmpzPzhiMDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRmlsZVVwbG9hZEluaXQgPSAoKSA9PiB7XHJcblx0Y2xhc3MgRmlsZVVwbG9hZCB7XHJcblx0XHRjb25zdHJ1Y3RvcihlbCkge1xyXG5cdFx0XHR0aGlzLmVsID0gZWw7XHJcblx0XHRcdC8vIHRoaXMuZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZWRcIjtcclxuXHRcdFx0dGhpcy5pbnB1dEVsZW1lbnQgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFt0eXBlPWZpbGVdXCIpO1xyXG5cdFx0XHR0aGlzLmV4aXN0aW5nSW1hZ2UgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuc2hvdy1pZi12YWx1ZSBpbWdcIik7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMucHJldmlld1Bob3RvKTtcclxuXHRcdH1cclxuXHJcbiAgICAgICAgcHJldmlld1Bob3RvID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5pbnB1dEVsZW1lbnQuZmlsZXM7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJldmlldyBwaG90b1wiKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlKTtcclxuICAgICAgICAgICAgaWYgKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcHJldmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3Nob3ctaWYtdmFsdWUgaW1hZ2Utd3JhcCcpO1xyXG4gICAgICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGlzdGluZ0ltYWdlLnNldEF0dHJpYnV0ZSgnc3JjJywgZXZlbnQudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiaGFzLXZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGVbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHRcdGVtcHR5VXBsb2FkKCkge1xyXG5cdFx0XHRcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuICAgIGNvbnN0IEFkZEdhbGxlcnlSb3cgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmFjZi1yZXBlYXRlci1hZGQtcm93XCIpO1xyXG4gICAgaWYoQWRkR2FsbGVyeVJvdyl7XHJcbiAgICAgICAgQWRkR2FsbGVyeVJvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBZGQgaW5zdGFuY2VcIik7XHJcbiAgICAgICAgICAgIHZhciBQYXJlbnQgPSBlLmN1cnJlbnRUYXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICB2YXIgTmV3VHJSb3dzID0gUGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWNmLXJvd1wiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coTmV3VHJSb3dzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChOZXdUclJvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coTmV3VHJSb3dzW05ld1RyUm93cy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coTmV3VHJSb3dzW05ld1RyUm93cy5sZW5ndGggLSAxXS5wcmV2aW91c1NpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBOZXdGaWxlVXBsb2FkZXIgPSBOZXdUclJvd3NbTmV3VHJSb3dzLmxlbmd0aCAtIDFdLnByZXZpb3VzU2libGluZy5xdWVyeVNlbGVjdG9yKFwiLmFjZi1pbWFnZS11cGxvYWRlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhOZXdGaWxlVXBsb2FkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBGaWxlVXBsb2FkKE5ld0ZpbGVVcGxvYWRlcilcclxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblx0Y29uc3QgRmlsZVVwbG9hZGVycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWNmLWltYWdlLXVwbG9hZGVyXCIpO1xyXG5cdFxyXG5cdGlmIChGaWxlVXBsb2FkZXJzLmxlbmd0aCkge1xyXG5cdFx0Wy4uLkZpbGVVcGxvYWRlcnNdLm1hcCgoRmlsZVVwbG9hZGVyKSA9PiBuZXcgRmlsZVVwbG9hZChGaWxlVXBsb2FkZXIpKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZpbGVVcGxvYWRJbml0O1xyXG4iXSwibmFtZXMiOlsiRmlsZVVwbG9hZEluaXQiLCJGaWxlVXBsb2FkIiwiY29uc3RydWN0b3IiLCJlbCIsImlucHV0RWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJleGlzdGluZ0ltYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInByZXZpZXdQaG90byIsImZpbGUiLCJmaWxlcyIsImNvbnNvbGUiLCJsb2ciLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImV2ZW50Iiwic2V0QXR0cmlidXRlIiwidGFyZ2V0IiwicmVzdWx0IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVhZEFzRGF0YVVSTCIsImVtcHR5VXBsb2FkIiwiQWRkR2FsbGVyeVJvdyIsImRvY3VtZW50IiwiZSIsIlBhcmVudCIsImN1cnJlbnRUYXJnZXQiLCJwYXJlbnROb2RlIiwiTmV3VHJSb3dzIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsInNldFRpbWVvdXQiLCJwcmV2aW91c1NpYmxpbmciLCJOZXdGaWxlVXBsb2FkZXIiLCJGaWxlVXBsb2FkZXJzIiwibWFwIiwiRmlsZVVwbG9hZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/dropzone.js\n");

/***/ }),

/***/ "./src/js/components/header.js":
/*!*************************************!*\
  !*** ./src/js/components/header.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _functional_relations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functional/relations */ \"./src/js/functional/relations.js\");\n\nconst Init_Header = () => {\n  var current_user_id = document.querySelector(\".current_user_id\");\n  var contactBtnsResponse = document.querySelectorAll('.relation_btn--contact-list-response');\n  contactBtnsResponse.forEach(contactBtnResponse => {\n    contactBtnResponse.addEventListener(\"click\", e => {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log(e.currentTarget.getAttribute(\"data-relation-type\"));\n      (0,_functional_relations__WEBPACK_IMPORTED_MODULE_0__.makeRelationBtw)(current_user_id.getAttribute(\"data-u-id\"), e.currentTarget.getAttribute(\"data-relation-him\"), e.currentTarget.getAttribute(\"data-relation-type\"), e.currentTarget);\n    });\n  });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Init_Header);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy9oZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEQ7QUFFMUQsTUFBTUMsV0FBVyxHQUFHQSxDQUFBLEtBQU07RUFDeEIsSUFBSUMsZUFBZSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQztFQUNoRSxJQUFJQyxtQkFBbUIsR0FBR0YsUUFBUSxDQUFDRyxnQkFBZ0IsQ0FBQyxzQ0FBc0MsQ0FBQztFQUNyRkQsbUJBQW1CLENBQUNFLE9BQU8sQ0FBQ0Msa0JBQWtCLElBQUk7SUFDOUNBLGtCQUFrQixDQUFDQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUdDLENBQUMsSUFBSztNQUNoREEsQ0FBQyxDQUFDQyxjQUFjLENBQUMsQ0FBQztNQUNsQkQsQ0FBQyxDQUFDRSxlQUFlLENBQUMsQ0FBQztNQUNuQkMsT0FBTyxDQUFDQyxHQUFHLENBQUNKLENBQUMsQ0FBQ0ssYUFBYSxDQUFDQyxZQUFZLENBQUMsb0JBQW9CLENBQUMsQ0FBQztNQUMvRGhCLHNFQUFlLENBQUNFLGVBQWUsQ0FBQ2MsWUFBWSxDQUFDLFdBQVcsQ0FBQyxFQUFFTixDQUFDLENBQUNLLGFBQWEsQ0FBQ0MsWUFBWSxDQUFDLG1CQUFtQixDQUFDLEVBQUVOLENBQUMsQ0FBQ0ssYUFBYSxDQUFDQyxZQUFZLENBQUMsb0JBQW9CLENBQUMsRUFBRU4sQ0FBQyxDQUFDSyxhQUFhLENBQUM7SUFDdEwsQ0FBQyxDQUFDO0VBQ04sQ0FBQyxDQUFDO0FBQ1YsQ0FBQztBQUVELGlFQUFlZCxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2NvbXBvbmVudHMvaGVhZGVyLmpzP2I0YTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFrZVJlbGF0aW9uQnR3IH0gZnJvbSAnLi4vZnVuY3Rpb25hbC9yZWxhdGlvbnMnO1xyXG5cclxuY29uc3QgSW5pdF9IZWFkZXIgPSAoKSA9PiB7XHJcblx0XHR2YXIgY3VycmVudF91c2VyX2lkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5jdXJyZW50X3VzZXJfaWRcIik7XHJcblx0XHR2YXIgY29udGFjdEJ0bnNSZXNwb25zZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZWxhdGlvbl9idG4tLWNvbnRhY3QtbGlzdC1yZXNwb25zZScpO1xyXG4gICAgICAgIGNvbnRhY3RCdG5zUmVzcG9uc2UuZm9yRWFjaChjb250YWN0QnRuUmVzcG9uc2UgPT4ge1xyXG4gICAgICAgICAgICBjb250YWN0QnRuUmVzcG9uc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVsYXRpb24tdHlwZVwiKSk7XHJcbiAgICAgICAgICAgICAgICBtYWtlUmVsYXRpb25CdHcoY3VycmVudF91c2VyX2lkLmdldEF0dHJpYnV0ZShcImRhdGEtdS1pZFwiKSwgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVsYXRpb24taGltXCIpLCBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi10eXBlXCIpLCBlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5pdF9IZWFkZXI7XHJcbiJdLCJuYW1lcyI6WyJtYWtlUmVsYXRpb25CdHciLCJJbml0X0hlYWRlciIsImN1cnJlbnRfdXNlcl9pZCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNvbnRhY3RCdG5zUmVzcG9uc2UiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImNvbnRhY3RCdG5SZXNwb25zZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjb25zb2xlIiwibG9nIiwiY3VycmVudFRhcmdldCIsImdldEF0dHJpYnV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/components/header.js\n");

/***/ }),

/***/ "./src/js/components/map-functions.js":
/*!********************************************!*\
  !*** ./src/js/components/map-functions.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var leaflet_markercluster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! leaflet.markercluster */ \"./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js\");\n/* harmony import */ var leaflet_markercluster__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet_markercluster__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/index.js\");\n/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modal */ \"./src/js/components/modal.js\");\n/* harmony import */ var _functional_relations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functional/relations */ \"./src/js/functional/relations.js\");\n\n\n\n\n\nconst MapLaunch = data => {\n  class Map {\n    constructor(el) {\n      this.element = el;\n      this.map = data.querySelector(\"#map\");\n      this.popup = data.querySelector(\"#map-popup\");\n      this.fitBounds = this.element.getAttribute('data-fit-bounds');\n      this.page = this.element.getAttribute('data-page');\n      this.leaflet_map = null;\n      this.marker = null;\n      this.UserMarker = null;\n      this.markerCluster = [];\n      this.bounds = [];\n      this.clickListener = null;\n      this.tl = gsap__WEBPACK_IMPORTED_MODULE_4__[\"default\"].timeline({\n        defaults: {\n          duration: 0.4,\n          ease: 'power2.inOut'\n        }\n      });\n      this.ww = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      this.wh = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      this.headerH = document.querySelector(\".header\").clientHeight;\n      this.init();\n      if (this.popup) {\n        this.initPopup();\n      }\n      if (this.page === \"wall--map\") {\n        // this.follow_click();\n        this.right_slates = document.querySelector(\".right-slates\");\n        this.right_slates__items = this.right_slates.querySelectorAll(\".card\");\n      }\n    }\n\n    // follow_click = () => {\n    // }\n\n    init = () => {\n      // Create the map\n      this.buildingsData = this.element.getAttribute('data-buildings');\n      if (this.page === \"single-user\") {\n        // La carte prend une hauteur \"moyenne\" en prenant une portion de la hauteur de la fentre\n        this.map.style.height = this.wh * 0.6 + \"px\"; // 60% de la hauteur de la fentre\n      } else if (this.page === \"single-post\") {\n        // La carte prend un peu moins de place\n        this.map.style.height = this.wh / 2.5 - (this.headerH - 60) + \"px\"; // 40% de la fentre\n      } else if (this.page === \"wall--map\") {\n        // Si la carte est sur une page de type \"wall--map\", ajuster en fonction du layout\n        document.querySelector(\".left-map\").style.height = this.wh * 0.7 + \"px\"; // 70% de la hauteur de la fentre\n        this.map.style.height = this.wh * 0.7 + \"px\"; // 70% de la hauteur de la fentre\n      } else {\n        // Si aucune page spcifique, dfinir une taille par dfaut\n        this.map.style.height = this.wh * 0.5 + \"px\"; // Par dfaut, 50% de la fentre\n      }\n      this.buildings = [];\n      this.leaflet_map = leaflet__WEBPACK_IMPORTED_MODULE_0___default().map(this.map, {\n        center: [50.4629, 4.5817],\n        zoom: 9,\n        pixelRatio: 1,\n        maxZoom: 18,\n        minZoom: 6,\n        zoomControl: true\n      });\n      this.displayMap(this.buildingsData);\n    };\n    displayMap = buildingsData => {\n      // Create a map layer\n      leaflet__WEBPACK_IMPORTED_MODULE_0___default().tileLayer('https://api.mapbox.com/styles/v1/marcelpirnay01/clxbkdvdz026p01qx2whgeoiw/tiles/512/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFyY2VscGlybmF5MDEiLCJhIjoiY2tleWJwc2ZzMDh6ODJ4b2Nyb2V1NGt6bSJ9.AWwWSlKl8ectRbxP9fd6qg', {\n        attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n        tileSize: 512,\n        zoomOffset: -1\n      }).addTo(this.leaflet_map);\n\n      // Parse the data from the DOM\n      this.buildings = JSON.parse(buildingsData);\n\n      // Create a cluster group\n      this.markerCluster = leaflet__WEBPACK_IMPORTED_MODULE_0___default().markerClusterGroup({\n        showCoverageOnHover: false,\n        zoomToBoundsOnClick: true,\n        maxClusterRadius: 1,\n        spiderfyOnMaxZoom: 18,\n        removeOutsideVisibleBounds: true,\n        iconCreateFunction: function (cluster) {\n          return leaflet__WEBPACK_IMPORTED_MODULE_0___default().divIcon({\n            className: \"marker marker--cluster\",\n            iconSize: null,\n            iconAnchor: [20, 20],\n            html: \"<b>\" + cluster.getChildCount() + \"</b>\"\n          });\n        }\n      });\n\n      // For all entries found in the DOM, create a marker and add it to the map\n      this.buildings.forEach(building => {\n        if (building.lat !== null && building.lng !== null) {\n          this.addMarker(building);\n        }\n      });\n\n      // Add the cluster to the map\n      this.markerCluster.addTo(this.leaflet_map);\n\n      // Listen for an attribute change\n      this.mutation_observer = new MutationObserver(() => {\n        this.updateMap();\n      });\n      this.intersection_observer = new IntersectionObserver((entries, _observer) => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            this.leaflet_map.invalidateSize();\n            if (this.fitBounds) {\n              this.leaflet_map.fitBounds([this.bounds], {\n                padding: [100, 30]\n              });\n            }\n          }\n        });\n      });\n      let element = document.querySelector(\"#map-data\");\n      this.intersection_observer.observe(this.map);\n      this.mutation_observer.observe(element, {\n        attributes: true\n      });\n    };\n    addMarker = building => {\n      // Create custom marker\n      let markerColor;\n      switch (building.post_type_slug) {\n        case \"real-estate\":\n          markerColor = '#B50EA7 0%, #6F12B6 100%';\n          break;\n        case 'users':\n          markerColor = '#FFD603 0%, #a2810c 100%';\n          break;\n        default:\n          markerColor = '#6F12B6';\n      }\n      const markerHtmlStyles = `background: linear-gradient(45deg, ${markerColor});`;\n      let customMarkerIcon = leaflet__WEBPACK_IMPORTED_MODULE_0___default().divIcon({\n        className: \"marker\",\n        iconAnchor: [0, 15],\n        labelAnchor: [-6, 0],\n        popupAnchor: [0, -36],\n        html: `<span class=\"marker-wrap\" style=\"${markerHtmlStyles}\" />`\n      });\n\n      // Prepare the data\n      let markerData = {\n        id: building.id\n        // todo_augustin map\n        // title: building.title,\n        // permalink: building.permalink,\n        // post_type_slug: building.post_type_slug,\n        // price: building.price,\n        // bathrooms: building.bathrooms,\n        // bedrooms: building.bedrooms,\n        // home_size: building.home_size,\n        // outdoor_size: building.outdoor_size,\n        // location: building.location,\n        // permalink: building.permalink,\n        // img: building.img,\n        // card_gallery: building.card_gallery,\n      };\n\n      // Set a new marker\n      this.marker = new (leaflet__WEBPACK_IMPORTED_MODULE_0___default().marker)([building.lat, building.lng], {\n        icon: customMarkerIcon\n      });\n\n      // Assign the data set to the marker\n      this.marker.markerData = markerData;\n\n      // If there's more than 1 building, create clusters, or else, just add the marker\n      if (this.buildings.length < 2) {\n        this.marker.addTo(this.leaflet_map);\n      } else {\n        // Add the markers to the layer\n        this.markerCluster.addLayer(this.marker);\n\n        // Add the layer to the map\n        this.leaflet_map.addLayer(this.markerCluster);\n      }\n      // Create an array with all markers' data\n      let clusterBounds = [];\n      clusterBounds.push(building.lat, building.lng);\n      this.bounds.push(clusterBounds);\n      if (this.fitBounds) {\n        this.leaflet_map.fitBounds([this.bounds], {\n          padding: [100, 30]\n        });\n      }\n\n      // On the click, call the next function\n      this.marker.on(\"click\", this.markerClick);\n    };\n    markerClick = event => {\n      // On the click, move the map to the marker clicked\n      this.leaflet_map.flyTo([event.latlng.lat, event.latlng.lng]);\n\n      // Get all markers on the map\n      let allMarkers = data.querySelectorAll(\".marker\");\n\n      // For each marker, remove the class\n      allMarkers.forEach(marker => {\n        marker.classList.remove(\"marker--selected\");\n      });\n\n      // On the marker clicked, add the class\n      event.target._icon.classList.add(\"marker--selected\");\n      if (this.page === \"wall--map\") {\n        var slates = this.right_slates.querySelectorAll(\".card\");\n        var related_slate = document.querySelector(\"#slate-\" + event.target.markerData.id);\n        const y = related_slate.getBoundingClientRect().top + window.scrollY;\n        slates.forEach(slate => {\n          if (slate.classList.contains(\"highlight\")) {\n            slate.classList.remove(\"highlight\");\n          }\n        });\n        related_slate.classList.add(\"highlight\");\n        window.scroll({\n          top: y - 200,\n          behavior: 'smooth'\n        });\n      }\n\n      // If a hidden popup exists, show it\n      if (this.popup) {\n        this.changePopupContent(event);\n        this.displayPopup();\n      }\n    };\n    initPopup = () => {\n      // Initially hide the popup\n      this.tl.set(this.popup, {\n        autoAlpha: 0,\n        opacity: 0,\n        y: 100\n      });\n    };\n    changePopupContent = event => {\n      this.closePopup(null);\n\n      // TODO : Retirer timeout si la carte est off\n      setTimeout(async () => {\n        // TODO todo_augustin : gerer l'appel  l'api  avec post_id = event.target.markerData.id\n\n        const response = await fetch(`/wp-json/custom/v1/post-details?post_id=${event.target.markerData.id}`);\n        if (!response.ok) {\n          throw new Error(\"Erreur lors de la rcupration des dtails du post\");\n        }\n        // Get all the fields\n        let link = this.popup.querySelector(\".map-slate--link\");\n        let title = this.popup.querySelector(\".title\");\n        // let price = this.popup.querySelector(\".post-details__price .value\");\n        let address = this.popup.querySelector(\".post-location\");\n        let bedroom = this.popup.querySelector(\".post-details__bedroom .value\");\n        let bathroom = this.popup.querySelector(\".post-details__bathroom .value\");\n        let house = this.popup.querySelector(\".post-details__house .value\");\n        let land = this.popup.querySelector(\".post-details__land .value\");\n        let image = this.popup.querySelector(\"img\");\n        // Change the values of the fields\n        // linkTag.href = event.target.markerData.permalink;\n\n        // json todo_augustin api map\n        const postData = await response.json();\n        this.popup.classList.remove(\"users\");\n        this.popup.classList.remove(\"real-estate\");\n        this.popup.classList.add(postData.post_type_slug);\n\n        // todo_augustin map swipper\n\n        //  console.log(postData);\n\n        let images = postData.card_gallery_images;\n        const imageContainer = this.popup.querySelector('.map-slate__image');\n\n        // ---------\n        const shareBu = this.popup.querySelector('.shareButon');\n        const favoriteButon = this.popup.querySelector('.favoriteButon');\n        shareBu.innerHTML = postData.templates.bouton_share_template;\n        favoriteButon.innerHTML = postData.templates.like_favorite_template;\n        (0,_modal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(shareBu);\n        var relationBtns = this.popup.querySelectorAll(\".relation_btn\");\n        if (relationBtns) {\n          relationBtns.forEach(relationBtn => {\n            relationBtn.addEventListener(\"click\", e => {\n              e.preventDefault();\n              e.stopPropagation();\n              // makeRelationBtw(this.current_user_id.getAttribute(\"data-u-id\"), this.el.getAttribute(\"data-h-id\"), this.el.getAttribute(\"data-post-type\"), e.currentTarget);\n\n              (0,_functional_relations__WEBPACK_IMPORTED_MODULE_3__.makeRelationBtw)(postData.user_id, postData.id, postData.post_type_slug, e.currentTarget);\n            });\n          });\n        }\n        if (!images || images.length === 0) {\n          // Si imgs est vide ou null, insrer une image unique\n          const singleImage = document.createElement('img');\n          singleImage.src = image;\n          singleImage.alt = \"Image unique\";\n          singleImage.classList.add('single-image');\n          imageContainer.appendChild(singleImage);\n        } else {\n          // Si imgs contient des images, insrer un carrousel\n          imageContainer.innerHTML = `\n            <div class=\"swiper-container\">\n\n                <div class=\"swiper-wrapper\">\n                    ${images.map(src => `<div class=\"swiper-slide\"><img src=\"${src}\" alt=\"Image de carrousel\"></div>`).join('')}\n\n\t\t\t\t</div>\n\t\t\t\t\t\t<!-- Ajout des boutons de navigation -->\n               <div class=\"swiper-button-next\"></div>\n\t\t\t\t\t<div class=\"swiper-button-prev\"></div>\n\t\t\t\t\t<!-- Ajout de la pagination -->\n\t\t\t\t\t<div class=\"swiper-pagination\"></div>\n\t\t\t\t</div>\n\n\n\n            </div>\n        `;\n        }\n        //end\n\n        // Initialiser Swiper\n        const swiper = new Swiper('.swiper-container', {\n          loop: true,\n          // Boucle infinie\n          pagination: {\n            el: '.swiper-pagination',\n            clickable: true\n          },\n          navigation: {\n            nextEl: '.swiper-button-next',\n            prevEl: '.swiper-button-prev'\n          }\n        });\n\n        // todo_augustin remplissage map info\n        link.href = postData.post_permalink; //event.target.markerData.permalink;\n        //image.src = ;//event.target.markerData.img;\n        title.innerHTML = postData.title; //event.target.markerData.title;\n        // price.innerHTML = ;//event.target.markerData.price;\n        address.innerHTML = postData.price; //event.target.markerData.price;\n        bedroom.innerHTML = postData.bedrooms; //event.target.markerData.bedrooms;\n        bathroom.innerHTML = postData.bathrooms; //event.target.markerData.bathrooms;\n        house.innerHTML = postData.home_size; //event.target.markerData.home_size;\n        land.innerHTML = postData.outdoor_size; //event.target.markerData.outdoor_size;\n      }, 400);\n      this.displayPopup();\n    };\n    displayPopup = () => {\n      // Display the popup\n      this.tl.to(this.popup, {\n        autoAlpha: 1,\n        opacity: 1,\n        y: 0\n      });\n      // data.querySelector(\"#card-icon\").addEventListener(\"click\", this.closePopup);\n    };\n    closePopup = event => {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      // Hide the popup\n      this.tl.to(this.popup, {\n        autoAlpha: 0,\n        opacity: 0,\n        y: 60\n      });\n    };\n    updateMap() {\n      this.leaflet_map.off();\n      this.leaflet_map.remove();\n      this.init();\n    }\n  }\n\n  // Get the DOM element\n  const maps = data.querySelectorAll(\"#map-data\");\n\n  // Check if the DOM element exists\n  if (maps.length) {\n    // If yes, call a new instance of the map\n    [...maps].map(map => new Map(map));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapLaunch);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUdrSixJQUFJLENBQUN0RixNQUFNLEVBQUU7SUFDZjtJQUNBLENBQUMsR0FBR3NGLElBQUksQ0FBQyxDQUFDbEwsR0FBRyxDQUFFQSxHQUFHLElBQUssSUFBSUosR0FBRyxDQUFDSSxHQUFHLENBQUMsQ0FBQztFQUNyQztBQUNELENBQUM7QUFFRCxpRUFBZU4sU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL21hcC1mdW5jdGlvbnMuanM/NjJiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTCBmcm9tIFwibGVhZmxldFwiO1xyXG5pbXBvcnQgXCJsZWFmbGV0Lm1hcmtlcmNsdXN0ZXJcIjtcclxuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcclxuaW1wb3J0IE1vZGFsc19Jbml0IGZyb20gXCIuL21vZGFsXCI7XHJcbmltcG9ydCB7bWFrZVJlbGF0aW9uQnR3fSBmcm9tIFwiLi4vZnVuY3Rpb25hbC9yZWxhdGlvbnNcIjtcclxuXHJcbmNvbnN0IE1hcExhdW5jaCA9IChkYXRhKSA9PiB7XHJcblx0Y2xhc3MgTWFwIHtcclxuXHRcdGNvbnN0cnVjdG9yKGVsKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudCA9IGVsO1xyXG5cdFx0XHR0aGlzLm1hcCA9IGRhdGEucXVlcnlTZWxlY3RvcihcIiNtYXBcIik7XHJcblx0XHRcdHRoaXMucG9wdXAgPSBkYXRhLnF1ZXJ5U2VsZWN0b3IoXCIjbWFwLXBvcHVwXCIpO1xyXG5cdFx0XHR0aGlzLmZpdEJvdW5kcyA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZml0LWJvdW5kcycpO1xyXG5cdFx0XHR0aGlzLnBhZ2UgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UnKTtcclxuXHRcdFx0dGhpcy5sZWFmbGV0X21hcCA9IG51bGw7XHJcblx0XHRcdHRoaXMubWFya2VyID0gbnVsbDtcclxuXHRcdFx0dGhpcy5Vc2VyTWFya2VyID0gbnVsbDtcclxuXHRcdFx0dGhpcy5tYXJrZXJDbHVzdGVyID0gW107XHJcblx0XHRcdHRoaXMuYm91bmRzID0gW107XHJcblx0XHRcdHRoaXMuY2xpY2tMaXN0ZW5lciA9IG51bGw7XHJcblx0XHRcdHRoaXMudGwgPSBnc2FwLnRpbWVsaW5lKHtcclxuXHRcdFx0XHRkZWZhdWx0czoge1xyXG5cdFx0XHRcdFx0ZHVyYXRpb246IDAuNCxcclxuXHRcdFx0XHRcdGVhc2U6ICdwb3dlcjIuaW5PdXQnLFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy53dyA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xyXG5cdFx0XHR0aGlzLndoID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XHJcblx0XHRcdHRoaXMuaGVhZGVySCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuaGVhZGVyXCIpLmNsaWVudEhlaWdodDtcclxuXHJcblx0XHRcdHRoaXMuaW5pdCgpO1xyXG5cclxuXHRcdFx0aWYodGhpcy5wb3B1cCkge1xyXG5cdFx0XHRcdHRoaXMuaW5pdFBvcHVwKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHRoaXMucGFnZSA9PT0gXCJ3YWxsLS1tYXBcIil7XHJcblx0XHRcdFx0Ly8gdGhpcy5mb2xsb3dfY2xpY2soKTtcclxuXHRcdFx0XHR0aGlzLnJpZ2h0X3NsYXRlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucmlnaHQtc2xhdGVzXCIpO1xyXG5cdFx0XHRcdHRoaXMucmlnaHRfc2xhdGVzX19pdGVtcyA9IHRoaXMucmlnaHRfc2xhdGVzLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2FyZFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvbGxvd19jbGljayA9ICgpID0+IHtcclxuXHRcdC8vIH1cclxuXHJcblxyXG5cdFx0aW5pdCA9ICgpID0+IHtcclxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5idWlsZGluZ3NEYXRhID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1idWlsZGluZ3MnKTtcclxuXHJcbiAgICAgIGlmKHRoaXMucGFnZSA9PT0gXCJzaW5nbGUtdXNlclwiKXtcclxuICAgICAgICAvLyBMYSBjYXJ0ZSBwcmVuZCB1bmUgaGF1dGV1ciBcIm1veWVubmVcIiBlbiBwcmVuYW50IHVuZSBwb3J0aW9uIGRlIGxhIGhhdXRldXIgZGUgbGEgZmVuw6p0cmVcclxuICAgICAgICB0aGlzLm1hcC5zdHlsZS5oZWlnaHQgPSAodGhpcy53aCAqIDAuNikgKyBcInB4XCI7IC8vIDYwJSBkZSBsYSBoYXV0ZXVyIGRlIGxhIGZlbsOqdHJlXHJcbiAgICAgIH1lbHNlIGlmKHRoaXMucGFnZSA9PT0gXCJzaW5nbGUtcG9zdFwiKXtcclxuICAgICAgICAvLyBMYSBjYXJ0ZSBwcmVuZCB1biBwZXUgbW9pbnMgZGUgcGxhY2VcclxuICAgICAgICB0aGlzLm1hcC5zdHlsZS5oZWlnaHQgPSAoKHRoaXMud2ggLyAyLjUpIC0gKHRoaXMuaGVhZGVySCAtIDYwKSkgKyBcInB4XCI7IC8vIDQwJSBkZSBsYSBmZW7DqnRyZVxyXG4gICAgICB9ZWxzZSBpZih0aGlzLnBhZ2UgPT09IFwid2FsbC0tbWFwXCIpe1xyXG4gICAgICAgIC8vIFNpIGxhIGNhcnRlIGVzdCBzdXIgdW5lIHBhZ2UgZGUgdHlwZSBcIndhbGwtLW1hcFwiLCBhanVzdGVyIGVuIGZvbmN0aW9uIGR1IGxheW91dFxyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubGVmdC1tYXBcIikuc3R5bGUuaGVpZ2h0ID0gKHRoaXMud2ggKiAwLjcpICsgXCJweFwiOyAvLyA3MCUgZGUgbGEgaGF1dGV1ciBkZSBsYSBmZW7DqnRyZVxyXG4gICAgICAgIHRoaXMubWFwLnN0eWxlLmhlaWdodCA9ICh0aGlzLndoICogMC43KSArIFwicHhcIjsgLy8gNzAlIGRlIGxhIGhhdXRldXIgZGUgbGEgZmVuw6p0cmVcclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgLy8gU2kgYXVjdW5lIHBhZ2Ugc3DDqWNpZmlxdWUsIGTDqWZpbmlyIHVuZSB0YWlsbGUgcGFyIGTDqWZhdXRcclxuICAgICAgICB0aGlzLm1hcC5zdHlsZS5oZWlnaHQgPSAodGhpcy53aCAqIDAuNSkgKyBcInB4XCI7IC8vIFBhciBkw6lmYXV0LCA1MCUgZGUgbGEgZmVuw6p0cmVcclxuICAgICAgfVxyXG5cclxuXHRcdFx0dGhpcy5idWlsZGluZ3MgPSBbXTtcclxuXHJcblx0XHRcdHRoaXMubGVhZmxldF9tYXAgPSBMLm1hcCh0aGlzLm1hcCwge1xyXG5cdFx0XHRcdGNlbnRlcjogWzUwLjQ2MjksIDQuNTgxN10sXHJcblx0XHRcdFx0em9vbTogOSxcclxuXHRcdFx0XHRwaXhlbFJhdGlvOiAxLFxyXG5cdFx0XHRcdG1heFpvb206IDE4LFxyXG5cdFx0XHRcdG1pblpvb206IDYsXHJcblx0XHRcdFx0em9vbUNvbnRyb2w6IHRydWUsXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy5kaXNwbGF5TWFwKHRoaXMuYnVpbGRpbmdzRGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGlzcGxheU1hcCA9IChidWlsZGluZ3NEYXRhKSA9PiB7XHJcblx0XHRcdC8vIENyZWF0ZSBhIG1hcCBsYXllclxyXG5cdFx0XHRMLnRpbGVMYXllcignaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zdHlsZXMvdjEvbWFyY2VscGlybmF5MDEvY2x4YmtkdmR6MDI2cDAxcXgyd2hnZW9pdy90aWxlcy81MTIve3p9L3t4fS97eX0/YWNjZXNzX3Rva2VuPXBrLmV5SjFJam9pYldGeVkyVnNjR2x5Ym1GNU1ERWlMQ0poSWpvaVkydGxlV0p3YzJaek1EaDZPREo0YjJOeWIyVjFOR3Q2YlNKOS5BV3dXU2xLbDhlY3RSYnhQOWZkNnFnJywge1xyXG5cdFx0XHRcdGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnLFxyXG5cdFx0XHRcdHRpbGVTaXplOiA1MTIsXHJcblx0XHRcdFx0em9vbU9mZnNldDogLTEsXHJcblx0XHRcdH0pLmFkZFRvKHRoaXMubGVhZmxldF9tYXApO1xyXG5cclxuXHRcdFx0Ly8gUGFyc2UgdGhlIGRhdGEgZnJvbSB0aGUgRE9NXHJcblx0XHRcdHRoaXMuYnVpbGRpbmdzID0gSlNPTi5wYXJzZShidWlsZGluZ3NEYXRhKTtcclxuXHJcblx0XHRcdC8vIENyZWF0ZSBhIGNsdXN0ZXIgZ3JvdXBcclxuXHRcdFx0dGhpcy5tYXJrZXJDbHVzdGVyID0gTC5tYXJrZXJDbHVzdGVyR3JvdXAoe1xyXG5cdFx0XHRcdHNob3dDb3ZlcmFnZU9uSG92ZXI6IGZhbHNlLFxyXG5cdFx0XHRcdHpvb21Ub0JvdW5kc09uQ2xpY2s6IHRydWUsXHJcblx0XHRcdFx0bWF4Q2x1c3RlclJhZGl1czogMSxcclxuXHRcdFx0XHRzcGlkZXJmeU9uTWF4Wm9vbTogMTgsXHJcblx0XHRcdFx0cmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHM6IHRydWUsXHJcblx0XHRcdFx0aWNvbkNyZWF0ZUZ1bmN0aW9uOiBmdW5jdGlvbihjbHVzdGVyKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gTC5kaXZJY29uKHtcclxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lOiBcIm1hcmtlciBtYXJrZXItLWNsdXN0ZXJcIixcclxuXHRcdFx0XHRcdFx0aWNvblNpemU6IG51bGwsXHJcblx0XHRcdFx0XHRcdGljb25BbmNob3I6IFsyMCwgMjBdLFxyXG5cdFx0XHRcdFx0XHRodG1sOiBcIjxiPlwiICsgY2x1c3Rlci5nZXRDaGlsZENvdW50KCkgKyBcIjwvYj5cIlxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIEZvciBhbGwgZW50cmllcyBmb3VuZCBpbiB0aGUgRE9NLCBjcmVhdGUgYSBtYXJrZXIgYW5kIGFkZCBpdCB0byB0aGUgbWFwXHJcblx0XHRcdHRoaXMuYnVpbGRpbmdzLmZvckVhY2goYnVpbGRpbmcgPT4ge1xyXG5cdFx0XHRcdGlmKGJ1aWxkaW5nLmxhdCAhPT0gbnVsbCAmJiBidWlsZGluZy5sbmcgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkTWFya2VyKGJ1aWxkaW5nKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHJcblx0XHRcdC8vIEFkZCB0aGUgY2x1c3RlciB0byB0aGUgbWFwXHJcblx0XHRcdHRoaXMubWFya2VyQ2x1c3Rlci5hZGRUbyh0aGlzLmxlYWZsZXRfbWFwKTtcclxuXHJcblx0XHRcdC8vIExpc3RlbiBmb3IgYW4gYXR0cmlidXRlIGNoYW5nZVxyXG5cdFx0XHR0aGlzLm11dGF0aW9uX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlTWFwKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy5pbnRlcnNlY3Rpb25fb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMsIF9vYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XHJcblx0XHRcdFx0XHRpZihlbnRyeS5pc0ludGVyc2VjdGluZykge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmxlYWZsZXRfbWFwLmludmFsaWRhdGVTaXplKCk7XHJcblx0XHRcdFx0XHRcdGlmKHRoaXMuZml0Qm91bmRzKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5sZWFmbGV0X21hcC5maXRCb3VuZHMoW3RoaXMuYm91bmRzXSwge3BhZGRpbmc6IFsxMDAsIDMwXX0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0bGV0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21hcC1kYXRhXCIpO1xyXG5cdFx0XHR0aGlzLmludGVyc2VjdGlvbl9vYnNlcnZlci5vYnNlcnZlKHRoaXMubWFwKTtcclxuXHRcdFx0dGhpcy5tdXRhdGlvbl9vYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcclxuXHRcdFx0XHRhdHRyaWJ1dGVzOiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFkZE1hcmtlciA9IChidWlsZGluZykgPT4ge1xyXG5cdFx0XHQvLyBDcmVhdGUgY3VzdG9tIG1hcmtlclxyXG5cdFx0XHRsZXQgbWFya2VyQ29sb3I7XHJcblx0XHRcdHN3aXRjaCAoYnVpbGRpbmcucG9zdF90eXBlX3NsdWcpIHtcclxuXHRcdFx0XHRjYXNlIFwicmVhbC1lc3RhdGVcIjpcclxuXHRcdFx0XHRcdG1hcmtlckNvbG9yID0gJyNCNTBFQTcgMCUsICM2RjEyQjYgMTAwJSc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlICd1c2Vycyc6XHJcblx0XHRcdFx0XHRtYXJrZXJDb2xvciA9ICcjRkZENjAzIDAlLCAjYTI4MTBjIDEwMCUnO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdG1hcmtlckNvbG9yID0gJyM2RjEyQjYnO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBtYXJrZXJIdG1sU3R5bGVzID0gYGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg0NWRlZywgJHttYXJrZXJDb2xvcn0pO2BcclxuXHJcblx0XHRcdGxldCBjdXN0b21NYXJrZXJJY29uID0gTC5kaXZJY29uKHtcclxuXHRcdFx0XHRjbGFzc05hbWU6IFwibWFya2VyXCIsXHJcblx0XHRcdFx0aWNvbkFuY2hvcjogWzAsIDE1XSxcclxuXHRcdFx0XHRsYWJlbEFuY2hvcjogWy02LCAwXSxcclxuXHRcdFx0XHRwb3B1cEFuY2hvcjogWzAsIC0zNl0sXHJcblx0XHRcdFx0aHRtbDogYDxzcGFuIGNsYXNzPVwibWFya2VyLXdyYXBcIiBzdHlsZT1cIiR7bWFya2VySHRtbFN0eWxlc31cIiAvPmBcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyBQcmVwYXJlIHRoZSBkYXRhXHJcblx0XHRcdGxldCBtYXJrZXJEYXRhID0ge1xyXG5cdFx0XHRcdGlkOiBidWlsZGluZy5pZCxcclxuIC8vIHRvZG9fYXVndXN0aW4gbWFwXHJcblx0XHRcdFx0Ly8gdGl0bGU6IGJ1aWxkaW5nLnRpdGxlLFxyXG5cdFx0XHRcdC8vIHBlcm1hbGluazogYnVpbGRpbmcucGVybWFsaW5rLFxyXG5cdFx0XHRcdC8vIHBvc3RfdHlwZV9zbHVnOiBidWlsZGluZy5wb3N0X3R5cGVfc2x1ZyxcclxuXHRcdFx0XHQvLyBwcmljZTogYnVpbGRpbmcucHJpY2UsXHJcblx0XHRcdFx0Ly8gYmF0aHJvb21zOiBidWlsZGluZy5iYXRocm9vbXMsXHJcblx0XHRcdFx0Ly8gYmVkcm9vbXM6IGJ1aWxkaW5nLmJlZHJvb21zLFxyXG5cdFx0XHRcdC8vIGhvbWVfc2l6ZTogYnVpbGRpbmcuaG9tZV9zaXplLFxyXG5cdFx0XHRcdC8vIG91dGRvb3Jfc2l6ZTogYnVpbGRpbmcub3V0ZG9vcl9zaXplLFxyXG5cdFx0XHRcdC8vIGxvY2F0aW9uOiBidWlsZGluZy5sb2NhdGlvbixcclxuXHRcdFx0XHQvLyBwZXJtYWxpbms6IGJ1aWxkaW5nLnBlcm1hbGluayxcclxuXHRcdFx0XHQvLyBpbWc6IGJ1aWxkaW5nLmltZyxcclxuXHRcdFx0XHQvLyBjYXJkX2dhbGxlcnk6IGJ1aWxkaW5nLmNhcmRfZ2FsbGVyeSxcclxuXHRcdFx0fTtcclxuXHJcblxyXG5cdFx0XHQvLyBTZXQgYSBuZXcgbWFya2VyXHJcblx0XHRcdHRoaXMubWFya2VyID0gbmV3IEwubWFya2VyKFtidWlsZGluZy5sYXQsIGJ1aWxkaW5nLmxuZ10sIHtcclxuXHRcdFx0XHRpY29uOiBjdXN0b21NYXJrZXJJY29uXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gQXNzaWduIHRoZSBkYXRhIHNldCB0byB0aGUgbWFya2VyXHJcblx0XHRcdHRoaXMubWFya2VyLm1hcmtlckRhdGEgPSBtYXJrZXJEYXRhO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRoYW4gMSBidWlsZGluZywgY3JlYXRlIGNsdXN0ZXJzLCBvciBlbHNlLCBqdXN0IGFkZCB0aGUgbWFya2VyXHJcblx0XHRcdGlmKHRoaXMuYnVpbGRpbmdzLmxlbmd0aCA8IDIpIHtcclxuXHRcdFx0XHR0aGlzLm1hcmtlci5hZGRUbyh0aGlzLmxlYWZsZXRfbWFwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBBZGQgdGhlIG1hcmtlcnMgdG8gdGhlIGxheWVyXHJcblx0XHRcdFx0dGhpcy5tYXJrZXJDbHVzdGVyLmFkZExheWVyKHRoaXMubWFya2VyKTtcclxuXHJcblx0XHRcdFx0Ly8gQWRkIHRoZSBsYXllciB0byB0aGUgbWFwXHJcblx0XHRcdFx0dGhpcy5sZWFmbGV0X21hcC5hZGRMYXllcih0aGlzLm1hcmtlckNsdXN0ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIENyZWF0ZSBhbiBhcnJheSB3aXRoIGFsbCBtYXJrZXJzJyBkYXRhXHJcblx0XHRcdGxldCBjbHVzdGVyQm91bmRzID0gW107XHJcblx0XHRcdGNsdXN0ZXJCb3VuZHMucHVzaChidWlsZGluZy5sYXQsIGJ1aWxkaW5nLmxuZyk7XHJcblx0XHRcdHRoaXMuYm91bmRzLnB1c2goY2x1c3RlckJvdW5kcyk7XHJcblxyXG5cdFx0XHRpZih0aGlzLmZpdEJvdW5kcykge1xyXG5cdFx0XHRcdHRoaXMubGVhZmxldF9tYXAuZml0Qm91bmRzKFt0aGlzLmJvdW5kc10sIHtwYWRkaW5nOiBbMTAwLCAzMF19KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gT24gdGhlIGNsaWNrLCBjYWxsIHRoZSBuZXh0IGZ1bmN0aW9uXHJcblx0XHRcdHRoaXMubWFya2VyLm9uKFwiY2xpY2tcIiwgdGhpcy5tYXJrZXJDbGljayk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWFya2VyQ2xpY2sgPSAoZXZlbnQpID0+IHtcclxuXHRcdFx0Ly8gT24gdGhlIGNsaWNrLCBtb3ZlIHRoZSBtYXAgdG8gdGhlIG1hcmtlciBjbGlja2VkXHJcblx0XHRcdHRoaXMubGVhZmxldF9tYXAuZmx5VG8oW2V2ZW50LmxhdGxuZy5sYXQsIGV2ZW50LmxhdGxuZy5sbmddKTtcclxuXHJcblx0XHRcdC8vIEdldCBhbGwgbWFya2VycyBvbiB0aGUgbWFwXHJcblx0XHRcdGxldCBhbGxNYXJrZXJzID0gZGF0YS5xdWVyeVNlbGVjdG9yQWxsKFwiLm1hcmtlclwiKTtcclxuXHJcblx0XHRcdC8vIEZvciBlYWNoIG1hcmtlciwgcmVtb3ZlIHRoZSBjbGFzc1xyXG5cdFx0XHRhbGxNYXJrZXJzLmZvckVhY2gobWFya2VyID0+IHtcclxuXHRcdFx0XHRtYXJrZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcmtlci0tc2VsZWN0ZWRcIik7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gT24gdGhlIG1hcmtlciBjbGlja2VkLCBhZGQgdGhlIGNsYXNzXHJcblx0XHRcdGV2ZW50LnRhcmdldC5faWNvbi5jbGFzc0xpc3QuYWRkKFwibWFya2VyLS1zZWxlY3RlZFwiKTtcclxuXHJcblx0XHRcdGlmKHRoaXMucGFnZSA9PT0gXCJ3YWxsLS1tYXBcIil7XHJcblx0XHRcdFx0dmFyIHNsYXRlcyA9IHRoaXMucmlnaHRfc2xhdGVzLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2FyZFwiKTtcclxuXHRcdFx0XHR2YXIgcmVsYXRlZF9zbGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2xhdGUtXCIgKyBldmVudC50YXJnZXQubWFya2VyRGF0YS5pZCk7XHJcblx0XHRcdFx0Y29uc3QgeSA9IHJlbGF0ZWRfc2xhdGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgd2luZG93LnNjcm9sbFk7XHJcblx0XHRcdFx0c2xhdGVzLmZvckVhY2goc2xhdGUgPT4ge1xyXG5cdFx0XHRcdFx0aWYoc2xhdGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlnaGxpZ2h0XCIpKXtcclxuXHRcdFx0XHRcdFx0c2xhdGUuY2xhc3NMaXN0LnJlbW92ZShcImhpZ2hsaWdodFwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZWxhdGVkX3NsYXRlLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRcIik7XHJcblx0XHRcdFx0d2luZG93LnNjcm9sbCh7XHJcblx0XHRcdFx0XHR0b3A6IHkgLSAyMDAsXHJcblx0XHRcdFx0XHRiZWhhdmlvcjogJ3Ntb290aCdcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgYSBoaWRkZW4gcG9wdXAgZXhpc3RzLCBzaG93IGl0XHJcblx0XHRcdGlmKHRoaXMucG9wdXApIHtcclxuXHRcdFx0XHR0aGlzLmNoYW5nZVBvcHVwQ29udGVudChldmVudClcclxuXHRcdFx0XHR0aGlzLmRpc3BsYXlQb3B1cCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aW5pdFBvcHVwID0gKCkgPT4ge1xyXG5cdFx0XHQvLyBJbml0aWFsbHkgaGlkZSB0aGUgcG9wdXBcclxuXHRcdFx0dGhpcy50bC5zZXQodGhpcy5wb3B1cCwge1xyXG5cdFx0XHRcdGF1dG9BbHBoYTogMCxcclxuXHRcdFx0XHRvcGFjaXR5OiAwLFxyXG5cdFx0XHRcdHk6IDEwMFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRjaGFuZ2VQb3B1cENvbnRlbnQgPSAoZXZlbnQpID0+IHtcclxuXHRcdFx0dGhpcy5jbG9zZVBvcHVwKG51bGwpO1xyXG5cclxuXHRcdFx0Ly8gVE9ETyA6IFJldGlyZXIgdGltZW91dCBzaSBsYSBjYXJ0ZSBlc3Qgb2ZmXHJcblx0XHRcdHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgLy8gVE9ETyB0b2RvX2F1Z3VzdGluIDogZ2VyZXIgbCdhcHBlbCDDoCBsJ2FwaSAgYXZlYyBwb3N0X2lkID0gZXZlbnQudGFyZ2V0Lm1hcmtlckRhdGEuaWRcclxuXHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvd3AtanNvbi9jdXN0b20vdjEvcG9zdC1kZXRhaWxzP3Bvc3RfaWQ9JHtldmVudC50YXJnZXQubWFya2VyRGF0YS5pZH1gKTtcclxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyZXVyIGxvcnMgZGUgbGEgcsOpY3Vww6lyYXRpb24gZGVzIGTDqXRhaWxzIGR1IHBvc3RcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgZmllbGRzXHJcbiAgICAgICAgbGV0IGxpbmsgPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCIubWFwLXNsYXRlLS1saW5rXCIpO1xyXG4gICAgICAgIGxldCB0aXRsZSA9IHRoaXMucG9wdXAucXVlcnlTZWxlY3RvcihcIi50aXRsZVwiKTtcclxuICAgICAgICAvLyBsZXQgcHJpY2UgPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCIucG9zdC1kZXRhaWxzX19wcmljZSAudmFsdWVcIik7XHJcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCIucG9zdC1sb2NhdGlvblwiKTtcclxuICAgICAgICBsZXQgYmVkcm9vbSA9IHRoaXMucG9wdXAucXVlcnlTZWxlY3RvcihcIi5wb3N0LWRldGFpbHNfX2JlZHJvb20gLnZhbHVlXCIpO1xyXG4gICAgICAgIGxldCBiYXRocm9vbSA9IHRoaXMucG9wdXAucXVlcnlTZWxlY3RvcihcIi5wb3N0LWRldGFpbHNfX2JhdGhyb29tIC52YWx1ZVwiKTtcclxuICAgICAgICBsZXQgaG91c2UgPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCIucG9zdC1kZXRhaWxzX19ob3VzZSAudmFsdWVcIik7XHJcbiAgICAgICAgbGV0IGxhbmQgPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCIucG9zdC1kZXRhaWxzX19sYW5kIC52YWx1ZVwiKTtcclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIik7XHJcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSB2YWx1ZXMgb2YgdGhlIGZpZWxkc1xyXG4gICAgICAgIC8vIGxpbmtUYWcuaHJlZiA9IGV2ZW50LnRhcmdldC5tYXJrZXJEYXRhLnBlcm1hbGluaztcclxuXHJcbiAgICAgICAgLy8ganNvbiB0b2RvX2F1Z3VzdGluIGFwaSBtYXBcclxuICAgICAgICBjb25zdCBwb3N0RGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3B1cC5jbGFzc0xpc3QucmVtb3ZlKFwidXNlcnNcIik7XHJcbiAgICAgICAgdGhpcy5wb3B1cC5jbGFzc0xpc3QucmVtb3ZlKFwicmVhbC1lc3RhdGVcIik7XHJcbiAgICAgICAgdGhpcy5wb3B1cC5jbGFzc0xpc3QuYWRkKHBvc3REYXRhLnBvc3RfdHlwZV9zbHVnKTtcclxuXHJcbiAgICAgICAgLy8gdG9kb19hdWd1c3RpbiBtYXAgc3dpcHBlclxyXG5cclxuICAgICAgICAvLyAgY29uc29sZS5sb2cocG9zdERhdGEpO1xyXG5cclxuICAgICAgICBsZXQgaW1hZ2VzID0gIHBvc3REYXRhLmNhcmRfZ2FsbGVyeV9pbWFnZXM7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VDb250YWluZXIgPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoJy5tYXAtc2xhdGVfX2ltYWdlJyk7XHJcblxyXG4gICAgICAgIC8vIC0tLS0tLS0tLVxyXG4gICAgICAgICAgY29uc3Qgc2hhcmVCdSA9IHRoaXMucG9wdXAucXVlcnlTZWxlY3RvcignLnNoYXJlQnV0b24nKTtcclxuICAgICAgICAgIGNvbnN0IGZhdm9yaXRlQnV0b24gPSB0aGlzLnBvcHVwLnF1ZXJ5U2VsZWN0b3IoJy5mYXZvcml0ZUJ1dG9uJyk7XHJcbiAgICAgICAgICBzaGFyZUJ1LmlubmVySFRNTCA9IHBvc3REYXRhLnRlbXBsYXRlcy5ib3V0b25fc2hhcmVfdGVtcGxhdGU7XHJcblxyXG4gICAgICAgICAgZmF2b3JpdGVCdXRvbi5pbm5lckhUTUwgPSBwb3N0RGF0YS50ZW1wbGF0ZXMubGlrZV9mYXZvcml0ZV90ZW1wbGF0ZTtcclxuXHJcbiAgICAgICAgICBNb2RhbHNfSW5pdChzaGFyZUJ1KTtcclxuXHJcbiAgICAgICAgICB2YXIgcmVsYXRpb25CdG5zID0gdGhpcy5wb3B1cC5xdWVyeVNlbGVjdG9yQWxsKFwiLnJlbGF0aW9uX2J0blwiKTtcclxuICAgICAgICAgIGlmKHJlbGF0aW9uQnRucyl7XHJcbiAgICAgICAgICAgIHJlbGF0aW9uQnRucy5mb3JFYWNoKHJlbGF0aW9uQnRuID0+IHtcclxuICAgICAgICAgICAgICByZWxhdGlvbkJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAvLyBtYWtlUmVsYXRpb25CdHcodGhpcy5jdXJyZW50X3VzZXJfaWQuZ2V0QXR0cmlidXRlKFwiZGF0YS11LWlkXCIpLCB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtaC1pZFwiKSwgdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBvc3QtdHlwZVwiKSwgZS5jdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBtYWtlUmVsYXRpb25CdHcocG9zdERhdGEudXNlcl9pZCwgcG9zdERhdGEuaWQsIHBvc3REYXRhLnBvc3RfdHlwZV9zbHVnLCBlLmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWltYWdlcyB8fCBpbWFnZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIFNpIGltZ3MgZXN0IHZpZGUgb3UgbnVsbCwgaW5zw6lyZXIgdW5lIGltYWdlIHVuaXF1ZVxyXG4gICAgICAgICAgICBjb25zdCBzaW5nbGVJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgICAgICBzaW5nbGVJbWFnZS5zcmMgPSBpbWFnZTtcclxuICAgICAgICAgICAgc2luZ2xlSW1hZ2UuYWx0ID0gXCJJbWFnZSB1bmlxdWVcIjtcclxuICAgICAgICAgICAgc2luZ2xlSW1hZ2UuY2xhc3NMaXN0LmFkZCgnc2luZ2xlLWltYWdlJyk7XHJcbiAgICAgICAgICAgIGltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKHNpbmdsZUltYWdlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNpIGltZ3MgY29udGllbnQgZGVzIGltYWdlcywgaW5zw6lyZXIgdW4gY2Fycm91c2VsXHJcbiAgICAgICAgICAgIGltYWdlQ29udGFpbmVyLmlubmVySFRNTCA9IGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN3aXBlci1jb250YWluZXJcIj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3dpcGVyLXdyYXBwZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAke2ltYWdlcy5tYXAoc3JjID0+IGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlXCI+PGltZyBzcmM9XCIke3NyY31cIiBhbHQ9XCJJbWFnZSBkZSBjYXJyb3VzZWxcIj48L2Rpdj5gKS5qb2luKCcnKX1cclxuXHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdDwhLS0gQWpvdXQgZGVzIGJvdXRvbnMgZGUgbmF2aWdhdGlvbiAtLT5cclxuICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN3aXBlci1idXR0b24tbmV4dFwiPjwvZGl2PlxyXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInN3aXBlci1idXR0b24tcHJldlwiPjwvZGl2PlxyXG5cdFx0XHRcdFx0PCEtLSBBam91dCBkZSBsYSBwYWdpbmF0aW9uIC0tPlxyXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInN3aXBlci1wYWdpbmF0aW9uXCI+PC9kaXY+XHJcblx0XHRcdFx0PC9kaXY+XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIGA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvL2VuZFxyXG5cclxuICAgICAgICAgIC8vIEluaXRpYWxpc2VyIFN3aXBlclxyXG4gICAgICAgICAgY29uc3Qgc3dpcGVyID0gbmV3IFN3aXBlcignLnN3aXBlci1jb250YWluZXInLCB7XHJcbiAgICAgICAgICAgIGxvb3A6IHRydWUsIC8vIEJvdWNsZSBpbmZpbmllXHJcbiAgICAgICAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICAgICAgICBlbDogJy5zd2lwZXItcGFnaW5hdGlvbicsXHJcbiAgICAgICAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgICAgbmV4dEVsOiAnLnN3aXBlci1idXR0b24tbmV4dCcsXHJcbiAgICAgICAgICAgICAgcHJldkVsOiAnLnN3aXBlci1idXR0b24tcHJldicsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gdG9kb19hdWd1c3RpbiByZW1wbGlzc2FnZSBtYXAgaW5mb1xyXG4gICAgICAgICAgbGluay5ocmVmID0gcG9zdERhdGEucG9zdF9wZXJtYWxpbms7Ly9ldmVudC50YXJnZXQubWFya2VyRGF0YS5wZXJtYWxpbms7XHJcbiAgICAgICAgICAvL2ltYWdlLnNyYyA9IDsvL2V2ZW50LnRhcmdldC5tYXJrZXJEYXRhLmltZztcclxuICAgICAgICAgIHRpdGxlLmlubmVySFRNTCA9IHBvc3REYXRhLnRpdGxlOy8vZXZlbnQudGFyZ2V0Lm1hcmtlckRhdGEudGl0bGU7XHJcbiAgICAgICAgICAvLyBwcmljZS5pbm5lckhUTUwgPSA7Ly9ldmVudC50YXJnZXQubWFya2VyRGF0YS5wcmljZTtcclxuICAgICAgICAgIGFkZHJlc3MuaW5uZXJIVE1MID0gcG9zdERhdGEucHJpY2U7Ly9ldmVudC50YXJnZXQubWFya2VyRGF0YS5wcmljZTtcclxuICAgICAgICAgIGJlZHJvb20uaW5uZXJIVE1MID0gcG9zdERhdGEuYmVkcm9vbXM7Ly9ldmVudC50YXJnZXQubWFya2VyRGF0YS5iZWRyb29tcztcclxuICAgICAgICAgIGJhdGhyb29tLmlubmVySFRNTCA9IHBvc3REYXRhLmJhdGhyb29tczsvL2V2ZW50LnRhcmdldC5tYXJrZXJEYXRhLmJhdGhyb29tcztcclxuICAgICAgICAgIGhvdXNlLmlubmVySFRNTCA9IHBvc3REYXRhLmhvbWVfc2l6ZTsvL2V2ZW50LnRhcmdldC5tYXJrZXJEYXRhLmhvbWVfc2l6ZTtcclxuICAgICAgICAgIGxhbmQuaW5uZXJIVE1MID0gcG9zdERhdGEub3V0ZG9vcl9zaXplOy8vZXZlbnQudGFyZ2V0Lm1hcmtlckRhdGEub3V0ZG9vcl9zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgLFxyXG4gICAgICAgIDQwMFxyXG4gICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICB0aGlzLmRpc3BsYXlQb3B1cCgpO1xyXG4gICAgICB9XHJcblxyXG5cdFx0ZGlzcGxheVBvcHVwID0gKCkgPT4ge1xyXG5cclxuXHRcdFx0Ly8gRGlzcGxheSB0aGUgcG9wdXBcclxuXHRcdFx0dGhpcy50bC50byh0aGlzLnBvcHVwLCB7XHJcblx0XHRcdFx0YXV0b0FscGhhOiAxLFxyXG5cdFx0XHRcdG9wYWNpdHk6IDEsXHJcblx0XHRcdFx0eTogMFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0Ly8gZGF0YS5xdWVyeVNlbGVjdG9yKFwiI2NhcmQtaWNvblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5jbG9zZVBvcHVwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbG9zZVBvcHVwID0gKGV2ZW50KSA9PiB7XHJcblx0XHRcdGlmKGV2ZW50KSB7XHJcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSGlkZSB0aGUgcG9wdXBcclxuXHRcdFx0dGhpcy50bC50byh0aGlzLnBvcHVwLCB7XHJcblx0XHRcdFx0YXV0b0FscGhhOiAwLFxyXG5cdFx0XHRcdG9wYWNpdHk6IDAsXHJcblx0XHRcdFx0eTogNjBcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dXBkYXRlTWFwKCkge1xyXG5cdFx0XHR0aGlzLmxlYWZsZXRfbWFwLm9mZigpO1xyXG5cdFx0XHR0aGlzLmxlYWZsZXRfbWFwLnJlbW92ZSgpO1xyXG5cdFx0XHR0aGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEdldCB0aGUgRE9NIGVsZW1lbnRcclxuXHRjb25zdCBtYXBzID0gZGF0YS5xdWVyeVNlbGVjdG9yQWxsKFwiI21hcC1kYXRhXCIpO1xyXG5cclxuXHQvLyBDaGVjayBpZiB0aGUgRE9NIGVsZW1lbnQgZXhpc3RzXHJcblx0aWYobWFwcy5sZW5ndGgpIHtcclxuXHRcdC8vIElmIHllcywgY2FsbCBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgbWFwXHJcblx0XHRbLi4ubWFwc10ubWFwKChtYXApID0+IG5ldyBNYXAobWFwKSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYXBMYXVuY2g7XHJcbiJdLCJuYW1lcyI6WyJMIiwiZ3NhcCIsIk1vZGFsc19Jbml0IiwibWFrZVJlbGF0aW9uQnR3IiwiTWFwTGF1bmNoIiwiZGF0YSIsIk1hcCIsImNvbnN0cnVjdG9yIiwiZWwiLCJlbGVtZW50IiwibWFwIiwicXVlcnlTZWxlY3RvciIsInBvcHVwIiwiZml0Qm91bmRzIiwiZ2V0QXR0cmlidXRlIiwicGFnZSIsImxlYWZsZXRfbWFwIiwibWFya2VyIiwiVXNlck1hcmtlciIsIm1hcmtlckNsdXN0ZXIiLCJib3VuZHMiLCJjbGlja0xpc3RlbmVyIiwidGwiLCJ0aW1lbGluZSIsImRlZmF1bHRzIiwiZHVyYXRpb24iLCJlYXNlIiwid3ciLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImJvZHkiLCJ3aCIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiaGVhZGVySCIsImluaXQiLCJpbml0UG9wdXAiLCJyaWdodF9zbGF0ZXMiLCJyaWdodF9zbGF0ZXNfX2l0ZW1zIiwicXVlcnlTZWxlY3RvckFsbCIsImJ1aWxkaW5nc0RhdGEiLCJzdHlsZSIsImhlaWdodCIsImJ1aWxkaW5ncyIsImNlbnRlciIsInpvb20iLCJwaXhlbFJhdGlvIiwibWF4Wm9vbSIsIm1pblpvb20iLCJ6b29tQ29udHJvbCIsImRpc3BsYXlNYXAiLCJ0aWxlTGF5ZXIiLCJhdHRyaWJ1dGlvbiIsInRpbGVTaXplIiwiem9vbU9mZnNldCIsImFkZFRvIiwiSlNPTiIsInBhcnNlIiwibWFya2VyQ2x1c3Rlckdyb3VwIiwic2hvd0NvdmVyYWdlT25Ib3ZlciIsInpvb21Ub0JvdW5kc09uQ2xpY2siLCJtYXhDbHVzdGVyUmFkaXVzIiwic3BpZGVyZnlPbk1heFpvb20iLCJyZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kcyIsImljb25DcmVhdGVGdW5jdGlvbiIsImNsdXN0ZXIiLCJkaXZJY29uIiwiY2xhc3NOYW1lIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwiaHRtbCIsImdldENoaWxkQ291bnQiLCJmb3JFYWNoIiwiYnVpbGRpbmciLCJsYXQiLCJsbmciLCJhZGRNYXJrZXIiLCJtdXRhdGlvbl9vYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJ1cGRhdGVNYXAiLCJpbnRlcnNlY3Rpb25fb2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJfb2JzZXJ2ZXIiLCJlbnRyeSIsImlzSW50ZXJzZWN0aW5nIiwiaW52YWxpZGF0ZVNpemUiLCJwYWRkaW5nIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJtYXJrZXJDb2xvciIsInBvc3RfdHlwZV9zbHVnIiwibWFya2VySHRtbFN0eWxlcyIsImN1c3RvbU1hcmtlckljb24iLCJsYWJlbEFuY2hvciIsInBvcHVwQW5jaG9yIiwibWFya2VyRGF0YSIsImlkIiwiaWNvbiIsImxlbmd0aCIsImFkZExheWVyIiwiY2x1c3RlckJvdW5kcyIsInB1c2giLCJvbiIsIm1hcmtlckNsaWNrIiwiZXZlbnQiLCJmbHlUbyIsImxhdGxuZyIsImFsbE1hcmtlcnMiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJ0YXJnZXQiLCJfaWNvbiIsImFkZCIsInNsYXRlcyIsInJlbGF0ZWRfc2xhdGUiLCJ5IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwic2Nyb2xsWSIsInNsYXRlIiwiY29udGFpbnMiLCJzY3JvbGwiLCJiZWhhdmlvciIsImNoYW5nZVBvcHVwQ29udGVudCIsImRpc3BsYXlQb3B1cCIsInNldCIsImF1dG9BbHBoYSIsIm9wYWNpdHkiLCJjbG9zZVBvcHVwIiwic2V0VGltZW91dCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwibGluayIsInRpdGxlIiwiYWRkcmVzcyIsImJlZHJvb20iLCJiYXRocm9vbSIsImhvdXNlIiwibGFuZCIsImltYWdlIiwicG9zdERhdGEiLCJqc29uIiwiaW1hZ2VzIiwiY2FyZF9nYWxsZXJ5X2ltYWdlcyIsImltYWdlQ29udGFpbmVyIiwic2hhcmVCdSIsImZhdm9yaXRlQnV0b24iLCJpbm5lckhUTUwiLCJ0ZW1wbGF0ZXMiLCJib3V0b25fc2hhcmVfdGVtcGxhdGUiLCJsaWtlX2Zhdm9yaXRlX3RlbXBsYXRlIiwicmVsYXRpb25CdG5zIiwicmVsYXRpb25CdG4iLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidXNlcl9pZCIsImN1cnJlbnRUYXJnZXQiLCJzaW5nbGVJbWFnZSIsImNyZWF0ZUVsZW1lbnQiLCJzcmMiLCJhbHQiLCJhcHBlbmRDaGlsZCIsImpvaW4iLCJzd2lwZXIiLCJTd2lwZXIiLCJsb29wIiwicGFnaW5hdGlvbiIsImNsaWNrYWJsZSIsIm5hdmlnYXRpb24iLCJuZXh0RWwiLCJwcmV2RWwiLCJocmVmIiwicG9zdF9wZXJtYWxpbmsiLCJwcmljZSIsImJlZHJvb21zIiwiYmF0aHJvb21zIiwiaG9tZV9zaXplIiwib3V0ZG9vcl9zaXplIiwidG8iLCJvZmYiLCJtYXBzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/map-functions.js\n");

/***/ }),

/***/ "./src/js/components/maps.js":
/*!***********************************!*\
  !*** ./src/js/components/maps.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// TODO: leaflet-control-geocoder-alternatives -> li onclick:\n// toggleClass .leaflet-control-geocoder-alternatives-minimized\n\nconst Maps_Init = () => {\n  class Map {\n    constructor(el) {\n      this.el = el;\n      this.leaflet_control_geocoder = this.el.querySelector(\".leaflet-control-geocoder\");\n\n      // console.log(map);\n      // console.log(this.el);\n      // console.log(this.leaflet_control_geocoder);\n\n      // const observer = new MutationObserver(() => {\n      //     console.log(\"map has changed\");\n      //     this.proposition_list = this.el.querySelector(\".leaflet-control-geocoder-alternatives\");\n      //     this.proposition_list_items = this.proposition_list.querySelectorAll(\"li\");\n      //     console.log(this.proposition_list_items);\n\n      //     this.proposition_list_items.forEach(element => {\n      //         console.log(element);\n      //         element.addEventListener(\"click\", function (e) {\n      //             console.log(e.target);\n      //             console.log(\"You clicked\");\n      //         });\n      //     });\n      // });\n\n      // observer.observe(this.el, {\n      //     subtree: true,\n      //     childList: true,\n      // });\n\n      // this.init();\n    }\n    // init() {\n    // \tconsole.log(\"map\");\n    // }\n  }\n  const maps = document.querySelectorAll(\".af-field-type-open-street-map\");\n  if (maps.length) {\n    [...maps].map(map => new Map(map));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Maps_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy9tYXBzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBLE1BQU1BLFNBQVMsR0FBR0EsQ0FBQSxLQUFNO0VBQ3ZCLE1BQU1DLEdBQUcsQ0FBQztJQUNUQyxXQUFXQSxDQUFDQyxFQUFFLEVBQUU7TUFDZixJQUFJLENBQUNBLEVBQUUsR0FBR0EsRUFBRTtNQUNILElBQUksQ0FBQ0Msd0JBQXdCLEdBQUcsSUFBSSxDQUFDRCxFQUFFLENBQUNFLGFBQWEsQ0FBQywyQkFBMkIsQ0FBQzs7TUFFbEY7TUFDQTtNQUNBOztNQUdBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O01BSUE7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7TUFFQTtNQUNBO01BQ0E7TUFDQTs7TUFFVDtJQUdEO0lBQ0E7SUFDQTtJQUNBO0VBQ0Q7RUFFQSxNQUFNQyxJQUFJLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsZ0NBQWdDLENBQUM7RUFHeEUsSUFBSUYsSUFBSSxDQUFDRyxNQUFNLEVBQUU7SUFDaEIsQ0FBQyxHQUFHSCxJQUFJLENBQUMsQ0FBQ0ksR0FBRyxDQUFFQSxHQUFHLElBQUssSUFBSVQsR0FBRyxDQUFDUyxHQUFHLENBQUMsQ0FBQztFQUNyQztBQUNELENBQUM7QUFFRCxpRUFBZVYsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL21hcHMuanM/NDhhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzIC0+IGxpIG9uY2xpY2s6XHJcbi8vIHRvZ2dsZUNsYXNzIC5sZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZFxyXG5cclxuY29uc3QgTWFwc19Jbml0ID0gKCkgPT4ge1xyXG5cdGNsYXNzIE1hcCB7XHJcblx0XHRjb25zdHJ1Y3RvcihlbCkge1xyXG5cdFx0XHR0aGlzLmVsID0gZWw7XHJcbiAgICAgICAgICAgIHRoaXMubGVhZmxldF9jb250cm9sX2dlb2NvZGVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmxlYWZsZXQtY29udHJvbC1nZW9jb2RlclwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG1hcCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZWwpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmxlYWZsZXRfY29udHJvbF9nZW9jb2Rlcik7XHJcbiAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAvLyBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwibWFwIGhhcyBjaGFuZ2VkXCIpO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy5wcm9wb3NpdGlvbl9saXN0ID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmxlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1hbHRlcm5hdGl2ZXNcIik7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnByb3Bvc2l0aW9uX2xpc3RfaXRlbXMgPSB0aGlzLnByb3Bvc2l0aW9uX2xpc3QucXVlcnlTZWxlY3RvckFsbChcImxpXCIpO1xyXG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2codGhpcy5wcm9wb3NpdGlvbl9saXN0X2l0ZW1zKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnByb3Bvc2l0aW9uX2xpc3RfaXRlbXMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBjb25zb2xlLmxvZyhlbGVtZW50KTtcclxuICAgICAgICAgICAgLy8gICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnRhcmdldCk7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiWW91IGNsaWNrZWRcIik7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vICAgICB9KTtcclxuICAgICAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIG9ic2VydmVyLm9ic2VydmUodGhpcy5lbCwge1xyXG4gICAgICAgICAgICAvLyAgICAgc3VidHJlZTogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gfSk7XHJcblxyXG5cdFx0XHQvLyB0aGlzLmluaXQoKTtcclxuXHJcblxyXG5cdFx0fVxyXG5cdFx0Ly8gaW5pdCgpIHtcclxuXHRcdC8vIFx0Y29uc29sZS5sb2coXCJtYXBcIik7XHJcblx0XHQvLyB9XHJcblx0fVxyXG5cdFxyXG5cdGNvbnN0IG1hcHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFmLWZpZWxkLXR5cGUtb3Blbi1zdHJlZXQtbWFwXCIpO1xyXG5cclxuXHRcclxuXHRpZiAobWFwcy5sZW5ndGgpIHtcclxuXHRcdFsuLi5tYXBzXS5tYXAoKG1hcCkgPT4gbmV3IE1hcChtYXApKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hcHNfSW5pdDtcclxuIl0sIm5hbWVzIjpbIk1hcHNfSW5pdCIsIk1hcCIsImNvbnN0cnVjdG9yIiwiZWwiLCJsZWFmbGV0X2NvbnRyb2xfZ2VvY29kZXIiLCJxdWVyeVNlbGVjdG9yIiwibWFwcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/components/maps.js\n");

/***/ }),

/***/ "./src/js/components/modal.js":
/*!************************************!*\
  !*** ./src/js/components/modal.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var micromodal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromodal */ \"./node_modules/micromodal/dist/micromodal.es.js\");\n\nconst Modals_Init = data => {\n  class Modal {\n    constructor(el) {\n      this.el = el;\n      this.id = this.el.getAttribute(\"data-open-modal\");\n      this.targetEL = document.querySelector(\"#\" + this.id);\n      this.el.addEventListener(\"click\", e => {\n        e.preventDefault();\n        e.stopPropagation();\n        micromodal__WEBPACK_IMPORTED_MODULE_0__[\"default\"].show(this.id, {\n          openTrigger: 'data-open-modal',\n          closeTrigger: 'data-close-modal',\n          openClass: 'is-open',\n          disableScroll: false,\n          disableFocus: false,\n          awaitOpenAnimation: false,\n          awaitCloseAnimation: false,\n          debugMode: false\n        });\n      });\n    }\n  }\n  const ModalBtns = document.querySelectorAll('[data-open-modal]');\n  if (ModalBtns.length) {\n    [...ModalBtns].map(ModalBtn => new Modal(ModalBtn));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Modals_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy9tb2RhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQztBQUVwQyxNQUFNQyxXQUFXLEdBQUlDLElBQUksSUFBSztFQUM3QixNQUFNQyxLQUFLLENBQUM7SUFDWEMsV0FBV0EsQ0FBQ0MsRUFBRSxFQUFFO01BQ2YsSUFBSSxDQUFDQSxFQUFFLEdBQUdBLEVBQUU7TUFDWixJQUFJLENBQUNDLEVBQUUsR0FBRyxJQUFJLENBQUNELEVBQUUsQ0FBQ0UsWUFBWSxDQUFDLGlCQUFpQixDQUFDO01BQ3hDLElBQUksQ0FBQ0MsUUFBUSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDSixFQUFFLENBQUM7TUFDckQsSUFBSSxDQUFDRCxFQUFFLENBQUNNLGdCQUFnQixDQUFDLE9BQU8sRUFBR0MsQ0FBQyxJQUFLO1FBQ3JDQSxDQUFDLENBQUNDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hCRCxDQUFDLENBQUNFLGVBQWUsQ0FBQyxDQUFDO1FBQ2JkLGtEQUFVLENBQUNlLElBQUksQ0FBQyxJQUFJLENBQUNULEVBQUUsRUFBRTtVQUNyQlUsV0FBVyxFQUFFLGlCQUFpQjtVQUM5QkMsWUFBWSxFQUFFLGtCQUFrQjtVQUNoQ0MsU0FBUyxFQUFFLFNBQVM7VUFDcEJDLGFBQWEsRUFBRSxLQUFLO1VBQ3BCQyxZQUFZLEVBQUUsS0FBSztVQUNuQkMsa0JBQWtCLEVBQUUsS0FBSztVQUN6QkMsbUJBQW1CLEVBQUUsS0FBSztVQUMxQkMsU0FBUyxFQUFFO1FBQ2YsQ0FBQyxDQUFDO01BQ04sQ0FBQyxDQUFDO0lBQ1o7RUFFRDtFQUVBLE1BQU1DLFNBQVMsR0FBR2YsUUFBUSxDQUFDZ0IsZ0JBQWdCLENBQUMsbUJBQW1CLENBQUM7RUFFaEUsSUFBSUQsU0FBUyxDQUFDRSxNQUFNLEVBQUU7SUFDcEIsQ0FBQyxHQUFHRixTQUFTLENBQUMsQ0FBQ0csR0FBRyxDQUFFQyxRQUFRLElBQUssSUFBSXpCLEtBQUssQ0FBQ3lCLFFBQVEsQ0FBQyxDQUFDO0VBQ3ZEO0FBQ0QsQ0FBQztBQUVELGlFQUFlM0IsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL21vZGFsLmpzPzJhMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1pY3JvTW9kYWwgZnJvbSAnbWljcm9tb2RhbCc7XHJcblxyXG5jb25zdCBNb2RhbHNfSW5pdCA9IChkYXRhKSA9PiB7XHJcblx0Y2xhc3MgTW9kYWwge1xyXG5cdFx0Y29uc3RydWN0b3IoZWwpIHtcclxuXHRcdFx0dGhpcy5lbCA9IGVsO1xyXG5cdFx0XHR0aGlzLmlkID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9wZW4tbW9kYWxcIik7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RUwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiICsgdGhpcy5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHQgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBNaWNyb01vZGFsLnNob3codGhpcy5pZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5UcmlnZ2VyOiAnZGF0YS1vcGVuLW1vZGFsJyxcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZVRyaWdnZXI6ICdkYXRhLWNsb3NlLW1vZGFsJyxcclxuICAgICAgICAgICAgICAgICAgICBvcGVuQ2xhc3M6ICdpcy1vcGVuJyxcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlU2Nyb2xsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlRm9jdXM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0T3BlbkFuaW1hdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXRDbG9zZUFuaW1hdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdNb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0pOyBcclxuICAgICAgICAgICAgfSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9XHJcblx0XHJcblx0Y29uc3QgTW9kYWxCdG5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtb3Blbi1tb2RhbF0nKTtcclxuXHJcblx0aWYgKE1vZGFsQnRucy5sZW5ndGgpIHtcclxuXHQgIFsuLi5Nb2RhbEJ0bnNdLm1hcCgoTW9kYWxCdG4pID0+IG5ldyBNb2RhbChNb2RhbEJ0bikpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTW9kYWxzX0luaXQ7XHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIk1pY3JvTW9kYWwiLCJNb2RhbHNfSW5pdCIsImRhdGEiLCJNb2RhbCIsImNvbnN0cnVjdG9yIiwiZWwiLCJpZCIsImdldEF0dHJpYnV0ZSIsInRhcmdldEVMIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInNob3ciLCJvcGVuVHJpZ2dlciIsImNsb3NlVHJpZ2dlciIsIm9wZW5DbGFzcyIsImRpc2FibGVTY3JvbGwiLCJkaXNhYmxlRm9jdXMiLCJhd2FpdE9wZW5BbmltYXRpb24iLCJhd2FpdENsb3NlQW5pbWF0aW9uIiwiZGVidWdNb2RlIiwiTW9kYWxCdG5zIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIm1hcCIsIk1vZGFsQnRuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/modal.js\n");

/***/ }),

/***/ "./src/js/components/navigation.js":
/*!*****************************************!*\
  !*** ./src/js/components/navigation.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Navigation_Init = () => {\n  function getCurrentURL() {\n    return window.location.href;\n  }\n\n  // Example\n  const url = getCurrentURL();\n  var act_for_items = document.querySelectorAll(\".act-for\");\n  var url_comp = url.split(\"/\");\n  var page = url_comp[url_comp.length - 2];\n  act_for_items.forEach(act_for_item => {\n    act_for_item.classList.remove(\"active\");\n  });\n  var current_page_active_el = document.querySelector(\".act-for-\" + page);\n  if (current_page_active_el) {\n    current_page_active_el.classList.add(\"active\");\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Navigation_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy9uYXZpZ2F0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFDQSxNQUFNQSxlQUFlLEdBQUdBLENBQUEsS0FBTTtFQUM3QixTQUFTQyxhQUFhQSxDQUFBLEVBQUk7SUFDekIsT0FBT0MsTUFBTSxDQUFDQyxRQUFRLENBQUNDLElBQUk7RUFDNUI7O0VBRUE7RUFDQSxNQUFNQyxHQUFHLEdBQUdKLGFBQWEsQ0FBQyxDQUFDO0VBQzNCLElBQUlLLGFBQWEsR0FBR0MsUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUM7RUFDekQsSUFBSUMsUUFBUSxHQUFHSixHQUFHLENBQUNLLEtBQUssQ0FBQyxHQUFHLENBQUM7RUFDN0IsSUFBSUMsSUFBSSxHQUFJRixRQUFRLENBQUNBLFFBQVEsQ0FBQ0csTUFBTSxHQUFHLENBQUMsQ0FBQztFQUV6Q04sYUFBYSxDQUFDTyxPQUFPLENBQUVDLFlBQVksSUFBSztJQUNwQ0EsWUFBWSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sQ0FBQyxRQUFRLENBQUM7RUFDM0MsQ0FBQyxDQUFDO0VBRUYsSUFBSUMsc0JBQXNCLEdBQUdWLFFBQVEsQ0FBQ1csYUFBYSxDQUFDLFdBQVcsR0FBR1AsSUFBSSxDQUFDO0VBRXZFLElBQUdNLHNCQUFzQixFQUFDO0lBQ3pCQSxzQkFBc0IsQ0FBQ0YsU0FBUyxDQUFDSSxHQUFHLENBQUMsUUFBUSxDQUFDO0VBQy9DO0FBQ0QsQ0FBQztBQUVELGlFQUFlbkIsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL25hdmlnYXRpb24uanM/M2JiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgTmF2aWdhdGlvbl9Jbml0ID0gKCkgPT4ge1xyXG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRVUkwgKCkge1xyXG5cdFx0cmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ocmVmXHJcblx0fVxyXG5cdFxyXG5cdC8vIEV4YW1wbGVcclxuXHRjb25zdCB1cmwgPSBnZXRDdXJyZW50VVJMKCk7XHJcblx0dmFyIGFjdF9mb3JfaXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFjdC1mb3JcIik7XHJcblx0dmFyIHVybF9jb21wID0gdXJsLnNwbGl0KFwiL1wiKTtcclxuXHR2YXIgcGFnZSA9ICB1cmxfY29tcFt1cmxfY29tcC5sZW5ndGggLSAyXTtcclxuXHRcclxuXHRhY3RfZm9yX2l0ZW1zLmZvckVhY2goKGFjdF9mb3JfaXRlbSkgPT4ge1xyXG4gICAgXHRhY3RfZm9yX2l0ZW0uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcclxuXHR9KTtcclxuXHJcblx0dmFyIGN1cnJlbnRfcGFnZV9hY3RpdmVfZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmFjdC1mb3ItXCIgKyBwYWdlKTtcclxuXHJcblx0aWYoY3VycmVudF9wYWdlX2FjdGl2ZV9lbCl7XHJcblx0XHRjdXJyZW50X3BhZ2VfYWN0aXZlX2VsLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0aW9uX0luaXQ7XHJcbiJdLCJuYW1lcyI6WyJOYXZpZ2F0aW9uX0luaXQiLCJnZXRDdXJyZW50VVJMIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwidXJsIiwiYWN0X2Zvcl9pdGVtcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsInVybF9jb21wIiwic3BsaXQiLCJwYWdlIiwibGVuZ3RoIiwiZm9yRWFjaCIsImFjdF9mb3JfaXRlbSIsImNsYXNzTGlzdCIsInJlbW92ZSIsImN1cnJlbnRfcGFnZV9hY3RpdmVfZWwiLCJxdWVyeVNlbGVjdG9yIiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/navigation.js\n");

/***/ }),

/***/ "./src/js/components/scrollTo.js":
/*!***************************************!*\
  !*** ./src/js/components/scrollTo.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst scrollTo = next => {\n  const queryString = window.location.search;\n  var inputSubmit = document.querySelector(\".frm_submit input\");\n  if (queryString) {\n    const urlParams = new URLSearchParams(queryString);\n    const scrollto = urlParams.get('scrollto');\n    var scrollTo__el = document.querySelector(\".\" + scrollto);\n    if (scrollTo__el) {\n      var scrollTo__el_y = scrollTo__el.offsetTop;\n      window.scrollTo({\n        top: scrollTo__el_y - 24,\n        behavior: 'smooth'\n      });\n    }\n  }\n\n  // avoid scrollTo after submitting a form\n  if (inputSubmit) {\n    inputSubmit.addEventListener('click', function (e) {\n      let url = new URL(window.location.href);\n      let scrolltoParam = url.searchParams.get('scrollto');\n      if (scrolltoParam) {\n        url.searchParams.delete('scrollto');\n        history.replaceState(history.state, '', url.href);\n      }\n    });\n  }\n};\nconst getOffset = (element, horizontal = false) => {\n  if (!element) return 0;\n  return getOffset(element.offsetParent, horizontal) + (horizontal ? element.offsetLeft : element.offsetTop);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scrollTo);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy9zY3JvbGxUby5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsUUFBUSxHQUFJQyxJQUFJLElBQUs7RUFDMUIsTUFBTUMsV0FBVyxHQUFHQyxNQUFNLENBQUNDLFFBQVEsQ0FBQ0MsTUFBTTtFQUMxQyxJQUFJQyxXQUFXLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLG1CQUFtQixDQUFDO0VBRTdELElBQUdOLFdBQVcsRUFBQztJQUNkLE1BQU1PLFNBQVMsR0FBRyxJQUFJQyxlQUFlLENBQUNSLFdBQVcsQ0FBQztJQUNsRCxNQUFNUyxRQUFRLEdBQUdGLFNBQVMsQ0FBQ0csR0FBRyxDQUFDLFVBQVUsQ0FBQztJQUMxQyxJQUFJQyxZQUFZLEdBQUdOLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLEdBQUcsR0FBR0csUUFBUSxDQUFDO0lBQ3pELElBQUdFLFlBQVksRUFBRTtNQUNoQixJQUFJQyxjQUFjLEdBQUdELFlBQVksQ0FBQ0UsU0FBUztNQUMzQ1osTUFBTSxDQUFDSCxRQUFRLENBQUM7UUFDZmdCLEdBQUcsRUFBRUYsY0FBYyxHQUFHLEVBQUU7UUFDeEJHLFFBQVEsRUFBRTtNQUNYLENBQUMsQ0FBQztJQUNIO0VBQ0Q7O0VBRUE7RUFDQSxJQUFHWCxXQUFXLEVBQUM7SUFDZEEsV0FBVyxDQUFDWSxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBU0MsQ0FBQyxFQUFFO01BQ2pELElBQUlDLEdBQUcsR0FBRyxJQUFJQyxHQUFHLENBQUNsQixNQUFNLENBQUNDLFFBQVEsQ0FBQ2tCLElBQUksQ0FBQztNQUN2QyxJQUFJQyxhQUFhLEdBQUdILEdBQUcsQ0FBQ0ksWUFBWSxDQUFDWixHQUFHLENBQUMsVUFBVSxDQUFDO01BQ3BELElBQUlXLGFBQWEsRUFBRTtRQUNsQkgsR0FBRyxDQUFDSSxZQUFZLENBQUNDLE1BQU0sQ0FBQyxVQUFVLENBQUM7UUFDbkNDLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDRCxPQUFPLENBQUNFLEtBQUssRUFBRSxFQUFFLEVBQUVSLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDO01BQ2xEO0lBQ0QsQ0FBQyxDQUFDO0VBQ0g7QUFFRCxDQUFDO0FBRUQsTUFBTU8sU0FBUyxHQUFHQSxDQUFDQyxPQUFPLEVBQUVDLFVBQVUsR0FBRyxLQUFLLEtBQUs7RUFDbEQsSUFBRyxDQUFDRCxPQUFPLEVBQUUsT0FBTyxDQUFDO0VBQ3JCLE9BQU9ELFNBQVMsQ0FBQ0MsT0FBTyxDQUFDRSxZQUFZLEVBQUVELFVBQVUsQ0FBQyxJQUFJQSxVQUFVLEdBQUdELE9BQU8sQ0FBQ0csVUFBVSxHQUFHSCxPQUFPLENBQUNmLFNBQVMsQ0FBQztBQUMzRyxDQUFDO0FBRUQsaUVBQWVmLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9zcmMvanMvY29tcG9uZW50cy9zY3JvbGxUby5qcz8wZDlmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHNjcm9sbFRvID0gKG5leHQpID0+IHtcclxuXHRjb25zdCBxdWVyeVN0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XHJcblx0dmFyIGlucHV0U3VibWl0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5mcm1fc3VibWl0IGlucHV0XCIpO1xyXG5cclxuXHRpZihxdWVyeVN0cmluZyl7XHJcblx0XHRjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5U3RyaW5nKTtcclxuXHRcdGNvbnN0IHNjcm9sbHRvID0gdXJsUGFyYW1zLmdldCgnc2Nyb2xsdG8nKVxyXG5cdFx0dmFyIHNjcm9sbFRvX19lbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBzY3JvbGx0byk7XHJcblx0XHRpZihzY3JvbGxUb19fZWwpIHtcclxuXHRcdFx0dmFyIHNjcm9sbFRvX19lbF95ID0gc2Nyb2xsVG9fX2VsLm9mZnNldFRvcDtcclxuXHRcdFx0d2luZG93LnNjcm9sbFRvKHtcclxuXHRcdFx0XHR0b3A6IHNjcm9sbFRvX19lbF95IC0gMjQsXHJcblx0XHRcdFx0YmVoYXZpb3I6ICdzbW9vdGgnLFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGF2b2lkIHNjcm9sbFRvIGFmdGVyIHN1Ym1pdHRpbmcgYSBmb3JtXHJcblx0aWYoaW5wdXRTdWJtaXQpe1xyXG5cdFx0aW5wdXRTdWJtaXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdGxldCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcclxuXHRcdFx0bGV0IHNjcm9sbHRvUGFyYW0gPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgnc2Nyb2xsdG8nKTtcclxuXHRcdFx0aWYgKHNjcm9sbHRvUGFyYW0pIHtcclxuXHRcdFx0XHR1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnc2Nyb2xsdG8nKTtcclxuXHRcdFx0XHRoaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5LnN0YXRlLCAnJywgdXJsLmhyZWYpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG59XHJcblxyXG5jb25zdCBnZXRPZmZzZXQgPSAoZWxlbWVudCwgaG9yaXpvbnRhbCA9IGZhbHNlKSA9PiB7XHJcblx0aWYoIWVsZW1lbnQpIHJldHVybiAwO1xyXG5cdHJldHVybiBnZXRPZmZzZXQoZWxlbWVudC5vZmZzZXRQYXJlbnQsIGhvcml6b250YWwpICsgKGhvcml6b250YWwgPyBlbGVtZW50Lm9mZnNldExlZnQgOiBlbGVtZW50Lm9mZnNldFRvcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNjcm9sbFRvOyJdLCJuYW1lcyI6WyJzY3JvbGxUbyIsIm5leHQiLCJxdWVyeVN0cmluZyIsIndpbmRvdyIsImxvY2F0aW9uIiwic2VhcmNoIiwiaW5wdXRTdWJtaXQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ1cmxQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzY3JvbGx0byIsImdldCIsInNjcm9sbFRvX19lbCIsInNjcm9sbFRvX19lbF95Iiwib2Zmc2V0VG9wIiwidG9wIiwiYmVoYXZpb3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInVybCIsIlVSTCIsImhyZWYiLCJzY3JvbGx0b1BhcmFtIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIiwiaGlzdG9yeSIsInJlcGxhY2VTdGF0ZSIsInN0YXRlIiwiZ2V0T2Zmc2V0IiwiZWxlbWVudCIsImhvcml6b250YWwiLCJvZmZzZXRQYXJlbnQiLCJvZmZzZXRMZWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/scrollTo.js\n");

/***/ }),

/***/ "./src/js/components/tabs.js":
/*!***********************************!*\
  !*** ./src/js/components/tabs.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Tabs_Init = data => {\n  class TabsGroup {\n    constructor(el) {\n      this.el = el;\n      var tab__buttons = this.el.querySelectorAll(\".tab-button\");\n      var tab__contents = this.el.querySelectorAll(\".tab-content\");\n      tab__buttons.forEach(btn => {\n        btn.addEventListener(\"click\", function (e) {\n          e.preventDefault();\n          e.stopPropagation();\n          const id = e.target.getAttribute(\"data-tabs-id\");\n          tab__buttons.forEach(tab__button => {\n            tab__button.classList.remove(\"active\");\n          });\n          e.target.classList.add(\"active\");\n          tab__contents.forEach(content => {\n            content.classList.add(\"hide\");\n          });\n          const element = document.getElementById(id);\n          console.log(id);\n          console.log(element);\n          element.classList.remove(\"hide\");\n        });\n      });\n    }\n  }\n  const tabs_group = data.container.querySelectorAll(\".tabs-group\");\n  if (tabs_group.length) {\n    [...tabs_group].map(tabs => new TabsGroup(tabs));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tabs_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy90YWJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxTQUFTLEdBQUlDLElBQUksSUFBSztFQUMzQixNQUFNQyxTQUFTLENBQUM7SUFDZkMsV0FBV0EsQ0FBQ0MsRUFBRSxFQUFFO01BQ2YsSUFBSSxDQUFDQSxFQUFFLEdBQUdBLEVBQUU7TUFDSCxJQUFJQyxZQUFZLEdBQUcsSUFBSSxDQUFDRCxFQUFFLENBQUNFLGdCQUFnQixDQUFDLGFBQWEsQ0FBQztNQUMxRCxJQUFJQyxhQUFhLEdBQUcsSUFBSSxDQUFDSCxFQUFFLENBQUNFLGdCQUFnQixDQUFDLGNBQWMsQ0FBQztNQUU1REQsWUFBWSxDQUFDRyxPQUFPLENBQUNDLEdBQUcsSUFBSTtRQUN4QkEsR0FBRyxDQUFDQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBVUMsQ0FBQyxFQUFFO1VBQ3ZDQSxDQUFDLENBQUNDLGNBQWMsQ0FBQyxDQUFDO1VBQ2xCRCxDQUFDLENBQUNFLGVBQWUsQ0FBQyxDQUFDO1VBQ25CLE1BQU1DLEVBQUUsR0FBR0gsQ0FBQyxDQUFDSSxNQUFNLENBQUNDLFlBQVksQ0FBQyxjQUFjLENBQUM7VUFDaERYLFlBQVksQ0FBQ0csT0FBTyxDQUFDUyxXQUFXLElBQUk7WUFDaENBLFdBQVcsQ0FBQ0MsU0FBUyxDQUFDQyxNQUFNLENBQUMsUUFBUSxDQUFDO1VBQzFDLENBQUMsQ0FBQztVQUNGUixDQUFDLENBQUNJLE1BQU0sQ0FBQ0csU0FBUyxDQUFDRSxHQUFHLENBQUMsUUFBUSxDQUFDO1VBRWhDYixhQUFhLENBQUNDLE9BQU8sQ0FBQ2EsT0FBTyxJQUFJO1lBQzdCQSxPQUFPLENBQUNILFNBQVMsQ0FBQ0UsR0FBRyxDQUFDLE1BQU0sQ0FBQztVQUNqQyxDQUFDLENBQUM7VUFDRixNQUFNRSxPQUFPLEdBQUdDLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDVixFQUFFLENBQUM7VUFDM0NXLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDWixFQUFFLENBQUM7VUFDZlcsT0FBTyxDQUFDQyxHQUFHLENBQUNKLE9BQU8sQ0FBQztVQUNwQkEsT0FBTyxDQUFDSixTQUFTLENBQUNDLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDcEMsQ0FBQyxDQUFDO01BQ04sQ0FBQyxDQUFDO0lBQ1o7RUFDRDtFQUVBLE1BQU1RLFVBQVUsR0FBRzFCLElBQUksQ0FBQzJCLFNBQVMsQ0FBQ3RCLGdCQUFnQixDQUFDLGFBQWEsQ0FBQztFQUVqRSxJQUFJcUIsVUFBVSxDQUFDRSxNQUFNLEVBQUU7SUFDckIsQ0FBQyxHQUFHRixVQUFVLENBQUMsQ0FBQ0csR0FBRyxDQUFFQyxJQUFJLElBQUssSUFBSTdCLFNBQVMsQ0FBQzZCLElBQUksQ0FBQyxDQUFDO0VBQ3BEO0FBQ0QsQ0FBQztBQUVELGlFQUFlL0IsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL3RhYnMuanM/YmEwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBUYWJzX0luaXQgPSAoZGF0YSkgPT4ge1xyXG5cdGNsYXNzIFRhYnNHcm91cCB7XHJcblx0XHRjb25zdHJ1Y3RvcihlbCkge1xyXG5cdFx0XHR0aGlzLmVsID0gZWw7XHJcbiAgICAgICAgICAgIHZhciB0YWJfX2J1dHRvbnMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFiLWJ1dHRvblwiKTtcclxuICAgICAgICAgICAgdmFyIHRhYl9fY29udGVudHMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFiLWNvbnRlbnRcIik7XHJcblxyXG4gICAgICAgICAgICB0YWJfX2J1dHRvbnMuZm9yRWFjaChidG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS10YWJzLWlkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhYl9fYnV0dG9ucy5mb3JFYWNoKHRhYl9fYnV0dG9uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiX19idXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0YWJfX2NvbnRlbnRzLmZvckVhY2goY29udGVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImhpZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZVwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Y29uc3QgdGFic19ncm91cCA9IGRhdGEuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFicy1ncm91cFwiKTtcclxuXHRcclxuXHRpZiAodGFic19ncm91cC5sZW5ndGgpIHtcclxuXHQgIFsuLi50YWJzX2dyb3VwXS5tYXAoKHRhYnMpID0+IG5ldyBUYWJzR3JvdXAodGFicykpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFic19Jbml0OyJdLCJuYW1lcyI6WyJUYWJzX0luaXQiLCJkYXRhIiwiVGFic0dyb3VwIiwiY29uc3RydWN0b3IiLCJlbCIsInRhYl9fYnV0dG9ucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0YWJfX2NvbnRlbnRzIiwiZm9yRWFjaCIsImJ0biIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJpZCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsInRhYl9fYnV0dG9uIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiYWRkIiwiY29udGVudCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiY29uc29sZSIsImxvZyIsInRhYnNfZ3JvdXAiLCJjb250YWluZXIiLCJsZW5ndGgiLCJtYXAiLCJ0YWJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/tabs.js\n");

/***/ }),

/***/ "./src/js/components/tags.js":
/*!***********************************!*\
  !*** ./src/js/components/tags.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Tags_Init = () => {\n  class TaxonomiesField {\n    constructor(el) {\n      this.el = el;\n      this.free_text_field = this.el;\n      this.free_text_field_input = this.free_text_field.querySelector(\"input\");\n      this.current_value = this.free_text_field_input.value.split(/[\\s,]+/).filter(e => e.trim().length > 0);\n      this.array_hashtags_init = this.current_value;\n      this.array_hashtags = this.current_value;\n      this.initFakeInputs();\n      this.free_text_field_input.classList.add(\"hide\");\n      this.tempInputWrapper = document.createElement('div');\n      this.tempInputWrapper.classList.add(\"tag-list-wrapper\");\n      this.tempInputWrapper.appendChild(this.tempInput);\n      this.el.querySelector(\".ginput_container\").appendChild(this.tempInputWrapper);\n    }\n    createFakeInput() {\n      var again = true;\n      let array_hashtags_cleaned_up = this.array_hashtags.map(str => str.replace(new RegExp(\"#\", 'g'), ''));\n      this.free_text_field_input.value = array_hashtags_cleaned_up.join(',');\n      this.createInputTag(again);\n    }\n    initFakeInputs() {\n      var again = false;\n      this.tempInput = document.createElement('div');\n      this.tempInput.classList.add(\"form-tag-list\");\n      // Create existing tags\n      this.array_hashtags.forEach(hashtag => {\n        const span = document.createElement('span');\n        const node = document.createTextNode('#' + hashtag);\n        span.classList.add(\"tag\");\n        span.appendChild(node);\n\n        // Add delete button to each tag\n        const deleteButton = document.createElement('button');\n        deleteButton.classList.add(\"delete-tag\");\n        deleteButton.textContent = \"x\";\n        deleteButton.addEventListener('click', () => this.deleteTag(span, hashtag));\n        span.appendChild(deleteButton);\n        this.tempInput.appendChild(span);\n      });\n      this.createInputTag(again);\n    }\n    createInputTag(again) {\n      // Vrifier s'il y a dj un input \"new-tag\" avant d'en crer un autre\n      const existingNewTag = this.tempInput.querySelector('.new-tag');\n      if (existingNewTag) {\n        return; // Si un lment \"new-tag\" existe dj, on ne cre pas de nouvel input\n      }\n      var input, inputSpan;\n      inputSpan = document.createElement('span');\n      inputSpan.classList.add(\"new-tag\");\n      input = document.createElement(\"input\");\n      input.classList = \"new-tag-input\";\n      input.type = \"text\";\n      input.style.width = \"40px\"; // Fixer la largeur initiale\n      inputSpan.appendChild(input);\n      this.tempInput.appendChild(inputSpan);\n      if (again) {\n        input.focus();\n      }\n      this.tempInput.input = input;\n      this.tempInput.inputSpan = inputSpan;\n      this.tempInput.that = this;\n      this.tempInput.again = again;\n      this.tempInput.addEventListener('click', this.focusFakeInput, false);\n      this.tempInput.addEventListener(\"keydown\", this.checkKeyDown, false);\n    }\n    checkKeyDown(event) {\n      var inputLength = event.currentTarget.input.value.length;\n      event.currentTarget.input.style.width = inputLength * 10 + 40 + \"px\";\n      if (event.key === \"#\") {\n        // this.initHashtag();\n      } else if (arrayOfFireKeys.includes(event.key)) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.currentTarget.that.closeHashtag(event.currentTarget.inputSpan, event.currentTarget.input);\n        event.currentTarget.input.value = \"\";\n      } else if (event.key === \"Backspace\") {\n        if (event.currentTarget.input.value.length < 1) {\n          event.currentTarget.that.deleteLastHashtag();\n        }\n      }\n    }\n    deleteLastHashtag() {\n      this.array_hashtags.pop();\n      var tags = this.tempInput.getElementsByClassName('tag');\n      var newTag = this.tempInput.querySelector('.new-tag');\n      var lastTagEl = tags[tags.length - 1];\n\n      // Ajout d'une vrification pour viter d'essayer de supprimer un lment inexistant\n      if (lastTagEl) {\n        lastTagEl.remove();\n        this.createFakeInput();\n      }\n    }\n    deleteTag(tagEl, hashtag) {\n      // Vrification si le tag existe avant d'essayer de le supprimer\n      if (tagEl && tagEl.parentNode) {\n        // Supprimer le hashtag de l'array\n        const index = this.array_hashtags.indexOf(hashtag);\n        if (index !== -1) {\n          this.array_hashtags.splice(index, 1);\n        }\n\n        // Supprimer l'lment DOM\n        tagEl.parentNode.removeChild(tagEl);\n\n        // Mettre  jour l'affichage\n        this.createFakeInput();\n      }\n    }\n    closeHashtag(inputSpan, input) {\n      var realInput = input.value.replace(\"#\", \"\").replace(\" \", \"\");\n      if (realInput.length > 1) {\n        this.array_hashtags.push(\"#\" + realInput);\n        const node = document.createTextNode(\"#\" + realInput);\n        inputSpan.classList.add(\"tag\");\n        inputSpan.classList.remove(\"new-tag\");\n        inputSpan.appendChild(node);\n\n        // Ajouter le bouton de suppression au nouveau tag\n        const deleteButton = document.createElement('button');\n        deleteButton.classList.add(\"delete-tag\");\n        deleteButton.textContent = \"x\";\n        deleteButton.addEventListener('click', () => this.deleteTag(inputSpan, realInput));\n        inputSpan.appendChild(deleteButton);\n        inputSpan.focus();\n        input.remove();\n        this.tempInput.removeEventListener(\"keydown\", this.checkKeyDown, false);\n        this.createFakeInput();\n      }\n    }\n    focusFakeInput(evt) {\n      evt.preventDefault();\n      evt.currentTarget.input.focus();\n      evt.currentTarget.removeEventListener('click', this.focusFakeInput, false);\n    }\n  }\n  const arrayOfFireKeys = [\" \", \"Enter\", \",\"];\n  const taxonomies_fields = document.querySelectorAll(\".dynamic-tags\");\n  if (taxonomies_fields.length) {\n    [...taxonomies_fields].map(taxonomies_field => new TaxonomiesField(taxonomies_field));\n  }\n  document.addEventListener('DOMContentLoaded', function () {\n    if (window.jQuery) {\n      jQuery(document).on('gform_page_loaded', function (event, form_id, current_page) {\n        const taxonomies_fields = document.querySelectorAll(\".dynamic-tags\");\n        if (taxonomies_fields.length) {\n          [...taxonomies_fields].map(taxonomies_field => new TaxonomiesField(taxonomies_field));\n        }\n      });\n    }\n  });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tags_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxDQUFDO1FBQ3pGO01BQ0YsQ0FBQyxDQUFDO0lBQ0o7RUFDRixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsaUVBQWVoRixTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL2NvbXBvbmVudHMvdGFncy5qcz9jZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFRhZ3NfSW5pdCA9ICgpID0+IHtcclxuICBjbGFzcyBUYXhvbm9taWVzRmllbGQge1xyXG4gICAgY29uc3RydWN0b3IoZWwpIHtcclxuICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICB0aGlzLmZyZWVfdGV4dF9maWVsZCA9IHRoaXMuZWw7XHJcbiAgICAgIHRoaXMuZnJlZV90ZXh0X2ZpZWxkX2lucHV0ID0gdGhpcy5mcmVlX3RleHRfZmllbGQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRfdmFsdWUgPSB0aGlzLmZyZWVfdGV4dF9maWVsZF9pbnB1dC52YWx1ZS5zcGxpdCgvW1xccyxdKy8pLmZpbHRlcihlID0+IGUudHJpbSgpLmxlbmd0aCA+IDApO1xyXG4gICAgICB0aGlzLmFycmF5X2hhc2h0YWdzX2luaXQgPSB0aGlzLmN1cnJlbnRfdmFsdWU7XHJcbiAgICAgIHRoaXMuYXJyYXlfaGFzaHRhZ3MgPSB0aGlzLmN1cnJlbnRfdmFsdWU7XHJcbiAgICAgIHRoaXMuaW5pdEZha2VJbnB1dHMoKTtcclxuXHJcbiAgICAgIHRoaXMuZnJlZV90ZXh0X2ZpZWxkX2lucHV0LmNsYXNzTGlzdC5hZGQoXCJoaWRlXCIpO1xyXG5cclxuICAgICAgdGhpcy50ZW1wSW5wdXRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIHRoaXMudGVtcElucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFwidGFnLWxpc3Qtd3JhcHBlclwiKTtcclxuXHJcbiAgICAgIHRoaXMudGVtcElucHV0V3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnRlbXBJbnB1dCk7XHJcbiAgICAgIHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5naW5wdXRfY29udGFpbmVyXCIpLmFwcGVuZENoaWxkKHRoaXMudGVtcElucHV0V3JhcHBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlRmFrZUlucHV0KCkge1xyXG4gICAgICB2YXIgYWdhaW4gPSB0cnVlO1xyXG4gICAgICBsZXQgYXJyYXlfaGFzaHRhZ3NfY2xlYW5lZF91cCA9IHRoaXMuYXJyYXlfaGFzaHRhZ3MubWFwKHN0ciA9PiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiI1wiLCAnZycpLCAnJykpO1xyXG4gICAgICB0aGlzLmZyZWVfdGV4dF9maWVsZF9pbnB1dC52YWx1ZSA9IGFycmF5X2hhc2h0YWdzX2NsZWFuZWRfdXAuam9pbignLCcpO1xyXG4gICAgICB0aGlzLmNyZWF0ZUlucHV0VGFnKGFnYWluKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0RmFrZUlucHV0cygpIHtcclxuICAgICAgdmFyIGFnYWluID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudGVtcElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIHRoaXMudGVtcElucHV0LmNsYXNzTGlzdC5hZGQoXCJmb3JtLXRhZy1saXN0XCIpO1xyXG4gICAgICAvLyBDcmVhdGUgZXhpc3RpbmcgdGFnc1xyXG4gICAgICB0aGlzLmFycmF5X2hhc2h0YWdzLmZvckVhY2goaGFzaHRhZyA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyMnICsgaGFzaHRhZyk7XHJcbiAgICAgICAgc3Bhbi5jbGFzc0xpc3QuYWRkKFwidGFnXCIpO1xyXG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQobm9kZSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBkZWxldGUgYnV0dG9uIHRvIGVhY2ggdGFnXHJcbiAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgZGVsZXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkZWxldGUtdGFnXCIpO1xyXG4gICAgICAgIGRlbGV0ZUJ1dHRvbi50ZXh0Q29udGVudCA9IFwieFwiO1xyXG4gICAgICAgIGRlbGV0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuZGVsZXRlVGFnKHNwYW4sIGhhc2h0YWcpKTtcclxuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRlbGV0ZUJ1dHRvbik7XHJcblxyXG4gICAgICAgIHRoaXMudGVtcElucHV0LmFwcGVuZENoaWxkKHNwYW4pO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5jcmVhdGVJbnB1dFRhZyhhZ2Fpbik7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlSW5wdXRUYWcoYWdhaW4pIHtcclxuICAgICAgLy8gVsOpcmlmaWVyIHMnaWwgeSBhIGTDqWrDoCB1biBpbnB1dCBcIm5ldy10YWdcIiBhdmFudCBkJ2VuIGNyw6llciB1biBhdXRyZVxyXG4gICAgICBjb25zdCBleGlzdGluZ05ld1RhZyA9IHRoaXMudGVtcElucHV0LnF1ZXJ5U2VsZWN0b3IoJy5uZXctdGFnJyk7XHJcbiAgICAgIGlmIChleGlzdGluZ05ld1RhZykge1xyXG4gICAgICAgIHJldHVybjsgIC8vIFNpIHVuIMOpbMOpbWVudCBcIm5ldy10YWdcIiBleGlzdGUgZMOpasOgLCBvbiBuZSBjcsOpZSBwYXMgZGUgbm91dmVsIGlucHV0XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpbnB1dCwgaW5wdXRTcGFuO1xyXG4gICAgICBpbnB1dFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgIGlucHV0U3Bhbi5jbGFzc0xpc3QuYWRkKFwibmV3LXRhZ1wiKTtcclxuICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgIGlucHV0LmNsYXNzTGlzdCA9IFwibmV3LXRhZy1pbnB1dFwiO1xyXG4gICAgICBpbnB1dC50eXBlID0gXCJ0ZXh0XCI7XHJcbiAgICAgIGlucHV0LnN0eWxlLndpZHRoID0gXCI0MHB4XCI7ICAvLyBGaXhlciBsYSBsYXJnZXVyIGluaXRpYWxlXHJcbiAgICAgIGlucHV0U3Bhbi5hcHBlbmRDaGlsZChpbnB1dCk7XHJcbiAgICAgIHRoaXMudGVtcElucHV0LmFwcGVuZENoaWxkKGlucHV0U3Bhbik7XHJcblxyXG4gICAgICBpZiAoYWdhaW4pIHtcclxuICAgICAgICBpbnB1dC5mb2N1cygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnRlbXBJbnB1dC5pbnB1dCA9IGlucHV0O1xyXG4gICAgICB0aGlzLnRlbXBJbnB1dC5pbnB1dFNwYW4gPSBpbnB1dFNwYW47XHJcbiAgICAgIHRoaXMudGVtcElucHV0LnRoYXQgPSB0aGlzO1xyXG4gICAgICB0aGlzLnRlbXBJbnB1dC5hZ2FpbiA9IGFnYWluO1xyXG4gICAgICB0aGlzLnRlbXBJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZm9jdXNGYWtlSW5wdXQsIGZhbHNlKTtcclxuICAgICAgdGhpcy50ZW1wSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5jaGVja0tleURvd24sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGVja0tleURvd24oZXZlbnQpIHtcclxuICAgICAgdmFyIGlucHV0TGVuZ3RoID0gZXZlbnQuY3VycmVudFRhcmdldC5pbnB1dC52YWx1ZS5sZW5ndGg7XHJcblxyXG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0LmlucHV0LnN0eWxlLndpZHRoID0gKChpbnB1dExlbmd0aCAqIDEwKSArIDQwKSArIFwicHhcIjtcclxuXHJcbiAgICAgIGlmIChldmVudC5rZXkgPT09IFwiI1wiKSB7XHJcbiAgICAgICAgLy8gdGhpcy5pbml0SGFzaHRhZygpO1xyXG4gICAgICB9IGVsc2UgaWYgKGFycmF5T2ZGaXJlS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LnRoYXQuY2xvc2VIYXNodGFnKGV2ZW50LmN1cnJlbnRUYXJnZXQuaW5wdXRTcGFuLCBldmVudC5jdXJyZW50VGFyZ2V0LmlucHV0KTtcclxuICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LmlucHV0LnZhbHVlID0gXCJcIjtcclxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcclxuICAgICAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldC5pbnB1dC52YWx1ZS5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LnRoYXQuZGVsZXRlTGFzdEhhc2h0YWcoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVMYXN0SGFzaHRhZygpIHtcclxuICAgICAgdGhpcy5hcnJheV9oYXNodGFncy5wb3AoKTtcclxuICAgICAgdmFyIHRhZ3MgPSB0aGlzLnRlbXBJbnB1dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0YWcnKTtcclxuICAgICAgdmFyIG5ld1RhZyA9IHRoaXMudGVtcElucHV0LnF1ZXJ5U2VsZWN0b3IoJy5uZXctdGFnJyk7XHJcbiAgICAgIHZhciBsYXN0VGFnRWwgPSB0YWdzW3RhZ3MubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAvLyBBam91dCBkJ3VuZSB2w6lyaWZpY2F0aW9uIHBvdXIgw6l2aXRlciBkJ2Vzc2F5ZXIgZGUgc3VwcHJpbWVyIHVuIMOpbMOpbWVudCBpbmV4aXN0YW50XHJcbiAgICAgIGlmIChsYXN0VGFnRWwpIHtcclxuICAgICAgICBsYXN0VGFnRWwucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVGYWtlSW5wdXQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZVRhZyh0YWdFbCwgaGFzaHRhZykge1xyXG4gICAgICAvLyBWw6lyaWZpY2F0aW9uIHNpIGxlIHRhZyBleGlzdGUgYXZhbnQgZCdlc3NheWVyIGRlIGxlIHN1cHByaW1lclxyXG4gICAgICBpZiAodGFnRWwgJiYgdGFnRWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIC8vIFN1cHByaW1lciBsZSBoYXNodGFnIGRlIGwnYXJyYXlcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYXJyYXlfaGFzaHRhZ3MuaW5kZXhPZihoYXNodGFnKTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICB0aGlzLmFycmF5X2hhc2h0YWdzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdXBwcmltZXIgbCfDqWzDqW1lbnQgRE9NXHJcbiAgICAgICAgdGFnRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWdFbCk7XHJcblxyXG4gICAgICAgIC8vIE1ldHRyZSDDoCBqb3VyIGwnYWZmaWNoYWdlXHJcbiAgICAgICAgdGhpcy5jcmVhdGVGYWtlSW5wdXQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlSGFzaHRhZyhpbnB1dFNwYW4sIGlucHV0KSB7XHJcbiAgICAgIHZhciByZWFsSW5wdXQgPSBpbnB1dC52YWx1ZS5yZXBsYWNlKFwiI1wiLCBcIlwiKS5yZXBsYWNlKFwiIFwiLCBcIlwiKTtcclxuICAgICAgaWYgKHJlYWxJbnB1dC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgdGhpcy5hcnJheV9oYXNodGFncy5wdXNoKFwiI1wiICsgcmVhbElucHV0KTtcclxuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIjXCIgKyByZWFsSW5wdXQpO1xyXG4gICAgICAgIGlucHV0U3Bhbi5jbGFzc0xpc3QuYWRkKFwidGFnXCIpO1xyXG4gICAgICAgIGlucHV0U3Bhbi5jbGFzc0xpc3QucmVtb3ZlKFwibmV3LXRhZ1wiKTtcclxuICAgICAgICBpbnB1dFNwYW4uYXBwZW5kQ2hpbGQobm9kZSk7XHJcblxyXG4gICAgICAgIC8vIEFqb3V0ZXIgbGUgYm91dG9uIGRlIHN1cHByZXNzaW9uIGF1IG5vdXZlYXUgdGFnXHJcbiAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgZGVsZXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkZWxldGUtdGFnXCIpO1xyXG4gICAgICAgIGRlbGV0ZUJ1dHRvbi50ZXh0Q29udGVudCA9IFwieFwiO1xyXG4gICAgICAgIGRlbGV0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuZGVsZXRlVGFnKGlucHV0U3BhbiwgcmVhbElucHV0KSk7XHJcbiAgICAgICAgaW5wdXRTcGFuLmFwcGVuZENoaWxkKGRlbGV0ZUJ1dHRvbik7XHJcblxyXG4gICAgICAgIGlucHV0U3Bhbi5mb2N1cygpO1xyXG4gICAgICAgIGlucHV0LnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMudGVtcElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuY2hlY2tLZXlEb3duLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVGYWtlSW5wdXQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvY3VzRmFrZUlucHV0KGV2dCkge1xyXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQuaW5wdXQuZm9jdXMoKTtcclxuICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmZvY3VzRmFrZUlucHV0LCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBhcnJheU9mRmlyZUtleXMgPSBbXCIgXCIsIFwiRW50ZXJcIiwgXCIsXCJdO1xyXG5cclxuICBjb25zdCB0YXhvbm9taWVzX2ZpZWxkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZHluYW1pYy10YWdzXCIpO1xyXG5cclxuICBpZiAodGF4b25vbWllc19maWVsZHMubGVuZ3RoKSB7XHJcbiAgICBbLi4udGF4b25vbWllc19maWVsZHNdLm1hcCgodGF4b25vbWllc19maWVsZCkgPT4gbmV3IFRheG9ub21pZXNGaWVsZCh0YXhvbm9taWVzX2ZpZWxkKSk7XHJcbiAgfVxyXG5cclxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHdpbmRvdy5qUXVlcnkpIHtcclxuICAgICAgalF1ZXJ5KGRvY3VtZW50KS5vbignZ2Zvcm1fcGFnZV9sb2FkZWQnLCBmdW5jdGlvbiAoZXZlbnQsIGZvcm1faWQsIGN1cnJlbnRfcGFnZSkge1xyXG4gICAgICAgIGNvbnN0IHRheG9ub21pZXNfZmllbGRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5keW5hbWljLXRhZ3NcIik7XHJcblxyXG4gICAgICAgIGlmICh0YXhvbm9taWVzX2ZpZWxkcy5sZW5ndGgpIHtcclxuICAgICAgICAgIFsuLi50YXhvbm9taWVzX2ZpZWxkc10ubWFwKCh0YXhvbm9taWVzX2ZpZWxkKSA9PiBuZXcgVGF4b25vbWllc0ZpZWxkKHRheG9ub21pZXNfZmllbGQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWdzX0luaXQ7XHJcbiJdLCJuYW1lcyI6WyJUYWdzX0luaXQiLCJUYXhvbm9taWVzRmllbGQiLCJjb25zdHJ1Y3RvciIsImVsIiwiZnJlZV90ZXh0X2ZpZWxkIiwiZnJlZV90ZXh0X2ZpZWxkX2lucHV0IiwicXVlcnlTZWxlY3RvciIsImN1cnJlbnRfdmFsdWUiLCJ2YWx1ZSIsInNwbGl0IiwiZmlsdGVyIiwiZSIsInRyaW0iLCJsZW5ndGgiLCJhcnJheV9oYXNodGFnc19pbml0IiwiYXJyYXlfaGFzaHRhZ3MiLCJpbml0RmFrZUlucHV0cyIsImNsYXNzTGlzdCIsImFkZCIsInRlbXBJbnB1dFdyYXBwZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInRlbXBJbnB1dCIsImNyZWF0ZUZha2VJbnB1dCIsImFnYWluIiwiYXJyYXlfaGFzaHRhZ3NfY2xlYW5lZF91cCIsIm1hcCIsInN0ciIsInJlcGxhY2UiLCJSZWdFeHAiLCJqb2luIiwiY3JlYXRlSW5wdXRUYWciLCJmb3JFYWNoIiwiaGFzaHRhZyIsInNwYW4iLCJub2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJkZWxldGVCdXR0b24iLCJ0ZXh0Q29udGVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZWxldGVUYWciLCJleGlzdGluZ05ld1RhZyIsImlucHV0IiwiaW5wdXRTcGFuIiwidHlwZSIsInN0eWxlIiwid2lkdGgiLCJmb2N1cyIsInRoYXQiLCJmb2N1c0Zha2VJbnB1dCIsImNoZWNrS2V5RG93biIsImV2ZW50IiwiaW5wdXRMZW5ndGgiLCJjdXJyZW50VGFyZ2V0Iiwia2V5IiwiYXJyYXlPZkZpcmVLZXlzIiwiaW5jbHVkZXMiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImNsb3NlSGFzaHRhZyIsImRlbGV0ZUxhc3RIYXNodGFnIiwicG9wIiwidGFncyIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJuZXdUYWciLCJsYXN0VGFnRWwiLCJyZW1vdmUiLCJ0YWdFbCIsInBhcmVudE5vZGUiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJyZW1vdmVDaGlsZCIsInJlYWxJbnB1dCIsInB1c2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZ0IiwidGF4b25vbWllc19maWVsZHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidGF4b25vbWllc19maWVsZCIsIndpbmRvdyIsImpRdWVyeSIsIm9uIiwiZm9ybV9pZCIsImN1cnJlbnRfcGFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/components/tags.js\n");

/***/ }),

/***/ "./src/js/components/tooltip.js":
/*!**************************************!*\
  !*** ./src/js/components/tooltip.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n// import { createPopper } from '@popperjs/core';\n// import { createPopper } from '@popperjs/core/lib/popper-lite';\n\n\n\n\n// Global settings\nconst tooltipMargin = '16';\nconst Tootlip_Init = data => {\n  class Tooltip {\n    constructor(el) {\n      this.el = el;\n      this.popperInstance = null;\n      this.targetId = this.el.getAttribute('data-tooltip');\n      this.targetEl = document.getElementById(this.targetId);\n      this.arrowEl = this.targetEl.querySelector(\".arrow\");\n      this.placement = this.el.getAttribute('data-tooltip-placement') || 'top';\n      this.events = this.el.getAttribute('data-tooltip-events') || 'hover';\n      const showEvents = this.events === 'click' ? ['click'] : ['mouseenter'];\n      const hideEvents = this.events === 'click' ? ['click'] : ['mouseleave'];\n\n      // this.hide();\n\n      this.el.addEventListener('click', e => {\n        e.preventDefault();\n        e.stopPropagation();\n        if (this.targetEl.hasAttribute('data-show')) {\n          this.hide(this.el, this.targetEl);\n        } else {\n          this.show(this.el, this.targetEl);\n        }\n      });\n      window.addEventListener(\"click\", e => {\n        if (!e.target.closest('#tooltip-notification') && !e.target.closest('.tooltip-pill.notifications') && this.targetEl.hasAttribute('data-show')) {\n          this.hide(this.el, this.targetEl);\n        }\n      });\n    }\n    show(triggerEl, targetEl) {\n      this.targetEl.setAttribute('data-show', '');\n      (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(triggerEl, targetEl, {\n        placement: this.placement,\n        middleware: [(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset)(4)]\n      }).then(({\n        x,\n        y\n      }) => {\n        Object.assign(targetEl.style, {\n          left: `${x}px`,\n          top: `${y}px`\n        });\n      });\n    }\n    hide(triggerEl, targetEl) {\n      this.targetEl.removeAttribute('data-show');\n    }\n  }\n  const tooltips = document.querySelectorAll('[data-tooltip]');\n  if (tooltips.length) {\n    [...tooltips].map(tooltip => new Tooltip(tooltip));\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tootlip_Init);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxNQUFNLENBQUNDLE1BQU0sQ0FBQ3pCLFFBQVEsQ0FBQzBCLEtBQUssRUFBRTtVQUM1QkMsSUFBSSxFQUFFLEdBQUdMLENBQUMsSUFBSTtVQUNkTSxHQUFHLEVBQUUsR0FBR0wsQ0FBQztRQUNYLENBQUMsQ0FBQztNQUNILENBQUMsQ0FBQztJQUNIO0lBQ0FyQyxJQUFJQSxDQUFDZ0MsU0FBUyxFQUFFbEIsUUFBUSxFQUFFO01BQ3pCLElBQUksQ0FBQ0EsUUFBUSxDQUFDNkIsZUFBZSxDQUFDLFdBQVcsQ0FBQztJQUMzQztFQUNEO0VBRUEsTUFBTUMsUUFBUSxHQUFHN0IsUUFBUSxDQUFDOEIsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUM7RUFFNUQsSUFBSUQsUUFBUSxDQUFDRSxNQUFNLEVBQUU7SUFDbkIsQ0FBQyxHQUFHRixRQUFRLENBQUMsQ0FBQ0csR0FBRyxDQUFFQyxPQUFPLElBQUssSUFBSXhDLE9BQU8sQ0FBQ3dDLE9BQU8sQ0FBQyxDQUFDO0VBQ3REO0FBQ0QsQ0FBQztBQUVELGlFQUFlMUMsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9jb21wb25lbnRzL3Rvb2x0aXAuanM/ZmY2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XHJcbi8vIGltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZSc7XHJcbmltcG9ydCB7Y29tcHV0ZVBvc2l0aW9ufSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcclxuaW1wb3J0IHthcnJvdywgaGlkZSwgb2Zmc2V0LCBmbGlwLCBzaGlmdH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XHJcbmltcG9ydCB7YXV0b1BsYWNlbWVudH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XHJcblxyXG4vLyBHbG9iYWwgc2V0dGluZ3NcclxuY29uc3QgdG9vbHRpcE1hcmdpbiA9ICcxNic7XHJcblxyXG5jb25zdCBUb290bGlwX0luaXQgPSAoZGF0YSkgPT4ge1xyXG5cdGNsYXNzIFRvb2x0aXAge1xyXG5cdFx0Y29uc3RydWN0b3IoZWwpIHtcclxuXHRcdFx0dGhpcy5lbCA9IGVsO1xyXG5cdFx0XHR0aGlzLnBvcHBlckluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvb2x0aXAnKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB0aGlzLmFycm93RWwgPSB0aGlzLnRhcmdldEVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXJyb3dcIik7XHJcblx0XHRcdHRoaXMucGxhY2VtZW50ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcC1wbGFjZW1lbnQnKSB8fCAndG9wJztcclxuXHRcdFx0dGhpcy5ldmVudHMgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLWV2ZW50cycpIHx8ICdob3Zlcic7XHJcblxyXG5cclxuXHRcdFx0Y29uc3Qgc2hvd0V2ZW50cyA9ICh0aGlzLmV2ZW50cyA9PT0gJ2NsaWNrJykgPyBbJ2NsaWNrJ10gOiAgWydtb3VzZWVudGVyJ10gO1xyXG5cdFx0XHRjb25zdCBoaWRlRXZlbnRzID0gKHRoaXMuZXZlbnRzID09PSAnY2xpY2snKSA/IFsnY2xpY2snXSA6ICBbJ21vdXNlbGVhdmUnXSA7XHJcblxyXG5cdFx0XHQvLyB0aGlzLmhpZGUoKTtcclxuXHJcblx0XHRcdHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTsgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRpZih0aGlzLnRhcmdldEVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zaG93Jykpe1xyXG5cdFx0XHRcdFx0dGhpcy5oaWRlKHRoaXMuZWwsIHRoaXMudGFyZ2V0RWwpO1xyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0dGhpcy5zaG93KHRoaXMuZWwsIHRoaXMudGFyZ2V0RWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHRcdFxyXG5cclxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xyXG5cdFx0XHRcdGlmICghZS50YXJnZXQuY2xvc2VzdCgnI3Rvb2x0aXAtbm90aWZpY2F0aW9uJykgJiYgIWUudGFyZ2V0LmNsb3Nlc3QoJy50b29sdGlwLXBpbGwubm90aWZpY2F0aW9ucycpICYmIHRoaXMudGFyZ2V0RWwuaGFzQXR0cmlidXRlKCdkYXRhLXNob3cnKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5oaWRlKHRoaXMuZWwsIHRoaXMudGFyZ2V0RWwpO1xyXG5cdFx0XHRcdCAgfVxyXG5cdFx0XHR9KTtcclxuXHJcblxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHRcdHNob3codHJpZ2dlckVsLCB0YXJnZXRFbCkge1xyXG5cdFx0XHR0aGlzLnRhcmdldEVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zaG93JywgJycpO1xyXG5cclxuXHRcdFx0Y29tcHV0ZVBvc2l0aW9uKHRyaWdnZXJFbCwgdGFyZ2V0RWwsIHtcclxuXHRcdFx0XHRwbGFjZW1lbnQ6IHRoaXMucGxhY2VtZW50LFxyXG5cdFx0XHRcdG1pZGRsZXdhcmU6IFtvZmZzZXQoNCldLFxyXG5cdFx0XHQgIH0pLnRoZW4oKHt4LCB5fSkgPT4ge1xyXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24odGFyZ2V0RWwuc3R5bGUsIHtcclxuXHRcdFx0XHQgIGxlZnQ6IGAke3h9cHhgLFxyXG5cdFx0XHRcdCAgdG9wOiBgJHt5fXB4YCxcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRoaWRlKHRyaWdnZXJFbCwgdGFyZ2V0RWwpIHtcclxuXHRcdFx0dGhpcy50YXJnZXRFbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc2hvdycpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y29uc3QgdG9vbHRpcHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b29sdGlwXScpO1xyXG5cdFxyXG5cdGlmICh0b29sdGlwcy5sZW5ndGgpIHtcclxuXHQgIFsuLi50b29sdGlwc10ubWFwKCh0b29sdGlwKSA9PiBuZXcgVG9vbHRpcCh0b29sdGlwKSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUb290bGlwX0luaXQ7XHJcbiJdLCJuYW1lcyI6WyJjb21wdXRlUG9zaXRpb24iLCJhcnJvdyIsImhpZGUiLCJvZmZzZXQiLCJmbGlwIiwic2hpZnQiLCJhdXRvUGxhY2VtZW50IiwidG9vbHRpcE1hcmdpbiIsIlRvb3RsaXBfSW5pdCIsImRhdGEiLCJUb29sdGlwIiwiY29uc3RydWN0b3IiLCJlbCIsInBvcHBlckluc3RhbmNlIiwidGFyZ2V0SWQiLCJnZXRBdHRyaWJ1dGUiLCJ0YXJnZXRFbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJhcnJvd0VsIiwicXVlcnlTZWxlY3RvciIsInBsYWNlbWVudCIsImV2ZW50cyIsInNob3dFdmVudHMiLCJoaWRlRXZlbnRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImhhc0F0dHJpYnV0ZSIsInNob3ciLCJ3aW5kb3ciLCJ0YXJnZXQiLCJjbG9zZXN0IiwidHJpZ2dlckVsIiwic2V0QXR0cmlidXRlIiwibWlkZGxld2FyZSIsInRoZW4iLCJ4IiwieSIsIk9iamVjdCIsImFzc2lnbiIsInN0eWxlIiwibGVmdCIsInRvcCIsInJlbW92ZUF0dHJpYnV0ZSIsInRvb2x0aXBzIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsIm1hcCIsInRvb2x0aXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/components/tooltip.js\n");

/***/ }),

/***/ "./src/js/functional/relations.js":
/*!****************************************!*\
  !*** ./src/js/functional/relations.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeRelationBtw: () => (/* binding */ makeRelationBtw)\n/* harmony export */ });\nconst makeRelationBtw = (me, him, post_type_clicked_on, relationBtn) => {\n  console.log(post_type_clicked_on);\n  const request = new XMLHttpRequest();\n  const adminAjaxUrl = document.querySelector('.main').getAttribute('data-admin-ajax');\n  request.open('POST', adminAjaxUrl, true);\n  request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;');\n  request.onload = function () {\n    console.log(this.response);\n    console.log(this.status);\n    if (this.status >= 200 && this.status < 400) {\n      //console.log(relation_type);\n      const relation_type = relationBtn.getAttribute(\"data-relation-type\");\n      if (relation_type === \"request-contact-list\") {\n        relationBtn.querySelector(\".btn__label\").innerHTML = \"\";\n        if (this.response === \"Contact request send\") {\n          relationBtn.classList.add(\"relation_btn--contact-requested\");\n          relationBtn.querySelector(\".btn__label\").innerHTML = decodeURIComponent(relationBtn.getAttribute(\"data-request-contact-requested\"));\n          relationBtn.querySelector(\".o-svg-icon\").innerHTML = \"<svg width=\\'24\\' height=\\'25\\' viewBox=\\'0 0 24 25\\' fill=\\'none\\' xmlns=\\'http://www.w3.org/2000/svg\\'><path d=\\'M0.75 17.4852C0.751544 15.2186 1.89011 13.1039 3.78149 11.8548C5.67287 10.6057 8.06476 10.3888 10.15 11.2772\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'></path><path fill-rule=\\'evenodd\\' clip-rule=\\'evenodd\\' d=\\'M7.5 9.23535C9.77817 9.23535 11.625 7.38853 11.625 5.11035C11.625 2.83218 9.77817 0.985352 7.5 0.985352C5.22183 0.985352 3.375 2.83218 3.375 5.11035C3.375 7.38853 5.22183 9.23535 7.5 9.23535Z\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'></path><path d=\\'M15 18.9854H11.25V22.7354\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'></path><path d=\\'M22.6668 19.7184C21.8501 22.1049 19.532 23.6452 17.0155 23.4734C14.4989 23.3017 12.4116 21.4607 11.9268 18.9854\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'></path><path d=\\'M19.5 15.9854H23.25V12.2354\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'></path><path d=\\'M11.832 15.2523C12.6487 12.8657 14.9668 11.3254 17.4833 11.4972C19.9999 11.6689 22.0872 13.5099 22.572 15.9853\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'></path></svg>\";\n        } else {\n          relationBtn.classList.remove(\"relation_btn--contact-requested\");\n          relationBtn.querySelector(\".btn__label\").innerHTML = decodeURIComponent(relationBtn.getAttribute(\"data-request-contact-default\"));\n          relationBtn.querySelector(\".o-svg-icon\").innerHTML = \"<svg width=\\'24\\' height=\\'25\\' viewBox=\\'0 0 24 25\\' fill=\\'none\\' xmlns=\\'http://www.w3.org/2000/svg\\'><path fill-rule=\\'evenodd\\' clip-rule=\\'evenodd\\' d=\\'M17.25 23.4854C20.5637 23.4854 23.25 20.7991 23.25 17.4854C23.25 14.1716 20.5637 11.4854 17.25 11.4854C13.9363 11.4854 11.25 14.1716 11.25 17.4854C11.25 20.7991 13.9363 23.4854 17.25 23.4854Z\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'/><path d=\\'M17.25 14.4854V20.4854\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'/><path d=\\'M14.25 17.4854H20.25\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'/><path d=\\'M0.75 17.4852C0.751544 15.2186 1.89011 13.1039 3.78149 11.8548C5.67287 10.6057 8.06476 10.3888 10.15 11.2772\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'/><path fill-rule=\\'evenodd\\' clip-rule=\\'evenodd\\' d=\\'M7.5 9.23535C9.77817 9.23535 11.625 7.38853 11.625 5.11035C11.625 2.83218 9.77817 0.985352 7.5 0.985352C5.22183 0.985352 3.375 2.83218 3.375 5.11035C3.375 7.38853 5.22183 9.23535 7.5 9.23535Z\\' stroke=\\'black\\' stroke-width=\\'1.5\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'/></svg>\";\n        }\n      } else if (relation_type === \"accept-contact-list\") {\n        if (this.response === \"Contact accepted\") {\n          const tooltip = document.querySelector(\"#tooltip-notification\");\n          const tooltip_pill_notifications = document.querySelector(\".tooltip-pill.notifications\");\n          const notification_counter = tooltip_pill_notifications.querySelector(\".notification_counter\");\n          const count_notifications = tooltip.querySelectorAll(\".notifications--section\").length;\n          const current_notification = tooltip.querySelector(\"#notification-\" + him);\n          console.log(current_notification);\n          console.log(count_notifications);\n          current_notification.style.display = \"none\";\n          // get parent box of notification\n          if (count_notifications - 1 <= 0) {\n            tooltip.removeAttribute('data-show');\n            tooltip_pill_notifications.style.display = \"none\";\n          }\n          notification_counter.innerHTML = \"\";\n          notification_counter.innerHTML = count_notifications - 1;\n        }\n      } else if (relation_type === \"refuse-contact-list\") {\n        if (this.response === \"Contact removed\") {\n          relationBtn.classList.remove(\"relation_btn--contact-relation-done\");\n        }\n      } else if (relation_type === \"favorite\" || relation_type === \"like\") {\n        var likeCount = relationBtn.parentElement.querySelector('.count-like_');\n        // Empcher le comportement par dfaut du lien\n\n        // Rcuprer la valeur actuelle du compteur\n        var currentCount = parseInt(likeCount.textContent) ? parseInt(likeCount.textContent) : 0; // Convertir la valeur en nombre\n\n        if (this.response === \"Relation added\") {\n          relationBtn.classList.add(\"relation_btn--checked\");\n          likeCount.textContent = currentCount + 1;\n        } else {\n          relationBtn.classList.remove(\"relation_btn--checked\");\n          likeCount.textContent = currentCount - 1;\n        }\n      } else if (relation_type === \"recommend\") {\n        if (this.response === \"Relation added\") {\n          relationBtn.classList.add(\"relation_btn--checked\");\n        } else {\n          relationBtn.classList.remove(\"relation_btn--checked\");\n        }\n      } else {\n        console.log(\"not recognized\");\n      }\n    } else {\n      // error\n    }\n  };\n  let field_me;\n  let me_uid = 'user_' + me;\n  let him_uid;\n  if (post_type_clicked_on === \"real-estate\") {\n    if (relationBtn.getAttribute(\"data-relation-type\") === \"favorite\") {\n      field_me = \"i_favorite_posts_relationships\";\n    } else {\n      field_me = \"i_like_posts_relationships\";\n    }\n    him_uid = him;\n    request.send('action=makeRelationBtw&me_uid=' + me_uid + '&him=' + him + '&field_me=' + field_me);\n  } else if (post_type_clicked_on === \"users\") {\n    if (relationBtn.getAttribute(\"data-relation-type\") === \"favorite\") {\n      field_me = \"i_favorite_users_relationships\";\n    } else {\n      field_me = \"i_like_users_relationships\";\n    }\n    him_uid = 'user_' + him;\n    request.send('action=makeRelationBtw&me_uid=' + me_uid + '&him=' + him + '&field_me=' + field_me);\n  } else if (post_type_clicked_on === \"request-contact-list\") {\n    field_me = \"i_request_contactlist_users_relationships\";\n    him_uid = 'user_' + him;\n    request.send('action=requestContact&me_uid=' + me_uid + '&him=' + him + '&field_me=' + field_me);\n  } else if (post_type_clicked_on === \"remove-request-contact-list\") {\n    alert(\"TODO: remove-request-contact-list\");\n  } else if (post_type_clicked_on === \"accept-contact-list\") {\n    field_me = \"i_accept_contactlist_users_relationships\";\n    him_uid = 'user_' + him;\n    request.send('action=acceptContact&me_uid=' + me_uid + '&me=' + me + '&him=' + him);\n  } else if (post_type_clicked_on === \"refuse-contact-list\") {\n    if (window.confirm(\"Are you sure you want to delete this user from your contact list ?\")) {\n      field_me = \"i_accept_contactlist_users_relationships\";\n      him_uid = 'user_' + him;\n      request.send('action=refuseContact&me_uid=' + me_uid + '&me=' + me + '&him=' + him);\n    }\n  } else if (post_type_clicked_on === \"recommend\") {\n    console.log(\"recommend\");\n    field_me = \"i_recommend_users_relationships\";\n    him_uid = 'user_' + him;\n    request.send('action=makeRelationBtw&me_uid=' + me_uid + '&him=' + him + '&field_me=' + field_me);\n  }\n  console.log(me_uid + \" :added \" + him_uid + \" on: \" + field_me);\n  request.onerror = function () {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEJpQyxRQUFRLEdBQUcsaUNBQWlDO0lBQzVDRSxPQUFPLEdBQUcsT0FBTyxHQUFHdkMsR0FBRztJQUN2QkssT0FBTyxDQUFDbUMsSUFBSSxDQUFDLGdDQUFnQyxHQUFHRixNQUFNLEdBQUcsT0FBTyxHQUFHdEMsR0FBRyxHQUFHLFlBQVksR0FBR3FDLFFBQVMsQ0FBQztFQUNuRztFQUVBbEMsT0FBTyxDQUFDQyxHQUFHLENBQUNrQyxNQUFNLEdBQUcsVUFBVSxHQUFHQyxPQUFPLEdBQUcsT0FBTyxHQUFHRixRQUFRLENBQUM7RUFFL0RoQyxPQUFPLENBQUN1QyxPQUFPLEdBQUcsWUFBVyxDQUFHLENBQUM7QUFDbEMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9mdW5jdGlvbmFsL3JlbGF0aW9ucy5qcz8wOTM3Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5jb25zdCBtYWtlUmVsYXRpb25CdHcgPSAobWUsIGhpbSwgcG9zdF90eXBlX2NsaWNrZWRfb24sIHJlbGF0aW9uQnRuKSA9PiB7XHJcblx0Y29uc29sZS5sb2cocG9zdF90eXBlX2NsaWNrZWRfb24pO1xyXG5cdGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHRjb25zdCBhZG1pbkFqYXhVcmwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbicpLmdldEF0dHJpYnV0ZSgnZGF0YS1hZG1pbi1hamF4Jyk7XHJcblx0cmVxdWVzdC5vcGVuKCdQT1NUJywgYWRtaW5BamF4VXJsLCB0cnVlKTtcclxuXHRyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Jyk7XHJcblx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdGNvbnNvbGUubG9nKHRoaXMucmVzcG9uc2UpO1xyXG5cdFx0Y29uc29sZS5sb2codGhpcy5zdGF0dXMpO1xyXG5cdFx0aWYodGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgNDAwKSB7XHJcblx0XHRcdC8vY29uc29sZS5sb2cocmVsYXRpb25fdHlwZSk7XHJcblx0XHRcdGNvbnN0IHJlbGF0aW9uX3R5cGUgPSByZWxhdGlvbkJ0bi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlbGF0aW9uLXR5cGVcIik7XHJcblx0XHRcdGlmKHJlbGF0aW9uX3R5cGUgPT09IFwicmVxdWVzdC1jb250YWN0LWxpc3RcIil7XHJcblx0XHRcdFx0cmVsYXRpb25CdG4ucXVlcnlTZWxlY3RvcihcIi5idG5fX2xhYmVsXCIpLmlubmVySFRNTCA9IFwiXCI7XHJcblx0XHRcdFx0aWYodGhpcy5yZXNwb25zZSA9PT0gXCJDb250YWN0IHJlcXVlc3Qgc2VuZFwiKSB7XHJcblx0XHRcdFx0XHRyZWxhdGlvbkJ0bi5jbGFzc0xpc3QuYWRkKFwicmVsYXRpb25fYnRuLS1jb250YWN0LXJlcXVlc3RlZFwiKTtcclxuXHRcdFx0XHRcdHJlbGF0aW9uQnRuLnF1ZXJ5U2VsZWN0b3IoXCIuYnRuX19sYWJlbFwiKS5pbm5lckhUTUwgPSBkZWNvZGVVUklDb21wb25lbnQocmVsYXRpb25CdG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXF1ZXN0LWNvbnRhY3QtcmVxdWVzdGVkXCIpKTtcclxuXHRcdFx0XHRcdHJlbGF0aW9uQnRuLnF1ZXJ5U2VsZWN0b3IoXCIuby1zdmctaWNvblwiKS5pbm5lckhUTUwgPSBcIjxzdmcgd2lkdGg9XFwnMjRcXCcgaGVpZ2h0PVxcJzI1XFwnIHZpZXdCb3g9XFwnMCAwIDI0IDI1XFwnIGZpbGw9XFwnbm9uZVxcJyB4bWxucz1cXCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcJz48cGF0aCBkPVxcJ00wLjc1IDE3LjQ4NTJDMC43NTE1NDQgMTUuMjE4NiAxLjg5MDExIDEzLjEwMzkgMy43ODE0OSAxMS44NTQ4QzUuNjcyODcgMTAuNjA1NyA4LjA2NDc2IDEwLjM4ODggMTAuMTUgMTEuMjc3MlxcJyBzdHJva2U9XFwnYmxhY2tcXCcgc3Ryb2tlLXdpZHRoPVxcJzEuNVxcJyBzdHJva2UtbGluZWNhcD1cXCdyb3VuZFxcJyBzdHJva2UtbGluZWpvaW49XFwncm91bmRcXCc+PC9wYXRoPjxwYXRoIGZpbGwtcnVsZT1cXCdldmVub2RkXFwnIGNsaXAtcnVsZT1cXCdldmVub2RkXFwnIGQ9XFwnTTcuNSA5LjIzNTM1QzkuNzc4MTcgOS4yMzUzNSAxMS42MjUgNy4zODg1MyAxMS42MjUgNS4xMTAzNUMxMS42MjUgMi44MzIxOCA5Ljc3ODE3IDAuOTg1MzUyIDcuNSAwLjk4NTM1MkM1LjIyMTgzIDAuOTg1MzUyIDMuMzc1IDIuODMyMTggMy4zNzUgNS4xMTAzNUMzLjM3NSA3LjM4ODUzIDUuMjIxODMgOS4yMzUzNSA3LjUgOS4yMzUzNVpcXCcgc3Ryb2tlPVxcJ2JsYWNrXFwnIHN0cm9rZS13aWR0aD1cXCcxLjVcXCcgc3Ryb2tlLWxpbmVjYXA9XFwncm91bmRcXCcgc3Ryb2tlLWxpbmVqb2luPVxcJ3JvdW5kXFwnPjwvcGF0aD48cGF0aCBkPVxcJ00xNSAxOC45ODU0SDExLjI1VjIyLjczNTRcXCcgc3Ryb2tlPVxcJ2JsYWNrXFwnIHN0cm9rZS13aWR0aD1cXCcxLjVcXCcgc3Ryb2tlLWxpbmVjYXA9XFwncm91bmRcXCcgc3Ryb2tlLWxpbmVqb2luPVxcJ3JvdW5kXFwnPjwvcGF0aD48cGF0aCBkPVxcJ00yMi42NjY4IDE5LjcxODRDMjEuODUwMSAyMi4xMDQ5IDE5LjUzMiAyMy42NDUyIDE3LjAxNTUgMjMuNDczNEMxNC40OTg5IDIzLjMwMTcgMTIuNDExNiAyMS40NjA3IDExLjkyNjggMTguOTg1NFxcJyBzdHJva2U9XFwnYmxhY2tcXCcgc3Ryb2tlLXdpZHRoPVxcJzEuNVxcJyBzdHJva2UtbGluZWNhcD1cXCdyb3VuZFxcJyBzdHJva2UtbGluZWpvaW49XFwncm91bmRcXCc+PC9wYXRoPjxwYXRoIGQ9XFwnTTE5LjUgMTUuOTg1NEgyMy4yNVYxMi4yMzU0XFwnIHN0cm9rZT1cXCdibGFja1xcJyBzdHJva2Utd2lkdGg9XFwnMS41XFwnIHN0cm9rZS1saW5lY2FwPVxcJ3JvdW5kXFwnIHN0cm9rZS1saW5lam9pbj1cXCdyb3VuZFxcJz48L3BhdGg+PHBhdGggZD1cXCdNMTEuODMyIDE1LjI1MjNDMTIuNjQ4NyAxMi44NjU3IDE0Ljk2NjggMTEuMzI1NCAxNy40ODMzIDExLjQ5NzJDMTkuOTk5OSAxMS42Njg5IDIyLjA4NzIgMTMuNTA5OSAyMi41NzIgMTUuOTg1M1xcJyBzdHJva2U9XFwnYmxhY2tcXCcgc3Ryb2tlLXdpZHRoPVxcJzEuNVxcJyBzdHJva2UtbGluZWNhcD1cXCdyb3VuZFxcJyBzdHJva2UtbGluZWpvaW49XFwncm91bmRcXCc+PC9wYXRoPjwvc3ZnPlwiO1xyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0cmVsYXRpb25CdG4uY2xhc3NMaXN0LnJlbW92ZShcInJlbGF0aW9uX2J0bi0tY29udGFjdC1yZXF1ZXN0ZWRcIik7XHJcblx0XHRcdFx0XHRyZWxhdGlvbkJ0bi5xdWVyeVNlbGVjdG9yKFwiLmJ0bl9fbGFiZWxcIikuaW5uZXJIVE1MID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlbGF0aW9uQnRuLmdldEF0dHJpYnV0ZShcImRhdGEtcmVxdWVzdC1jb250YWN0LWRlZmF1bHRcIikpO1xyXG5cdFx0XHRcdFx0cmVsYXRpb25CdG4ucXVlcnlTZWxlY3RvcihcIi5vLXN2Zy1pY29uXCIpLmlubmVySFRNTCA9IFwiPHN2ZyB3aWR0aD1cXCcyNFxcJyBoZWlnaHQ9XFwnMjVcXCcgdmlld0JveD1cXCcwIDAgMjQgMjVcXCcgZmlsbD1cXCdub25lXFwnIHhtbG5zPVxcJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFwnPjxwYXRoIGZpbGwtcnVsZT1cXCdldmVub2RkXFwnIGNsaXAtcnVsZT1cXCdldmVub2RkXFwnIGQ9XFwnTTE3LjI1IDIzLjQ4NTRDMjAuNTYzNyAyMy40ODU0IDIzLjI1IDIwLjc5OTEgMjMuMjUgMTcuNDg1NEMyMy4yNSAxNC4xNzE2IDIwLjU2MzcgMTEuNDg1NCAxNy4yNSAxMS40ODU0QzEzLjkzNjMgMTEuNDg1NCAxMS4yNSAxNC4xNzE2IDExLjI1IDE3LjQ4NTRDMTEuMjUgMjAuNzk5MSAxMy45MzYzIDIzLjQ4NTQgMTcuMjUgMjMuNDg1NFpcXCcgc3Ryb2tlPVxcJ2JsYWNrXFwnIHN0cm9rZS13aWR0aD1cXCcxLjVcXCcgc3Ryb2tlLWxpbmVjYXA9XFwncm91bmRcXCcgc3Ryb2tlLWxpbmVqb2luPVxcJ3JvdW5kXFwnLz48cGF0aCBkPVxcJ00xNy4yNSAxNC40ODU0VjIwLjQ4NTRcXCcgc3Ryb2tlPVxcJ2JsYWNrXFwnIHN0cm9rZS13aWR0aD1cXCcxLjVcXCcgc3Ryb2tlLWxpbmVjYXA9XFwncm91bmRcXCcgc3Ryb2tlLWxpbmVqb2luPVxcJ3JvdW5kXFwnLz48cGF0aCBkPVxcJ00xNC4yNSAxNy40ODU0SDIwLjI1XFwnIHN0cm9rZT1cXCdibGFja1xcJyBzdHJva2Utd2lkdGg9XFwnMS41XFwnIHN0cm9rZS1saW5lY2FwPVxcJ3JvdW5kXFwnIHN0cm9rZS1saW5lam9pbj1cXCdyb3VuZFxcJy8+PHBhdGggZD1cXCdNMC43NSAxNy40ODUyQzAuNzUxNTQ0IDE1LjIxODYgMS44OTAxMSAxMy4xMDM5IDMuNzgxNDkgMTEuODU0OEM1LjY3Mjg3IDEwLjYwNTcgOC4wNjQ3NiAxMC4zODg4IDEwLjE1IDExLjI3NzJcXCcgc3Ryb2tlPVxcJ2JsYWNrXFwnIHN0cm9rZS13aWR0aD1cXCcxLjVcXCcgc3Ryb2tlLWxpbmVjYXA9XFwncm91bmRcXCcgc3Ryb2tlLWxpbmVqb2luPVxcJ3JvdW5kXFwnLz48cGF0aCBmaWxsLXJ1bGU9XFwnZXZlbm9kZFxcJyBjbGlwLXJ1bGU9XFwnZXZlbm9kZFxcJyBkPVxcJ003LjUgOS4yMzUzNUM5Ljc3ODE3IDkuMjM1MzUgMTEuNjI1IDcuMzg4NTMgMTEuNjI1IDUuMTEwMzVDMTEuNjI1IDIuODMyMTggOS43NzgxNyAwLjk4NTM1MiA3LjUgMC45ODUzNTJDNS4yMjE4MyAwLjk4NTM1MiAzLjM3NSAyLjgzMjE4IDMuMzc1IDUuMTEwMzVDMy4zNzUgNy4zODg1MyA1LjIyMTgzIDkuMjM1MzUgNy41IDkuMjM1MzVaXFwnIHN0cm9rZT1cXCdibGFja1xcJyBzdHJva2Utd2lkdGg9XFwnMS41XFwnIHN0cm9rZS1saW5lY2FwPVxcJ3JvdW5kXFwnIHN0cm9rZS1saW5lam9pbj1cXCdyb3VuZFxcJy8+PC9zdmc+XCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihyZWxhdGlvbl90eXBlID09PSBcImFjY2VwdC1jb250YWN0LWxpc3RcIiApe1xyXG5cdFx0XHRcdGlmKHRoaXMucmVzcG9uc2UgPT09IFwiQ29udGFjdCBhY2NlcHRlZFwiKSB7XHJcblx0XHRcdFx0XHRjb25zdCB0b29sdGlwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0b29sdGlwLW5vdGlmaWNhdGlvblwiKTtcclxuXHRcdFx0XHRcdGNvbnN0IHRvb2x0aXBfcGlsbF9ub3RpZmljYXRpb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50b29sdGlwLXBpbGwubm90aWZpY2F0aW9uc1wiKVxyXG5cdFx0XHRcdFx0Y29uc3Qgbm90aWZpY2F0aW9uX2NvdW50ZXIgPSB0b29sdGlwX3BpbGxfbm90aWZpY2F0aW9ucy5xdWVyeVNlbGVjdG9yKFwiLm5vdGlmaWNhdGlvbl9jb3VudGVyXCIpO1xyXG5cdFx0XHRcdFx0Y29uc3QgY291bnRfbm90aWZpY2F0aW9ucyA9IHRvb2x0aXAucXVlcnlTZWxlY3RvckFsbChcIi5ub3RpZmljYXRpb25zLS1zZWN0aW9uXCIpLmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRfbm90aWZpY2F0aW9uID0gdG9vbHRpcC5xdWVyeVNlbGVjdG9yKFwiI25vdGlmaWNhdGlvbi1cIiArIGhpbSk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhjdXJyZW50X25vdGlmaWNhdGlvbik7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhjb3VudF9ub3RpZmljYXRpb25zKTtcclxuXHJcblx0XHRcdFx0XHRjdXJyZW50X25vdGlmaWNhdGlvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcblx0XHRcdFx0XHQvLyBnZXQgcGFyZW50IGJveCBvZiBub3RpZmljYXRpb25cclxuXHRcdFx0XHRcdGlmKChjb3VudF9ub3RpZmljYXRpb25zIC0gMSkgPD0gMCl7XHJcblx0XHRcdFx0XHRcdHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNob3cnKTtcclxuXHRcdFx0XHRcdFx0dG9vbHRpcF9waWxsX25vdGlmaWNhdGlvbnMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bm90aWZpY2F0aW9uX2NvdW50ZXIuaW5uZXJIVE1MID0gXCJcIjtcclxuXHRcdFx0XHRcdG5vdGlmaWNhdGlvbl9jb3VudGVyLmlubmVySFRNTCA9IGNvdW50X25vdGlmaWNhdGlvbnMgLSAxO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWVsc2UgaWYocmVsYXRpb25fdHlwZSA9PT0gXCJyZWZ1c2UtY29udGFjdC1saXN0XCIgKXtcclxuXHRcdFx0XHRpZih0aGlzLnJlc3BvbnNlID09PSBcIkNvbnRhY3QgcmVtb3ZlZFwiKSB7XHJcblx0XHRcdFx0XHRyZWxhdGlvbkJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwicmVsYXRpb25fYnRuLS1jb250YWN0LXJlbGF0aW9uLWRvbmVcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihyZWxhdGlvbl90eXBlID09PSBcImZhdm9yaXRlXCIgfHwgcmVsYXRpb25fdHlwZSA9PT0gXCJsaWtlXCIgKSB7XHJcblxyXG4gICAgICAgIHZhciBsaWtlQ291bnQgPSByZWxhdGlvbkJ0bi5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb3VudC1saWtlXycpO1xyXG4gICAgICAgIC8vIEVtcMOqY2hlciBsZSBjb21wb3J0ZW1lbnQgcGFyIGTDqWZhdXQgZHUgbGllblxyXG5cclxuXHJcbiAgICAgICAgLy8gUsOpY3Vww6lyZXIgbGEgdmFsZXVyIGFjdHVlbGxlIGR1IGNvbXB0ZXVyXHJcbiAgICAgICAgdmFyIGN1cnJlbnRDb3VudCA9IHBhcnNlSW50KGxpa2VDb3VudC50ZXh0Q29udGVudCkgPyBwYXJzZUludChsaWtlQ291bnQudGV4dENvbnRlbnQpIDogIDA7ICAvLyBDb252ZXJ0aXIgbGEgdmFsZXVyIGVuIG5vbWJyZVxyXG5cclxuXHJcblxyXG5cdFx0XHRcdGlmKHRoaXMucmVzcG9uc2UgPT09IFwiUmVsYXRpb24gYWRkZWRcIikge1xyXG5cdFx0XHRcdFx0cmVsYXRpb25CdG4uY2xhc3NMaXN0LmFkZChcInJlbGF0aW9uX2J0bi0tY2hlY2tlZFwiKTtcclxuICAgICAgICAgIGxpa2VDb3VudC50ZXh0Q29udGVudCA9IGN1cnJlbnRDb3VudCArIDE7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRyZWxhdGlvbkJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwicmVsYXRpb25fYnRuLS1jaGVja2VkXCIpO1xyXG4gICAgICAgICAgbGlrZUNvdW50LnRleHRDb250ZW50ID0gY3VycmVudENvdW50IC0gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKHJlbGF0aW9uX3R5cGUgPT09IFwicmVjb21tZW5kXCIgKXtcclxuXHRcdFx0XHRpZih0aGlzLnJlc3BvbnNlID09PSBcIlJlbGF0aW9uIGFkZGVkXCIpIHtcclxuXHRcdFx0XHRcdHJlbGF0aW9uQnRuLmNsYXNzTGlzdC5hZGQoXCJyZWxhdGlvbl9idG4tLWNoZWNrZWRcIik7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRyZWxhdGlvbkJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwicmVsYXRpb25fYnRuLS1jaGVja2VkXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJub3QgcmVjb2duaXplZFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1lbHNle1xyXG5cdFx0XHQvLyBlcnJvclxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHRsZXQgZmllbGRfbWU7XHJcblx0bGV0IG1lX3VpZCA9ICd1c2VyXycgKyBtZTtcclxuXHRsZXQgaGltX3VpZDtcclxuXHRpZihwb3N0X3R5cGVfY2xpY2tlZF9vbiA9PT0gXCJyZWFsLWVzdGF0ZVwiKSB7XHJcblx0XHRpZihyZWxhdGlvbkJ0bi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlbGF0aW9uLXR5cGVcIikgPT09IFwiZmF2b3JpdGVcIil7XHJcblx0XHRcdGZpZWxkX21lID0gXCJpX2Zhdm9yaXRlX3Bvc3RzX3JlbGF0aW9uc2hpcHNcIjtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRmaWVsZF9tZSA9IFwiaV9saWtlX3Bvc3RzX3JlbGF0aW9uc2hpcHNcIjtcclxuXHRcdH1cclxuXHRcdGhpbV91aWQgPSBoaW07XHJcblx0XHRyZXF1ZXN0LnNlbmQoJ2FjdGlvbj1tYWtlUmVsYXRpb25CdHcmbWVfdWlkPScgKyBtZV91aWQgKyAnJmhpbT0nICsgaGltICsgJyZmaWVsZF9tZT0nICsgZmllbGRfbWUgKTtcclxuXHR9XHJcblx0ZWxzZSBpZihwb3N0X3R5cGVfY2xpY2tlZF9vbiA9PT0gXCJ1c2Vyc1wiKSB7XHJcblx0XHRpZihyZWxhdGlvbkJ0bi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlbGF0aW9uLXR5cGVcIikgPT09IFwiZmF2b3JpdGVcIil7XHJcblx0XHRcdGZpZWxkX21lID0gXCJpX2Zhdm9yaXRlX3VzZXJzX3JlbGF0aW9uc2hpcHNcIjtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRmaWVsZF9tZSA9IFwiaV9saWtlX3VzZXJzX3JlbGF0aW9uc2hpcHNcIjtcclxuXHRcdH1cclxuXHRcdGhpbV91aWQgPSAndXNlcl8nICsgaGltO1xyXG5cdFx0cmVxdWVzdC5zZW5kKCdhY3Rpb249bWFrZVJlbGF0aW9uQnR3Jm1lX3VpZD0nICsgbWVfdWlkICsgJyZoaW09JyArIGhpbSArICcmZmllbGRfbWU9JyArIGZpZWxkX21lICk7XHJcblx0fVxyXG5cdGVsc2UgaWYocG9zdF90eXBlX2NsaWNrZWRfb24gPT09IFwicmVxdWVzdC1jb250YWN0LWxpc3RcIikge1xyXG5cdFx0ZmllbGRfbWUgPSBcImlfcmVxdWVzdF9jb250YWN0bGlzdF91c2Vyc19yZWxhdGlvbnNoaXBzXCI7XHJcblx0XHRoaW1fdWlkID0gJ3VzZXJfJyArIGhpbTtcclxuXHRcdHJlcXVlc3Quc2VuZCgnYWN0aW9uPXJlcXVlc3RDb250YWN0Jm1lX3VpZD0nICsgbWVfdWlkICsgJyZoaW09JyArIGhpbSArICcmZmllbGRfbWU9JyArIGZpZWxkX21lICk7XHJcblx0fVxyXG4gIGVsc2UgaWYocG9zdF90eXBlX2NsaWNrZWRfb24gPT09IFwicmVtb3ZlLXJlcXVlc3QtY29udGFjdC1saXN0XCIpIHtcclxuXHRcdGFsZXJ0KFwiVE9ETzogcmVtb3ZlLXJlcXVlc3QtY29udGFjdC1saXN0XCIpO1xyXG5cdH1cclxuXHRlbHNlIGlmKHBvc3RfdHlwZV9jbGlja2VkX29uID09PSBcImFjY2VwdC1jb250YWN0LWxpc3RcIikge1xyXG5cdFx0ZmllbGRfbWUgPSBcImlfYWNjZXB0X2NvbnRhY3RsaXN0X3VzZXJzX3JlbGF0aW9uc2hpcHNcIjtcclxuXHRcdGhpbV91aWQgPSAndXNlcl8nICsgaGltO1xyXG5cdFx0cmVxdWVzdC5zZW5kKCdhY3Rpb249YWNjZXB0Q29udGFjdCZtZV91aWQ9JyArIG1lX3VpZCArICcmbWU9JyArIG1lICsgJyZoaW09JyArIGhpbSApO1xyXG5cdH1cclxuXHRlbHNlIGlmKHBvc3RfdHlwZV9jbGlja2VkX29uID09PSBcInJlZnVzZS1jb250YWN0LWxpc3RcIikge1xyXG5cdFx0aWYgKHdpbmRvdy5jb25maXJtKFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIHVzZXIgZnJvbSB5b3VyIGNvbnRhY3QgbGlzdCA/XCIpKSB7XHJcblx0XHRcdGZpZWxkX21lID0gXCJpX2FjY2VwdF9jb250YWN0bGlzdF91c2Vyc19yZWxhdGlvbnNoaXBzXCI7XHJcblx0XHRcdGhpbV91aWQgPSAndXNlcl8nICsgaGltO1xyXG5cdFx0XHRyZXF1ZXN0LnNlbmQoJ2FjdGlvbj1yZWZ1c2VDb250YWN0Jm1lX3VpZD0nICsgbWVfdWlkICsgJyZtZT0nICsgbWUgKyAnJmhpbT0nICsgaGltICk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGVsc2UgaWYocG9zdF90eXBlX2NsaWNrZWRfb24gPT09IFwicmVjb21tZW5kXCIpIHtcclxuXHRcdGNvbnNvbGUubG9nKFwicmVjb21tZW5kXCIpO1xyXG5cdFx0ZmllbGRfbWUgPSBcImlfcmVjb21tZW5kX3VzZXJzX3JlbGF0aW9uc2hpcHNcIjtcclxuXHRcdGhpbV91aWQgPSAndXNlcl8nICsgaGltO1xyXG5cdFx0cmVxdWVzdC5zZW5kKCdhY3Rpb249bWFrZVJlbGF0aW9uQnR3Jm1lX3VpZD0nICsgbWVfdWlkICsgJyZoaW09JyArIGhpbSArICcmZmllbGRfbWU9JyArIGZpZWxkX21lICk7XHJcblx0fVxyXG5cclxuXHRjb25zb2xlLmxvZyhtZV91aWQgKyBcIiA6YWRkZWQgXCIgKyBoaW1fdWlkICsgXCIgb246IFwiICsgZmllbGRfbWUpO1xyXG5cclxuXHRyZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHsgIH07XHJcbn1cclxuXHJcbmV4cG9ydCB7bWFrZVJlbGF0aW9uQnR3fTtcclxuIl0sIm5hbWVzIjpbIm1ha2VSZWxhdGlvbkJ0dyIsIm1lIiwiaGltIiwicG9zdF90eXBlX2NsaWNrZWRfb24iLCJyZWxhdGlvbkJ0biIsImNvbnNvbGUiLCJsb2ciLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJhZG1pbkFqYXhVcmwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRBdHRyaWJ1dGUiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ubG9hZCIsInJlc3BvbnNlIiwic3RhdHVzIiwicmVsYXRpb25fdHlwZSIsImlubmVySFRNTCIsImNsYXNzTGlzdCIsImFkZCIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlbW92ZSIsInRvb2x0aXAiLCJ0b29sdGlwX3BpbGxfbm90aWZpY2F0aW9ucyIsIm5vdGlmaWNhdGlvbl9jb3VudGVyIiwiY291bnRfbm90aWZpY2F0aW9ucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsZW5ndGgiLCJjdXJyZW50X25vdGlmaWNhdGlvbiIsInN0eWxlIiwiZGlzcGxheSIsInJlbW92ZUF0dHJpYnV0ZSIsImxpa2VDb3VudCIsInBhcmVudEVsZW1lbnQiLCJjdXJyZW50Q291bnQiLCJwYXJzZUludCIsInRleHRDb250ZW50IiwiZmllbGRfbWUiLCJtZV91aWQiLCJoaW1fdWlkIiwic2VuZCIsImFsZXJ0Iiwid2luZG93IiwiY29uZmlybSIsIm9uZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/functional/relations.js\n");

/***/ }),

/***/ "./src/js/pages/home.js":
/*!******************************!*\
  !*** ./src/js/pages/home.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Home {\n  namespace = 'home';\n  beforeEnter = data => {\n    console.log(data, 'on home page');\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Home());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvcGFnZXMvaG9tZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsSUFBSSxDQUFDO0VBQ1ZDLFNBQVMsR0FBRyxNQUFNO0VBRWxCQyxXQUFXLEdBQUdDLElBQUksSUFBSTtJQUNyQkMsT0FBTyxDQUFDQyxHQUFHLENBQUNGLElBQUksRUFBRSxjQUFjLENBQUM7RUFDbEMsQ0FBQztBQUdGO0FBRUEsaUVBQWUsSUFBSUgsSUFBSSxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9zcmMvanMvcGFnZXMvaG9tZS5qcz9hNWI2Il0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEhvbWUge1xyXG5cdG5hbWVzcGFjZSA9ICdob21lJztcclxuXHJcblx0YmVmb3JlRW50ZXIgPSBkYXRhID0+IHtcclxuXHRcdGNvbnNvbGUubG9nKGRhdGEsICdvbiBob21lIHBhZ2UnKTtcclxuXHR9O1xyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBIb21lKCk7XHJcbiJdLCJuYW1lcyI6WyJIb21lIiwibmFtZXNwYWNlIiwiYmVmb3JlRW50ZXIiLCJkYXRhIiwiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/pages/home.js\n");

/***/ }),

/***/ "./src/js/pages/post.js":
/*!******************************!*\
  !*** ./src/js/pages/post.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _functional_relations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functional/relations */ \"./src/js/functional/relations.js\");\n\nclass Post {\n  namespace = 'post';\n  constructor() {}\n  beforeEnter = data => {\n    var current_user_id = data.next.container.querySelector(\".current_user_id\");\n    var relationBtns = data.next.container.querySelectorAll(\".relation_btn\");\n    if (relationBtns) {\n      relationBtns.forEach(relationBtn => {\n        relationBtn.addEventListener(\"click\", e => {\n          e.preventDefault();\n          e.stopPropagation();\n          // console.log(e.currentTarget.getAttribute(\"data-relation-type\"));\n          (0,_functional_relations__WEBPACK_IMPORTED_MODULE_0__.makeRelationBtw)(current_user_id.getAttribute(\"data-u-id\"), e.currentTarget.getAttribute(\"data-relation-him\"), \"real-estate\", e.currentTarget);\n        });\n      });\n    }\n\n    // input_87,input_123,input_124,input_105.1,input_106.1\n    // todo_augustin add contact\n\n    var relationBtns_ = data.next.container.querySelectorAll(\".add-contact-btn_\");\n    if (relationBtns_) {\n      relationBtns_.forEach(relationBtn => {\n        relationBtn.addEventListener(\"click\", e => {\n          e.preventDefault();\n          e.stopPropagation();\n          (0,_functional_relations__WEBPACK_IMPORTED_MODULE_0__.makeRelationBtw)(current_user_id.getAttribute(\"data-u-id\"), e.currentTarget.getAttribute(\"data-relation-him\"), \"request-contact-list\", e.currentTarget);\n          //makeRelationBtw(current_user_id.getAttribute(\"data-u-id\"), e.currentTarget.getAttribute(\"data-relation-him\"), \"real-estate\", e.currentTarget);\n        });\n      });\n    }\n  };\n\n  // todo_augustin: edit\n  afterEnter = data => {\n    var edit_post_main = data.next.container.querySelector(\".edit_post_main\");\n    if (edit_post_main) {\n      var edit_post_btns = data.next.container.querySelectorAll(\".edit-area\");\n\n      // Toggle the dropdown visibility\n      window.toggleDropdown = function () {\n        data.next.container.querySelector(\"#status-options\").classList.toggle(\"show\");\n      };\n\n      // Set the status text and close dropdown\n      window.setStatus = function (status, post_id) {\n        data.next.container.querySelector(\"#post-status\").textContent = status + \" \";\n        data.next.container.querySelector(\"#status-options\").classList.remove(\"show\");\n        var datad = {\n          action: 'update_post_status',\n          // Nom de l'action qui sera utilise dans le PHP\n          post_id: post_id,\n          status: status\n        };\n        const adminAjaxUrl = document.querySelector('.main').getAttribute('data-admin-ajax');\n        jQuery.post(adminAjaxUrl, datad, function (response) {\n          console.log(response); // Rponse du serveur (en cas de succs ou d'erreur)\n        });\n      };\n\n      // Close the dropdown if the user clicks outside of it\n      window.onclick = function (event) {\n        if (!event.target.matches('#post-status')) {\n          var dropdowns = data.next.container.querySelector(\".dropdown-content\");\n          for (var i = 0; i < dropdowns.length; i++) {\n            var openDropdown = dropdowns[i];\n            if (openDropdown.classList.contains('show')) {\n              openDropdown.classList.remove('show');\n            }\n          }\n        }\n      };\n\n      // Toggle visibility of edit areas when clicking edit_post_main\n      edit_post_main.addEventListener('click', e => {\n        e.preventDefault();\n        e.stopPropagation();\n        edit_post_main.classList.toggle('active');\n        edit_post_btns.forEach(edit_post_btn => {\n          edit_post_btn.classList.toggle('hide');\n        });\n      });\n    }\n\n    // todo_augustin: read_more functionality\n    var readMoreBtns = data.next.container.querySelectorAll(\".read-more-btn_\");\n    var expandableContents = data.next.container.querySelectorAll(\".expandablecontent\");\n    readMoreBtns.forEach((readMoreBtn, index) => {\n      var expandableContent = expandableContents[index];\n      if (expandableContent) {\n        var fullText = expandableContent.getAttribute(\"data-full-text\");\n        var postContent = data.next.container.querySelectorAll(\".post-content_\")[index];\n        readMoreBtn.addEventListener('click', e => {\n          e.preventDefault(); // Prevent default action if the button is within a form or link\n\n          if (postContent) {\n            postContent.innerHTML = fullText.replace(/\\n/g, \"<br>\");\n          }\n\n          // Hide the Read More button after clicking\n          readMoreBtn.style.display = \"none\";\n        });\n      }\n    });\n\n    // todo_augustin: Popup functionality for editing post\n    const editButton = data.next.container.querySelector('.edit_post_main');\n    const popup = data.next.container.querySelector('#editPostPopup');\n    const closeButton = popup.querySelector('.close-btn-circle');\n    let currentStep = 0;\n\n    // Show popup on edit button click\n    if (editButton) {\n      editButton.addEventListener(\"click\", function (event) {\n        event.preventDefault();\n        popup.style.display = \"flex\"; // Center using flex display\n      });\n    }\n\n    // Close popup on close button click\n    if (closeButton) {\n      closeButton.addEventListener(\"click\", function () {\n        popup.style.display = \"none\";\n      });\n    }\n\n    // Close popup when clicking outside of it\n    window.addEventListener(\"click\", function (event) {\n      if (event.target === popup) {\n        popup.style.display = \"none\";\n      }\n    });\n\n    // Navigate steps with \"Previous\" and \"Next\" buttons\n    window.navigateSteps = function (step) {\n      const steps = data.next.container.querySelectorAll(\".form-step\");\n      steps[currentStep].style.display = \"none\"; // Hide current step\n      currentStep += step;\n\n      // Ensure currentStep remains in valid range\n      if (currentStep < 0) currentStep = 0;\n      if (currentStep >= steps.length) currentStep = steps.length - 1;\n      steps[currentStep].style.display = \"block\"; // Show new step\n      data.next.container.querySelector(\"#step-count\").textContent = `${currentStep} / 6`;\n    };\n\n    // Go to a specific step directly from summary\n    window.goToStep = function (stepNumber) {\n      const steps = data.next.container.querySelectorAll(\".form-step\");\n      steps[currentStep].style.display = \"none\"; // Hide current step\n      currentStep = stepNumber;\n      steps[currentStep].style.display = \"block\"; // Show selected step\n      data.next.container.querySelector(\"#step-count\").textContent = `${currentStep} / 6`;\n    };\n\n    // makeRelationBtw(current_user_id.getAttribute(\"data-u-id\"), e.currentTarget.getAttribute(\"data-relation-him\"), \"request-contact-list\", e.currentTarget);\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Post());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYWtlUmVsYXRpb25CdHcgfSBmcm9tICcuLi9mdW5jdGlvbmFsL3JlbGF0aW9ucyc7XHJcblxyXG5jbGFzcyBQb3N0IHtcclxuXHRuYW1lc3BhY2UgPSAncG9zdCc7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gIH1cclxuXHJcblxyXG5cdGJlZm9yZUVudGVyID0gZGF0YSA9PiB7XHJcblxyXG5cdFx0dmFyIGN1cnJlbnRfdXNlcl9pZCA9IGRhdGEubmV4dC5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5jdXJyZW50X3VzZXJfaWRcIik7XHJcblx0XHR2YXIgcmVsYXRpb25CdG5zID0gZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLnJlbGF0aW9uX2J0blwiKTtcclxuXHRcdGlmKHJlbGF0aW9uQnRucyl7XHJcblx0XHRcdHJlbGF0aW9uQnRucy5mb3JFYWNoKHJlbGF0aW9uQnRuID0+IHtcclxuXHRcdFx0XHRyZWxhdGlvbkJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcclxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi10eXBlXCIpKTtcclxuXHRcdFx0XHRcdG1ha2VSZWxhdGlvbkJ0dyhjdXJyZW50X3VzZXJfaWQuZ2V0QXR0cmlidXRlKFwiZGF0YS11LWlkXCIpLCBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi1oaW1cIiksIFwicmVhbC1lc3RhdGVcIiwgZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG4vLyBpbnB1dF84NyxpbnB1dF8xMjMsaW5wdXRfMTI0LGlucHV0XzEwNS4xLGlucHV0XzEwNi4xXHJcbiAvLyB0b2RvX2F1Z3VzdGluIGFkZCBjb250YWN0XHJcblxyXG5cdFx0dmFyIHJlbGF0aW9uQnRuc18gPSBkYXRhLm5leHQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWRkLWNvbnRhY3QtYnRuX1wiKTtcclxuXHRcdGlmKHJlbGF0aW9uQnRuc18pe1xyXG5cdFx0XHRyZWxhdGlvbkJ0bnNfLmZvckVhY2gocmVsYXRpb25CdG4gPT4ge1xyXG5cdFx0XHRcdHJlbGF0aW9uQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xyXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIG1ha2VSZWxhdGlvbkJ0dyhjdXJyZW50X3VzZXJfaWQuZ2V0QXR0cmlidXRlKFwiZGF0YS11LWlkXCIpLCBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi1oaW1cIiksIFwicmVxdWVzdC1jb250YWN0LWxpc3RcIiwgZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0XHRcdC8vbWFrZVJlbGF0aW9uQnR3KGN1cnJlbnRfdXNlcl9pZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXUtaWRcIiksIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlbGF0aW9uLWhpbVwiKSwgXCJyZWFsLWVzdGF0ZVwiLCBlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gdG9kb19hdWd1c3RpbjogZWRpdFxyXG5hZnRlckVudGVyID0gZGF0YSA9PiB7XHJcbiAgICB2YXIgZWRpdF9wb3N0X21haW4gPSBkYXRhLm5leHQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZWRpdF9wb3N0X21haW5cIik7XHJcblxyXG4gICAgaWYgKGVkaXRfcG9zdF9tYWluKSB7XHJcbiAgICAgICAgdmFyIGVkaXRfcG9zdF9idG5zID0gZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmVkaXQtYXJlYVwiKTtcclxuXHJcbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBkcm9wZG93biB2aXNpYmlsaXR5XHJcbiAgICAgICAgd2luZG93LnRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBkYXRhLm5leHQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIjc3RhdHVzLW9wdGlvbnNcIikuY2xhc3NMaXN0LnRvZ2dsZShcInNob3dcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHN0YXR1cyB0ZXh0IGFuZCBjbG9zZSBkcm9wZG93blxyXG4gICAgICAgIHdpbmRvdy5zZXRTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzLHBvc3RfaWQpIHtcclxuICAgICAgICAgICAgZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3Bvc3Qtc3RhdHVzXCIpLnRleHRDb250ZW50ID0gc3RhdHVzICsgXCIg4pa8XCI7XHJcbiAgICAgICAgICAgIGRhdGEubmV4dC5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNzdGF0dXMtb3B0aW9uc1wiKS5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcclxuXHJcbiAgICAgICAgICB2YXIgZGF0YWQgPSB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJ3VwZGF0ZV9wb3N0X3N0YXR1cycsIC8vIE5vbSBkZSBsJ2FjdGlvbiBxdWkgc2VyYSB1dGlsaXPDqWUgZGFucyBsZSBQSFBcclxuICAgICAgICAgICAgcG9zdF9pZDogcG9zdF9pZCxcclxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGNvbnN0IGFkbWluQWpheFVybCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluJykuZ2V0QXR0cmlidXRlKCdkYXRhLWFkbWluLWFqYXgnKTtcclxuICAgICAgICAgIGpRdWVyeS5wb3N0KGFkbWluQWpheFVybCwgZGF0YWQsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTsgLy8gUsOpcG9uc2UgZHUgc2VydmV1ciAoZW4gY2FzIGRlIHN1Y2PDqHMgb3UgZCdlcnJldXIpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBpZiB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSBvZiBpdFxyXG4gICAgICAgIHdpbmRvdy5vbmNsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcygnI3Bvc3Qtc3RhdHVzJykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcm9wZG93bnMgPSBkYXRhLm5leHQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZHJvcGRvd24tY29udGVudFwiKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJvcGRvd25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5Ecm9wZG93biA9IGRyb3Bkb3duc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbkRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Ecm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gVG9nZ2xlIHZpc2liaWxpdHkgb2YgZWRpdCBhcmVhcyB3aGVuIGNsaWNraW5nIGVkaXRfcG9zdF9tYWluXHJcbiAgICAgICAgZWRpdF9wb3N0X21haW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIGVkaXRfcG9zdF9tYWluLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBlZGl0X3Bvc3RfYnRucy5mb3JFYWNoKGVkaXRfcG9zdF9idG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgZWRpdF9wb3N0X2J0bi5jbGFzc0xpc3QudG9nZ2xlKCdoaWRlJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAvLyB0b2RvX2F1Z3VzdGluOiByZWFkX21vcmUgZnVuY3Rpb25hbGl0eVxyXG4gIHZhciByZWFkTW9yZUJ0bnMgPSBkYXRhLm5leHQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIucmVhZC1tb3JlLWJ0bl9cIik7XHJcbiAgdmFyIGV4cGFuZGFibGVDb250ZW50cyA9IGRhdGEubmV4dC5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5leHBhbmRhYmxlY29udGVudFwiKTtcclxuXHJcbiAgcmVhZE1vcmVCdG5zLmZvckVhY2goKHJlYWRNb3JlQnRuLCBpbmRleCkgPT4ge1xyXG4gICAgdmFyIGV4cGFuZGFibGVDb250ZW50ID0gZXhwYW5kYWJsZUNvbnRlbnRzW2luZGV4XTtcclxuXHJcbiAgICBpZiAoZXhwYW5kYWJsZUNvbnRlbnQpIHtcclxuICAgICAgdmFyIGZ1bGxUZXh0ID0gZXhwYW5kYWJsZUNvbnRlbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1mdWxsLXRleHRcIik7XHJcbiAgICAgIHZhciBwb3N0Q29udGVudCA9IGRhdGEubmV4dC5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5wb3N0LWNvbnRlbnRfXCIpW2luZGV4XTtcclxuXHJcbiAgICAgIHJlYWRNb3JlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7ICAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9uIGlmIHRoZSBidXR0b24gaXMgd2l0aGluIGEgZm9ybSBvciBsaW5rXHJcblxyXG4gICAgICAgIGlmIChwb3N0Q29udGVudCkge1xyXG4gICAgICAgICAgcG9zdENvbnRlbnQuaW5uZXJIVE1MID0gZnVsbFRleHQucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhpZGUgdGhlIFJlYWQgTW9yZSBidXR0b24gYWZ0ZXIgY2xpY2tpbmdcclxuICAgICAgICByZWFkTW9yZUJ0bi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gdG9kb19hdWd1c3RpbjogUG9wdXAgZnVuY3Rpb25hbGl0eSBmb3IgZWRpdGluZyBwb3N0XHJcbiAgICBjb25zdCBlZGl0QnV0dG9uID0gZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZWRpdF9wb3N0X21haW4nKTtcclxuICAgIGNvbnN0IHBvcHVwID0gZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjZWRpdFBvc3RQb3B1cCcpO1xyXG4gICAgY29uc3QgY2xvc2VCdXR0b24gPSBwb3B1cC5xdWVyeVNlbGVjdG9yKCcuY2xvc2UtYnRuLWNpcmNsZScpO1xyXG4gICAgbGV0IGN1cnJlbnRTdGVwID0gMDtcclxuXHJcbiAgICAvLyBTaG93IHBvcHVwIG9uIGVkaXQgYnV0dG9uIGNsaWNrXHJcbiAgICBpZiAoZWRpdEJ1dHRvbikge1xyXG4gICAgICAgIGVkaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHBvcHVwLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjsgLy8gQ2VudGVyIHVzaW5nIGZsZXggZGlzcGxheVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsb3NlIHBvcHVwIG9uIGNsb3NlIGJ1dHRvbiBjbGlja1xyXG4gICAgaWYgKGNsb3NlQnV0dG9uKSB7XHJcbiAgICAgICAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBwb3B1cC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xvc2UgcG9wdXAgd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIGl0XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gcG9wdXApIHtcclxuICAgICAgICAgICAgcG9wdXAuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE5hdmlnYXRlIHN0ZXBzIHdpdGggXCJQcmV2aW91c1wiIGFuZCBcIk5leHRcIiBidXR0b25zXHJcbiAgICB3aW5kb3cubmF2aWdhdGVTdGVwcyA9IGZ1bmN0aW9uKHN0ZXApIHtcclxuICAgICAgICBjb25zdCBzdGVwcyA9IGRhdGEubmV4dC5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5mb3JtLXN0ZXBcIik7XHJcbiAgICAgICAgc3RlcHNbY3VycmVudFN0ZXBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgLy8gSGlkZSBjdXJyZW50IHN0ZXBcclxuICAgICAgICBjdXJyZW50U3RlcCArPSBzdGVwO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgY3VycmVudFN0ZXAgcmVtYWlucyBpbiB2YWxpZCByYW5nZVxyXG4gICAgICAgIGlmIChjdXJyZW50U3RlcCA8IDApIGN1cnJlbnRTdGVwID0gMDtcclxuICAgICAgICBpZiAoY3VycmVudFN0ZXAgPj0gc3RlcHMubGVuZ3RoKSBjdXJyZW50U3RlcCA9IHN0ZXBzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgIHN0ZXBzW2N1cnJlbnRTdGVwXS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiOyAvLyBTaG93IG5ldyBzdGVwXHJcbiAgICAgICAgZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3N0ZXAtY291bnRcIikudGV4dENvbnRlbnQgPSBgJHtjdXJyZW50U3RlcH0gLyA2YDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR28gdG8gYSBzcGVjaWZpYyBzdGVwIGRpcmVjdGx5IGZyb20gc3VtbWFyeVxyXG4gICAgd2luZG93LmdvVG9TdGVwID0gZnVuY3Rpb24oc3RlcE51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IHN0ZXBzID0gZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmZvcm0tc3RlcFwiKTtcclxuICAgICAgICBzdGVwc1tjdXJyZW50U3RlcF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyAvLyBIaWRlIGN1cnJlbnQgc3RlcFxyXG4gICAgICAgIGN1cnJlbnRTdGVwID0gc3RlcE51bWJlcjtcclxuICAgICAgICBzdGVwc1tjdXJyZW50U3RlcF0uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjsgLy8gU2hvdyBzZWxlY3RlZCBzdGVwXHJcbiAgICAgICAgZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI3N0ZXAtY291bnRcIikudGV4dENvbnRlbnQgPSBgJHtjdXJyZW50U3RlcH0gLyA2YDtcclxuICAgIH07XHJcblxyXG4gLy8gbWFrZVJlbGF0aW9uQnR3KGN1cnJlbnRfdXNlcl9pZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXUtaWRcIiksIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlbGF0aW9uLWhpbVwiKSwgXCJyZXF1ZXN0LWNvbnRhY3QtbGlzdFwiLCBlLmN1cnJlbnRUYXJnZXQpO1xyXG5cclxuXHJcblxyXG5cclxufTtcclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBuZXcgUG9zdCgpO1xyXG4iXSwibmFtZXMiOlsibWFrZVJlbGF0aW9uQnR3IiwiUG9zdCIsIm5hbWVzcGFjZSIsImNvbnN0cnVjdG9yIiwiYmVmb3JlRW50ZXIiLCJkYXRhIiwiY3VycmVudF91c2VyX2lkIiwibmV4dCIsImNvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWxhdGlvbkJ0bnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsInJlbGF0aW9uQnRuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImdldEF0dHJpYnV0ZSIsImN1cnJlbnRUYXJnZXQiLCJyZWxhdGlvbkJ0bnNfIiwiYWZ0ZXJFbnRlciIsImVkaXRfcG9zdF9tYWluIiwiZWRpdF9wb3N0X2J0bnMiLCJ3aW5kb3ciLCJ0b2dnbGVEcm9wZG93biIsImNsYXNzTGlzdCIsInRvZ2dsZSIsInNldFN0YXR1cyIsInN0YXR1cyIsInBvc3RfaWQiLCJ0ZXh0Q29udGVudCIsInJlbW92ZSIsImRhdGFkIiwiYWN0aW9uIiwiYWRtaW5BamF4VXJsIiwiZG9jdW1lbnQiLCJqUXVlcnkiLCJwb3N0IiwicmVzcG9uc2UiLCJjb25zb2xlIiwibG9nIiwib25jbGljayIsImV2ZW50IiwidGFyZ2V0IiwibWF0Y2hlcyIsImRyb3Bkb3ducyIsImkiLCJsZW5ndGgiLCJvcGVuRHJvcGRvd24iLCJjb250YWlucyIsImVkaXRfcG9zdF9idG4iLCJyZWFkTW9yZUJ0bnMiLCJleHBhbmRhYmxlQ29udGVudHMiLCJyZWFkTW9yZUJ0biIsImluZGV4IiwiZXhwYW5kYWJsZUNvbnRlbnQiLCJmdWxsVGV4dCIsInBvc3RDb250ZW50IiwiaW5uZXJIVE1MIiwicmVwbGFjZSIsInN0eWxlIiwiZGlzcGxheSIsImVkaXRCdXR0b24iLCJwb3B1cCIsImNsb3NlQnV0dG9uIiwiY3VycmVudFN0ZXAiLCJuYXZpZ2F0ZVN0ZXBzIiwic3RlcCIsInN0ZXBzIiwiZ29Ub1N0ZXAiLCJzdGVwTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/pages/post.js\n");

/***/ }),

/***/ "./src/js/pages/user.js":
/*!******************************!*\
  !*** ./src/js/pages/user.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _functional_relations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functional/relations */ \"./src/js/functional/relations.js\");\n\nclass User {\n  namespace = 'user';\n  beforeEnter = data => {\n    // Add contact btn\n    var current_user_id = data.next.container.querySelector(\".current_user_id\");\n    var relationBtns = data.next.container.querySelectorAll('.relation_btn');\n    if (relationBtns) {\n      relationBtns.forEach(relationBtn => {\n        relationBtn.addEventListener(\"click\", e => {\n          e.preventDefault();\n          e.stopPropagation();\n          (0,_functional_relations__WEBPACK_IMPORTED_MODULE_0__.makeRelationBtw)(current_user_id.getAttribute(\"data-u-id\"), e.currentTarget.getAttribute(\"data-relation-him\"), e.currentTarget.getAttribute(\"data-relation-type\"), e.currentTarget);\n        });\n      });\n    }\n\n    // Show favorites only\n    const MyfavoritesBtn = data.next.container.querySelector('[data-action=\"show-favorites-only\"]');\n    if (MyfavoritesBtn) {\n      MyfavoritesBtn.addEventListener(\"click\", e => {\n        e.preventDefault();\n        e.stopPropagation();\n        const listRequest = new XMLHttpRequest();\n        const gridRequest = new XMLHttpRequest();\n        const mapRequest = new XMLHttpRequest();\n        const adminAjaxUrl = document.querySelector('.main').getAttribute('data-admin-ajax');\n        listRequest.open('POST', adminAjaxUrl, true);\n        gridRequest.open('POST', adminAjaxUrl, true);\n        mapRequest.open('POST', adminAjaxUrl, true);\n        listRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;');\n        gridRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;');\n        mapRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;');\n        listRequest.onload = function () {\n          if (this.status >= 200 && this.status < 400) {\n            var updatedContainerItems = document.querySelector('.tab-content.profile-content__list');\n            updatedContainerItems.innerHTML = \"\";\n            updatedContainerItems.innerHTML = this.response;\n          }\n        };\n        gridRequest.onload = function () {\n          if (this.status >= 200 && this.status < 400) {\n            var updatedContainerItems = document.querySelector('.tab-content.profile-content__grid');\n            updatedContainerItems.innerHTML = \"\";\n            updatedContainerItems.innerHTML = this.response;\n          }\n        };\n        mapRequest.onload = function () {\n          if (this.status >= 200 && this.status < 400) {\n            let updatedMapData = document.querySelector(\"#map-data\");\n            updatedMapData.setAttribute(\"data-buildings\", \"\");\n            updatedMapData.setAttribute(\"data-buildings\", this.response);\n          }\n        };\n        if (!e.currentTarget.classList.contains(\"show-favorites-checked\")) {\n          e.currentTarget.classList.add(\"show-favorites-checked\");\n          listRequest.send('action=filterFavoritesList&me_id=' + current_user_id.getAttribute(\"data-u-id\") + '&filter=' + \"favorites\");\n          gridRequest.send('action=filterFavoritesGrid&me_id=' + current_user_id.getAttribute(\"data-u-id\") + '&filter=' + \"favorites\");\n          mapRequest.send('action=filterFavoritesMap&me_id=' + current_user_id.getAttribute(\"data-u-id\") + '&filter=' + \"favorites\");\n        } else {\n          e.currentTarget.classList.remove(\"show-favorites-checked\");\n          listRequest.send('action=filterFavoritesList&me_id=' + current_user_id.getAttribute(\"data-u-id\") + '&filter=' + \"mine\");\n          gridRequest.send('action=filterFavoritesGrid&me_id=' + current_user_id.getAttribute(\"data-u-id\") + '&filter=' + \"mine\");\n          mapRequest.send('action=filterFavoritesMap&me_id=' + current_user_id.getAttribute(\"data-u-id\") + '&filter=' + \"mine\");\n        }\n        listRequest.onerror = function () {};\n      });\n    }\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new User());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVyxDQUFDO1FBQzVILENBQUMsTUFBSTtVQUNKSCxDQUFDLENBQUNJLGFBQWEsQ0FBQ2lCLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLHdCQUF3QixDQUFDO1VBQzFEbkIsV0FBVyxDQUFDa0IsSUFBSSxDQUFDLG1DQUFtQyxHQUFHakMsZUFBZSxDQUFDWSxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsVUFBVSxHQUFJLE1BQU0sQ0FBQztVQUN4SEssV0FBVyxDQUFDZ0IsSUFBSSxDQUFDLG1DQUFtQyxHQUFHakMsZUFBZSxDQUFDWSxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsVUFBVSxHQUFJLE1BQU0sQ0FBQztVQUN4SE0sVUFBVSxDQUFDZSxJQUFJLENBQUMsa0NBQWtDLEdBQUdqQyxlQUFlLENBQUNZLFlBQVksQ0FBQyxXQUFXLENBQUMsR0FBRyxVQUFVLEdBQUksTUFBTSxDQUFDO1FBQ3ZIO1FBQ0FHLFdBQVcsQ0FBQ29CLE9BQU8sR0FBRyxZQUFXLENBQUMsQ0FBQztNQUVwQyxDQUFDLENBQUM7SUFDSDtFQUNELENBQUM7QUFDRjtBQUVBLGlFQUFlLElBQUl2QyxJQUFJLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL3NyYy9qcy9wYWdlcy91c2VyLmpzPzU4NWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFrZVJlbGF0aW9uQnR3IH0gZnJvbSAnLi4vZnVuY3Rpb25hbC9yZWxhdGlvbnMnO1xyXG5cclxuY2xhc3MgVXNlciB7XHJcblx0bmFtZXNwYWNlID0gJ3VzZXInO1xyXG5cclxuXHRiZWZvcmVFbnRlciA9IGRhdGEgPT4ge1xyXG5cdFx0Ly8gQWRkIGNvbnRhY3QgYnRuXHJcblx0XHR2YXIgY3VycmVudF91c2VyX2lkID0gZGF0YS5uZXh0LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmN1cnJlbnRfdXNlcl9pZFwiKTtcclxuXHRcdHZhciByZWxhdGlvbkJ0bnMgPSBkYXRhLm5leHQuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yZWxhdGlvbl9idG4nKTtcclxuXHRcdGlmKHJlbGF0aW9uQnRucyl7XHJcblx0XHRcdHJlbGF0aW9uQnRucy5mb3JFYWNoKHJlbGF0aW9uQnRuID0+IHtcclxuXHRcdFx0XHRyZWxhdGlvbkJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcclxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHRtYWtlUmVsYXRpb25CdHcoY3VycmVudF91c2VyX2lkLmdldEF0dHJpYnV0ZShcImRhdGEtdS1pZFwiKSwgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVsYXRpb24taGltXCIpLCBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWxhdGlvbi10eXBlXCIpLCBlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTaG93IGZhdm9yaXRlcyBvbmx5XHJcblx0XHRjb25zdCBNeWZhdm9yaXRlc0J0biA9IGRhdGEubmV4dC5jb250YWluZXIucXVlcnlTZWxlY3RvcignW2RhdGEtYWN0aW9uPVwic2hvdy1mYXZvcml0ZXMtb25seVwiXScpO1xyXG5cdFx0aWYoTXlmYXZvcml0ZXNCdG4pe1xyXG5cdFx0XHRNeWZhdm9yaXRlc0J0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcclxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRjb25zdCBsaXN0UmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0XHRcdGNvbnN0IGdyaWRSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0XHRcdFx0Y29uc3QgbWFwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0XHRcdGNvbnN0IGFkbWluQWpheFVybCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluJykuZ2V0QXR0cmlidXRlKCdkYXRhLWFkbWluLWFqYXgnKTtcclxuXHRcdFx0XHRsaXN0UmVxdWVzdC5vcGVuKCdQT1NUJywgYWRtaW5BamF4VXJsLCB0cnVlKTtcclxuXHRcdFx0XHRncmlkUmVxdWVzdC5vcGVuKCdQT1NUJywgYWRtaW5BamF4VXJsLCB0cnVlKTtcclxuXHRcdFx0XHRtYXBSZXF1ZXN0Lm9wZW4oJ1BPU1QnLCBhZG1pbkFqYXhVcmwsIHRydWUpO1xyXG5cdFx0XHRcdGxpc3RSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Jyk7XHJcblx0XHRcdFx0Z3JpZFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsnKTtcclxuXHRcdFx0XHRtYXBSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Jyk7XHJcblxyXG5cdFx0XHRcdGxpc3RSZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYodGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgNDAwKSB7XHJcblx0XHRcdFx0XHRcdHZhciB1cGRhdGVkQ29udGFpbmVySXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFiLWNvbnRlbnQucHJvZmlsZS1jb250ZW50X19saXN0Jyk7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZWRDb250YWluZXJJdGVtcy5pbm5lckhUTUwgPSBcIlwiO1xyXG5cdFx0XHRcdFx0XHR1cGRhdGVkQ29udGFpbmVySXRlbXMuaW5uZXJIVE1MID0gdGhpcy5yZXNwb25zZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Z3JpZFJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZih0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCA0MDApIHtcclxuXHRcdFx0XHRcdFx0dmFyIHVwZGF0ZWRDb250YWluZXJJdGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWItY29udGVudC5wcm9maWxlLWNvbnRlbnRfX2dyaWQnKTtcclxuXHRcdFx0XHRcdFx0dXBkYXRlZENvbnRhaW5lckl0ZW1zLmlubmVySFRNTCA9IFwiXCI7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZWRDb250YWluZXJJdGVtcy5pbm5lckhUTUwgPSB0aGlzLnJlc3BvbnNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtYXBSZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYodGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgNDAwKSB7XHJcblx0XHRcdFx0XHRcdGxldCB1cGRhdGVkTWFwRGF0YSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWFwLWRhdGFcIik7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZWRNYXBEYXRhLnNldEF0dHJpYnV0ZShcImRhdGEtYnVpbGRpbmdzXCIsIFwiXCIpO1xyXG5cdFx0XHRcdFx0XHR1cGRhdGVkTWFwRGF0YS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWJ1aWxkaW5nc1wiLCB0aGlzLnJlc3BvbnNlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKCFlLmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvdy1mYXZvcml0ZXMtY2hlY2tlZFwiKSl7XHJcblx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LmFkZChcInNob3ctZmF2b3JpdGVzLWNoZWNrZWRcIik7XHJcblx0XHRcdFx0XHRsaXN0UmVxdWVzdC5zZW5kKCdhY3Rpb249ZmlsdGVyRmF2b3JpdGVzTGlzdCZtZV9pZD0nICsgY3VycmVudF91c2VyX2lkLmdldEF0dHJpYnV0ZShcImRhdGEtdS1pZFwiKSArICcmZmlsdGVyPScgICsgXCJmYXZvcml0ZXNcIik7XHJcblx0XHRcdFx0XHRncmlkUmVxdWVzdC5zZW5kKCdhY3Rpb249ZmlsdGVyRmF2b3JpdGVzR3JpZCZtZV9pZD0nICsgY3VycmVudF91c2VyX2lkLmdldEF0dHJpYnV0ZShcImRhdGEtdS1pZFwiKSArICcmZmlsdGVyPScgICsgXCJmYXZvcml0ZXNcIik7XHJcblx0XHRcdFx0XHRtYXBSZXF1ZXN0LnNlbmQoJ2FjdGlvbj1maWx0ZXJGYXZvcml0ZXNNYXAmbWVfaWQ9JyArIGN1cnJlbnRfdXNlcl9pZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXUtaWRcIikgKyAnJmZpbHRlcj0nICArIFwiZmF2b3JpdGVzXCIpO1xyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93LWZhdm9yaXRlcy1jaGVja2VkXCIpO1xyXG5cdFx0XHRcdFx0bGlzdFJlcXVlc3Quc2VuZCgnYWN0aW9uPWZpbHRlckZhdm9yaXRlc0xpc3QmbWVfaWQ9JyArIGN1cnJlbnRfdXNlcl9pZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXUtaWRcIikgKyAnJmZpbHRlcj0nICArIFwibWluZVwiKTtcclxuXHRcdFx0XHRcdGdyaWRSZXF1ZXN0LnNlbmQoJ2FjdGlvbj1maWx0ZXJGYXZvcml0ZXNHcmlkJm1lX2lkPScgKyBjdXJyZW50X3VzZXJfaWQuZ2V0QXR0cmlidXRlKFwiZGF0YS11LWlkXCIpICsgJyZmaWx0ZXI9JyAgKyBcIm1pbmVcIik7XHJcblx0XHRcdFx0XHRtYXBSZXF1ZXN0LnNlbmQoJ2FjdGlvbj1maWx0ZXJGYXZvcml0ZXNNYXAmbWVfaWQ9JyArIGN1cnJlbnRfdXNlcl9pZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXUtaWRcIikgKyAnJmZpbHRlcj0nICArIFwibWluZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBuZXcgVXNlcigpOyAiXSwibmFtZXMiOlsibWFrZVJlbGF0aW9uQnR3IiwiVXNlciIsIm5hbWVzcGFjZSIsImJlZm9yZUVudGVyIiwiZGF0YSIsImN1cnJlbnRfdXNlcl9pZCIsIm5leHQiLCJjb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwicmVsYXRpb25CdG5zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJyZWxhdGlvbkJ0biIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJnZXRBdHRyaWJ1dGUiLCJjdXJyZW50VGFyZ2V0IiwiTXlmYXZvcml0ZXNCdG4iLCJsaXN0UmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwiZ3JpZFJlcXVlc3QiLCJtYXBSZXF1ZXN0IiwiYWRtaW5BamF4VXJsIiwiZG9jdW1lbnQiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ubG9hZCIsInN0YXR1cyIsInVwZGF0ZWRDb250YWluZXJJdGVtcyIsImlubmVySFRNTCIsInJlc3BvbnNlIiwidXBkYXRlZE1hcERhdGEiLCJzZXRBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImFkZCIsInNlbmQiLCJyZW1vdmUiLCJvbmVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/pages/user.js\n");

/***/ }),

/***/ "./src/js/signatureInConsole.js":
/*!**************************************!*\
  !*** ./src/js/signatureInConsole.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst signatureInConsole = () => {\n  let msg = \"%c Fait par hellomarcel.be\";\n  let styles = ['font-size: 12px', 'font-family: monospace', 'background: white', 'display: inline-block', 'color: black', 'padding: 8px 19px', 'margin: 18px 0', 'background: linear-gradient(to right, #f2f2f2, #fff);', 'border: 1px solid;'].join(';');\n  console.log(msg, styles);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (signatureInConsole);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvc2lnbmF0dXJlSW5Db25zb2xlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxrQkFBa0IsR0FBR0EsQ0FBQSxLQUFNO0VBQzdCLElBQUlDLEdBQUcsR0FBRyw0QkFBNEI7RUFDekMsSUFBSUMsTUFBTSxHQUFHLENBQ1osaUJBQWlCLEVBQ2pCLHdCQUF3QixFQUN4QixtQkFBbUIsRUFDbkIsdUJBQXVCLEVBQ3ZCLGNBQWMsRUFDZCxtQkFBbUIsRUFDbkIsZ0JBQWdCLEVBQ2hCLHVEQUF1RCxFQUN2RCxvQkFBb0IsQ0FDcEIsQ0FBQ0MsSUFBSSxDQUFDLEdBQUcsQ0FBQztFQUVSQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0osR0FBRyxFQUFFQyxNQUFNLENBQUM7QUFDNUIsQ0FBQztBQUVELGlFQUFlRixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9zcmMvanMvc2lnbmF0dXJlSW5Db25zb2xlLmpzP2JiMDIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc2lnbmF0dXJlSW5Db25zb2xlID0gKCkgPT4ge1xyXG4gICAgbGV0IG1zZyA9IFwiJWMgRmFpdCBwYXIgaGVsbG9tYXJjZWwuYmVcIjsgXHJcblx0bGV0IHN0eWxlcyA9IFsgXHJcblx0XHQnZm9udC1zaXplOiAxMnB4JywgXHJcblx0XHQnZm9udC1mYW1pbHk6IG1vbm9zcGFjZScsIFxyXG5cdFx0J2JhY2tncm91bmQ6IHdoaXRlJywgXHJcblx0XHQnZGlzcGxheTogaW5saW5lLWJsb2NrJywgXHJcblx0XHQnY29sb3I6IGJsYWNrJywgXHJcblx0XHQncGFkZGluZzogOHB4IDE5cHgnLCBcclxuXHRcdCdtYXJnaW46IDE4cHggMCcsIFxyXG5cdFx0J2JhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgI2YyZjJmMiwgI2ZmZik7JywgXHJcblx0XHQnYm9yZGVyOiAxcHggc29saWQ7JyBcclxuXHRdLmpvaW4oJzsnKTtcclxuXHRcclxuICAgIGNvbnNvbGUubG9nKG1zZywgc3R5bGVzKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2lnbmF0dXJlSW5Db25zb2xlOyJdLCJuYW1lcyI6WyJzaWduYXR1cmVJbkNvbnNvbGUiLCJtc2ciLCJzdHlsZXMiLCJqb2luIiwiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/signatureInConsole.js\n");

/***/ }),

/***/ "./src/js/updateBodyClasses.js":
/*!*************************************!*\
  !*** ./src/js/updateBodyClasses.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst updateBodyClasses = next => {\n  var body = document.querySelector('body');\n  if (next.container.getAttribute('data-page-body-class')) {\n    var pageClass = next.container.getAttribute('data-page-body-class');\n  } else {\n    var pageClass = next.container.getAttribute('data-barba-namespace');\n  }\n  body.className = '';\n  body.classList.add(pageClass);\n  body.classList.add(next.container.getAttribute('data-theme'));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (updateBodyClasses);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvdXBkYXRlQm9keUNsYXNzZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGlCQUFpQixHQUFJQyxJQUFJLElBQUs7RUFDbkMsSUFBSUMsSUFBSSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxNQUFNLENBQUM7RUFDdEMsSUFBR0gsSUFBSSxDQUFDSSxTQUFTLENBQUNDLFlBQVksQ0FBQyxzQkFBc0IsQ0FBQyxFQUFDO0lBQ25ELElBQUlDLFNBQVMsR0FBR04sSUFBSSxDQUFDSSxTQUFTLENBQUNDLFlBQVksQ0FBQyxzQkFBc0IsQ0FBQztFQUN2RSxDQUFDLE1BQUk7SUFDRCxJQUFJQyxTQUFTLEdBQUdOLElBQUksQ0FBQ0ksU0FBUyxDQUFDQyxZQUFZLENBQUMsc0JBQXNCLENBQUM7RUFDdkU7RUFDQUosSUFBSSxDQUFDTSxTQUFTLEdBQUcsRUFBRTtFQUNuQk4sSUFBSSxDQUFDTyxTQUFTLENBQUNDLEdBQUcsQ0FBQ0gsU0FBUyxDQUFDO0VBQzdCTCxJQUFJLENBQUNPLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDVCxJQUFJLENBQUNJLFNBQVMsQ0FBQ0MsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2pFLENBQUM7QUFFRCxpRUFBZU4saUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vc3JjL2pzL3VwZGF0ZUJvZHlDbGFzc2VzLmpzPzYwOTciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXBkYXRlQm9keUNsYXNzZXMgPSAobmV4dCkgPT4ge1xyXG5cdHZhciBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xyXG4gICAgaWYobmV4dC5jb250YWluZXIuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UtYm9keS1jbGFzcycpKXtcclxuICAgICAgICB2YXIgcGFnZUNsYXNzID0gbmV4dC5jb250YWluZXIuZ2V0QXR0cmlidXRlKCdkYXRhLXBhZ2UtYm9keS1jbGFzcycpO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdmFyIHBhZ2VDbGFzcyA9IG5leHQuY29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGF0YS1iYXJiYS1uYW1lc3BhY2UnKTtcclxuICAgIH1cclxuICAgIGJvZHkuY2xhc3NOYW1lID0gJyc7XHJcbiAgICBib2R5LmNsYXNzTGlzdC5hZGQocGFnZUNsYXNzKTtcclxuICAgIGJvZHkuY2xhc3NMaXN0LmFkZChuZXh0LmNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHVwZGF0ZUJvZHlDbGFzc2VzOyJdLCJuYW1lcyI6WyJ1cGRhdGVCb2R5Q2xhc3NlcyIsIm5leHQiLCJib2R5IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiY29udGFpbmVyIiwiZ2V0QXR0cmlidXRlIiwicGFnZUNsYXNzIiwiY2xhc3NOYW1lIiwiY2xhc3NMaXN0IiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/updateBodyClasses.js\n");

/***/ }),

/***/ "./node_modules/glightbox/dist/js/glightbox.min.js":
/*!*********************************************************!*\
  !*** ./node_modules/glightbox/dist/js/glightbox.min.js ***!
  \*********************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){\"use strict\";function e(e){var t=function(e,t){if(\"object\"!=typeof e||!e)return e;var i=e[Symbol.toPrimitive];if(void 0!==i){var n=i.call(e,t||\"default\");if(\"object\"!=typeof n)return n;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===t?String:Number)(e)}(e,\"string\");return\"symbol\"==typeof t?t:t+\"\"}function t(e){return(t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function i(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function n(t,i){for(var n=0;n<i.length;n++){var s=i[n];s.enumerable=s.enumerable||!1,s.configurable=!0,\"value\"in s&&(s.writable=!0),Object.defineProperty(t,e(s.key),s)}}function s(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),Object.defineProperty(e,\"prototype\",{writable:!1}),e}var l=Date.now();function o(){var e={},t=!0,i=0,n=arguments.length;\"[object Boolean]\"===Object.prototype.toString.call(arguments[0])&&(t=arguments[0],i++);for(var s=function(i){for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(t&&\"[object Object]\"===Object.prototype.toString.call(i[n])?e[n]=o(!0,e[n],i[n]):e[n]=i[n])};i<n;i++){var l=arguments[i];s(l)}return e}function r(e,t){if((E(e)||e===window||e===document)&&(e=[e]),L(e)||I(e)||(e=[e]),0!=M(e))if(L(e)&&!I(e))for(var i=e.length,n=0;n<i&&!1!==t.call(e[n],e[n],n,e);n++);else if(I(e))for(var s in e)if(P(e,s)&&!1===t.call(e[s],e[s],s,e))break}function a(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=e[l]=e[l]||[],s={all:n,evt:null,found:null};return t&&i&&M(n)>0&&r(n,(function(e,n){if(e.eventName==t&&e.fn.toString()==i.toString())return s.found=!0,s.evt=n,!1})),s}function h(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=t.onElement,n=t.withCallback,s=t.avoidDuplicate,l=void 0===s||s,o=t.once,h=void 0!==o&&o,d=t.useCapture,c=void 0!==d&&d,u=arguments.length>2?arguments[2]:void 0,g=i||[];function v(e){C(n)&&n.call(u,e,this),h&&v.destroy()}return k(g)&&(g=document.querySelectorAll(g)),v.destroy=function(){r(g,(function(t){var i=a(t,e,v);i.found&&i.all.splice(i.evt,1),t.removeEventListener&&t.removeEventListener(e,v,c)}))},r(g,(function(t){var i=a(t,e,v);(t.addEventListener&&l&&!i.found||!l)&&(t.addEventListener(e,v,c),i.all.push({eventName:e,fn:v}))})),v}function d(e,t){r(t.split(\" \"),(function(t){return e.classList.add(t)}))}function c(e,t){r(t.split(\" \"),(function(t){return e.classList.remove(t)}))}function u(e,t){return e.classList.contains(t)}function g(e,t){for(;e!==document.body;){if(!(e=e.parentElement))return!1;if(\"function\"==typeof e.matches?e.matches(t):e.msMatchesSelector(t))return e}}function v(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e||\"\"===t)return!1;if(\"none\"===t)return C(i)&&i(),!1;var n=b(),s=t.split(\" \");r(s,(function(t){d(e,\"g\"+t)})),h(n,{onElement:e,avoidDuplicate:!1,once:!0,withCallback:function(e,t){r(s,(function(e){c(t,\"g\"+e)})),C(i)&&i()}})}function f(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\";if(\"\"===t)return e.style.webkitTransform=\"\",e.style.MozTransform=\"\",e.style.msTransform=\"\",e.style.OTransform=\"\",e.style.transform=\"\",!1;e.style.webkitTransform=t,e.style.MozTransform=t,e.style.msTransform=t,e.style.OTransform=t,e.style.transform=t}function p(e){e.style.display=\"block\"}function m(e){e.style.display=\"none\"}function y(e){var t=document.createDocumentFragment(),i=document.createElement(\"div\");for(i.innerHTML=e;i.firstChild;)t.appendChild(i.firstChild);return t}function x(){return{width:window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,height:window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}}function b(){var e,t=document.createElement(\"fakeelement\"),i={animation:\"animationend\",OAnimation:\"oAnimationEnd\",MozAnimation:\"animationend\",WebkitAnimation:\"webkitAnimationEnd\"};for(e in i)if(void 0!==t.style[e])return i[e]}function S(e,t,i,n){if(e())t();else{var s;i||(i=100);var l=setInterval((function(){e()&&(clearInterval(l),s&&clearTimeout(s),t())}),i);n&&(s=setTimeout((function(){clearInterval(l)}),n))}}function w(e,t,i){if(O(e))console.error(\"Inject assets error\");else if(C(t)&&(i=t,t=!1),k(t)&&t in window)C(i)&&i();else{var n;if(-1!==e.indexOf(\".css\")){if((n=document.querySelectorAll('link[href=\"'+e+'\"]'))&&n.length>0)return void(C(i)&&i());var s=document.getElementsByTagName(\"head\")[0],l=s.querySelectorAll('link[rel=\"stylesheet\"]'),o=document.createElement(\"link\");return o.rel=\"stylesheet\",o.type=\"text/css\",o.href=e,o.media=\"all\",l?s.insertBefore(o,l[0]):s.appendChild(o),void(C(i)&&i())}if((n=document.querySelectorAll('script[src=\"'+e+'\"]'))&&n.length>0){if(C(i)){if(k(t))return S((function(){return void 0!==window[t]}),(function(){i()})),!1;i()}}else{var r=document.createElement(\"script\");r.type=\"text/javascript\",r.src=e,r.onload=function(){if(C(i)){if(k(t))return S((function(){return void 0!==window[t]}),(function(){i()})),!1;i()}},document.body.appendChild(r)}}}function T(){return\"navigator\"in window&&window.navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(Android)|(PlayBook)|(BB10)|(BlackBerry)|(Opera Mini)|(IEMobile)|(webOS)|(MeeGo)/i)}function C(e){return\"function\"==typeof e}function k(e){return\"string\"==typeof e}function E(e){return!(!e||!e.nodeType||1!=e.nodeType)}function A(e){return Array.isArray(e)}function L(e){return e&&e.length&&isFinite(e.length)}function I(e){return\"object\"===t(e)&&null!=e&&!C(e)&&!A(e)}function O(e){return null==e}function P(e,t){return null!==e&&hasOwnProperty.call(e,t)}function M(e){if(I(e)){if(e.keys)return e.keys().length;var t=0;for(var i in e)P(e,i)&&t++;return t}return e.length}function z(e){return!isNaN(parseFloat(e))&&isFinite(e)}function X(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,t=document.querySelectorAll(\".gbtn[data-taborder]:not(.disabled)\");if(!t.length)return!1;if(1==t.length)return t[0];\"string\"==typeof e&&(e=parseInt(e));var i=[];r(t,(function(e){i.push(e.getAttribute(\"data-taborder\"))}));var n=Math.max.apply(Math,i.map((function(e){return parseInt(e)}))),s=e<0?1:e+1;s>n&&(s=\"1\");var l=i.filter((function(e){return e>=parseInt(s)})),o=l.sort()[0];return document.querySelector('.gbtn[data-taborder=\"'.concat(o,'\"]'))}function Y(e){if(e.events.hasOwnProperty(\"keyboard\"))return!1;e.events.keyboard=h(\"keydown\",{onElement:window,withCallback:function(t,i){var n=(t=t||window.event).keyCode;if(9==n){var s=document.querySelector(\".gbtn.focused\");if(!s){var l=!(!document.activeElement||!document.activeElement.nodeName)&&document.activeElement.nodeName.toLocaleLowerCase();if(\"input\"==l||\"textarea\"==l||\"button\"==l)return}t.preventDefault();var o=document.querySelectorAll(\".gbtn[data-taborder]\");if(!o||o.length<=0)return;if(!s){var r=X();return void(r&&(r.focus(),d(r,\"focused\")))}var a=X(s.getAttribute(\"data-taborder\"));c(s,\"focused\"),a&&(a.focus(),d(a,\"focused\"))}39==n&&e.nextSlide(),37==n&&e.prevSlide(),27==n&&e.close()}})}var q=s((function e(t,n){var s=this,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(i(this,e),this.img=t,this.slide=n,this.onclose=l,this.img.setZoomEvents)return!1;this.active=!1,this.zoomedIn=!1,this.dragging=!1,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.img.addEventListener(\"mousedown\",(function(e){return s.dragStart(e)}),!1),this.img.addEventListener(\"mouseup\",(function(e){return s.dragEnd(e)}),!1),this.img.addEventListener(\"mousemove\",(function(e){return s.drag(e)}),!1),this.img.addEventListener(\"click\",(function(e){return s.slide.classList.contains(\"dragging-nav\")?(s.zoomOut(),!1):s.zoomedIn?void(s.zoomedIn&&!s.dragging&&s.zoomOut()):s.zoomIn()}),!1),this.img.setZoomEvents=!0}),[{key:\"zoomIn\",value:function(){var e=this.widowWidth();if(!(this.zoomedIn||e<=768)){var t=this.img;if(t.setAttribute(\"data-style\",t.getAttribute(\"style\")),t.style.maxWidth=t.naturalWidth+\"px\",t.style.maxHeight=t.naturalHeight+\"px\",t.naturalWidth>e){var i=e/2-t.naturalWidth/2;this.setTranslate(this.img.parentNode,i,0)}this.slide.classList.add(\"zoomed\"),this.zoomedIn=!0}}},{key:\"zoomOut\",value:function(){this.img.parentNode.setAttribute(\"style\",\"\"),this.img.setAttribute(\"style\",this.img.getAttribute(\"data-style\")),this.slide.classList.remove(\"zoomed\"),this.zoomedIn=!1,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.onclose&&\"function\"==typeof this.onclose&&this.onclose()}},{key:\"dragStart\",value:function(e){e.preventDefault(),this.zoomedIn?(\"touchstart\"===e.type?(this.initialX=e.touches[0].clientX-this.xOffset,this.initialY=e.touches[0].clientY-this.yOffset):(this.initialX=e.clientX-this.xOffset,this.initialY=e.clientY-this.yOffset),e.target===this.img&&(this.active=!0,this.img.classList.add(\"dragging\"))):this.active=!1}},{key:\"dragEnd\",value:function(e){var t=this;e.preventDefault(),this.initialX=this.currentX,this.initialY=this.currentY,this.active=!1,setTimeout((function(){t.dragging=!1,t.img.isDragging=!1,t.img.classList.remove(\"dragging\")}),100)}},{key:\"drag\",value:function(e){this.active&&(e.preventDefault(),\"touchmove\"===e.type?(this.currentX=e.touches[0].clientX-this.initialX,this.currentY=e.touches[0].clientY-this.initialY):(this.currentX=e.clientX-this.initialX,this.currentY=e.clientY-this.initialY),this.xOffset=this.currentX,this.yOffset=this.currentY,this.img.isDragging=!0,this.dragging=!0,this.setTranslate(this.img,this.currentX,this.currentY))}},{key:\"onMove\",value:function(e){if(this.zoomedIn){var t=e.clientX-this.img.naturalWidth/2,i=e.clientY-this.img.naturalHeight/2;this.setTranslate(this.img,t,i)}}},{key:\"setTranslate\",value:function(e,t,i){e.style.transform=\"translate3d(\"+t+\"px, \"+i+\"px, 0)\"}},{key:\"widowWidth\",value:function(){return window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth}}]),N=s((function e(){var t=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e);var s=n.dragEl,l=n.toleranceX,o=void 0===l?40:l,r=n.toleranceY,a=void 0===r?65:r,h=n.slide,d=void 0===h?null:h,c=n.instance,u=void 0===c?null:c;this.el=s,this.active=!1,this.dragging=!1,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.direction=null,this.lastDirection=null,this.toleranceX=o,this.toleranceY=a,this.toleranceReached=!1,this.dragContainer=this.el,this.slide=d,this.instance=u,this.el.addEventListener(\"mousedown\",(function(e){return t.dragStart(e)}),!1),this.el.addEventListener(\"mouseup\",(function(e){return t.dragEnd(e)}),!1),this.el.addEventListener(\"mousemove\",(function(e){return t.drag(e)}),!1)}),[{key:\"dragStart\",value:function(e){if(this.slide.classList.contains(\"zoomed\"))this.active=!1;else{\"touchstart\"===e.type?(this.initialX=e.touches[0].clientX-this.xOffset,this.initialY=e.touches[0].clientY-this.yOffset):(this.initialX=e.clientX-this.xOffset,this.initialY=e.clientY-this.yOffset);var t=e.target.nodeName.toLowerCase();e.target.classList.contains(\"nodrag\")||g(e.target,\".nodrag\")||-1!==[\"input\",\"select\",\"textarea\",\"button\",\"a\"].indexOf(t)?this.active=!1:(e.preventDefault(),(e.target===this.el||\"img\"!==t&&g(e.target,\".gslide-inline\"))&&(this.active=!0,this.el.classList.add(\"dragging\"),this.dragContainer=g(e.target,\".ginner-container\")))}}},{key:\"dragEnd\",value:function(e){var t=this;e&&e.preventDefault(),this.initialX=0,this.initialY=0,this.currentX=null,this.currentY=null,this.initialX=null,this.initialY=null,this.xOffset=0,this.yOffset=0,this.active=!1,this.doSlideChange&&(this.instance.preventOutsideClick=!0,\"right\"==this.doSlideChange&&this.instance.prevSlide(),\"left\"==this.doSlideChange&&this.instance.nextSlide()),this.doSlideClose&&this.instance.close(),this.toleranceReached||this.setTranslate(this.dragContainer,0,0,!0),setTimeout((function(){t.instance.preventOutsideClick=!1,t.toleranceReached=!1,t.lastDirection=null,t.dragging=!1,t.el.isDragging=!1,t.el.classList.remove(\"dragging\"),t.slide.classList.remove(\"dragging-nav\"),t.dragContainer.style.transform=\"\",t.dragContainer.style.transition=\"\"}),100)}},{key:\"drag\",value:function(e){if(this.active){e.preventDefault(),this.slide.classList.add(\"dragging-nav\"),\"touchmove\"===e.type?(this.currentX=e.touches[0].clientX-this.initialX,this.currentY=e.touches[0].clientY-this.initialY):(this.currentX=e.clientX-this.initialX,this.currentY=e.clientY-this.initialY),this.xOffset=this.currentX,this.yOffset=this.currentY,this.el.isDragging=!0,this.dragging=!0,this.doSlideChange=!1,this.doSlideClose=!1;var t=Math.abs(this.currentX),i=Math.abs(this.currentY);if(t>0&&t>=Math.abs(this.currentY)&&(!this.lastDirection||\"x\"==this.lastDirection)){this.yOffset=0,this.lastDirection=\"x\",this.setTranslate(this.dragContainer,this.currentX,0);var n=this.shouldChange();if(!this.instance.settings.dragAutoSnap&&n&&(this.doSlideChange=n),this.instance.settings.dragAutoSnap&&n)return this.instance.preventOutsideClick=!0,this.toleranceReached=!0,this.active=!1,this.instance.preventOutsideClick=!0,this.dragEnd(null),\"right\"==n&&this.instance.prevSlide(),void(\"left\"==n&&this.instance.nextSlide())}if(this.toleranceY>0&&i>0&&i>=t&&(!this.lastDirection||\"y\"==this.lastDirection)){this.xOffset=0,this.lastDirection=\"y\",this.setTranslate(this.dragContainer,0,this.currentY);var s=this.shouldClose();return!this.instance.settings.dragAutoSnap&&s&&(this.doSlideClose=!0),void(this.instance.settings.dragAutoSnap&&s&&this.instance.close())}}}},{key:\"shouldChange\",value:function(){var e=!1;if(Math.abs(this.currentX)>=this.toleranceX){var t=this.currentX>0?\"right\":\"left\";(\"left\"==t&&this.slide!==this.slide.parentNode.lastChild||\"right\"==t&&this.slide!==this.slide.parentNode.firstChild)&&(e=t)}return e}},{key:\"shouldClose\",value:function(){var e=!1;return Math.abs(this.currentY)>=this.toleranceY&&(e=!0),e}},{key:\"setTranslate\",value:function(e,t,i){var n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];e.style.transition=n?\"all .2s ease\":\"\",e.style.transform=\"translate3d(\".concat(t,\"px, \").concat(i,\"px, 0)\")}}]);function D(e,t,i,n){var s=e.querySelector(\".gslide-media\"),l=new Image,o=\"gSlideTitle_\"+i,r=\"gSlideDesc_\"+i;l.addEventListener(\"load\",(function(){C(n)&&n()}),!1),l.src=t.href,\"\"!=t.sizes&&\"\"!=t.srcset&&(l.sizes=t.sizes,l.srcset=t.srcset),l.alt=\"\",O(t.alt)||\"\"===t.alt||(l.alt=t.alt),\"\"!==t.title&&l.setAttribute(\"aria-labelledby\",o),\"\"!==t.description&&l.setAttribute(\"aria-describedby\",r),t.hasOwnProperty(\"_hasCustomWidth\")&&t._hasCustomWidth&&(l.style.width=t.width),t.hasOwnProperty(\"_hasCustomHeight\")&&t._hasCustomHeight&&(l.style.height=t.height),s.insertBefore(l,s.firstChild)}function _(e,t,i,n){var s=this,l=e.querySelector(\".ginner-container\"),o=\"gvideo\"+i,r=e.querySelector(\".gslide-media\"),a=this.getAllPlayers();d(l,\"gvideo-container\"),r.insertBefore(y('<div class=\"gvideo-wrapper\"></div>'),r.firstChild);var h=e.querySelector(\".gvideo-wrapper\");w(this.settings.plyr.css,\"Plyr\");var c=t.href,u=null==t?void 0:t.videoProvider,g=!1;r.style.maxWidth=t.width,w(this.settings.plyr.js,\"Plyr\",(function(){if(!u&&c.match(/vimeo\\.com\\/([0-9]*)/)&&(u=\"vimeo\"),!u&&(c.match(/(youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+)/)||c.match(/youtu\\.be\\/([a-zA-Z0-9\\-_]+)/)||c.match(/(youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+)/)||c.match(/(youtube\\.com|youtube-nocookie\\.com)\\/shorts\\/([a-zA-Z0-9\\-_]+)/))&&(u=\"youtube\"),\"local\"===u||!u){u=\"local\";var l='<video id=\"'+o+'\" ';l+='style=\"background:#000; max-width: '.concat(t.width,';\" '),l+='preload=\"metadata\" ',l+='x-webkit-airplay=\"allow\" ',l+=\"playsinline \",l+=\"controls \",l+='class=\"gvideo-local\">',l+='<source src=\"'.concat(c,'\">'),g=y(l+=\"</video>\")}var r=g||y('<div id=\"'.concat(o,'\" data-plyr-provider=\"').concat(u,'\" data-plyr-embed-id=\"').concat(c,'\"></div>'));d(h,\"\".concat(u,\"-video gvideo\")),h.appendChild(r),h.setAttribute(\"data-id\",o),h.setAttribute(\"data-index\",i);var v=P(s.settings.plyr,\"config\")?s.settings.plyr.config:{},f=new Plyr(\"#\"+o,v);f.on(\"ready\",(function(e){a[o]=e.detail.plyr,C(n)&&n()})),S((function(){return e.querySelector(\"iframe\")&&\"true\"==e.querySelector(\"iframe\").dataset.ready}),(function(){s.resize(e)})),f.on(\"enterfullscreen\",W),f.on(\"exitfullscreen\",W)}))}function W(e){var t=g(e.target,\".gslide-media\");\"enterfullscreen\"===e.type&&d(t,\"fullscreen\"),\"exitfullscreen\"===e.type&&c(t,\"fullscreen\")}function B(e,t,i,n){var s,l=this,o=e.querySelector(\".gslide-media\"),r=!(!P(t,\"href\")||!t.href)&&t.href.split(\"#\").pop().trim(),a=!(!P(t,\"content\")||!t.content)&&t.content;if(a&&(k(a)&&(s=y('<div class=\"ginlined-content\">'.concat(a,\"</div>\"))),E(a))){\"none\"==a.style.display&&(a.style.display=\"block\");var c=document.createElement(\"div\");c.className=\"ginlined-content\",c.appendChild(a),s=c}if(r){var u=document.getElementById(r);if(!u)return!1;var g=u.cloneNode(!0);g.style.height=t.height,g.style.maxWidth=t.width,d(g,\"ginlined-content\"),s=g}if(!s)return console.error(\"Unable to append inline slide content\",t),!1;o.style.height=t.height,o.style.width=t.width,o.appendChild(s),this.events[\"inlineclose\"+r]=h(\"click\",{onElement:o.querySelectorAll(\".gtrigger-close\"),withCallback:function(e){e.preventDefault(),l.close()}}),C(n)&&n()}function H(e,t,i,n){var s=e.querySelector(\".gslide-media\"),l=function(e){var t=e.url,i=e.allow,n=e.callback,s=e.appendTo,l=document.createElement(\"iframe\");return l.className=\"vimeo-video gvideo\",l.src=t,l.style.width=\"100%\",l.style.height=\"100%\",i&&l.setAttribute(\"allow\",i),l.onload=function(){l.onload=null,d(l,\"node-ready\"),C(n)&&n()},s&&s.appendChild(l),l}({url:t.href,callback:n});s.parentNode.style.maxWidth=t.width,s.parentNode.style.height=t.height,s.appendChild(l)}var j=s((function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e),this.defaults={href:\"\",sizes:\"\",srcset:\"\",title:\"\",type:\"\",videoProvider:\"\",description:\"\",alt:\"\",descPosition:\"bottom\",effect:\"\",width:\"\",height:\"\",content:!1,zoomable:!0,draggable:!0},I(t)&&(this.defaults=o(this.defaults,t))}),[{key:\"sourceType\",value:function(e){var t=e;return null!==(e=e.toLowerCase()).match(/\\.(jpeg|jpg|jpe|gif|png|apn|webp|avif|svg)/)?\"image\":e.match(/(youtube\\.com|youtube-nocookie\\.com)\\/watch\\?v=([a-zA-Z0-9\\-_]+)/)||e.match(/youtu\\.be\\/([a-zA-Z0-9\\-_]+)/)||e.match(/(youtube\\.com|youtube-nocookie\\.com)\\/embed\\/([a-zA-Z0-9\\-_]+)/)||e.match(/(youtube\\.com|youtube-nocookie\\.com)\\/shorts\\/([a-zA-Z0-9\\-_]+)/)||e.match(/vimeo\\.com\\/([0-9]*)/)||null!==e.match(/\\.(mp4|ogg|webm|mov)/)?\"video\":null!==e.match(/\\.(mp3|wav|wma|aac|ogg)/)?\"audio\":e.indexOf(\"#\")>-1&&\"\"!==t.split(\"#\").pop().trim()?\"inline\":e.indexOf(\"goajax=true\")>-1?\"ajax\":\"external\"}},{key:\"parseConfig\",value:function(e,t){var i=this,n=o({descPosition:t.descPosition},this.defaults);if(I(e)&&!E(e)){P(e,\"type\")||(P(e,\"content\")&&e.content?e.type=\"inline\":P(e,\"href\")&&(e.type=this.sourceType(e.href)));var s=o(n,e);return this.setSize(s,t),s}var l=\"\",a=e.getAttribute(\"data-glightbox\"),h=e.nodeName.toLowerCase();if(\"a\"===h&&(l=e.href),\"img\"===h&&(l=e.src,n.alt=e.alt),n.href=l,r(n,(function(s,l){P(t,l)&&\"width\"!==l&&(n[l]=t[l]);var o=e.dataset[l];O(o)||(n[l]=i.sanitizeValue(o))})),n.content&&(n.type=\"inline\"),!n.type&&l&&(n.type=this.sourceType(l)),O(a)){if(!n.title&&\"a\"==h){var d=e.title;O(d)||\"\"===d||(n.title=d)}if(!n.title&&\"img\"==h){var c=e.alt;O(c)||\"\"===c||(n.title=c)}}else{var u=[];r(n,(function(e,t){u.push(\";\\\\s?\"+t)})),u=u.join(\"\\\\s?:|\"),\"\"!==a.trim()&&r(n,(function(e,t){var s=a,l=new RegExp(\"s?\"+t+\"s?:s?(.*?)(\"+u+\"s?:|$)\"),o=s.match(l);if(o&&o.length&&o[1]){var r=o[1].trim().replace(/;\\s*$/,\"\");n[t]=i.sanitizeValue(r)}}))}if(n.description&&\".\"===n.description.substring(0,1)){var g;try{g=document.querySelector(n.description).innerHTML}catch(e){if(!(e instanceof DOMException))throw e}g&&(n.description=g)}if(!n.description){var v=e.querySelector(\".glightbox-desc\");v&&(n.description=v.innerHTML)}return this.setSize(n,t,e),this.slideConfig=n,n}},{key:\"setSize\",value:function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=\"video\"==e.type?this.checkSize(t.videosWidth):this.checkSize(t.width),s=this.checkSize(t.height);return e.width=P(e,\"width\")&&\"\"!==e.width?this.checkSize(e.width):n,e.height=P(e,\"height\")&&\"\"!==e.height?this.checkSize(e.height):s,i&&\"image\"==e.type&&(e._hasCustomWidth=!!i.dataset.width,e._hasCustomHeight=!!i.dataset.height),e}},{key:\"checkSize\",value:function(e){return z(e)?\"\".concat(e,\"px\"):e}},{key:\"sanitizeValue\",value:function(e){return\"true\"!==e&&\"false\"!==e?e:\"true\"===e}}]),V=s((function e(t,n,s){i(this,e),this.element=t,this.instance=n,this.index=s}),[{key:\"setContent\",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(u(t,\"loaded\"))return!1;var n=this.instance.settings,s=this.slideConfig,l=T();C(n.beforeSlideLoad)&&n.beforeSlideLoad({index:this.index,slide:t,player:!1});var o=s.type,r=s.descPosition,a=t.querySelector(\".gslide-media\"),h=t.querySelector(\".gslide-title\"),c=t.querySelector(\".gslide-desc\"),g=t.querySelector(\".gdesc-inner\"),v=i,f=\"gSlideTitle_\"+this.index,p=\"gSlideDesc_\"+this.index;if(C(n.afterSlideLoad)&&(v=function(){C(i)&&i(),n.afterSlideLoad({index:e.index,slide:t,player:e.instance.getSlidePlayerInstance(e.index)})}),\"\"==s.title&&\"\"==s.description?g&&g.parentNode.parentNode.removeChild(g.parentNode):(h&&\"\"!==s.title?(h.id=f,h.innerHTML=s.title):h.parentNode.removeChild(h),c&&\"\"!==s.description?(c.id=p,l&&n.moreLength>0?(s.smallDescription=this.slideShortDesc(s.description,n.moreLength,n.moreText),c.innerHTML=s.smallDescription,this.descriptionEvents(c,s)):c.innerHTML=s.description):c.parentNode.removeChild(c),d(a.parentNode,\"desc-\".concat(r)),d(g.parentNode,\"description-\".concat(r))),d(a,\"gslide-\".concat(o)),d(t,\"loaded\"),\"video\"!==o){if(\"external\"!==o)return\"inline\"===o?(B.apply(this.instance,[t,s,this.index,v]),void(s.draggable&&new N({dragEl:t.querySelector(\".gslide-inline\"),toleranceX:n.dragToleranceX,toleranceY:n.dragToleranceY,slide:t,instance:this.instance}))):void(\"image\"!==o?C(v)&&v():D(t,s,this.index,(function(){var i=t.querySelector(\"img\");s.draggable&&new N({dragEl:i,toleranceX:n.dragToleranceX,toleranceY:n.dragToleranceY,slide:t,instance:e.instance}),s.zoomable&&i.naturalWidth>i.offsetWidth&&(d(i,\"zoomable\"),new q(i,t,(function(){e.instance.resize()}))),C(v)&&v()})));H.apply(this,[t,s,this.index,v])}else _.apply(this.instance,[t,s,this.index,v])}},{key:\"slideShortDesc\",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:50,i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=document.createElement(\"div\");n.innerHTML=e;var s=n.innerText,l=i;if((e=s.trim()).length<=t)return e;var o=e.substr(0,t-1);return l?(n=null,o+'... <a href=\"#\" class=\"desc-more\">'+i+\"</a>\"):o}},{key:\"descriptionEvents\",value:function(e,t){var i=this,n=e.querySelector(\".desc-more\");if(!n)return!1;h(\"click\",{onElement:n,withCallback:function(e,n){e.preventDefault();var s=document.body,l=g(n,\".gslide-desc\");if(!l)return!1;l.innerHTML=t.description,d(s,\"gdesc-open\");var o=h(\"click\",{onElement:[s,g(l,\".gslide-description\")],withCallback:function(e,n){\"a\"!==e.target.nodeName.toLowerCase()&&(c(s,\"gdesc-open\"),d(s,\"gdesc-closed\"),l.innerHTML=t.smallDescription,i.descriptionEvents(l,t),setTimeout((function(){c(s,\"gdesc-closed\")}),400),o.destroy())}})}})}},{key:\"create\",value:function(){return y(this.instance.settings.slideHTML)}},{key:\"getConfig\",value:function(){E(this.element)||this.element.hasOwnProperty(\"draggable\")||(this.element.draggable=this.instance.settings.draggable);var e=new j(this.instance.settings.slideExtraAttributes);return this.slideConfig=e.parseConfig(this.element,this.instance.settings),this.slideConfig}}]);function F(e){return Math.sqrt(e.x*e.x+e.y*e.y)}function R(e,t){var i=function(e,t){var i=F(e)*F(t);if(0===i)return 0;var n=function(e,t){return e.x*t.x+e.y*t.y}(e,t)/i;return n>1&&(n=1),Math.acos(n)}(e,t);return function(e,t){return e.x*t.y-t.x*e.y}(e,t)>0&&(i*=-1),180*i/Math.PI}var G=s((function e(t){i(this,e),this.handlers=[],this.el=t}),[{key:\"add\",value:function(e){this.handlers.push(e)}},{key:\"del\",value:function(e){e||(this.handlers=[]);for(var t=this.handlers.length;t>=0;t--)this.handlers[t]===e&&this.handlers.splice(t,1)}},{key:\"dispatch\",value:function(){for(var e=0,t=this.handlers.length;e<t;e++){var i=this.handlers[e];\"function\"==typeof i&&i.apply(this.el,arguments)}}}]);function Z(e,t){var i=new G(e);return i.add(t),i}var U=s((function e(t,n){i(this,e),this.element=\"string\"==typeof t?document.querySelector(t):t,this.start=this.start.bind(this),this.move=this.move.bind(this),this.end=this.end.bind(this),this.cancel=this.cancel.bind(this),this.element.addEventListener(\"touchstart\",this.start,!1),this.element.addEventListener(\"touchmove\",this.move,!1),this.element.addEventListener(\"touchend\",this.end,!1),this.element.addEventListener(\"touchcancel\",this.cancel,!1),this.preV={x:null,y:null},this.pinchStartLen=null,this.zoom=1,this.isDoubleTap=!1;var s=function(){};this.rotate=Z(this.element,n.rotate||s),this.touchStart=Z(this.element,n.touchStart||s),this.multipointStart=Z(this.element,n.multipointStart||s),this.multipointEnd=Z(this.element,n.multipointEnd||s),this.pinch=Z(this.element,n.pinch||s),this.swipe=Z(this.element,n.swipe||s),this.tap=Z(this.element,n.tap||s),this.doubleTap=Z(this.element,n.doubleTap||s),this.longTap=Z(this.element,n.longTap||s),this.singleTap=Z(this.element,n.singleTap||s),this.pressMove=Z(this.element,n.pressMove||s),this.twoFingerPressMove=Z(this.element,n.twoFingerPressMove||s),this.touchMove=Z(this.element,n.touchMove||s),this.touchEnd=Z(this.element,n.touchEnd||s),this.touchCancel=Z(this.element,n.touchCancel||s),this.translateContainer=this.element,this._cancelAllHandler=this.cancelAll.bind(this),window.addEventListener(\"scroll\",this._cancelAllHandler),this.delta=null,this.last=null,this.now=null,this.tapTimeout=null,this.singleTapTimeout=null,this.longTapTimeout=null,this.swipeTimeout=null,this.x1=this.x2=this.y1=this.y2=null,this.preTapPosition={x:null,y:null}}),[{key:\"start\",value:function(e){if(e.touches)if(e.target&&e.target.nodeName&&[\"a\",\"button\",\"input\"].indexOf(e.target.nodeName.toLowerCase())>=0)console.log(\"ignore drag for this touched element\",e.target.nodeName.toLowerCase());else{this.now=Date.now(),this.x1=e.touches[0].pageX,this.y1=e.touches[0].pageY,this.delta=this.now-(this.last||this.now),this.touchStart.dispatch(e,this.element),null!==this.preTapPosition.x&&(this.isDoubleTap=this.delta>0&&this.delta<=250&&Math.abs(this.preTapPosition.x-this.x1)<30&&Math.abs(this.preTapPosition.y-this.y1)<30,this.isDoubleTap&&clearTimeout(this.singleTapTimeout)),this.preTapPosition.x=this.x1,this.preTapPosition.y=this.y1,this.last=this.now;var t=this.preV;if(e.touches.length>1){this._cancelLongTap(),this._cancelSingleTap();var i={x:e.touches[1].pageX-this.x1,y:e.touches[1].pageY-this.y1};t.x=i.x,t.y=i.y,this.pinchStartLen=F(t),this.multipointStart.dispatch(e,this.element)}this._preventTap=!1,this.longTapTimeout=setTimeout(function(){this.longTap.dispatch(e,this.element),this._preventTap=!0}.bind(this),750)}}},{key:\"move\",value:function(e){if(e.touches){var t=this.preV,i=e.touches.length,n=e.touches[0].pageX,s=e.touches[0].pageY;if(this.isDoubleTap=!1,i>1){var l=e.touches[1].pageX,o=e.touches[1].pageY,r={x:e.touches[1].pageX-n,y:e.touches[1].pageY-s};null!==t.x&&(this.pinchStartLen>0&&(e.zoom=F(r)/this.pinchStartLen,this.pinch.dispatch(e,this.element)),e.angle=R(r,t),this.rotate.dispatch(e,this.element)),t.x=r.x,t.y=r.y,null!==this.x2&&null!==this.sx2?(e.deltaX=(n-this.x2+l-this.sx2)/2,e.deltaY=(s-this.y2+o-this.sy2)/2):(e.deltaX=0,e.deltaY=0),this.twoFingerPressMove.dispatch(e,this.element),this.sx2=l,this.sy2=o}else{if(null!==this.x2){e.deltaX=n-this.x2,e.deltaY=s-this.y2;var a=Math.abs(this.x1-this.x2),h=Math.abs(this.y1-this.y2);(a>10||h>10)&&(this._preventTap=!0)}else e.deltaX=0,e.deltaY=0;this.pressMove.dispatch(e,this.element)}this.touchMove.dispatch(e,this.element),this._cancelLongTap(),this.x2=n,this.y2=s,i>1&&e.preventDefault()}}},{key:\"end\",value:function(e){if(e.changedTouches){this._cancelLongTap();var t=this;e.touches.length<2&&(this.multipointEnd.dispatch(e,this.element),this.sx2=this.sy2=null),this.x2&&Math.abs(this.x1-this.x2)>30||this.y2&&Math.abs(this.y1-this.y2)>30?(e.direction=this._swipeDirection(this.x1,this.x2,this.y1,this.y2),this.swipeTimeout=setTimeout((function(){t.swipe.dispatch(e,t.element)}),0)):(this.tapTimeout=setTimeout((function(){t._preventTap||t.tap.dispatch(e,t.element),t.isDoubleTap&&(t.doubleTap.dispatch(e,t.element),t.isDoubleTap=!1)}),0),t.isDoubleTap||(t.singleTapTimeout=setTimeout((function(){t.singleTap.dispatch(e,t.element)}),250))),this.touchEnd.dispatch(e,this.element),this.preV.x=0,this.preV.y=0,this.zoom=1,this.pinchStartLen=null,this.x1=this.x2=this.y1=this.y2=null}}},{key:\"cancelAll\",value:function(){this._preventTap=!0,clearTimeout(this.singleTapTimeout),clearTimeout(this.tapTimeout),clearTimeout(this.longTapTimeout),clearTimeout(this.swipeTimeout)}},{key:\"cancel\",value:function(e){this.cancelAll(),this.touchCancel.dispatch(e,this.element)}},{key:\"_cancelLongTap\",value:function(){clearTimeout(this.longTapTimeout)}},{key:\"_cancelSingleTap\",value:function(){clearTimeout(this.singleTapTimeout)}},{key:\"_swipeDirection\",value:function(e,t,i,n){return Math.abs(e-t)>=Math.abs(i-n)?e-t>0?\"Left\":\"Right\":i-n>0?\"Up\":\"Down\"}},{key:\"on\",value:function(e,t){this[e]&&this[e].add(t)}},{key:\"off\",value:function(e,t){this[e]&&this[e].del(t)}},{key:\"destroy\",value:function(){return this.singleTapTimeout&&clearTimeout(this.singleTapTimeout),this.tapTimeout&&clearTimeout(this.tapTimeout),this.longTapTimeout&&clearTimeout(this.longTapTimeout),this.swipeTimeout&&clearTimeout(this.swipeTimeout),this.element.removeEventListener(\"touchstart\",this.start),this.element.removeEventListener(\"touchmove\",this.move),this.element.removeEventListener(\"touchend\",this.end),this.element.removeEventListener(\"touchcancel\",this.cancel),this.rotate.del(),this.touchStart.del(),this.multipointStart.del(),this.multipointEnd.del(),this.pinch.del(),this.swipe.del(),this.tap.del(),this.doubleTap.del(),this.longTap.del(),this.singleTap.del(),this.pressMove.del(),this.twoFingerPressMove.del(),this.touchMove.del(),this.touchEnd.del(),this.touchCancel.del(),this.preV=this.pinchStartLen=this.zoom=this.isDoubleTap=this.delta=this.last=this.now=this.tapTimeout=this.singleTapTimeout=this.longTapTimeout=this.swipeTimeout=this.x1=this.x2=this.y1=this.y2=this.preTapPosition=this.rotate=this.touchStart=this.multipointStart=this.multipointEnd=this.pinch=this.swipe=this.tap=this.doubleTap=this.longTap=this.singleTap=this.pressMove=this.touchMove=this.touchEnd=this.touchCancel=this.twoFingerPressMove=null,window.removeEventListener(\"scroll\",this._cancelAllHandler),null}}]);function $(e){var t=function(){var e,t=document.createElement(\"fakeelement\"),i={transition:\"transitionend\",OTransition:\"oTransitionEnd\",MozTransition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\"};for(e in i)if(void 0!==t.style[e])return i[e]}(),i=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u(e,\"gslide-media\")?e:e.querySelector(\".gslide-media\"),s=g(n,\".ginner-container\"),l=e.querySelector(\".gslide-description\");i>769&&(n=s),d(n,\"greset\"),f(n,\"translate3d(0, 0, 0)\"),h(t,{onElement:n,once:!0,withCallback:function(e,t){c(n,\"greset\")}}),n.style.opacity=\"\",l&&(l.style.opacity=\"\")}function J(e){if(e.events.hasOwnProperty(\"touch\"))return!1;var t,i,n,s=x(),l=s.width,o=s.height,r=!1,a=null,h=null,v=null,p=!1,m=1,y=1,b=!1,S=!1,w=null,T=null,C=null,k=null,E=0,A=0,L=!1,I=!1,O={},P={},M=0,z=0,X=document.getElementById(\"glightbox-slider\"),Y=document.querySelector(\".goverlay\"),q=new U(X,{touchStart:function(t){if(r=!0,(u(t.targetTouches[0].target,\"ginner-container\")||g(t.targetTouches[0].target,\".gslide-desc\")||\"a\"==t.targetTouches[0].target.nodeName.toLowerCase())&&(r=!1),g(t.targetTouches[0].target,\".gslide-inline\")&&!u(t.targetTouches[0].target.parentNode,\"gslide-inline\")&&(r=!1),r){if(P=t.targetTouches[0],O.pageX=t.targetTouches[0].pageX,O.pageY=t.targetTouches[0].pageY,M=t.targetTouches[0].clientX,z=t.targetTouches[0].clientY,a=e.activeSlide,h=a.querySelector(\".gslide-media\"),n=a.querySelector(\".gslide-inline\"),v=null,u(h,\"gslide-image\")&&(v=h.querySelector(\"img\")),(window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth)>769&&(h=a.querySelector(\".ginner-container\")),c(Y,\"greset\"),t.pageX>20&&t.pageX<window.innerWidth-20)return;t.preventDefault()}},touchMove:function(s){if(r&&(P=s.targetTouches[0],!b&&!S)){if(n&&n.offsetHeight>o){var a=O.pageX-P.pageX;if(Math.abs(a)<=13)return!1}p=!0;var d,c=s.targetTouches[0].clientX,u=s.targetTouches[0].clientY,g=M-c,m=z-u;if(Math.abs(g)>Math.abs(m)?(L=!1,I=!0):(I=!1,L=!0),t=P.pageX-O.pageX,E=100*t/l,i=P.pageY-O.pageY,A=100*i/o,L&&v&&(d=1-Math.abs(i)/o,Y.style.opacity=d,e.settings.touchFollowAxis&&(E=0)),I&&(d=1-Math.abs(t)/l,h.style.opacity=d,e.settings.touchFollowAxis&&(A=0)),!v)return f(h,\"translate3d(\".concat(E,\"%, 0, 0)\"));f(h,\"translate3d(\".concat(E,\"%, \").concat(A,\"%, 0)\"))}},touchEnd:function(){if(r){if(p=!1,S||b)return C=w,void(k=T);var t=Math.abs(parseInt(A)),i=Math.abs(parseInt(E));if(!(t>29&&v))return t<29&&i<25?(d(Y,\"greset\"),Y.style.opacity=1,$(h)):void 0;e.close()}},multipointEnd:function(){setTimeout((function(){b=!1}),50)},multipointStart:function(){b=!0,m=y||1},pinch:function(e){if(!v||p)return!1;b=!0,v.scaleX=v.scaleY=m*e.zoom;var t=m*e.zoom;if(S=!0,t<=1)return S=!1,t=1,k=null,C=null,w=null,T=null,void v.setAttribute(\"style\",\"\");t>4.5&&(t=4.5),v.style.transform=\"scale3d(\".concat(t,\", \").concat(t,\", 1)\"),y=t},pressMove:function(e){if(S&&!b){var t=P.pageX-O.pageX,i=P.pageY-O.pageY;C&&(t+=C),k&&(i+=k),w=t,T=i;var n=\"translate3d(\".concat(t,\"px, \").concat(i,\"px, 0)\");y&&(n+=\" scale3d(\".concat(y,\", \").concat(y,\", 1)\")),f(v,n)}},swipe:function(t){if(!S)if(b)b=!1;else{if(\"Left\"==t.direction){if(e.index==e.elements.length-1)return $(h);e.nextSlide()}if(\"Right\"==t.direction){if(0==e.index)return $(h);e.prevSlide()}}}});e.events.touch=q}var K=T(),Q=null!==T()||void 0!==document.createTouch||\"ontouchstart\"in window||\"onmsgesturechange\"in window||navigator.msMaxTouchPoints,ee=document.getElementsByTagName(\"html\")[0],te={selector:\".glightbox\",elements:null,skin:\"clean\",theme:\"clean\",closeButton:!0,startAt:null,autoplayVideos:!0,autofocusVideos:!0,descPosition:\"bottom\",width:\"900px\",height:\"506px\",videosWidth:\"960px\",beforeSlideChange:null,afterSlideChange:null,beforeSlideLoad:null,afterSlideLoad:null,slideInserted:null,slideRemoved:null,slideExtraAttributes:null,onOpen:null,onClose:null,loop:!1,zoomable:!0,draggable:!0,dragAutoSnap:!1,dragToleranceX:40,dragToleranceY:65,preload:!0,oneSlidePerOpen:!1,touchNavigation:!0,touchFollowAxis:!0,keyboardNavigation:!0,closeOnOutsideClick:!0,plugins:!1,plyr:{css:\"https://cdn.plyr.io/3.6.12/plyr.css\",js:\"https://cdn.plyr.io/3.6.12/plyr.js\",config:{ratio:\"16:9\",fullscreen:{enabled:!0,iosNative:!0},youtube:{noCookie:!0,rel:0,showinfo:0,iv_load_policy:3},vimeo:{byline:!1,portrait:!1,title:!1,transparent:!1}}},openEffect:\"zoom\",closeEffect:\"zoom\",slideEffect:\"slide\",moreText:\"See more\",moreLength:60,cssEfects:{fade:{in:\"fadeIn\",out:\"fadeOut\"},zoom:{in:\"zoomIn\",out:\"zoomOut\"},slide:{in:\"slideInRight\",out:\"slideOutLeft\"},slideBack:{in:\"slideInLeft\",out:\"slideOutRight\"},none:{in:\"none\",out:\"none\"}},svg:{close:'<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" xml:space=\"preserve\"><g><g><path d=\"M505.943,6.058c-8.077-8.077-21.172-8.077-29.249,0L6.058,476.693c-8.077,8.077-8.077,21.172,0,29.249C10.096,509.982,15.39,512,20.683,512c5.293,0,10.586-2.019,14.625-6.059L505.943,35.306C514.019,27.23,514.019,14.135,505.943,6.058z\"/></g></g><g><g><path d=\"M505.942,476.694L35.306,6.059c-8.076-8.077-21.172-8.077-29.248,0c-8.077,8.076-8.077,21.171,0,29.248l470.636,470.636c4.038,4.039,9.332,6.058,14.625,6.058c5.293,0,10.587-2.019,14.624-6.057C514.018,497.866,514.018,484.771,505.942,476.694z\"/></g></g></svg>',next:'<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 477.175 477.175\" xml:space=\"preserve\"> <g><path d=\"M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z\"/></g></svg>',prev:'<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 477.175 477.175\" xml:space=\"preserve\"><g><path d=\"M145.188,238.575l215.5-215.5c5.3-5.3,5.3-13.8,0-19.1s-13.8-5.3-19.1,0l-225.1,225.1c-5.3,5.3-5.3,13.8,0,19.1l225.1,225c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1L145.188,238.575z\"/></g></svg>'},slideHTML:'<div class=\"gslide\">\\n    <div class=\"gslide-inner-content\">\\n        <div class=\"ginner-container\">\\n            <div class=\"gslide-media\">\\n            </div>\\n            <div class=\"gslide-description\">\\n                <div class=\"gdesc-inner\">\\n                    <h4 class=\"gslide-title\"></h4>\\n                    <div class=\"gslide-desc\"></div>\\n                </div>\\n            </div>\\n        </div>\\n    </div>\\n</div>',lightboxHTML:'<div id=\"glightbox-body\" class=\"glightbox-container\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"false\">\\n    <div class=\"gloader visible\"></div>\\n    <div class=\"goverlay\"></div>\\n    <div class=\"gcontainer\">\\n    <div id=\"glightbox-slider\" class=\"gslider\"></div>\\n    <button class=\"gclose gbtn\" aria-label=\"Close\" data-taborder=\"3\">{closeSVG}</button>\\n    <button class=\"gprev gbtn\" aria-label=\"Previous\" data-taborder=\"2\">{prevSVG}</button>\\n    <button class=\"gnext gbtn\" aria-label=\"Next\" data-taborder=\"1\">{nextSVG}</button>\\n</div>\\n</div>'},ie=s((function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,e),this.customOptions=t,this.settings=o(te,t),this.effectsClasses=this.getAnimationClasses(),this.videoPlayers={},this.apiEvents=[],this.fullElementsList=!1}),[{key:\"init\",value:function(){var e=this,t=this.getSelector();t&&(this.baseEvents=h(\"click\",{onElement:t,withCallback:function(t,i){t.preventDefault(),e.open(i)}})),this.elements=this.getElements()}},{key:\"open\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(0===this.elements.length)return!1;this.activeSlide=null,this.prevActiveSlideIndex=null,this.prevActiveSlide=null;var i=z(t)?t:this.settings.startAt;if(E(e)){var n=e.getAttribute(\"data-gallery\");n&&(this.fullElementsList=this.elements,this.elements=this.getGalleryElements(this.elements,n)),O(i)&&(i=this.getElementIndex(e))<0&&(i=0)}z(i)||(i=0),this.build(),v(this.overlay,\"none\"===this.settings.openEffect?\"none\":this.settings.cssEfects.fade.in);var s=document.body,l=window.innerWidth-document.documentElement.clientWidth;if(l>0){var o=document.createElement(\"style\");o.type=\"text/css\",o.className=\"gcss-styles\",o.innerText=\".gscrollbar-fixer {margin-right: \".concat(l,\"px}\"),document.head.appendChild(o),d(s,\"gscrollbar-fixer\")}d(s,\"glightbox-open\"),d(ee,\"glightbox-open\"),K&&(d(document.body,\"glightbox-mobile\"),this.settings.slideEffect=\"slide\"),this.showSlide(i,!0),1===this.elements.length?(d(this.prevButton,\"glightbox-button-hidden\"),d(this.nextButton,\"glightbox-button-hidden\")):(c(this.prevButton,\"glightbox-button-hidden\"),c(this.nextButton,\"glightbox-button-hidden\")),this.lightboxOpen=!0,this.trigger(\"open\"),C(this.settings.onOpen)&&this.settings.onOpen(),Q&&this.settings.touchNavigation&&J(this),this.settings.keyboardNavigation&&Y(this)}},{key:\"openAt\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;this.open(null,e)}},{key:\"showSlide\",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];p(this.loader),this.index=parseInt(t);var n=this.slidesContainer.querySelector(\".current\");n&&c(n,\"current\"),this.slideAnimateOut();var s=this.slidesContainer.querySelectorAll(\".gslide\")[t];if(u(s,\"loaded\"))this.slideAnimateIn(s,i),m(this.loader);else{p(this.loader);var l=this.elements[t],o={index:this.index,slide:s,slideNode:s,slideConfig:l.slideConfig,slideIndex:this.index,trigger:l.node,player:null};this.trigger(\"slide_before_load\",o),l.instance.setContent(s,(function(){m(e.loader),e.resize(),e.slideAnimateIn(s,i),e.trigger(\"slide_after_load\",o)}))}this.slideDescription=s.querySelector(\".gslide-description\"),this.slideDescriptionContained=this.slideDescription&&u(this.slideDescription.parentNode,\"gslide-media\"),this.settings.preload&&(this.preloadSlide(t+1),this.preloadSlide(t-1)),this.updateNavigationClasses(),this.activeSlide=s}},{key:\"preloadSlide\",value:function(e){var t=this;if(e<0||e>this.elements.length-1)return!1;if(O(this.elements[e]))return!1;var i=this.slidesContainer.querySelectorAll(\".gslide\")[e];if(u(i,\"loaded\"))return!1;var n=this.elements[e],s=n.type,l={index:e,slide:i,slideNode:i,slideConfig:n.slideConfig,slideIndex:e,trigger:n.node,player:null};this.trigger(\"slide_before_load\",l),\"video\"===s||\"external\"===s?setTimeout((function(){n.instance.setContent(i,(function(){t.trigger(\"slide_after_load\",l)}))}),200):n.instance.setContent(i,(function(){t.trigger(\"slide_after_load\",l)}))}},{key:\"prevSlide\",value:function(){this.goToSlide(this.index-1)}},{key:\"nextSlide\",value:function(){this.goToSlide(this.index+1)}},{key:\"goToSlide\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.prevActiveSlide=this.activeSlide,this.prevActiveSlideIndex=this.index,!this.loop()&&(e<0||e>this.elements.length-1))return!1;e<0?e=this.elements.length-1:e>=this.elements.length&&(e=0),this.showSlide(e)}},{key:\"insertSlide\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;t<0&&(t=this.elements.length);var i=new V(e,this,t),n=i.getConfig(),s=o({},n),l=i.create(),r=this.elements.length-1;s.index=t,s.node=!1,s.instance=i,s.slideConfig=n,this.elements.splice(t,0,s);var a=null,h=null;if(this.slidesContainer){if(t>r)this.slidesContainer.appendChild(l);else{var d=this.slidesContainer.querySelectorAll(\".gslide\")[t];this.slidesContainer.insertBefore(l,d)}(this.settings.preload&&0==this.index&&0==t||this.index-1==t||this.index+1==t)&&this.preloadSlide(t),0===this.index&&0===t&&(this.index=1),this.updateNavigationClasses(),a=this.slidesContainer.querySelectorAll(\".gslide\")[t],h=this.getSlidePlayerInstance(t),s.slideNode=a}this.trigger(\"slide_inserted\",{index:t,slide:a,slideNode:a,slideConfig:n,slideIndex:t,trigger:null,player:h}),C(this.settings.slideInserted)&&this.settings.slideInserted({index:t,slide:a,player:h})}},{key:\"removeSlide\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;if(e<0||e>this.elements.length-1)return!1;var t=this.slidesContainer&&this.slidesContainer.querySelectorAll(\".gslide\")[e];t&&(this.getActiveSlideIndex()==e&&(e==this.elements.length-1?this.prevSlide():this.nextSlide()),t.parentNode.removeChild(t)),this.elements.splice(e,1),this.trigger(\"slide_removed\",e),C(this.settings.slideRemoved)&&this.settings.slideRemoved(e)}},{key:\"slideAnimateIn\",value:function(e,t){var i=this,n=e.querySelector(\".gslide-media\"),s=e.querySelector(\".gslide-description\"),l={index:this.prevActiveSlideIndex,slide:this.prevActiveSlide,slideNode:this.prevActiveSlide,slideIndex:this.prevActiveSlide,slideConfig:O(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].slideConfig,trigger:O(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].node,player:this.getSlidePlayerInstance(this.prevActiveSlideIndex)},o={index:this.index,slide:this.activeSlide,slideNode:this.activeSlide,slideConfig:this.elements[this.index].slideConfig,slideIndex:this.index,trigger:this.elements[this.index].node,player:this.getSlidePlayerInstance(this.index)};if(n.offsetWidth>0&&s&&(m(s),s.style.display=\"\"),c(e,this.effectsClasses),t)v(e,this.settings.cssEfects[this.settings.openEffect].in,(function(){i.settings.autoplayVideos&&i.slidePlayerPlay(e),i.trigger(\"slide_changed\",{prev:l,current:o}),C(i.settings.afterSlideChange)&&i.settings.afterSlideChange.apply(i,[l,o])}));else{var r=this.settings.slideEffect,a=\"none\"!==r?this.settings.cssEfects[r].in:r;this.prevActiveSlideIndex>this.index&&\"slide\"==this.settings.slideEffect&&(a=this.settings.cssEfects.slideBack.in),v(e,a,(function(){i.settings.autoplayVideos&&i.slidePlayerPlay(e),i.trigger(\"slide_changed\",{prev:l,current:o}),C(i.settings.afterSlideChange)&&i.settings.afterSlideChange.apply(i,[l,o])}))}setTimeout((function(){i.resize(e)}),100),d(e,\"current\")}},{key:\"slideAnimateOut\",value:function(){if(!this.prevActiveSlide)return!1;var e=this.prevActiveSlide;c(e,this.effectsClasses),d(e,\"prev\");var t=this.settings.slideEffect,i=\"none\"!==t?this.settings.cssEfects[t].out:t;this.slidePlayerPause(e),this.trigger(\"slide_before_change\",{prev:{index:this.prevActiveSlideIndex,slide:this.prevActiveSlide,slideNode:this.prevActiveSlide,slideIndex:this.prevActiveSlideIndex,slideConfig:O(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].slideConfig,trigger:O(this.prevActiveSlideIndex)?null:this.elements[this.prevActiveSlideIndex].node,player:this.getSlidePlayerInstance(this.prevActiveSlideIndex)},current:{index:this.index,slide:this.activeSlide,slideNode:this.activeSlide,slideIndex:this.index,slideConfig:this.elements[this.index].slideConfig,trigger:this.elements[this.index].node,player:this.getSlidePlayerInstance(this.index)}}),C(this.settings.beforeSlideChange)&&this.settings.beforeSlideChange.apply(this,[{index:this.prevActiveSlideIndex,slide:this.prevActiveSlide,player:this.getSlidePlayerInstance(this.prevActiveSlideIndex)},{index:this.index,slide:this.activeSlide,player:this.getSlidePlayerInstance(this.index)}]),this.prevActiveSlideIndex>this.index&&\"slide\"==this.settings.slideEffect&&(i=this.settings.cssEfects.slideBack.out),v(e,i,(function(){var t=e.querySelector(\".ginner-container\"),i=e.querySelector(\".gslide-media\"),n=e.querySelector(\".gslide-description\");t.style.transform=\"\",i.style.transform=\"\",c(i,\"greset\"),i.style.opacity=\"\",n&&(n.style.opacity=\"\"),c(e,\"prev\")}))}},{key:\"getAllPlayers\",value:function(){return this.videoPlayers}},{key:\"getSlidePlayerInstance\",value:function(e){var t=\"gvideo\"+e,i=this.getAllPlayers();return!(!P(i,t)||!i[t])&&i[t]}},{key:\"stopSlideVideo\",value:function(e){if(E(e)){var t=e.querySelector(\".gvideo-wrapper\");t&&(e=t.getAttribute(\"data-index\"))}console.log(\"stopSlideVideo is deprecated, use slidePlayerPause\");var i=this.getSlidePlayerInstance(e);i&&i.playing&&i.pause()}},{key:\"slidePlayerPause\",value:function(e){if(E(e)){var t=e.querySelector(\".gvideo-wrapper\");t&&(e=t.getAttribute(\"data-index\"))}var i=this.getSlidePlayerInstance(e);i&&i.playing&&i.pause()}},{key:\"playSlideVideo\",value:function(e){if(E(e)){var t=e.querySelector(\".gvideo-wrapper\");t&&(e=t.getAttribute(\"data-index\"))}console.log(\"playSlideVideo is deprecated, use slidePlayerPlay\");var i=this.getSlidePlayerInstance(e);i&&!i.playing&&i.play()}},{key:\"slidePlayerPlay\",value:function(e){var t;if(!K||null!==(t=this.settings.plyr.config)&&void 0!==t&&t.muted){if(E(e)){var i=e.querySelector(\".gvideo-wrapper\");i&&(e=i.getAttribute(\"data-index\"))}var n=this.getSlidePlayerInstance(e);n&&!n.playing&&(n.play(),this.settings.autofocusVideos&&n.elements.container.focus())}}},{key:\"setElements\",value:function(e){var t=this;this.settings.elements=!1;var i=[];e&&e.length&&r(e,(function(e,n){var s=new V(e,t,n),l=s.getConfig(),r=o({},l);r.slideConfig=l,r.instance=s,r.index=n,i.push(r)})),this.elements=i,this.lightboxOpen&&(this.slidesContainer.innerHTML=\"\",this.elements.length&&(r(this.elements,(function(){var e=y(t.settings.slideHTML);t.slidesContainer.appendChild(e)})),this.showSlide(0,!0)))}},{key:\"getElementIndex\",value:function(e){var t=!1;return r(this.elements,(function(i,n){if(P(i,\"node\")&&i.node==e)return t=n,!0})),t}},{key:\"getElements\",value:function(){var e=this,t=[];this.elements=this.elements?this.elements:[],!O(this.settings.elements)&&A(this.settings.elements)&&this.settings.elements.length&&r(this.settings.elements,(function(i,n){var s=new V(i,e,n),l=s.getConfig(),r=o({},l);r.node=!1,r.index=n,r.instance=s,r.slideConfig=l,t.push(r)}));var i=!1;return this.getSelector()&&(i=document.querySelectorAll(this.getSelector())),i?(r(i,(function(i,n){var s=new V(i,e,n),l=s.getConfig(),r=o({},l);r.node=i,r.index=n,r.instance=s,r.slideConfig=l,r.gallery=i.getAttribute(\"data-gallery\"),t.push(r)})),t):t}},{key:\"getGalleryElements\",value:function(e,t){return e.filter((function(e){return e.gallery==t}))}},{key:\"getSelector\",value:function(){return!this.settings.elements&&(this.settings.selector&&\"data-\"==this.settings.selector.substring(0,5)?\"*[\".concat(this.settings.selector,\"]\"):this.settings.selector)}},{key:\"getActiveSlide\",value:function(){return this.slidesContainer.querySelectorAll(\".gslide\")[this.index]}},{key:\"getActiveSlideIndex\",value:function(){return this.index}},{key:\"getAnimationClasses\",value:function(){var e=[];for(var t in this.settings.cssEfects)if(this.settings.cssEfects.hasOwnProperty(t)){var i=this.settings.cssEfects[t];e.push(\"g\".concat(i.in)),e.push(\"g\".concat(i.out))}return e.join(\" \")}},{key:\"build\",value:function(){var e=this;if(this.built)return!1;var t=document.body.childNodes,i=[];r(t,(function(e){e.parentNode==document.body&&\"#\"!==e.nodeName.charAt(0)&&e.hasAttribute&&!e.hasAttribute(\"aria-hidden\")&&(i.push(e),e.setAttribute(\"aria-hidden\",\"true\"))}));var n=P(this.settings.svg,\"next\")?this.settings.svg.next:\"\",s=P(this.settings.svg,\"prev\")?this.settings.svg.prev:\"\",l=P(this.settings.svg,\"close\")?this.settings.svg.close:\"\",o=this.settings.lightboxHTML;o=y(o=(o=(o=o.replace(/{nextSVG}/g,n)).replace(/{prevSVG}/g,s)).replace(/{closeSVG}/g,l)),document.body.appendChild(o);var a=document.getElementById(\"glightbox-body\");this.modal=a;var c=a.querySelector(\".gclose\");this.prevButton=a.querySelector(\".gprev\"),this.nextButton=a.querySelector(\".gnext\"),this.overlay=a.querySelector(\".goverlay\"),this.loader=a.querySelector(\".gloader\"),this.slidesContainer=document.getElementById(\"glightbox-slider\"),this.bodyHiddenChildElms=i,this.events={},d(this.modal,\"glightbox-\"+this.settings.skin),this.settings.closeButton&&c&&(this.events.close=h(\"click\",{onElement:c,withCallback:function(t,i){t.preventDefault(),e.close()}})),c&&!this.settings.closeButton&&c.parentNode.removeChild(c),this.nextButton&&(this.events.next=h(\"click\",{onElement:this.nextButton,withCallback:function(t,i){t.preventDefault(),e.nextSlide()}})),this.prevButton&&(this.events.prev=h(\"click\",{onElement:this.prevButton,withCallback:function(t,i){t.preventDefault(),e.prevSlide()}})),this.settings.closeOnOutsideClick&&(this.events.outClose=h(\"click\",{onElement:a,withCallback:function(t,i){e.preventOutsideClick||u(document.body,\"glightbox-mobile\")||g(t.target,\".ginner-container\")||g(t.target,\".gbtn\")||u(t.target,\"gnext\")||u(t.target,\"gprev\")||e.close()}})),r(this.elements,(function(t,i){e.slidesContainer.appendChild(t.instance.create()),t.slideNode=e.slidesContainer.querySelectorAll(\".gslide\")[i]})),Q&&d(document.body,\"glightbox-touch\"),this.events.resize=h(\"resize\",{onElement:window,withCallback:function(){e.resize()}}),this.built=!0}},{key:\"resize\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if((e=e||this.activeSlide)&&!u(e,\"zoomed\")){var t=x(),i=e.querySelector(\".gvideo-wrapper\"),n=e.querySelector(\".gslide-image\"),s=this.slideDescription,l=t.width,o=t.height;if(l<=768?d(document.body,\"glightbox-mobile\"):c(document.body,\"glightbox-mobile\"),i||n){var r=!1;if(s&&(u(s,\"description-bottom\")||u(s,\"description-top\"))&&!u(s,\"gabsolute\")&&(r=!0),n)if(l<=768)n.querySelector(\"img\");else if(r){var a,h=s.offsetHeight,g=n.querySelector(\"img\"),v=this.elements[this.index].node,f=null!==(a=v.getAttribute(\"data-height\"))&&void 0!==a?a:\"100vh\";g.setAttribute(\"style\",\"max-height: calc(\".concat(f,\" - \").concat(h,\"px)\")),s.setAttribute(\"style\",\"max-width: \".concat(g.offsetWidth,\"px;\"))}if(i){var p=P(this.settings.plyr.config,\"ratio\")?this.settings.plyr.config.ratio:\"\";if(!p){var m=i.clientWidth,y=i.clientHeight,b=m/y;p=\"\".concat(m/b,\":\").concat(y/b)}var S=p.split(\":\"),w=this.settings.videosWidth,T=this.settings.videosWidth,C=(T=z(w)||-1!==w.indexOf(\"px\")?parseInt(w):-1!==w.indexOf(\"vw\")?l*parseInt(w)/100:-1!==w.indexOf(\"vh\")?o*parseInt(w)/100:-1!==w.indexOf(\"%\")?l*parseInt(w)/100:parseInt(i.clientWidth))/(parseInt(S[0])/parseInt(S[1]));if(C=Math.floor(C),r&&(o-=s.offsetHeight),T>l||C>o||o<C&&l>T){var k=i.offsetWidth,E=i.offsetHeight,A=o/E,L={width:k*A,height:E*A};i.parentNode.setAttribute(\"style\",\"max-width: \".concat(L.width,\"px\")),r&&s.setAttribute(\"style\",\"max-width: \".concat(L.width,\"px;\"))}else i.parentNode.style.maxWidth=\"\".concat(w),r&&s.setAttribute(\"style\",\"max-width: \".concat(w,\";\"))}}}}},{key:\"reload\",value:function(){this.init()}},{key:\"updateNavigationClasses\",value:function(){var e=this.loop();c(this.nextButton,\"disabled\"),c(this.prevButton,\"disabled\"),0==this.index&&this.elements.length-1==0?(d(this.prevButton,\"disabled\"),d(this.nextButton,\"disabled\")):0!==this.index||e?this.index!==this.elements.length-1||e||d(this.nextButton,\"disabled\"):d(this.prevButton,\"disabled\")}},{key:\"loop\",value:function(){var e=P(this.settings,\"loopAtEnd\")?this.settings.loopAtEnd:null;return e=P(this.settings,\"loop\")?this.settings.loop:e,e}},{key:\"close\",value:function(){var e=this;if(!this.lightboxOpen){if(this.events){for(var t in this.events)this.events.hasOwnProperty(t)&&this.events[t].destroy();this.events=null}return!1}if(this.closing)return!1;this.closing=!0,this.slidePlayerPause(this.activeSlide),this.fullElementsList&&(this.elements=this.fullElementsList),this.bodyHiddenChildElms.length&&r(this.bodyHiddenChildElms,(function(e){e.removeAttribute(\"aria-hidden\")})),d(this.modal,\"glightbox-closing\"),v(this.overlay,\"none\"==this.settings.openEffect?\"none\":this.settings.cssEfects.fade.out),v(this.activeSlide,this.settings.cssEfects[this.settings.closeEffect].out,(function(){if(e.activeSlide=null,e.prevActiveSlideIndex=null,e.prevActiveSlide=null,e.built=!1,e.events){for(var t in e.events)e.events.hasOwnProperty(t)&&e.events[t].destroy();e.events=null}var i=document.body;c(ee,\"glightbox-open\"),c(i,\"glightbox-open touching gdesc-open glightbox-touch glightbox-mobile gscrollbar-fixer\"),e.modal.parentNode.removeChild(e.modal),e.trigger(\"close\"),C(e.settings.onClose)&&e.settings.onClose();var n=document.querySelector(\".gcss-styles\");n&&n.parentNode.removeChild(n),e.lightboxOpen=!1,e.closing=null}))}},{key:\"destroy\",value:function(){this.close(),this.clearAllEvents(),this.baseEvents&&this.baseEvents.destroy()}},{key:\"on\",value:function(e,t){var i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e||!C(t))throw new TypeError(\"Event name and callback must be defined\");this.apiEvents.push({evt:e,once:i,callback:t})}},{key:\"once\",value:function(e,t){this.on(e,t,!0)}},{key:\"trigger\",value:function(e){var t=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=[];r(this.apiEvents,(function(t,s){var l=t.evt,o=t.once,r=t.callback;l==e&&(r(i),o&&n.push(s))})),n.length&&r(n,(function(e){return t.apiEvents.splice(e,1)}))}},{key:\"clearAllEvents\",value:function(){this.apiEvents.splice(0,this.apiEvents.length)}},{key:\"version\",value:function(){return\"3.3.0\"}}]);return function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=new ie(e);return t.init(),t}}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2xpZ2h0Ym94L2Rpc3QvanMvZ2xpZ2h0Ym94Lm1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQW9ELG9CQUFvQixDQUF5RSxDQUFDLGtCQUFrQixhQUFhLGNBQWMsb0JBQW9CLG1DQUFtQyw0QkFBNEIsZUFBZSw2QkFBNkIsK0JBQStCLG9FQUFvRSxzQ0FBc0MsYUFBYSxnQ0FBZ0MsY0FBYyxpRkFBaUYsZ0JBQWdCLGFBQWEsb0dBQW9HLEtBQUssZ0JBQWdCLDhFQUE4RSxnQkFBZ0IsWUFBWSxXQUFXLEtBQUssV0FBVyxrSEFBa0gsa0JBQWtCLDBFQUEwRSxZQUFZLElBQUksaUJBQWlCLGFBQWEsUUFBUSw2QkFBNkIsd0ZBQXdGLHNCQUFzQix3SkFBd0osSUFBSSxLQUFLLG1CQUFtQixLQUFLLFNBQVMsZ0JBQWdCLCtHQUErRyxnQ0FBZ0MsS0FBSyx3RUFBd0UsY0FBYyxtSkFBbUosMkJBQTJCLHdDQUF3Qyw4RUFBOEUsS0FBSyxjQUFjLCtEQUErRCw0S0FBNEssY0FBYyxzQ0FBc0MsbUVBQW1FLGlCQUFpQixlQUFlLG1GQUFtRixHQUFHLGtCQUFrQixlQUFlLDhFQUE4RSxpQkFBaUIsR0FBRyxLQUFLLGdCQUFnQiw0QkFBNEIsMEJBQTBCLEdBQUcsZ0JBQWdCLDRCQUE0Qiw2QkFBNkIsR0FBRyxnQkFBZ0IsK0JBQStCLGdCQUFnQixLQUFLLGtCQUFrQixFQUFFLGlDQUFpQyw4RUFBOEUsY0FBYywwSEFBMEgsdUJBQXVCLGtDQUFrQyx5QkFBeUIsaUJBQWlCLFdBQVcsUUFBUSxpRUFBaUUsaUJBQWlCLFdBQVcsY0FBYyxFQUFFLGNBQWMsZ0VBQWdFLHlJQUF5SSxnSEFBZ0gsY0FBYyx3QkFBd0IsY0FBYyx1QkFBdUIsY0FBYyx3RUFBd0Usa0JBQWtCLGFBQWEsNkJBQTZCLFNBQVMsYUFBYSxPQUFPLHVMQUF1TCxhQUFhLGlEQUFpRCxzSEFBc0gsOENBQThDLG9CQUFvQixXQUFXLEtBQUssTUFBTSxXQUFXLDhCQUE4QiwrQ0FBK0MsS0FBSyw2QkFBNkIsaUJBQWlCLE9BQU8sa0JBQWtCLDZDQUE2QyxxREFBcUQsS0FBSyxNQUFNLDJCQUEyQiwwRkFBMEYsK0hBQStILDZIQUE2SCxxRUFBcUUsU0FBUyw2QkFBNkIsMEJBQTBCLGNBQWMsSUFBSSxNQUFNLEtBQUssS0FBSyx1Q0FBdUMscURBQXFELFNBQVMsNkJBQTZCLDBCQUEwQixjQUFjLElBQUksTUFBTSxLQUFLLGdDQUFnQyxhQUFhLHlLQUF5SyxjQUFjLDJCQUEyQixjQUFjLHlCQUF5QixjQUFjLHdDQUF3QyxjQUFjLHdCQUF3QixjQUFjLHVDQUF1QyxjQUFjLDZDQUE2QyxjQUFjLGVBQWUsZ0JBQWdCLDBDQUEwQyxjQUFjLFNBQVMsaUNBQWlDLFFBQVEsMkJBQTJCLFNBQVMsZ0JBQWdCLGNBQWMseUNBQXlDLGFBQWEsbUlBQW1JLHNCQUFzQiwyQkFBMkIsb0NBQW9DLFNBQVMsaUJBQWlCLHdDQUF3QyxHQUFHLDZDQUE2QyxtQkFBbUIsZ0JBQWdCLGFBQWEsNEJBQTRCLHNCQUFzQixpQkFBaUIsc0VBQXNFLGNBQWMsZ0RBQWdELCtCQUErQiw0Q0FBNEMsa0NBQWtDLFNBQVMsOENBQThDLE9BQU8sd0hBQXdILGlEQUFpRCxtQkFBbUIsd0RBQXdELDBCQUEwQixPQUFPLFVBQVUsMkNBQTJDLHlDQUF5Qyw2Q0FBNkMsNERBQTRELEVBQUUseUJBQXlCLHlFQUF5RSxvRkFBb0YsOE1BQThNLHNCQUFzQix1REFBdUQsb0JBQW9CLHlEQUF5RCxpQkFBaUIscURBQXFELG9JQUFvSSxnQ0FBZ0MsSUFBSSw4QkFBOEIsd0JBQXdCLDZCQUE2QixlQUFlLHNKQUFzSiwyQkFBMkIsMkNBQTJDLHNEQUFzRCxFQUFFLCtCQUErQixnVkFBZ1YsRUFBRSxrQ0FBa0MsZ1VBQWdVLEVBQUUsZ0NBQWdDLFdBQVcsaUhBQWlILHFFQUFxRSxRQUFRLEVBQUUsNkJBQTZCLGdZQUFnWSxFQUFFLCtCQUErQixrQkFBa0IsNkVBQTZFLGtDQUFrQyxFQUFFLHlDQUF5QyxzREFBc0QsRUFBRSxrQ0FBa0MsMkZBQTJGLHFCQUFxQix1RUFBdUUsVUFBVSxnSkFBZ0osdVdBQXVXLHNCQUFzQixzREFBc0Qsb0JBQW9CLHdEQUF3RCxpQkFBaUIsTUFBTSxJQUFJLGtDQUFrQywwREFBMEQsS0FBSyxvTUFBb00sc0NBQXNDLG9VQUFvVSxFQUFFLGdDQUFnQyxXQUFXLDJkQUEyZCxnUUFBZ1EsUUFBUSxFQUFFLDZCQUE2QixnQkFBZ0IsMllBQTJZLHdEQUF3RCxvRkFBb0YsNEZBQTRGLDBCQUEwQix1VUFBdVUsaUZBQWlGLDRGQUE0Rix5QkFBeUIsNklBQTZJLEVBQUUsb0NBQW9DLFNBQVMsNkNBQTZDLHFDQUFxQyw0SEFBNEgsVUFBVSxFQUFFLG1DQUFtQyxTQUFTLDJEQUEyRCxFQUFFLHlDQUF5Qyw4REFBOEQsNkdBQTZHLEdBQUcsb0JBQW9CLHdGQUF3RixzQ0FBc0MsVUFBVSw2YUFBNmEsb0JBQW9CLHlIQUF5SCw2RkFBNkYseUNBQXlDLGlDQUFpQyxtREFBbUQsb0VBQW9FLHNXQUFzVyxVQUFVLDJCQUEyQiw0QkFBNEIsOEJBQThCLDhLQUE4SyxtSEFBbUgsOEdBQThHLDJEQUEyRCxxQkFBcUIsMEJBQTBCLDZCQUE2QixpQkFBaUIsa0ZBQWtGLGNBQWMsWUFBWSxzREFBc0QsR0FBRyxjQUFjLGtDQUFrQywyRkFBMkYsb0JBQW9CLHVKQUF1SiwrRUFBK0UsbURBQW1ELG9DQUFvQyxvREFBb0QsTUFBTSxpQ0FBaUMsZUFBZSxzQkFBc0IsNkVBQTZFLHlFQUF5RSx1R0FBdUcseUVBQXlFLDhCQUE4QixZQUFZLG9CQUFvQixxREFBcUQsbUZBQW1GLDRJQUE0SSwwQ0FBMEMsdUJBQXVCLEVBQUUsc0JBQXNCLEVBQUUsd0ZBQXdGLHNCQUFzQixnRUFBZ0UseUJBQXlCLDBLQUEwSywwQ0FBMEMsSUFBSSxtQ0FBbUMsUUFBUSx1bEJBQXVsQixFQUFFLHNDQUFzQyxnQkFBZ0IsNEJBQTRCLGdCQUFnQixnQkFBZ0IsdUdBQXVHLGFBQWEsMkJBQTJCLHVFQUF1RSxvRkFBb0YsaUNBQWlDLG1CQUFtQixnQ0FBZ0MsOEVBQThFLHFCQUFxQixjQUFjLDBCQUEwQix1QkFBdUIsWUFBWSwyQkFBMkIsS0FBSyxTQUFTLG1CQUFtQixTQUFTLFNBQVMsd0RBQXdELG1FQUFtRSxzQkFBc0IsNEJBQTRCLFVBQVUseUJBQXlCLEdBQUcsc0RBQXNELE1BQU0sSUFBSSxrREFBa0QsU0FBUyx3Q0FBd0MscUJBQXFCLG1CQUFtQix5Q0FBeUMsK0JBQStCLGlEQUFpRCxFQUFFLGtDQUFrQyxxS0FBcUssd09BQXdPLEVBQUUsa0NBQWtDLGlDQUFpQyxFQUFFLHNDQUFzQyw0Q0FBNEMsMEJBQTBCLHNEQUFzRCxJQUFJLGtDQUFrQyxtSUFBbUksMEJBQTBCLHNEQUFzRCx5Q0FBeUMsbUNBQW1DLEVBQUUsbU9BQW1PLHNDQUFzQyw0QkFBNEIsd0VBQXdFLEVBQUUsa2hCQUFraEIseUdBQXlHLGdJQUFnSSw0REFBNEQsNkJBQTZCLG9CQUFvQiw2RkFBNkYsbUZBQW1GLG9CQUFvQixjQUFjLElBQUksaUNBQWlDLGdEQUFnRCxFQUFFLHVDQUF1QywwSkFBMEosY0FBYyxzQkFBc0IsbUNBQW1DLHNCQUFzQixxRUFBcUUsRUFBRSw0Q0FBNEMsMkNBQTJDLGVBQWUsV0FBVyx1Q0FBdUMsbUJBQW1CLDBDQUEwQyxlQUFlLDRDQUE0QyxpQkFBaUIsb0VBQW9FLDZKQUE2SixvQkFBb0IscUJBQXFCLEdBQUcsR0FBRyxFQUFFLDhCQUE4Qiw0Q0FBNEMsRUFBRSxpQ0FBaUMscUhBQXFILHlEQUF5RCw2RkFBNkYsR0FBRyxjQUFjLGtDQUFrQyxnQkFBZ0Isb0JBQW9CLGdCQUFnQixrQkFBa0Isb0JBQW9CLHVCQUF1QixRQUFRLCtCQUErQixNQUFNLHFCQUFxQix1QkFBdUIsK0JBQStCLHVCQUF1QixxQ0FBcUMsSUFBSSw0QkFBNEIsdUJBQXVCLEVBQUUsNEJBQTRCLHNCQUFzQiwrQkFBK0IsS0FBSyxxREFBcUQsRUFBRSxnQ0FBZ0MsbUNBQW1DLElBQUksS0FBSyx1QkFBdUIsbURBQW1ELEdBQUcsZ0JBQWdCLGVBQWUsa0JBQWtCLHlCQUF5QixxYkFBcWIsY0FBYyx5REFBeUQsbUJBQW1CLDRnQ0FBNGdDLGVBQWUsSUFBSSw4QkFBOEIsb01BQW9NLEtBQUsseWNBQXljLGdCQUFnQix1QkFBdUIsOENBQThDLE9BQU8sMkRBQTJELHNGQUFzRiw4REFBOEQsMERBQTBELG1CQUFtQixFQUFFLDZCQUE2QixjQUFjLDZFQUE2RSw0QkFBNEIsaURBQWlELCtDQUErQyxrWEFBa1gsS0FBSyxtQkFBbUIsc0NBQXNDLDREQUE0RCxvQ0FBb0MsMkJBQTJCLHdDQUF3Qyw0R0FBNEcsRUFBRSw0QkFBNEIscUJBQXFCLHNCQUFzQixXQUFXLGtSQUFrUiw4QkFBOEIsOENBQThDLCtHQUErRywrREFBK0Qsa0NBQWtDLHVKQUF1SixFQUFFLGlDQUFpQyx5SkFBeUosRUFBRSwrQkFBK0IsNERBQTRELEVBQUUsc0NBQXNDLG1DQUFtQyxFQUFFLHdDQUF3QyxxQ0FBcUMsRUFBRSw4Q0FBOEMsNEVBQTRFLEVBQUUsNkJBQTZCLHlCQUF5QixFQUFFLDhCQUE4Qix5QkFBeUIsRUFBRSwrQkFBK0IsNHZDQUE0dkMsR0FBRyxjQUFjLGlCQUFpQixpREFBaUQsOEhBQThILDhDQUE4QyxxTkFBcU4sNERBQTRELCtDQUErQyxlQUFlLDZDQUE2QyxjQUFjLDZDQUE2Qyx3SUFBd0ksS0FBSyx3R0FBd0csdUJBQXVCLHlSQUF5UixtZUFBbWUsb0JBQW9CLHVCQUF1QixxQ0FBcUMsd0JBQXdCLHNCQUFzQiw0QkFBNEIsS0FBSyw0RUFBNEUsdVRBQXVULHVEQUF1RCxxQkFBcUIsTUFBTSxrQ0FBa0Msb0RBQW9ELDhFQUE4RSxXQUFXLDBCQUEwQix1QkFBdUIsS0FBSyxNQUFNLDRCQUE0QixZQUFZLG1CQUFtQixrQkFBa0IsZ0NBQWdDLGVBQWUseUZBQXlGLGdGQUFnRix1QkFBdUIsVUFBVSx3Q0FBd0MsNEJBQTRCLHlEQUF5RCw0REFBNEQsbUJBQW1CLGdCQUFnQixLQUFLLHdCQUF3Qiw0Q0FBNEMsY0FBYyx5QkFBeUIsMEJBQTBCLGlCQUFpQixFQUFFLGlCQUFpQix5TEFBeUwsNGtCQUE0a0IsMEZBQTBGLHlCQUF5Qix3QkFBd0IsVUFBVSw4Q0FBOEMsUUFBUSxnREFBZ0QsdUdBQXVHLE1BQU0sMEJBQTBCLE9BQU8sMEJBQTBCLFFBQVEscUNBQXFDLFlBQVkscUNBQXFDLE9BQU8sc0JBQXNCLE1BQU0sNDZDQUE0NkMsMnhCQUEyeEIsU0FBUyxtRkFBbUYsUUFBUSwrRUFBK0UsUUFBUSwyQkFBMkIsb0JBQW9CLGdFQUFnRSx3SEFBd0gsNENBQTRDLElBQUksNEJBQTRCLGdDQUFnQywrQkFBK0IsdUNBQXVDLDhCQUE4QixxQ0FBcUMsRUFBRSw0QkFBNEIsZ0lBQWdJLHFDQUFxQywrRUFBK0UsbUNBQW1DLFNBQVMscUNBQXFDLDJJQUEySSxrSEFBa0gsNkVBQTZFLFFBQVEsc0NBQXNDLDRFQUE0RSw2QkFBNkIsd0RBQXdELDZnQkFBNmdCLEVBQUUsOEJBQThCLCtEQUErRCxtQkFBbUIsRUFBRSxpQ0FBaUMsZ0lBQWdJLHNDQUFzQyxxREFBcUQseUNBQXlDLDBEQUEwRCx5REFBeUQsS0FBSyxlQUFlLDBCQUEwQixpSEFBaUgsd0VBQXdFLDZFQUE2RSxHQUFHLGdTQUFnUyxFQUFFLHFDQUFxQyxXQUFXLDBDQUEwQyxnQ0FBZ0MsMERBQTBELDBCQUEwQixtQ0FBbUMsK0ZBQStGLHVGQUF1RixvQ0FBb0MsZ0NBQWdDLEdBQUcsMkNBQTJDLGdDQUFnQyxJQUFJLEVBQUUsaUNBQWlDLDhCQUE4QixFQUFFLGlDQUFpQyw4QkFBOEIsRUFBRSxpQ0FBaUMsOERBQThELHFJQUFxSSwrRUFBK0UsRUFBRSxtQ0FBbUMsK0RBQStELDZEQUE2RCw4QkFBOEIsNENBQTRDLDBDQUEwQyw2RUFBNkUsa0JBQWtCLHlCQUF5QiwyQ0FBMkMsS0FBSywwREFBMEQsdUNBQXVDLCtRQUErUSwrQkFBK0IsNkVBQTZFLCtEQUErRCx5QkFBeUIsR0FBRyxFQUFFLG1DQUFtQyxnRUFBZ0UsMENBQTBDLGdGQUFnRixzUEFBc1AsRUFBRSx5Q0FBeUMsMEZBQTBGLG1YQUFtWCxJQUFJLGtPQUFrTyxpSkFBaUosMkVBQTJFLGlCQUFpQiw2RUFBNkUsR0FBRyxLQUFLLDZFQUE2RSxxSUFBcUksMkVBQTJFLGlCQUFpQiw2RUFBNkUsR0FBRyx1QkFBdUIsWUFBWSx1QkFBdUIsRUFBRSx1Q0FBdUMsa0NBQWtDLDJCQUEyQixxQ0FBcUMsOEVBQThFLDZEQUE2RCxNQUFNLHdYQUF3WCxVQUFVLGtPQUFrTyxtRkFBbUYseUhBQXlILEVBQUUsdUZBQXVGLHlJQUF5SSx1SEFBdUgsK0dBQStHLElBQUksRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUUsK0NBQStDLHdDQUF3QywrQkFBK0IsRUFBRSx1Q0FBdUMsU0FBUyx5Q0FBeUMsb0NBQW9DLGtFQUFrRSxxQ0FBcUMseUJBQXlCLEVBQUUseUNBQXlDLFNBQVMseUNBQXlDLG9DQUFvQyxxQ0FBcUMseUJBQXlCLEVBQUUsdUNBQXVDLFNBQVMseUNBQXlDLG9DQUFvQyxpRUFBaUUscUNBQXFDLHlCQUF5QixFQUFFLHdDQUF3QyxNQUFNLGtFQUFrRSxTQUFTLHlDQUF5QyxvQ0FBb0MscUNBQXFDLHdGQUF3RixFQUFFLG9DQUFvQyxXQUFXLDBCQUEwQixTQUFTLGdDQUFnQyx5Q0FBeUMsSUFBSSxpREFBaUQsNEhBQTRILDhCQUE4QixpQ0FBaUMsMkJBQTJCLEVBQUUsd0NBQXdDLFNBQVMsc0NBQXNDLHdDQUF3QyxNQUFNLEVBQUUsbUNBQW1DLGdCQUFnQiwyS0FBMksseUNBQXlDLElBQUksMkRBQTJELEdBQUcsU0FBUyxtR0FBbUcseUNBQXlDLElBQUksbUdBQW1HLFNBQVMsRUFBRSw2Q0FBNkMsNkJBQTZCLG9CQUFvQixJQUFJLEVBQUUsbUNBQW1DLHdLQUF3SyxFQUFFLHNDQUFzQyxxRUFBcUUsRUFBRSwyQ0FBMkMsbUJBQW1CLEVBQUUsMkNBQTJDLFNBQVMsbUZBQW1GLGlDQUFpQyxtREFBbUQsb0JBQW9CLEVBQUUsNkJBQTZCLFdBQVcsdUJBQXVCLG9DQUFvQyxpQkFBaUIsMEpBQTBKLEdBQUcsMk1BQTJNLHdCQUF3QixRQUFRLGlCQUFpQixRQUFRLGlCQUFpQixTQUFTLG9DQUFvQyxnREFBZ0QsYUFBYSxpQ0FBaUMsZ1JBQWdSLDJHQUEyRyx1Q0FBdUMsOEJBQThCLDRHQUE0RyxxREFBcUQsa0NBQWtDLGlEQUFpRCxxREFBcUQsa0NBQWtDLHVFQUF1RSx1Q0FBdUMsdUtBQXVLLGtDQUFrQyxnSEFBZ0gsd0VBQXdFLHlDQUF5QyxZQUFZLGlCQUFpQixFQUFFLDhCQUE4QixrRUFBa0UsNENBQTRDLCtIQUErSCx3RkFBd0YsU0FBUyx3SEFBd0gsV0FBVyxrSkFBa0osMElBQTBJLElBQUksTUFBTSw4RUFBOEUsT0FBTywyQ0FBMkMsaUNBQWlDLG9TQUFvUyw4REFBOEQsOENBQThDLHNCQUFzQixpSUFBaUksSUFBSSxpR0FBaUcsUUFBUSxFQUFFLDhCQUE4QixhQUFhLEVBQUUsK0NBQStDLGtCQUFrQiwwUkFBMFIsRUFBRSw0QkFBNEIsZ0VBQWdFLHlEQUF5RCxFQUFFLDZCQUE2QixXQUFXLHVCQUF1QixnQkFBZ0IsaUZBQWlGLGlCQUFpQixTQUFTLHlCQUF5Qiw4TEFBOEwsaUNBQWlDLG9OQUFvTiw4RkFBOEYsd0VBQXdFLGNBQWMsb0JBQW9CLDBOQUEwTiw2Q0FBNkMsZ0VBQWdFLElBQUksRUFBRSwrQkFBK0IsK0VBQStFLEVBQUUsNkJBQTZCLDhEQUE4RCw0RUFBNEUscUJBQXFCLHdCQUF3QixHQUFHLEVBQUUsK0JBQStCLGlCQUFpQixFQUFFLGdDQUFnQyw4RUFBOEUsZ0NBQWdDLGtDQUFrQywwQkFBMEIsOEJBQThCLCtCQUErQixJQUFJLEVBQUUsc0NBQXNDLGdEQUFnRCxFQUFFLCtCQUErQixlQUFlLEdBQUcsa0JBQWtCLCtEQUErRCxhQUFhLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL25vZGVfbW9kdWxlcy9nbGlnaHRib3gvZGlzdC9qcy9nbGlnaHRib3gubWluLmpzPzdiNjAiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KGU9ZXx8c2VsZikuR0xpZ2h0Ym94PXQoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKGUpe3ZhciB0PWZ1bmN0aW9uKGUsdCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fCFlKXJldHVybiBlO3ZhciBpPWVbU3ltYm9sLnRvUHJpbWl0aXZlXTtpZih2b2lkIDAhPT1pKXt2YXIgbj1pLmNhbGwoZSx0fHxcImRlZmF1bHRcIik7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG4pcmV0dXJuIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpfXJldHVybihcInN0cmluZ1wiPT09dD9TdHJpbmc6TnVtYmVyKShlKX0oZSxcInN0cmluZ1wiKTtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdD90OnQrXCJcIn1mdW5jdGlvbiB0KGUpe3JldHVybih0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBpKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBuKHQsaSl7Zm9yKHZhciBuPTA7bjxpLmxlbmd0aDtuKyspe3ZhciBzPWlbbl07cy5lbnVtZXJhYmxlPXMuZW51bWVyYWJsZXx8ITEscy5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gcyYmKHMud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUocy5rZXkpLHMpfX1mdW5jdGlvbiBzKGUsdCxpKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxpJiZuKGUsaSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJwcm90b3R5cGVcIix7d3JpdGFibGU6ITF9KSxlfXZhciBsPURhdGUubm93KCk7ZnVuY3Rpb24gbygpe3ZhciBlPXt9LHQ9ITAsaT0wLG49YXJndW1lbnRzLmxlbmd0aDtcIltvYmplY3QgQm9vbGVhbl1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHNbMF0pJiYodD1hcmd1bWVudHNbMF0saSsrKTtmb3IodmFyIHM9ZnVuY3Rpb24oaSl7Zm9yKHZhciBuIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksbikmJih0JiZcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlbbl0pP2Vbbl09byghMCxlW25dLGlbbl0pOmVbbl09aVtuXSl9O2k8bjtpKyspe3ZhciBsPWFyZ3VtZW50c1tpXTtzKGwpfXJldHVybiBlfWZ1bmN0aW9uIHIoZSx0KXtpZigoRShlKXx8ZT09PXdpbmRvd3x8ZT09PWRvY3VtZW50KSYmKGU9W2VdKSxMKGUpfHxJKGUpfHwoZT1bZV0pLDAhPU0oZSkpaWYoTChlKSYmIUkoZSkpZm9yKHZhciBpPWUubGVuZ3RoLG49MDtuPGkmJiExIT09dC5jYWxsKGVbbl0sZVtuXSxuLGUpO24rKyk7ZWxzZSBpZihJKGUpKWZvcih2YXIgcyBpbiBlKWlmKFAoZSxzKSYmITE9PT10LmNhbGwoZVtzXSxlW3NdLHMsZSkpYnJlYWt9ZnVuY3Rpb24gYShlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06bnVsbCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49ZVtsXT1lW2xdfHxbXSxzPXthbGw6bixldnQ6bnVsbCxmb3VuZDpudWxsfTtyZXR1cm4gdCYmaSYmTShuKT4wJiZyKG4sKGZ1bmN0aW9uKGUsbil7aWYoZS5ldmVudE5hbWU9PXQmJmUuZm4udG9TdHJpbmcoKT09aS50b1N0cmluZygpKXJldHVybiBzLmZvdW5kPSEwLHMuZXZ0PW4sITF9KSksc31mdW5jdGlvbiBoKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxpPXQub25FbGVtZW50LG49dC53aXRoQ2FsbGJhY2sscz10LmF2b2lkRHVwbGljYXRlLGw9dm9pZCAwPT09c3x8cyxvPXQub25jZSxoPXZvaWQgMCE9PW8mJm8sZD10LnVzZUNhcHR1cmUsYz12b2lkIDAhPT1kJiZkLHU9YXJndW1lbnRzLmxlbmd0aD4yP2FyZ3VtZW50c1syXTp2b2lkIDAsZz1pfHxbXTtmdW5jdGlvbiB2KGUpe0MobikmJm4uY2FsbCh1LGUsdGhpcyksaCYmdi5kZXN0cm95KCl9cmV0dXJuIGsoZykmJihnPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZykpLHYuZGVzdHJveT1mdW5jdGlvbigpe3IoZywoZnVuY3Rpb24odCl7dmFyIGk9YSh0LGUsdik7aS5mb3VuZCYmaS5hbGwuc3BsaWNlKGkuZXZ0LDEpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lciYmdC5yZW1vdmVFdmVudExpc3RlbmVyKGUsdixjKX0pKX0scihnLChmdW5jdGlvbih0KXt2YXIgaT1hKHQsZSx2KTsodC5hZGRFdmVudExpc3RlbmVyJiZsJiYhaS5mb3VuZHx8IWwpJiYodC5hZGRFdmVudExpc3RlbmVyKGUsdixjKSxpLmFsbC5wdXNoKHtldmVudE5hbWU6ZSxmbjp2fSkpfSkpLHZ9ZnVuY3Rpb24gZChlLHQpe3IodC5zcGxpdChcIiBcIiksKGZ1bmN0aW9uKHQpe3JldHVybiBlLmNsYXNzTGlzdC5hZGQodCl9KSl9ZnVuY3Rpb24gYyhlLHQpe3IodC5zcGxpdChcIiBcIiksKGZ1bmN0aW9uKHQpe3JldHVybiBlLmNsYXNzTGlzdC5yZW1vdmUodCl9KSl9ZnVuY3Rpb24gdShlLHQpe3JldHVybiBlLmNsYXNzTGlzdC5jb250YWlucyh0KX1mdW5jdGlvbiBnKGUsdCl7Zm9yKDtlIT09ZG9jdW1lbnQuYm9keTspe2lmKCEoZT1lLnBhcmVudEVsZW1lbnQpKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUubWF0Y2hlcz9lLm1hdGNoZXModCk6ZS5tc01hdGNoZXNTZWxlY3Rvcih0KSlyZXR1cm4gZX19ZnVuY3Rpb24gdihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJcIixpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07aWYoIWV8fFwiXCI9PT10KXJldHVybiExO2lmKFwibm9uZVwiPT09dClyZXR1cm4gQyhpKSYmaSgpLCExO3ZhciBuPWIoKSxzPXQuc3BsaXQoXCIgXCIpO3IocywoZnVuY3Rpb24odCl7ZChlLFwiZ1wiK3QpfSkpLGgobix7b25FbGVtZW50OmUsYXZvaWREdXBsaWNhdGU6ITEsb25jZTohMCx3aXRoQ2FsbGJhY2s6ZnVuY3Rpb24oZSx0KXtyKHMsKGZ1bmN0aW9uKGUpe2ModCxcImdcIitlKX0pKSxDKGkpJiZpKCl9fSl9ZnVuY3Rpb24gZihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJcIjtpZihcIlwiPT09dClyZXR1cm4gZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm09XCJcIixlLnN0eWxlLk1velRyYW5zZm9ybT1cIlwiLGUuc3R5bGUubXNUcmFuc2Zvcm09XCJcIixlLnN0eWxlLk9UcmFuc2Zvcm09XCJcIixlLnN0eWxlLnRyYW5zZm9ybT1cIlwiLCExO2Uuc3R5bGUud2Via2l0VHJhbnNmb3JtPXQsZS5zdHlsZS5Nb3pUcmFuc2Zvcm09dCxlLnN0eWxlLm1zVHJhbnNmb3JtPXQsZS5zdHlsZS5PVHJhbnNmb3JtPXQsZS5zdHlsZS50cmFuc2Zvcm09dH1mdW5jdGlvbiBwKGUpe2Uuc3R5bGUuZGlzcGxheT1cImJsb2NrXCJ9ZnVuY3Rpb24gbShlKXtlLnN0eWxlLmRpc3BsYXk9XCJub25lXCJ9ZnVuY3Rpb24geShlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2ZvcihpLmlubmVySFRNTD1lO2kuZmlyc3RDaGlsZDspdC5hcHBlbmRDaGlsZChpLmZpcnN0Q2hpbGQpO3JldHVybiB0fWZ1bmN0aW9uIHgoKXtyZXR1cm57d2lkdGg6d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aHx8ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCxoZWlnaHQ6d2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0fHxkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodH19ZnVuY3Rpb24gYigpe3ZhciBlLHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZha2VlbGVtZW50XCIpLGk9e2FuaW1hdGlvbjpcImFuaW1hdGlvbmVuZFwiLE9BbmltYXRpb246XCJvQW5pbWF0aW9uRW5kXCIsTW96QW5pbWF0aW9uOlwiYW5pbWF0aW9uZW5kXCIsV2Via2l0QW5pbWF0aW9uOlwid2Via2l0QW5pbWF0aW9uRW5kXCJ9O2ZvcihlIGluIGkpaWYodm9pZCAwIT09dC5zdHlsZVtlXSlyZXR1cm4gaVtlXX1mdW5jdGlvbiBTKGUsdCxpLG4pe2lmKGUoKSl0KCk7ZWxzZXt2YXIgcztpfHwoaT0xMDApO3ZhciBsPXNldEludGVydmFsKChmdW5jdGlvbigpe2UoKSYmKGNsZWFySW50ZXJ2YWwobCkscyYmY2xlYXJUaW1lb3V0KHMpLHQoKSl9KSxpKTtuJiYocz1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwobCl9KSxuKSl9fWZ1bmN0aW9uIHcoZSx0LGkpe2lmKE8oZSkpY29uc29sZS5lcnJvcihcIkluamVjdCBhc3NldHMgZXJyb3JcIik7ZWxzZSBpZihDKHQpJiYoaT10LHQ9ITEpLGsodCkmJnQgaW4gd2luZG93KUMoaSkmJmkoKTtlbHNle3ZhciBuO2lmKC0xIT09ZS5pbmRleE9mKFwiLmNzc1wiKSl7aWYoKG49ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tocmVmPVwiJytlKydcIl0nKSkmJm4ubGVuZ3RoPjApcmV0dXJuIHZvaWQoQyhpKSYmaSgpKTt2YXIgcz1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0sbD1zLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXScpLG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7cmV0dXJuIG8ucmVsPVwic3R5bGVzaGVldFwiLG8udHlwZT1cInRleHQvY3NzXCIsby5ocmVmPWUsby5tZWRpYT1cImFsbFwiLGw/cy5pbnNlcnRCZWZvcmUobyxsWzBdKTpzLmFwcGVuZENoaWxkKG8pLHZvaWQoQyhpKSYmaSgpKX1pZigobj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbc3JjPVwiJytlKydcIl0nKSkmJm4ubGVuZ3RoPjApe2lmKEMoaSkpe2lmKGsodCkpcmV0dXJuIFMoKGZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXdpbmRvd1t0XX0pLChmdW5jdGlvbigpe2koKX0pKSwhMTtpKCl9fWVsc2V7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtyLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIixyLnNyYz1lLHIub25sb2FkPWZ1bmN0aW9uKCl7aWYoQyhpKSl7aWYoayh0KSlyZXR1cm4gUygoZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09d2luZG93W3RdfSksKGZ1bmN0aW9uKCl7aSgpfSkpLCExO2koKX19LGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocil9fX1mdW5jdGlvbiBUKCl7cmV0dXJuXCJuYXZpZ2F0b3JcImluIHdpbmRvdyYmd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLyhpUGFkKXwoaVBob25lKXwoaVBvZCl8KEFuZHJvaWQpfChQbGF5Qm9vayl8KEJCMTApfChCbGFja0JlcnJ5KXwoT3BlcmEgTWluaSl8KElFTW9iaWxlKXwod2ViT1MpfChNZWVHbykvaSl9ZnVuY3Rpb24gQyhlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlfWZ1bmN0aW9uIGsoZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV9ZnVuY3Rpb24gRShlKXtyZXR1cm4hKCFlfHwhZS5ub2RlVHlwZXx8MSE9ZS5ub2RlVHlwZSl9ZnVuY3Rpb24gQShlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKX1mdW5jdGlvbiBMKGUpe3JldHVybiBlJiZlLmxlbmd0aCYmaXNGaW5pdGUoZS5sZW5ndGgpfWZ1bmN0aW9uIEkoZSl7cmV0dXJuXCJvYmplY3RcIj09PXQoZSkmJm51bGwhPWUmJiFDKGUpJiYhQShlKX1mdW5jdGlvbiBPKGUpe3JldHVybiBudWxsPT1lfWZ1bmN0aW9uIFAoZSx0KXtyZXR1cm4gbnVsbCE9PWUmJmhhc093blByb3BlcnR5LmNhbGwoZSx0KX1mdW5jdGlvbiBNKGUpe2lmKEkoZSkpe2lmKGUua2V5cylyZXR1cm4gZS5rZXlzKCkubGVuZ3RoO3ZhciB0PTA7Zm9yKHZhciBpIGluIGUpUChlLGkpJiZ0Kys7cmV0dXJuIHR9cmV0dXJuIGUubGVuZ3RofWZ1bmN0aW9uIHooZSl7cmV0dXJuIWlzTmFOKHBhcnNlRmxvYXQoZSkpJiZpc0Zpbml0ZShlKX1mdW5jdGlvbiBYKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOi0xLHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5nYnRuW2RhdGEtdGFib3JkZXJdOm5vdCguZGlzYWJsZWQpXCIpO2lmKCF0Lmxlbmd0aClyZXR1cm4hMTtpZigxPT10Lmxlbmd0aClyZXR1cm4gdFswXTtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9cGFyc2VJbnQoZSkpO3ZhciBpPVtdO3IodCwoZnVuY3Rpb24oZSl7aS5wdXNoKGUuZ2V0QXR0cmlidXRlKFwiZGF0YS10YWJvcmRlclwiKSl9KSk7dmFyIG49TWF0aC5tYXguYXBwbHkoTWF0aCxpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUpfSkpKSxzPWU8MD8xOmUrMTtzPm4mJihzPVwiMVwiKTt2YXIgbD1pLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGU+PXBhcnNlSW50KHMpfSkpLG89bC5zb3J0KClbMF07cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5nYnRuW2RhdGEtdGFib3JkZXI9XCInLmNvbmNhdChvLCdcIl0nKSl9ZnVuY3Rpb24gWShlKXtpZihlLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShcImtleWJvYXJkXCIpKXJldHVybiExO2UuZXZlbnRzLmtleWJvYXJkPWgoXCJrZXlkb3duXCIse29uRWxlbWVudDp3aW5kb3csd2l0aENhbGxiYWNrOmZ1bmN0aW9uKHQsaSl7dmFyIG49KHQ9dHx8d2luZG93LmV2ZW50KS5rZXlDb2RlO2lmKDk9PW4pe3ZhciBzPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZ2J0bi5mb2N1c2VkXCIpO2lmKCFzKXt2YXIgbD0hKCFkb2N1bWVudC5hY3RpdmVFbGVtZW50fHwhZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSkmJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtpZihcImlucHV0XCI9PWx8fFwidGV4dGFyZWFcIj09bHx8XCJidXR0b25cIj09bClyZXR1cm59dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBvPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZ2J0bltkYXRhLXRhYm9yZGVyXVwiKTtpZighb3x8by5sZW5ndGg8PTApcmV0dXJuO2lmKCFzKXt2YXIgcj1YKCk7cmV0dXJuIHZvaWQociYmKHIuZm9jdXMoKSxkKHIsXCJmb2N1c2VkXCIpKSl9dmFyIGE9WChzLmdldEF0dHJpYnV0ZShcImRhdGEtdGFib3JkZXJcIikpO2MocyxcImZvY3VzZWRcIiksYSYmKGEuZm9jdXMoKSxkKGEsXCJmb2N1c2VkXCIpKX0zOT09biYmZS5uZXh0U2xpZGUoKSwzNz09biYmZS5wcmV2U2xpZGUoKSwyNz09biYmZS5jbG9zZSgpfX0pfXZhciBxPXMoKGZ1bmN0aW9uIGUodCxuKXt2YXIgcz10aGlzLGw9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7aWYoaSh0aGlzLGUpLHRoaXMuaW1nPXQsdGhpcy5zbGlkZT1uLHRoaXMub25jbG9zZT1sLHRoaXMuaW1nLnNldFpvb21FdmVudHMpcmV0dXJuITE7dGhpcy5hY3RpdmU9ITEsdGhpcy56b29tZWRJbj0hMSx0aGlzLmRyYWdnaW5nPSExLHRoaXMuY3VycmVudFg9bnVsbCx0aGlzLmN1cnJlbnRZPW51bGwsdGhpcy5pbml0aWFsWD1udWxsLHRoaXMuaW5pdGlhbFk9bnVsbCx0aGlzLnhPZmZzZXQ9MCx0aGlzLnlPZmZzZXQ9MCx0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsKGZ1bmN0aW9uKGUpe3JldHVybiBzLmRyYWdTdGFydChlKX0pLCExKSx0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLChmdW5jdGlvbihlKXtyZXR1cm4gcy5kcmFnRW5kKGUpfSksITEpLHRoaXMuaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwoZnVuY3Rpb24oZSl7cmV0dXJuIHMuZHJhZyhlKX0pLCExKSx0aGlzLmltZy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwoZnVuY3Rpb24oZSl7cmV0dXJuIHMuc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZHJhZ2dpbmctbmF2XCIpPyhzLnpvb21PdXQoKSwhMSk6cy56b29tZWRJbj92b2lkKHMuem9vbWVkSW4mJiFzLmRyYWdnaW5nJiZzLnpvb21PdXQoKSk6cy56b29tSW4oKX0pLCExKSx0aGlzLmltZy5zZXRab29tRXZlbnRzPSEwfSksW3trZXk6XCJ6b29tSW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMud2lkb3dXaWR0aCgpO2lmKCEodGhpcy56b29tZWRJbnx8ZTw9NzY4KSl7dmFyIHQ9dGhpcy5pbWc7aWYodC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlXCIsdC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSksdC5zdHlsZS5tYXhXaWR0aD10Lm5hdHVyYWxXaWR0aCtcInB4XCIsdC5zdHlsZS5tYXhIZWlnaHQ9dC5uYXR1cmFsSGVpZ2h0K1wicHhcIix0Lm5hdHVyYWxXaWR0aD5lKXt2YXIgaT1lLzItdC5uYXR1cmFsV2lkdGgvMjt0aGlzLnNldFRyYW5zbGF0ZSh0aGlzLmltZy5wYXJlbnROb2RlLGksMCl9dGhpcy5zbGlkZS5jbGFzc0xpc3QuYWRkKFwiem9vbWVkXCIpLHRoaXMuem9vbWVkSW49ITB9fX0se2tleTpcInpvb21PdXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW1nLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcIlwiKSx0aGlzLmltZy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLHRoaXMuaW1nLmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVcIikpLHRoaXMuc2xpZGUuY2xhc3NMaXN0LnJlbW92ZShcInpvb21lZFwiKSx0aGlzLnpvb21lZEluPSExLHRoaXMuY3VycmVudFg9bnVsbCx0aGlzLmN1cnJlbnRZPW51bGwsdGhpcy5pbml0aWFsWD1udWxsLHRoaXMuaW5pdGlhbFk9bnVsbCx0aGlzLnhPZmZzZXQ9MCx0aGlzLnlPZmZzZXQ9MCx0aGlzLm9uY2xvc2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub25jbG9zZSYmdGhpcy5vbmNsb3NlKCl9fSx7a2V5OlwiZHJhZ1N0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuem9vbWVkSW4/KFwidG91Y2hzdGFydFwiPT09ZS50eXBlPyh0aGlzLmluaXRpYWxYPWUudG91Y2hlc1swXS5jbGllbnRYLXRoaXMueE9mZnNldCx0aGlzLmluaXRpYWxZPWUudG91Y2hlc1swXS5jbGllbnRZLXRoaXMueU9mZnNldCk6KHRoaXMuaW5pdGlhbFg9ZS5jbGllbnRYLXRoaXMueE9mZnNldCx0aGlzLmluaXRpYWxZPWUuY2xpZW50WS10aGlzLnlPZmZzZXQpLGUudGFyZ2V0PT09dGhpcy5pbWcmJih0aGlzLmFjdGl2ZT0hMCx0aGlzLmltZy5jbGFzc0xpc3QuYWRkKFwiZHJhZ2dpbmdcIikpKTp0aGlzLmFjdGl2ZT0hMX19LHtrZXk6XCJkcmFnRW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlLnByZXZlbnREZWZhdWx0KCksdGhpcy5pbml0aWFsWD10aGlzLmN1cnJlbnRYLHRoaXMuaW5pdGlhbFk9dGhpcy5jdXJyZW50WSx0aGlzLmFjdGl2ZT0hMSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3QuZHJhZ2dpbmc9ITEsdC5pbWcuaXNEcmFnZ2luZz0hMSx0LmltZy5jbGFzc0xpc3QucmVtb3ZlKFwiZHJhZ2dpbmdcIil9KSwxMDApfX0se2tleTpcImRyYWdcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmFjdGl2ZSYmKGUucHJldmVudERlZmF1bHQoKSxcInRvdWNobW92ZVwiPT09ZS50eXBlPyh0aGlzLmN1cnJlbnRYPWUudG91Y2hlc1swXS5jbGllbnRYLXRoaXMuaW5pdGlhbFgsdGhpcy5jdXJyZW50WT1lLnRvdWNoZXNbMF0uY2xpZW50WS10aGlzLmluaXRpYWxZKToodGhpcy5jdXJyZW50WD1lLmNsaWVudFgtdGhpcy5pbml0aWFsWCx0aGlzLmN1cnJlbnRZPWUuY2xpZW50WS10aGlzLmluaXRpYWxZKSx0aGlzLnhPZmZzZXQ9dGhpcy5jdXJyZW50WCx0aGlzLnlPZmZzZXQ9dGhpcy5jdXJyZW50WSx0aGlzLmltZy5pc0RyYWdnaW5nPSEwLHRoaXMuZHJhZ2dpbmc9ITAsdGhpcy5zZXRUcmFuc2xhdGUodGhpcy5pbWcsdGhpcy5jdXJyZW50WCx0aGlzLmN1cnJlbnRZKSl9fSx7a2V5Olwib25Nb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy56b29tZWRJbil7dmFyIHQ9ZS5jbGllbnRYLXRoaXMuaW1nLm5hdHVyYWxXaWR0aC8yLGk9ZS5jbGllbnRZLXRoaXMuaW1nLm5hdHVyYWxIZWlnaHQvMjt0aGlzLnNldFRyYW5zbGF0ZSh0aGlzLmltZyx0LGkpfX19LHtrZXk6XCJzZXRUcmFuc2xhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSl7ZS5zdHlsZS50cmFuc2Zvcm09XCJ0cmFuc2xhdGUzZChcIit0K1wicHgsIFwiK2krXCJweCwgMClcIn19LHtrZXk6XCJ3aWRvd1dpZHRoXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aHx8ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aH19XSksTj1zKChmdW5jdGlvbiBlKCl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpKHRoaXMsZSk7dmFyIHM9bi5kcmFnRWwsbD1uLnRvbGVyYW5jZVgsbz12b2lkIDA9PT1sPzQwOmwscj1uLnRvbGVyYW5jZVksYT12b2lkIDA9PT1yPzY1OnIsaD1uLnNsaWRlLGQ9dm9pZCAwPT09aD9udWxsOmgsYz1uLmluc3RhbmNlLHU9dm9pZCAwPT09Yz9udWxsOmM7dGhpcy5lbD1zLHRoaXMuYWN0aXZlPSExLHRoaXMuZHJhZ2dpbmc9ITEsdGhpcy5jdXJyZW50WD1udWxsLHRoaXMuY3VycmVudFk9bnVsbCx0aGlzLmluaXRpYWxYPW51bGwsdGhpcy5pbml0aWFsWT1udWxsLHRoaXMueE9mZnNldD0wLHRoaXMueU9mZnNldD0wLHRoaXMuZGlyZWN0aW9uPW51bGwsdGhpcy5sYXN0RGlyZWN0aW9uPW51bGwsdGhpcy50b2xlcmFuY2VYPW8sdGhpcy50b2xlcmFuY2VZPWEsdGhpcy50b2xlcmFuY2VSZWFjaGVkPSExLHRoaXMuZHJhZ0NvbnRhaW5lcj10aGlzLmVsLHRoaXMuc2xpZGU9ZCx0aGlzLmluc3RhbmNlPXUsdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmRyYWdTdGFydChlKX0pLCExKSx0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmRyYWdFbmQoZSl9KSwhMSksdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmRyYWcoZSl9KSwhMSl9KSxbe2tleTpcImRyYWdTdGFydFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiem9vbWVkXCIpKXRoaXMuYWN0aXZlPSExO2Vsc2V7XCJ0b3VjaHN0YXJ0XCI9PT1lLnR5cGU/KHRoaXMuaW5pdGlhbFg9ZS50b3VjaGVzWzBdLmNsaWVudFgtdGhpcy54T2Zmc2V0LHRoaXMuaW5pdGlhbFk9ZS50b3VjaGVzWzBdLmNsaWVudFktdGhpcy55T2Zmc2V0KToodGhpcy5pbml0aWFsWD1lLmNsaWVudFgtdGhpcy54T2Zmc2V0LHRoaXMuaW5pdGlhbFk9ZS5jbGllbnRZLXRoaXMueU9mZnNldCk7dmFyIHQ9ZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJub2RyYWdcIil8fGcoZS50YXJnZXQsXCIubm9kcmFnXCIpfHwtMSE9PVtcImlucHV0XCIsXCJzZWxlY3RcIixcInRleHRhcmVhXCIsXCJidXR0b25cIixcImFcIl0uaW5kZXhPZih0KT90aGlzLmFjdGl2ZT0hMTooZS5wcmV2ZW50RGVmYXVsdCgpLChlLnRhcmdldD09PXRoaXMuZWx8fFwiaW1nXCIhPT10JiZnKGUudGFyZ2V0LFwiLmdzbGlkZS1pbmxpbmVcIikpJiYodGhpcy5hY3RpdmU9ITAsdGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiZHJhZ2dpbmdcIiksdGhpcy5kcmFnQ29udGFpbmVyPWcoZS50YXJnZXQsXCIuZ2lubmVyLWNvbnRhaW5lclwiKSkpfX19LHtrZXk6XCJkcmFnRW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlJiZlLnByZXZlbnREZWZhdWx0KCksdGhpcy5pbml0aWFsWD0wLHRoaXMuaW5pdGlhbFk9MCx0aGlzLmN1cnJlbnRYPW51bGwsdGhpcy5jdXJyZW50WT1udWxsLHRoaXMuaW5pdGlhbFg9bnVsbCx0aGlzLmluaXRpYWxZPW51bGwsdGhpcy54T2Zmc2V0PTAsdGhpcy55T2Zmc2V0PTAsdGhpcy5hY3RpdmU9ITEsdGhpcy5kb1NsaWRlQ2hhbmdlJiYodGhpcy5pbnN0YW5jZS5wcmV2ZW50T3V0c2lkZUNsaWNrPSEwLFwicmlnaHRcIj09dGhpcy5kb1NsaWRlQ2hhbmdlJiZ0aGlzLmluc3RhbmNlLnByZXZTbGlkZSgpLFwibGVmdFwiPT10aGlzLmRvU2xpZGVDaGFuZ2UmJnRoaXMuaW5zdGFuY2UubmV4dFNsaWRlKCkpLHRoaXMuZG9TbGlkZUNsb3NlJiZ0aGlzLmluc3RhbmNlLmNsb3NlKCksdGhpcy50b2xlcmFuY2VSZWFjaGVkfHx0aGlzLnNldFRyYW5zbGF0ZSh0aGlzLmRyYWdDb250YWluZXIsMCwwLCEwKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3QuaW5zdGFuY2UucHJldmVudE91dHNpZGVDbGljaz0hMSx0LnRvbGVyYW5jZVJlYWNoZWQ9ITEsdC5sYXN0RGlyZWN0aW9uPW51bGwsdC5kcmFnZ2luZz0hMSx0LmVsLmlzRHJhZ2dpbmc9ITEsdC5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiZHJhZ2dpbmdcIiksdC5zbGlkZS5jbGFzc0xpc3QucmVtb3ZlKFwiZHJhZ2dpbmctbmF2XCIpLHQuZHJhZ0NvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm09XCJcIix0LmRyYWdDb250YWluZXIuc3R5bGUudHJhbnNpdGlvbj1cIlwifSksMTAwKX19LHtrZXk6XCJkcmFnXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy5hY3RpdmUpe2UucHJldmVudERlZmF1bHQoKSx0aGlzLnNsaWRlLmNsYXNzTGlzdC5hZGQoXCJkcmFnZ2luZy1uYXZcIiksXCJ0b3VjaG1vdmVcIj09PWUudHlwZT8odGhpcy5jdXJyZW50WD1lLnRvdWNoZXNbMF0uY2xpZW50WC10aGlzLmluaXRpYWxYLHRoaXMuY3VycmVudFk9ZS50b3VjaGVzWzBdLmNsaWVudFktdGhpcy5pbml0aWFsWSk6KHRoaXMuY3VycmVudFg9ZS5jbGllbnRYLXRoaXMuaW5pdGlhbFgsdGhpcy5jdXJyZW50WT1lLmNsaWVudFktdGhpcy5pbml0aWFsWSksdGhpcy54T2Zmc2V0PXRoaXMuY3VycmVudFgsdGhpcy55T2Zmc2V0PXRoaXMuY3VycmVudFksdGhpcy5lbC5pc0RyYWdnaW5nPSEwLHRoaXMuZHJhZ2dpbmc9ITAsdGhpcy5kb1NsaWRlQ2hhbmdlPSExLHRoaXMuZG9TbGlkZUNsb3NlPSExO3ZhciB0PU1hdGguYWJzKHRoaXMuY3VycmVudFgpLGk9TWF0aC5hYnModGhpcy5jdXJyZW50WSk7aWYodD4wJiZ0Pj1NYXRoLmFicyh0aGlzLmN1cnJlbnRZKSYmKCF0aGlzLmxhc3REaXJlY3Rpb258fFwieFwiPT10aGlzLmxhc3REaXJlY3Rpb24pKXt0aGlzLnlPZmZzZXQ9MCx0aGlzLmxhc3REaXJlY3Rpb249XCJ4XCIsdGhpcy5zZXRUcmFuc2xhdGUodGhpcy5kcmFnQ29udGFpbmVyLHRoaXMuY3VycmVudFgsMCk7dmFyIG49dGhpcy5zaG91bGRDaGFuZ2UoKTtpZighdGhpcy5pbnN0YW5jZS5zZXR0aW5ncy5kcmFnQXV0b1NuYXAmJm4mJih0aGlzLmRvU2xpZGVDaGFuZ2U9biksdGhpcy5pbnN0YW5jZS5zZXR0aW5ncy5kcmFnQXV0b1NuYXAmJm4pcmV0dXJuIHRoaXMuaW5zdGFuY2UucHJldmVudE91dHNpZGVDbGljaz0hMCx0aGlzLnRvbGVyYW5jZVJlYWNoZWQ9ITAsdGhpcy5hY3RpdmU9ITEsdGhpcy5pbnN0YW5jZS5wcmV2ZW50T3V0c2lkZUNsaWNrPSEwLHRoaXMuZHJhZ0VuZChudWxsKSxcInJpZ2h0XCI9PW4mJnRoaXMuaW5zdGFuY2UucHJldlNsaWRlKCksdm9pZChcImxlZnRcIj09biYmdGhpcy5pbnN0YW5jZS5uZXh0U2xpZGUoKSl9aWYodGhpcy50b2xlcmFuY2VZPjAmJmk+MCYmaT49dCYmKCF0aGlzLmxhc3REaXJlY3Rpb258fFwieVwiPT10aGlzLmxhc3REaXJlY3Rpb24pKXt0aGlzLnhPZmZzZXQ9MCx0aGlzLmxhc3REaXJlY3Rpb249XCJ5XCIsdGhpcy5zZXRUcmFuc2xhdGUodGhpcy5kcmFnQ29udGFpbmVyLDAsdGhpcy5jdXJyZW50WSk7dmFyIHM9dGhpcy5zaG91bGRDbG9zZSgpO3JldHVybiF0aGlzLmluc3RhbmNlLnNldHRpbmdzLmRyYWdBdXRvU25hcCYmcyYmKHRoaXMuZG9TbGlkZUNsb3NlPSEwKSx2b2lkKHRoaXMuaW5zdGFuY2Uuc2V0dGluZ3MuZHJhZ0F1dG9TbmFwJiZzJiZ0aGlzLmluc3RhbmNlLmNsb3NlKCkpfX19fSx7a2V5Olwic2hvdWxkQ2hhbmdlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT0hMTtpZihNYXRoLmFicyh0aGlzLmN1cnJlbnRYKT49dGhpcy50b2xlcmFuY2VYKXt2YXIgdD10aGlzLmN1cnJlbnRYPjA/XCJyaWdodFwiOlwibGVmdFwiOyhcImxlZnRcIj09dCYmdGhpcy5zbGlkZSE9PXRoaXMuc2xpZGUucGFyZW50Tm9kZS5sYXN0Q2hpbGR8fFwicmlnaHRcIj09dCYmdGhpcy5zbGlkZSE9PXRoaXMuc2xpZGUucGFyZW50Tm9kZS5maXJzdENoaWxkKSYmKGU9dCl9cmV0dXJuIGV9fSx7a2V5Olwic2hvdWxkQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPSExO3JldHVybiBNYXRoLmFicyh0aGlzLmN1cnJlbnRZKT49dGhpcy50b2xlcmFuY2VZJiYoZT0hMCksZX19LHtrZXk6XCJzZXRUcmFuc2xhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQsaSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXTtlLnN0eWxlLnRyYW5zaXRpb249bj9cImFsbCAuMnMgZWFzZVwiOlwiXCIsZS5zdHlsZS50cmFuc2Zvcm09XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQodCxcInB4LCBcIikuY29uY2F0KGksXCJweCwgMClcIil9fV0pO2Z1bmN0aW9uIEQoZSx0LGksbil7dmFyIHM9ZS5xdWVyeVNlbGVjdG9yKFwiLmdzbGlkZS1tZWRpYVwiKSxsPW5ldyBJbWFnZSxvPVwiZ1NsaWRlVGl0bGVfXCIraSxyPVwiZ1NsaWRlRGVzY19cIitpO2wuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtDKG4pJiZuKCl9KSwhMSksbC5zcmM9dC5ocmVmLFwiXCIhPXQuc2l6ZXMmJlwiXCIhPXQuc3Jjc2V0JiYobC5zaXplcz10LnNpemVzLGwuc3Jjc2V0PXQuc3Jjc2V0KSxsLmFsdD1cIlwiLE8odC5hbHQpfHxcIlwiPT09dC5hbHR8fChsLmFsdD10LmFsdCksXCJcIiE9PXQudGl0bGUmJmwuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsbyksXCJcIiE9PXQuZGVzY3JpcHRpb24mJmwuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLHIpLHQuaGFzT3duUHJvcGVydHkoXCJfaGFzQ3VzdG9tV2lkdGhcIikmJnQuX2hhc0N1c3RvbVdpZHRoJiYobC5zdHlsZS53aWR0aD10LndpZHRoKSx0Lmhhc093blByb3BlcnR5KFwiX2hhc0N1c3RvbUhlaWdodFwiKSYmdC5faGFzQ3VzdG9tSGVpZ2h0JiYobC5zdHlsZS5oZWlnaHQ9dC5oZWlnaHQpLHMuaW5zZXJ0QmVmb3JlKGwscy5maXJzdENoaWxkKX1mdW5jdGlvbiBfKGUsdCxpLG4pe3ZhciBzPXRoaXMsbD1lLnF1ZXJ5U2VsZWN0b3IoXCIuZ2lubmVyLWNvbnRhaW5lclwiKSxvPVwiZ3ZpZGVvXCIraSxyPWUucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtbWVkaWFcIiksYT10aGlzLmdldEFsbFBsYXllcnMoKTtkKGwsXCJndmlkZW8tY29udGFpbmVyXCIpLHIuaW5zZXJ0QmVmb3JlKHkoJzxkaXYgY2xhc3M9XCJndmlkZW8td3JhcHBlclwiPjwvZGl2PicpLHIuZmlyc3RDaGlsZCk7dmFyIGg9ZS5xdWVyeVNlbGVjdG9yKFwiLmd2aWRlby13cmFwcGVyXCIpO3codGhpcy5zZXR0aW5ncy5wbHlyLmNzcyxcIlBseXJcIik7dmFyIGM9dC5ocmVmLHU9bnVsbD09dD92b2lkIDA6dC52aWRlb1Byb3ZpZGVyLGc9ITE7ci5zdHlsZS5tYXhXaWR0aD10LndpZHRoLHcodGhpcy5zZXR0aW5ncy5wbHlyLmpzLFwiUGx5clwiLChmdW5jdGlvbigpe2lmKCF1JiZjLm1hdGNoKC92aW1lb1xcLmNvbVxcLyhbMC05XSopLykmJih1PVwidmltZW9cIiksIXUmJihjLm1hdGNoKC8oeW91dHViZVxcLmNvbXx5b3V0dWJlLW5vY29va2llXFwuY29tKVxcL3dhdGNoXFw/dj0oW2EtekEtWjAtOVxcLV9dKykvKXx8Yy5tYXRjaCgveW91dHVcXC5iZVxcLyhbYS16QS1aMC05XFwtX10rKS8pfHxjLm1hdGNoKC8oeW91dHViZVxcLmNvbXx5b3V0dWJlLW5vY29va2llXFwuY29tKVxcL2VtYmVkXFwvKFthLXpBLVowLTlcXC1fXSspLyl8fGMubWF0Y2goLyh5b3V0dWJlXFwuY29tfHlvdXR1YmUtbm9jb29raWVcXC5jb20pXFwvc2hvcnRzXFwvKFthLXpBLVowLTlcXC1fXSspLykpJiYodT1cInlvdXR1YmVcIiksXCJsb2NhbFwiPT09dXx8IXUpe3U9XCJsb2NhbFwiO3ZhciBsPSc8dmlkZW8gaWQ9XCInK28rJ1wiICc7bCs9J3N0eWxlPVwiYmFja2dyb3VuZDojMDAwOyBtYXgtd2lkdGg6ICcuY29uY2F0KHQud2lkdGgsJztcIiAnKSxsKz0ncHJlbG9hZD1cIm1ldGFkYXRhXCIgJyxsKz0neC13ZWJraXQtYWlycGxheT1cImFsbG93XCIgJyxsKz1cInBsYXlzaW5saW5lIFwiLGwrPVwiY29udHJvbHMgXCIsbCs9J2NsYXNzPVwiZ3ZpZGVvLWxvY2FsXCI+JyxsKz0nPHNvdXJjZSBzcmM9XCInLmNvbmNhdChjLCdcIj4nKSxnPXkobCs9XCI8L3ZpZGVvPlwiKX12YXIgcj1nfHx5KCc8ZGl2IGlkPVwiJy5jb25jYXQobywnXCIgZGF0YS1wbHlyLXByb3ZpZGVyPVwiJykuY29uY2F0KHUsJ1wiIGRhdGEtcGx5ci1lbWJlZC1pZD1cIicpLmNvbmNhdChjLCdcIj48L2Rpdj4nKSk7ZChoLFwiXCIuY29uY2F0KHUsXCItdmlkZW8gZ3ZpZGVvXCIpKSxoLmFwcGVuZENoaWxkKHIpLGguc2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiLG8pLGguc2V0QXR0cmlidXRlKFwiZGF0YS1pbmRleFwiLGkpO3ZhciB2PVAocy5zZXR0aW5ncy5wbHlyLFwiY29uZmlnXCIpP3Muc2V0dGluZ3MucGx5ci5jb25maWc6e30sZj1uZXcgUGx5cihcIiNcIitvLHYpO2Yub24oXCJyZWFkeVwiLChmdW5jdGlvbihlKXthW29dPWUuZGV0YWlsLnBseXIsQyhuKSYmbigpfSkpLFMoKGZ1bmN0aW9uKCl7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKSYmXCJ0cnVlXCI9PWUucXVlcnlTZWxlY3RvcihcImlmcmFtZVwiKS5kYXRhc2V0LnJlYWR5fSksKGZ1bmN0aW9uKCl7cy5yZXNpemUoZSl9KSksZi5vbihcImVudGVyZnVsbHNjcmVlblwiLFcpLGYub24oXCJleGl0ZnVsbHNjcmVlblwiLFcpfSkpfWZ1bmN0aW9uIFcoZSl7dmFyIHQ9ZyhlLnRhcmdldCxcIi5nc2xpZGUtbWVkaWFcIik7XCJlbnRlcmZ1bGxzY3JlZW5cIj09PWUudHlwZSYmZCh0LFwiZnVsbHNjcmVlblwiKSxcImV4aXRmdWxsc2NyZWVuXCI9PT1lLnR5cGUmJmModCxcImZ1bGxzY3JlZW5cIil9ZnVuY3Rpb24gQihlLHQsaSxuKXt2YXIgcyxsPXRoaXMsbz1lLnF1ZXJ5U2VsZWN0b3IoXCIuZ3NsaWRlLW1lZGlhXCIpLHI9ISghUCh0LFwiaHJlZlwiKXx8IXQuaHJlZikmJnQuaHJlZi5zcGxpdChcIiNcIikucG9wKCkudHJpbSgpLGE9ISghUCh0LFwiY29udGVudFwiKXx8IXQuY29udGVudCkmJnQuY29udGVudDtpZihhJiYoayhhKSYmKHM9eSgnPGRpdiBjbGFzcz1cImdpbmxpbmVkLWNvbnRlbnRcIj4nLmNvbmNhdChhLFwiPC9kaXY+XCIpKSksRShhKSkpe1wibm9uZVwiPT1hLnN0eWxlLmRpc3BsYXkmJihhLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiKTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2MuY2xhc3NOYW1lPVwiZ2lubGluZWQtY29udGVudFwiLGMuYXBwZW5kQ2hpbGQoYSkscz1jfWlmKHIpe3ZhciB1PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHIpO2lmKCF1KXJldHVybiExO3ZhciBnPXUuY2xvbmVOb2RlKCEwKTtnLnN0eWxlLmhlaWdodD10LmhlaWdodCxnLnN0eWxlLm1heFdpZHRoPXQud2lkdGgsZChnLFwiZ2lubGluZWQtY29udGVudFwiKSxzPWd9aWYoIXMpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gYXBwZW5kIGlubGluZSBzbGlkZSBjb250ZW50XCIsdCksITE7by5zdHlsZS5oZWlnaHQ9dC5oZWlnaHQsby5zdHlsZS53aWR0aD10LndpZHRoLG8uYXBwZW5kQ2hpbGQocyksdGhpcy5ldmVudHNbXCJpbmxpbmVjbG9zZVwiK3JdPWgoXCJjbGlja1wiLHtvbkVsZW1lbnQ6by5xdWVyeVNlbGVjdG9yQWxsKFwiLmd0cmlnZ2VyLWNsb3NlXCIpLHdpdGhDYWxsYmFjazpmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksbC5jbG9zZSgpfX0pLEMobikmJm4oKX1mdW5jdGlvbiBIKGUsdCxpLG4pe3ZhciBzPWUucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtbWVkaWFcIiksbD1mdW5jdGlvbihlKXt2YXIgdD1lLnVybCxpPWUuYWxsb3csbj1lLmNhbGxiYWNrLHM9ZS5hcHBlbmRUbyxsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7cmV0dXJuIGwuY2xhc3NOYW1lPVwidmltZW8tdmlkZW8gZ3ZpZGVvXCIsbC5zcmM9dCxsLnN0eWxlLndpZHRoPVwiMTAwJVwiLGwuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLGkmJmwuc2V0QXR0cmlidXRlKFwiYWxsb3dcIixpKSxsLm9ubG9hZD1mdW5jdGlvbigpe2wub25sb2FkPW51bGwsZChsLFwibm9kZS1yZWFkeVwiKSxDKG4pJiZuKCl9LHMmJnMuYXBwZW5kQ2hpbGQobCksbH0oe3VybDp0LmhyZWYsY2FsbGJhY2s6bn0pO3MucGFyZW50Tm9kZS5zdHlsZS5tYXhXaWR0aD10LndpZHRoLHMucGFyZW50Tm9kZS5zdHlsZS5oZWlnaHQ9dC5oZWlnaHQscy5hcHBlbmRDaGlsZChsKX12YXIgaj1zKChmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9O2kodGhpcyxlKSx0aGlzLmRlZmF1bHRzPXtocmVmOlwiXCIsc2l6ZXM6XCJcIixzcmNzZXQ6XCJcIix0aXRsZTpcIlwiLHR5cGU6XCJcIix2aWRlb1Byb3ZpZGVyOlwiXCIsZGVzY3JpcHRpb246XCJcIixhbHQ6XCJcIixkZXNjUG9zaXRpb246XCJib3R0b21cIixlZmZlY3Q6XCJcIix3aWR0aDpcIlwiLGhlaWdodDpcIlwiLGNvbnRlbnQ6ITEsem9vbWFibGU6ITAsZHJhZ2dhYmxlOiEwfSxJKHQpJiYodGhpcy5kZWZhdWx0cz1vKHRoaXMuZGVmYXVsdHMsdCkpfSksW3trZXk6XCJzb3VyY2VUeXBlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZTtyZXR1cm4gbnVsbCE9PShlPWUudG9Mb3dlckNhc2UoKSkubWF0Y2goL1xcLihqcGVnfGpwZ3xqcGV8Z2lmfHBuZ3xhcG58d2VicHxhdmlmfHN2ZykvKT9cImltYWdlXCI6ZS5tYXRjaCgvKHlvdXR1YmVcXC5jb218eW91dHViZS1ub2Nvb2tpZVxcLmNvbSlcXC93YXRjaFxcP3Y9KFthLXpBLVowLTlcXC1fXSspLyl8fGUubWF0Y2goL3lvdXR1XFwuYmVcXC8oW2EtekEtWjAtOVxcLV9dKykvKXx8ZS5tYXRjaCgvKHlvdXR1YmVcXC5jb218eW91dHViZS1ub2Nvb2tpZVxcLmNvbSlcXC9lbWJlZFxcLyhbYS16QS1aMC05XFwtX10rKS8pfHxlLm1hdGNoKC8oeW91dHViZVxcLmNvbXx5b3V0dWJlLW5vY29va2llXFwuY29tKVxcL3Nob3J0c1xcLyhbYS16QS1aMC05XFwtX10rKS8pfHxlLm1hdGNoKC92aW1lb1xcLmNvbVxcLyhbMC05XSopLyl8fG51bGwhPT1lLm1hdGNoKC9cXC4obXA0fG9nZ3x3ZWJtfG1vdikvKT9cInZpZGVvXCI6bnVsbCE9PWUubWF0Y2goL1xcLihtcDN8d2F2fHdtYXxhYWN8b2dnKS8pP1wiYXVkaW9cIjplLmluZGV4T2YoXCIjXCIpPi0xJiZcIlwiIT09dC5zcGxpdChcIiNcIikucG9wKCkudHJpbSgpP1wiaW5saW5lXCI6ZS5pbmRleE9mKFwiZ29hamF4PXRydWVcIik+LTE/XCJhamF4XCI6XCJleHRlcm5hbFwifX0se2tleTpcInBhcnNlQ29uZmlnXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLG49byh7ZGVzY1Bvc2l0aW9uOnQuZGVzY1Bvc2l0aW9ufSx0aGlzLmRlZmF1bHRzKTtpZihJKGUpJiYhRShlKSl7UChlLFwidHlwZVwiKXx8KFAoZSxcImNvbnRlbnRcIikmJmUuY29udGVudD9lLnR5cGU9XCJpbmxpbmVcIjpQKGUsXCJocmVmXCIpJiYoZS50eXBlPXRoaXMuc291cmNlVHlwZShlLmhyZWYpKSk7dmFyIHM9byhuLGUpO3JldHVybiB0aGlzLnNldFNpemUocyx0KSxzfXZhciBsPVwiXCIsYT1lLmdldEF0dHJpYnV0ZShcImRhdGEtZ2xpZ2h0Ym94XCIpLGg9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwiYVwiPT09aCYmKGw9ZS5ocmVmKSxcImltZ1wiPT09aCYmKGw9ZS5zcmMsbi5hbHQ9ZS5hbHQpLG4uaHJlZj1sLHIobiwoZnVuY3Rpb24ocyxsKXtQKHQsbCkmJlwid2lkdGhcIiE9PWwmJihuW2xdPXRbbF0pO3ZhciBvPWUuZGF0YXNldFtsXTtPKG8pfHwobltsXT1pLnNhbml0aXplVmFsdWUobykpfSkpLG4uY29udGVudCYmKG4udHlwZT1cImlubGluZVwiKSwhbi50eXBlJiZsJiYobi50eXBlPXRoaXMuc291cmNlVHlwZShsKSksTyhhKSl7aWYoIW4udGl0bGUmJlwiYVwiPT1oKXt2YXIgZD1lLnRpdGxlO08oZCl8fFwiXCI9PT1kfHwobi50aXRsZT1kKX1pZighbi50aXRsZSYmXCJpbWdcIj09aCl7dmFyIGM9ZS5hbHQ7TyhjKXx8XCJcIj09PWN8fChuLnRpdGxlPWMpfX1lbHNle3ZhciB1PVtdO3IobiwoZnVuY3Rpb24oZSx0KXt1LnB1c2goXCI7XFxcXHM/XCIrdCl9KSksdT11LmpvaW4oXCJcXFxccz86fFwiKSxcIlwiIT09YS50cmltKCkmJnIobiwoZnVuY3Rpb24oZSx0KXt2YXIgcz1hLGw9bmV3IFJlZ0V4cChcInM/XCIrdCtcInM/OnM/KC4qPykoXCIrdStcInM/OnwkKVwiKSxvPXMubWF0Y2gobCk7aWYobyYmby5sZW5ndGgmJm9bMV0pe3ZhciByPW9bMV0udHJpbSgpLnJlcGxhY2UoLztcXHMqJC8sXCJcIik7blt0XT1pLnNhbml0aXplVmFsdWUocil9fSkpfWlmKG4uZGVzY3JpcHRpb24mJlwiLlwiPT09bi5kZXNjcmlwdGlvbi5zdWJzdHJpbmcoMCwxKSl7dmFyIGc7dHJ5e2c9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihuLmRlc2NyaXB0aW9uKS5pbm5lckhUTUx9Y2F0Y2goZSl7aWYoIShlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSl0aHJvdyBlfWcmJihuLmRlc2NyaXB0aW9uPWcpfWlmKCFuLmRlc2NyaXB0aW9uKXt2YXIgdj1lLnF1ZXJ5U2VsZWN0b3IoXCIuZ2xpZ2h0Ym94LWRlc2NcIik7diYmKG4uZGVzY3JpcHRpb249di5pbm5lckhUTUwpfXJldHVybiB0aGlzLnNldFNpemUobix0LGUpLHRoaXMuc2xpZGVDb25maWc9bixufX0se2tleTpcInNldFNpemVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLG49XCJ2aWRlb1wiPT1lLnR5cGU/dGhpcy5jaGVja1NpemUodC52aWRlb3NXaWR0aCk6dGhpcy5jaGVja1NpemUodC53aWR0aCkscz10aGlzLmNoZWNrU2l6ZSh0LmhlaWdodCk7cmV0dXJuIGUud2lkdGg9UChlLFwid2lkdGhcIikmJlwiXCIhPT1lLndpZHRoP3RoaXMuY2hlY2tTaXplKGUud2lkdGgpOm4sZS5oZWlnaHQ9UChlLFwiaGVpZ2h0XCIpJiZcIlwiIT09ZS5oZWlnaHQ/dGhpcy5jaGVja1NpemUoZS5oZWlnaHQpOnMsaSYmXCJpbWFnZVwiPT1lLnR5cGUmJihlLl9oYXNDdXN0b21XaWR0aD0hIWkuZGF0YXNldC53aWR0aCxlLl9oYXNDdXN0b21IZWlnaHQ9ISFpLmRhdGFzZXQuaGVpZ2h0KSxlfX0se2tleTpcImNoZWNrU2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB6KGUpP1wiXCIuY29uY2F0KGUsXCJweFwiKTplfX0se2tleTpcInNhbml0aXplVmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm5cInRydWVcIiE9PWUmJlwiZmFsc2VcIiE9PWU/ZTpcInRydWVcIj09PWV9fV0pLFY9cygoZnVuY3Rpb24gZSh0LG4scyl7aSh0aGlzLGUpLHRoaXMuZWxlbWVudD10LHRoaXMuaW5zdGFuY2U9bix0aGlzLmluZGV4PXN9KSxbe2tleTpcInNldENvbnRlbnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bnVsbCxpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV07aWYodSh0LFwibG9hZGVkXCIpKXJldHVybiExO3ZhciBuPXRoaXMuaW5zdGFuY2Uuc2V0dGluZ3Mscz10aGlzLnNsaWRlQ29uZmlnLGw9VCgpO0Mobi5iZWZvcmVTbGlkZUxvYWQpJiZuLmJlZm9yZVNsaWRlTG9hZCh7aW5kZXg6dGhpcy5pbmRleCxzbGlkZTp0LHBsYXllcjohMX0pO3ZhciBvPXMudHlwZSxyPXMuZGVzY1Bvc2l0aW9uLGE9dC5xdWVyeVNlbGVjdG9yKFwiLmdzbGlkZS1tZWRpYVwiKSxoPXQucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtdGl0bGVcIiksYz10LnF1ZXJ5U2VsZWN0b3IoXCIuZ3NsaWRlLWRlc2NcIiksZz10LnF1ZXJ5U2VsZWN0b3IoXCIuZ2Rlc2MtaW5uZXJcIiksdj1pLGY9XCJnU2xpZGVUaXRsZV9cIit0aGlzLmluZGV4LHA9XCJnU2xpZGVEZXNjX1wiK3RoaXMuaW5kZXg7aWYoQyhuLmFmdGVyU2xpZGVMb2FkKSYmKHY9ZnVuY3Rpb24oKXtDKGkpJiZpKCksbi5hZnRlclNsaWRlTG9hZCh7aW5kZXg6ZS5pbmRleCxzbGlkZTp0LHBsYXllcjplLmluc3RhbmNlLmdldFNsaWRlUGxheWVySW5zdGFuY2UoZS5pbmRleCl9KX0pLFwiXCI9PXMudGl0bGUmJlwiXCI9PXMuZGVzY3JpcHRpb24/ZyYmZy5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZy5wYXJlbnROb2RlKTooaCYmXCJcIiE9PXMudGl0bGU/KGguaWQ9ZixoLmlubmVySFRNTD1zLnRpdGxlKTpoLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaCksYyYmXCJcIiE9PXMuZGVzY3JpcHRpb24/KGMuaWQ9cCxsJiZuLm1vcmVMZW5ndGg+MD8ocy5zbWFsbERlc2NyaXB0aW9uPXRoaXMuc2xpZGVTaG9ydERlc2Mocy5kZXNjcmlwdGlvbixuLm1vcmVMZW5ndGgsbi5tb3JlVGV4dCksYy5pbm5lckhUTUw9cy5zbWFsbERlc2NyaXB0aW9uLHRoaXMuZGVzY3JpcHRpb25FdmVudHMoYyxzKSk6Yy5pbm5lckhUTUw9cy5kZXNjcmlwdGlvbik6Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpLGQoYS5wYXJlbnROb2RlLFwiZGVzYy1cIi5jb25jYXQocikpLGQoZy5wYXJlbnROb2RlLFwiZGVzY3JpcHRpb24tXCIuY29uY2F0KHIpKSksZChhLFwiZ3NsaWRlLVwiLmNvbmNhdChvKSksZCh0LFwibG9hZGVkXCIpLFwidmlkZW9cIiE9PW8pe2lmKFwiZXh0ZXJuYWxcIiE9PW8pcmV0dXJuXCJpbmxpbmVcIj09PW8/KEIuYXBwbHkodGhpcy5pbnN0YW5jZSxbdCxzLHRoaXMuaW5kZXgsdl0pLHZvaWQocy5kcmFnZ2FibGUmJm5ldyBOKHtkcmFnRWw6dC5xdWVyeVNlbGVjdG9yKFwiLmdzbGlkZS1pbmxpbmVcIiksdG9sZXJhbmNlWDpuLmRyYWdUb2xlcmFuY2VYLHRvbGVyYW5jZVk6bi5kcmFnVG9sZXJhbmNlWSxzbGlkZTp0LGluc3RhbmNlOnRoaXMuaW5zdGFuY2V9KSkpOnZvaWQoXCJpbWFnZVwiIT09bz9DKHYpJiZ2KCk6RCh0LHMsdGhpcy5pbmRleCwoZnVuY3Rpb24oKXt2YXIgaT10LnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIik7cy5kcmFnZ2FibGUmJm5ldyBOKHtkcmFnRWw6aSx0b2xlcmFuY2VYOm4uZHJhZ1RvbGVyYW5jZVgsdG9sZXJhbmNlWTpuLmRyYWdUb2xlcmFuY2VZLHNsaWRlOnQsaW5zdGFuY2U6ZS5pbnN0YW5jZX0pLHMuem9vbWFibGUmJmkubmF0dXJhbFdpZHRoPmkub2Zmc2V0V2lkdGgmJihkKGksXCJ6b29tYWJsZVwiKSxuZXcgcShpLHQsKGZ1bmN0aW9uKCl7ZS5pbnN0YW5jZS5yZXNpemUoKX0pKSksQyh2KSYmdigpfSkpKTtILmFwcGx5KHRoaXMsW3Qscyx0aGlzLmluZGV4LHZdKX1lbHNlIF8uYXBwbHkodGhpcy5pbnN0YW5jZSxbdCxzLHRoaXMuaW5kZXgsdl0pfX0se2tleTpcInNsaWRlU2hvcnREZXNjXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjUwLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7bi5pbm5lckhUTUw9ZTt2YXIgcz1uLmlubmVyVGV4dCxsPWk7aWYoKGU9cy50cmltKCkpLmxlbmd0aDw9dClyZXR1cm4gZTt2YXIgbz1lLnN1YnN0cigwLHQtMSk7cmV0dXJuIGw/KG49bnVsbCxvKycuLi4gPGEgaHJlZj1cIiNcIiBjbGFzcz1cImRlc2MtbW9yZVwiPicraStcIjwvYT5cIik6b319LHtrZXk6XCJkZXNjcmlwdGlvbkV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcyxuPWUucXVlcnlTZWxlY3RvcihcIi5kZXNjLW1vcmVcIik7aWYoIW4pcmV0dXJuITE7aChcImNsaWNrXCIse29uRWxlbWVudDpuLHdpdGhDYWxsYmFjazpmdW5jdGlvbihlLG4pe2UucHJldmVudERlZmF1bHQoKTt2YXIgcz1kb2N1bWVudC5ib2R5LGw9ZyhuLFwiLmdzbGlkZS1kZXNjXCIpO2lmKCFsKXJldHVybiExO2wuaW5uZXJIVE1MPXQuZGVzY3JpcHRpb24sZChzLFwiZ2Rlc2Mtb3BlblwiKTt2YXIgbz1oKFwiY2xpY2tcIix7b25FbGVtZW50OltzLGcobCxcIi5nc2xpZGUtZGVzY3JpcHRpb25cIildLHdpdGhDYWxsYmFjazpmdW5jdGlvbihlLG4pe1wiYVwiIT09ZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmKGMocyxcImdkZXNjLW9wZW5cIiksZChzLFwiZ2Rlc2MtY2xvc2VkXCIpLGwuaW5uZXJIVE1MPXQuc21hbGxEZXNjcmlwdGlvbixpLmRlc2NyaXB0aW9uRXZlbnRzKGwsdCksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtjKHMsXCJnZGVzYy1jbG9zZWRcIil9KSw0MDApLG8uZGVzdHJveSgpKX19KX19KX19LHtrZXk6XCJjcmVhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB5KHRoaXMuaW5zdGFuY2Uuc2V0dGluZ3Muc2xpZGVIVE1MKX19LHtrZXk6XCJnZXRDb25maWdcIix2YWx1ZTpmdW5jdGlvbigpe0UodGhpcy5lbGVtZW50KXx8dGhpcy5lbGVtZW50Lmhhc093blByb3BlcnR5KFwiZHJhZ2dhYmxlXCIpfHwodGhpcy5lbGVtZW50LmRyYWdnYWJsZT10aGlzLmluc3RhbmNlLnNldHRpbmdzLmRyYWdnYWJsZSk7dmFyIGU9bmV3IGoodGhpcy5pbnN0YW5jZS5zZXR0aW5ncy5zbGlkZUV4dHJhQXR0cmlidXRlcyk7cmV0dXJuIHRoaXMuc2xpZGVDb25maWc9ZS5wYXJzZUNvbmZpZyh0aGlzLmVsZW1lbnQsdGhpcy5pbnN0YW5jZS5zZXR0aW5ncyksdGhpcy5zbGlkZUNvbmZpZ319XSk7ZnVuY3Rpb24gRihlKXtyZXR1cm4gTWF0aC5zcXJ0KGUueCplLngrZS55KmUueSl9ZnVuY3Rpb24gUihlLHQpe3ZhciBpPWZ1bmN0aW9uKGUsdCl7dmFyIGk9RihlKSpGKHQpO2lmKDA9PT1pKXJldHVybiAwO3ZhciBuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUueCp0LngrZS55KnQueX0oZSx0KS9pO3JldHVybiBuPjEmJihuPTEpLE1hdGguYWNvcyhuKX0oZSx0KTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS54KnQueS10LngqZS55fShlLHQpPjAmJihpKj0tMSksMTgwKmkvTWF0aC5QSX12YXIgRz1zKChmdW5jdGlvbiBlKHQpe2kodGhpcyxlKSx0aGlzLmhhbmRsZXJzPVtdLHRoaXMuZWw9dH0pLFt7a2V5OlwiYWRkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5oYW5kbGVycy5wdXNoKGUpfX0se2tleTpcImRlbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2V8fCh0aGlzLmhhbmRsZXJzPVtdKTtmb3IodmFyIHQ9dGhpcy5oYW5kbGVycy5sZW5ndGg7dD49MDt0LS0pdGhpcy5oYW5kbGVyc1t0XT09PWUmJnRoaXMuaGFuZGxlcnMuc3BsaWNlKHQsMSl9fSx7a2V5OlwiZGlzcGF0Y2hcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT0wLHQ9dGhpcy5oYW5kbGVycy5sZW5ndGg7ZTx0O2UrKyl7dmFyIGk9dGhpcy5oYW5kbGVyc1tlXTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiZpLmFwcGx5KHRoaXMuZWwsYXJndW1lbnRzKX19fV0pO2Z1bmN0aW9uIFooZSx0KXt2YXIgaT1uZXcgRyhlKTtyZXR1cm4gaS5hZGQodCksaX12YXIgVT1zKChmdW5jdGlvbiBlKHQsbil7aSh0aGlzLGUpLHRoaXMuZWxlbWVudD1cInN0cmluZ1wiPT10eXBlb2YgdD9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpOnQsdGhpcy5zdGFydD10aGlzLnN0YXJ0LmJpbmQodGhpcyksdGhpcy5tb3ZlPXRoaXMubW92ZS5iaW5kKHRoaXMpLHRoaXMuZW5kPXRoaXMuZW5kLmJpbmQodGhpcyksdGhpcy5jYW5jZWw9dGhpcy5jYW5jZWwuYmluZCh0aGlzKSx0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLnN0YXJ0LCExKSx0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMubW92ZSwhMSksdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMuZW5kLCExKSx0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsdGhpcy5jYW5jZWwsITEpLHRoaXMucHJlVj17eDpudWxsLHk6bnVsbH0sdGhpcy5waW5jaFN0YXJ0TGVuPW51bGwsdGhpcy56b29tPTEsdGhpcy5pc0RvdWJsZVRhcD0hMTt2YXIgcz1mdW5jdGlvbigpe307dGhpcy5yb3RhdGU9Wih0aGlzLmVsZW1lbnQsbi5yb3RhdGV8fHMpLHRoaXMudG91Y2hTdGFydD1aKHRoaXMuZWxlbWVudCxuLnRvdWNoU3RhcnR8fHMpLHRoaXMubXVsdGlwb2ludFN0YXJ0PVoodGhpcy5lbGVtZW50LG4ubXVsdGlwb2ludFN0YXJ0fHxzKSx0aGlzLm11bHRpcG9pbnRFbmQ9Wih0aGlzLmVsZW1lbnQsbi5tdWx0aXBvaW50RW5kfHxzKSx0aGlzLnBpbmNoPVoodGhpcy5lbGVtZW50LG4ucGluY2h8fHMpLHRoaXMuc3dpcGU9Wih0aGlzLmVsZW1lbnQsbi5zd2lwZXx8cyksdGhpcy50YXA9Wih0aGlzLmVsZW1lbnQsbi50YXB8fHMpLHRoaXMuZG91YmxlVGFwPVoodGhpcy5lbGVtZW50LG4uZG91YmxlVGFwfHxzKSx0aGlzLmxvbmdUYXA9Wih0aGlzLmVsZW1lbnQsbi5sb25nVGFwfHxzKSx0aGlzLnNpbmdsZVRhcD1aKHRoaXMuZWxlbWVudCxuLnNpbmdsZVRhcHx8cyksdGhpcy5wcmVzc01vdmU9Wih0aGlzLmVsZW1lbnQsbi5wcmVzc01vdmV8fHMpLHRoaXMudHdvRmluZ2VyUHJlc3NNb3ZlPVoodGhpcy5lbGVtZW50LG4udHdvRmluZ2VyUHJlc3NNb3ZlfHxzKSx0aGlzLnRvdWNoTW92ZT1aKHRoaXMuZWxlbWVudCxuLnRvdWNoTW92ZXx8cyksdGhpcy50b3VjaEVuZD1aKHRoaXMuZWxlbWVudCxuLnRvdWNoRW5kfHxzKSx0aGlzLnRvdWNoQ2FuY2VsPVoodGhpcy5lbGVtZW50LG4udG91Y2hDYW5jZWx8fHMpLHRoaXMudHJhbnNsYXRlQ29udGFpbmVyPXRoaXMuZWxlbWVudCx0aGlzLl9jYW5jZWxBbGxIYW5kbGVyPXRoaXMuY2FuY2VsQWxsLmJpbmQodGhpcyksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix0aGlzLl9jYW5jZWxBbGxIYW5kbGVyKSx0aGlzLmRlbHRhPW51bGwsdGhpcy5sYXN0PW51bGwsdGhpcy5ub3c9bnVsbCx0aGlzLnRhcFRpbWVvdXQ9bnVsbCx0aGlzLnNpbmdsZVRhcFRpbWVvdXQ9bnVsbCx0aGlzLmxvbmdUYXBUaW1lb3V0PW51bGwsdGhpcy5zd2lwZVRpbWVvdXQ9bnVsbCx0aGlzLngxPXRoaXMueDI9dGhpcy55MT10aGlzLnkyPW51bGwsdGhpcy5wcmVUYXBQb3NpdGlvbj17eDpudWxsLHk6bnVsbH19KSxbe2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZS50b3VjaGVzKWlmKGUudGFyZ2V0JiZlLnRhcmdldC5ub2RlTmFtZSYmW1wiYVwiLFwiYnV0dG9uXCIsXCJpbnB1dFwiXS5pbmRleE9mKGUudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpPj0wKWNvbnNvbGUubG9nKFwiaWdub3JlIGRyYWcgZm9yIHRoaXMgdG91Y2hlZCBlbGVtZW50XCIsZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7ZWxzZXt0aGlzLm5vdz1EYXRlLm5vdygpLHRoaXMueDE9ZS50b3VjaGVzWzBdLnBhZ2VYLHRoaXMueTE9ZS50b3VjaGVzWzBdLnBhZ2VZLHRoaXMuZGVsdGE9dGhpcy5ub3ctKHRoaXMubGFzdHx8dGhpcy5ub3cpLHRoaXMudG91Y2hTdGFydC5kaXNwYXRjaChlLHRoaXMuZWxlbWVudCksbnVsbCE9PXRoaXMucHJlVGFwUG9zaXRpb24ueCYmKHRoaXMuaXNEb3VibGVUYXA9dGhpcy5kZWx0YT4wJiZ0aGlzLmRlbHRhPD0yNTAmJk1hdGguYWJzKHRoaXMucHJlVGFwUG9zaXRpb24ueC10aGlzLngxKTwzMCYmTWF0aC5hYnModGhpcy5wcmVUYXBQb3NpdGlvbi55LXRoaXMueTEpPDMwLHRoaXMuaXNEb3VibGVUYXAmJmNsZWFyVGltZW91dCh0aGlzLnNpbmdsZVRhcFRpbWVvdXQpKSx0aGlzLnByZVRhcFBvc2l0aW9uLng9dGhpcy54MSx0aGlzLnByZVRhcFBvc2l0aW9uLnk9dGhpcy55MSx0aGlzLmxhc3Q9dGhpcy5ub3c7dmFyIHQ9dGhpcy5wcmVWO2lmKGUudG91Y2hlcy5sZW5ndGg+MSl7dGhpcy5fY2FuY2VsTG9uZ1RhcCgpLHRoaXMuX2NhbmNlbFNpbmdsZVRhcCgpO3ZhciBpPXt4OmUudG91Y2hlc1sxXS5wYWdlWC10aGlzLngxLHk6ZS50b3VjaGVzWzFdLnBhZ2VZLXRoaXMueTF9O3QueD1pLngsdC55PWkueSx0aGlzLnBpbmNoU3RhcnRMZW49Rih0KSx0aGlzLm11bHRpcG9pbnRTdGFydC5kaXNwYXRjaChlLHRoaXMuZWxlbWVudCl9dGhpcy5fcHJldmVudFRhcD0hMSx0aGlzLmxvbmdUYXBUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aGlzLmxvbmdUYXAuZGlzcGF0Y2goZSx0aGlzLmVsZW1lbnQpLHRoaXMuX3ByZXZlbnRUYXA9ITB9LmJpbmQodGhpcyksNzUwKX19fSx7a2V5OlwibW92ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUudG91Y2hlcyl7dmFyIHQ9dGhpcy5wcmVWLGk9ZS50b3VjaGVzLmxlbmd0aCxuPWUudG91Y2hlc1swXS5wYWdlWCxzPWUudG91Y2hlc1swXS5wYWdlWTtpZih0aGlzLmlzRG91YmxlVGFwPSExLGk+MSl7dmFyIGw9ZS50b3VjaGVzWzFdLnBhZ2VYLG89ZS50b3VjaGVzWzFdLnBhZ2VZLHI9e3g6ZS50b3VjaGVzWzFdLnBhZ2VYLW4seTplLnRvdWNoZXNbMV0ucGFnZVktc307bnVsbCE9PXQueCYmKHRoaXMucGluY2hTdGFydExlbj4wJiYoZS56b29tPUYocikvdGhpcy5waW5jaFN0YXJ0TGVuLHRoaXMucGluY2guZGlzcGF0Y2goZSx0aGlzLmVsZW1lbnQpKSxlLmFuZ2xlPVIocix0KSx0aGlzLnJvdGF0ZS5kaXNwYXRjaChlLHRoaXMuZWxlbWVudCkpLHQueD1yLngsdC55PXIueSxudWxsIT09dGhpcy54MiYmbnVsbCE9PXRoaXMuc3gyPyhlLmRlbHRhWD0obi10aGlzLngyK2wtdGhpcy5zeDIpLzIsZS5kZWx0YVk9KHMtdGhpcy55MitvLXRoaXMuc3kyKS8yKTooZS5kZWx0YVg9MCxlLmRlbHRhWT0wKSx0aGlzLnR3b0ZpbmdlclByZXNzTW92ZS5kaXNwYXRjaChlLHRoaXMuZWxlbWVudCksdGhpcy5zeDI9bCx0aGlzLnN5Mj1vfWVsc2V7aWYobnVsbCE9PXRoaXMueDIpe2UuZGVsdGFYPW4tdGhpcy54MixlLmRlbHRhWT1zLXRoaXMueTI7dmFyIGE9TWF0aC5hYnModGhpcy54MS10aGlzLngyKSxoPU1hdGguYWJzKHRoaXMueTEtdGhpcy55Mik7KGE+MTB8fGg+MTApJiYodGhpcy5fcHJldmVudFRhcD0hMCl9ZWxzZSBlLmRlbHRhWD0wLGUuZGVsdGFZPTA7dGhpcy5wcmVzc01vdmUuZGlzcGF0Y2goZSx0aGlzLmVsZW1lbnQpfXRoaXMudG91Y2hNb3ZlLmRpc3BhdGNoKGUsdGhpcy5lbGVtZW50KSx0aGlzLl9jYW5jZWxMb25nVGFwKCksdGhpcy54Mj1uLHRoaXMueTI9cyxpPjEmJmUucHJldmVudERlZmF1bHQoKX19fSx7a2V5OlwiZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZS5jaGFuZ2VkVG91Y2hlcyl7dGhpcy5fY2FuY2VsTG9uZ1RhcCgpO3ZhciB0PXRoaXM7ZS50b3VjaGVzLmxlbmd0aDwyJiYodGhpcy5tdWx0aXBvaW50RW5kLmRpc3BhdGNoKGUsdGhpcy5lbGVtZW50KSx0aGlzLnN4Mj10aGlzLnN5Mj1udWxsKSx0aGlzLngyJiZNYXRoLmFicyh0aGlzLngxLXRoaXMueDIpPjMwfHx0aGlzLnkyJiZNYXRoLmFicyh0aGlzLnkxLXRoaXMueTIpPjMwPyhlLmRpcmVjdGlvbj10aGlzLl9zd2lwZURpcmVjdGlvbih0aGlzLngxLHRoaXMueDIsdGhpcy55MSx0aGlzLnkyKSx0aGlzLnN3aXBlVGltZW91dD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe3Quc3dpcGUuZGlzcGF0Y2goZSx0LmVsZW1lbnQpfSksMCkpOih0aGlzLnRhcFRpbWVvdXQ9c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0Ll9wcmV2ZW50VGFwfHx0LnRhcC5kaXNwYXRjaChlLHQuZWxlbWVudCksdC5pc0RvdWJsZVRhcCYmKHQuZG91YmxlVGFwLmRpc3BhdGNoKGUsdC5lbGVtZW50KSx0LmlzRG91YmxlVGFwPSExKX0pLDApLHQuaXNEb3VibGVUYXB8fCh0LnNpbmdsZVRhcFRpbWVvdXQ9c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LnNpbmdsZVRhcC5kaXNwYXRjaChlLHQuZWxlbWVudCl9KSwyNTApKSksdGhpcy50b3VjaEVuZC5kaXNwYXRjaChlLHRoaXMuZWxlbWVudCksdGhpcy5wcmVWLng9MCx0aGlzLnByZVYueT0wLHRoaXMuem9vbT0xLHRoaXMucGluY2hTdGFydExlbj1udWxsLHRoaXMueDE9dGhpcy54Mj10aGlzLnkxPXRoaXMueTI9bnVsbH19fSx7a2V5OlwiY2FuY2VsQWxsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9wcmV2ZW50VGFwPSEwLGNsZWFyVGltZW91dCh0aGlzLnNpbmdsZVRhcFRpbWVvdXQpLGNsZWFyVGltZW91dCh0aGlzLnRhcFRpbWVvdXQpLGNsZWFyVGltZW91dCh0aGlzLmxvbmdUYXBUaW1lb3V0KSxjbGVhclRpbWVvdXQodGhpcy5zd2lwZVRpbWVvdXQpfX0se2tleTpcImNhbmNlbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2FuY2VsQWxsKCksdGhpcy50b3VjaENhbmNlbC5kaXNwYXRjaChlLHRoaXMuZWxlbWVudCl9fSx7a2V5OlwiX2NhbmNlbExvbmdUYXBcIix2YWx1ZTpmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLmxvbmdUYXBUaW1lb3V0KX19LHtrZXk6XCJfY2FuY2VsU2luZ2xlVGFwXCIsdmFsdWU6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5zaW5nbGVUYXBUaW1lb3V0KX19LHtrZXk6XCJfc3dpcGVEaXJlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQsaSxuKXtyZXR1cm4gTWF0aC5hYnMoZS10KT49TWF0aC5hYnMoaS1uKT9lLXQ+MD9cIkxlZnRcIjpcIlJpZ2h0XCI6aS1uPjA/XCJVcFwiOlwiRG93blwifX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzW2VdJiZ0aGlzW2VdLmFkZCh0KX19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXNbZV0mJnRoaXNbZV0uZGVsKHQpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpbmdsZVRhcFRpbWVvdXQmJmNsZWFyVGltZW91dCh0aGlzLnNpbmdsZVRhcFRpbWVvdXQpLHRoaXMudGFwVGltZW91dCYmY2xlYXJUaW1lb3V0KHRoaXMudGFwVGltZW91dCksdGhpcy5sb25nVGFwVGltZW91dCYmY2xlYXJUaW1lb3V0KHRoaXMubG9uZ1RhcFRpbWVvdXQpLHRoaXMuc3dpcGVUaW1lb3V0JiZjbGVhclRpbWVvdXQodGhpcy5zd2lwZVRpbWVvdXQpLHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLHRoaXMuc3RhcnQpLHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5tb3ZlKSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5lbmQpLHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIix0aGlzLmNhbmNlbCksdGhpcy5yb3RhdGUuZGVsKCksdGhpcy50b3VjaFN0YXJ0LmRlbCgpLHRoaXMubXVsdGlwb2ludFN0YXJ0LmRlbCgpLHRoaXMubXVsdGlwb2ludEVuZC5kZWwoKSx0aGlzLnBpbmNoLmRlbCgpLHRoaXMuc3dpcGUuZGVsKCksdGhpcy50YXAuZGVsKCksdGhpcy5kb3VibGVUYXAuZGVsKCksdGhpcy5sb25nVGFwLmRlbCgpLHRoaXMuc2luZ2xlVGFwLmRlbCgpLHRoaXMucHJlc3NNb3ZlLmRlbCgpLHRoaXMudHdvRmluZ2VyUHJlc3NNb3ZlLmRlbCgpLHRoaXMudG91Y2hNb3ZlLmRlbCgpLHRoaXMudG91Y2hFbmQuZGVsKCksdGhpcy50b3VjaENhbmNlbC5kZWwoKSx0aGlzLnByZVY9dGhpcy5waW5jaFN0YXJ0TGVuPXRoaXMuem9vbT10aGlzLmlzRG91YmxlVGFwPXRoaXMuZGVsdGE9dGhpcy5sYXN0PXRoaXMubm93PXRoaXMudGFwVGltZW91dD10aGlzLnNpbmdsZVRhcFRpbWVvdXQ9dGhpcy5sb25nVGFwVGltZW91dD10aGlzLnN3aXBlVGltZW91dD10aGlzLngxPXRoaXMueDI9dGhpcy55MT10aGlzLnkyPXRoaXMucHJlVGFwUG9zaXRpb249dGhpcy5yb3RhdGU9dGhpcy50b3VjaFN0YXJ0PXRoaXMubXVsdGlwb2ludFN0YXJ0PXRoaXMubXVsdGlwb2ludEVuZD10aGlzLnBpbmNoPXRoaXMuc3dpcGU9dGhpcy50YXA9dGhpcy5kb3VibGVUYXA9dGhpcy5sb25nVGFwPXRoaXMuc2luZ2xlVGFwPXRoaXMucHJlc3NNb3ZlPXRoaXMudG91Y2hNb3ZlPXRoaXMudG91Y2hFbmQ9dGhpcy50b3VjaENhbmNlbD10aGlzLnR3b0ZpbmdlclByZXNzTW92ZT1udWxsLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5fY2FuY2VsQWxsSGFuZGxlciksbnVsbH19XSk7ZnVuY3Rpb24gJChlKXt2YXIgdD1mdW5jdGlvbigpe3ZhciBlLHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZha2VlbGVtZW50XCIpLGk9e3RyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCIsT1RyYW5zaXRpb246XCJvVHJhbnNpdGlvbkVuZFwiLE1velRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCIsV2Via2l0VHJhbnNpdGlvbjpcIndlYmtpdFRyYW5zaXRpb25FbmRcIn07Zm9yKGUgaW4gaSlpZih2b2lkIDAhPT10LnN0eWxlW2VdKXJldHVybiBpW2VdfSgpLGk9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aHx8ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCxuPXUoZSxcImdzbGlkZS1tZWRpYVwiKT9lOmUucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtbWVkaWFcIikscz1nKG4sXCIuZ2lubmVyLWNvbnRhaW5lclwiKSxsPWUucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtZGVzY3JpcHRpb25cIik7aT43NjkmJihuPXMpLGQobixcImdyZXNldFwiKSxmKG4sXCJ0cmFuc2xhdGUzZCgwLCAwLCAwKVwiKSxoKHQse29uRWxlbWVudDpuLG9uY2U6ITAsd2l0aENhbGxiYWNrOmZ1bmN0aW9uKGUsdCl7YyhuLFwiZ3Jlc2V0XCIpfX0pLG4uc3R5bGUub3BhY2l0eT1cIlwiLGwmJihsLnN0eWxlLm9wYWNpdHk9XCJcIil9ZnVuY3Rpb24gSihlKXtpZihlLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShcInRvdWNoXCIpKXJldHVybiExO3ZhciB0LGksbixzPXgoKSxsPXMud2lkdGgsbz1zLmhlaWdodCxyPSExLGE9bnVsbCxoPW51bGwsdj1udWxsLHA9ITEsbT0xLHk9MSxiPSExLFM9ITEsdz1udWxsLFQ9bnVsbCxDPW51bGwsaz1udWxsLEU9MCxBPTAsTD0hMSxJPSExLE89e30sUD17fSxNPTAsej0wLFg9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnbGlnaHRib3gtc2xpZGVyXCIpLFk9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5nb3ZlcmxheVwiKSxxPW5ldyBVKFgse3RvdWNoU3RhcnQ6ZnVuY3Rpb24odCl7aWYocj0hMCwodSh0LnRhcmdldFRvdWNoZXNbMF0udGFyZ2V0LFwiZ2lubmVyLWNvbnRhaW5lclwiKXx8Zyh0LnRhcmdldFRvdWNoZXNbMF0udGFyZ2V0LFwiLmdzbGlkZS1kZXNjXCIpfHxcImFcIj09dC50YXJnZXRUb3VjaGVzWzBdLnRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSYmKHI9ITEpLGcodC50YXJnZXRUb3VjaGVzWzBdLnRhcmdldCxcIi5nc2xpZGUtaW5saW5lXCIpJiYhdSh0LnRhcmdldFRvdWNoZXNbMF0udGFyZ2V0LnBhcmVudE5vZGUsXCJnc2xpZGUtaW5saW5lXCIpJiYocj0hMSkscil7aWYoUD10LnRhcmdldFRvdWNoZXNbMF0sTy5wYWdlWD10LnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsTy5wYWdlWT10LnRhcmdldFRvdWNoZXNbMF0ucGFnZVksTT10LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCx6PXQudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLGE9ZS5hY3RpdmVTbGlkZSxoPWEucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtbWVkaWFcIiksbj1hLnF1ZXJ5U2VsZWN0b3IoXCIuZ3NsaWRlLWlubGluZVwiKSx2PW51bGwsdShoLFwiZ3NsaWRlLWltYWdlXCIpJiYodj1oLnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIikpLCh3aW5kb3cuaW5uZXJXaWR0aHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRofHxkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKT43NjkmJihoPWEucXVlcnlTZWxlY3RvcihcIi5naW5uZXItY29udGFpbmVyXCIpKSxjKFksXCJncmVzZXRcIiksdC5wYWdlWD4yMCYmdC5wYWdlWDx3aW5kb3cuaW5uZXJXaWR0aC0yMClyZXR1cm47dC5wcmV2ZW50RGVmYXVsdCgpfX0sdG91Y2hNb3ZlOmZ1bmN0aW9uKHMpe2lmKHImJihQPXMudGFyZ2V0VG91Y2hlc1swXSwhYiYmIVMpKXtpZihuJiZuLm9mZnNldEhlaWdodD5vKXt2YXIgYT1PLnBhZ2VYLVAucGFnZVg7aWYoTWF0aC5hYnMoYSk8PTEzKXJldHVybiExfXA9ITA7dmFyIGQsYz1zLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCx1PXMudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZLGc9TS1jLG09ei11O2lmKE1hdGguYWJzKGcpPk1hdGguYWJzKG0pPyhMPSExLEk9ITApOihJPSExLEw9ITApLHQ9UC5wYWdlWC1PLnBhZ2VYLEU9MTAwKnQvbCxpPVAucGFnZVktTy5wYWdlWSxBPTEwMCppL28sTCYmdiYmKGQ9MS1NYXRoLmFicyhpKS9vLFkuc3R5bGUub3BhY2l0eT1kLGUuc2V0dGluZ3MudG91Y2hGb2xsb3dBeGlzJiYoRT0wKSksSSYmKGQ9MS1NYXRoLmFicyh0KS9sLGguc3R5bGUub3BhY2l0eT1kLGUuc2V0dGluZ3MudG91Y2hGb2xsb3dBeGlzJiYoQT0wKSksIXYpcmV0dXJuIGYoaCxcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChFLFwiJSwgMCwgMClcIikpO2YoaCxcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChFLFwiJSwgXCIpLmNvbmNhdChBLFwiJSwgMClcIikpfX0sdG91Y2hFbmQ6ZnVuY3Rpb24oKXtpZihyKXtpZihwPSExLFN8fGIpcmV0dXJuIEM9dyx2b2lkKGs9VCk7dmFyIHQ9TWF0aC5hYnMocGFyc2VJbnQoQSkpLGk9TWF0aC5hYnMocGFyc2VJbnQoRSkpO2lmKCEodD4yOSYmdikpcmV0dXJuIHQ8MjkmJmk8MjU/KGQoWSxcImdyZXNldFwiKSxZLnN0eWxlLm9wYWNpdHk9MSwkKGgpKTp2b2lkIDA7ZS5jbG9zZSgpfX0sbXVsdGlwb2ludEVuZDpmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7Yj0hMX0pLDUwKX0sbXVsdGlwb2ludFN0YXJ0OmZ1bmN0aW9uKCl7Yj0hMCxtPXl8fDF9LHBpbmNoOmZ1bmN0aW9uKGUpe2lmKCF2fHxwKXJldHVybiExO2I9ITAsdi5zY2FsZVg9di5zY2FsZVk9bSplLnpvb207dmFyIHQ9bSplLnpvb207aWYoUz0hMCx0PD0xKXJldHVybiBTPSExLHQ9MSxrPW51bGwsQz1udWxsLHc9bnVsbCxUPW51bGwsdm9pZCB2LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJcIik7dD40LjUmJih0PTQuNSksdi5zdHlsZS50cmFuc2Zvcm09XCJzY2FsZTNkKFwiLmNvbmNhdCh0LFwiLCBcIikuY29uY2F0KHQsXCIsIDEpXCIpLHk9dH0scHJlc3NNb3ZlOmZ1bmN0aW9uKGUpe2lmKFMmJiFiKXt2YXIgdD1QLnBhZ2VYLU8ucGFnZVgsaT1QLnBhZ2VZLU8ucGFnZVk7QyYmKHQrPUMpLGsmJihpKz1rKSx3PXQsVD1pO3ZhciBuPVwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHQsXCJweCwgXCIpLmNvbmNhdChpLFwicHgsIDApXCIpO3kmJihuKz1cIiBzY2FsZTNkKFwiLmNvbmNhdCh5LFwiLCBcIikuY29uY2F0KHksXCIsIDEpXCIpKSxmKHYsbil9fSxzd2lwZTpmdW5jdGlvbih0KXtpZighUylpZihiKWI9ITE7ZWxzZXtpZihcIkxlZnRcIj09dC5kaXJlY3Rpb24pe2lmKGUuaW5kZXg9PWUuZWxlbWVudHMubGVuZ3RoLTEpcmV0dXJuICQoaCk7ZS5uZXh0U2xpZGUoKX1pZihcIlJpZ2h0XCI9PXQuZGlyZWN0aW9uKXtpZigwPT1lLmluZGV4KXJldHVybiAkKGgpO2UucHJldlNsaWRlKCl9fX19KTtlLmV2ZW50cy50b3VjaD1xfXZhciBLPVQoKSxRPW51bGwhPT1UKCl8fHZvaWQgMCE9PWRvY3VtZW50LmNyZWF0ZVRvdWNofHxcIm9udG91Y2hzdGFydFwiaW4gd2luZG93fHxcIm9ubXNnZXN0dXJlY2hhbmdlXCJpbiB3aW5kb3d8fG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzLGVlPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaHRtbFwiKVswXSx0ZT17c2VsZWN0b3I6XCIuZ2xpZ2h0Ym94XCIsZWxlbWVudHM6bnVsbCxza2luOlwiY2xlYW5cIix0aGVtZTpcImNsZWFuXCIsY2xvc2VCdXR0b246ITAsc3RhcnRBdDpudWxsLGF1dG9wbGF5VmlkZW9zOiEwLGF1dG9mb2N1c1ZpZGVvczohMCxkZXNjUG9zaXRpb246XCJib3R0b21cIix3aWR0aDpcIjkwMHB4XCIsaGVpZ2h0OlwiNTA2cHhcIix2aWRlb3NXaWR0aDpcIjk2MHB4XCIsYmVmb3JlU2xpZGVDaGFuZ2U6bnVsbCxhZnRlclNsaWRlQ2hhbmdlOm51bGwsYmVmb3JlU2xpZGVMb2FkOm51bGwsYWZ0ZXJTbGlkZUxvYWQ6bnVsbCxzbGlkZUluc2VydGVkOm51bGwsc2xpZGVSZW1vdmVkOm51bGwsc2xpZGVFeHRyYUF0dHJpYnV0ZXM6bnVsbCxvbk9wZW46bnVsbCxvbkNsb3NlOm51bGwsbG9vcDohMSx6b29tYWJsZTohMCxkcmFnZ2FibGU6ITAsZHJhZ0F1dG9TbmFwOiExLGRyYWdUb2xlcmFuY2VYOjQwLGRyYWdUb2xlcmFuY2VZOjY1LHByZWxvYWQ6ITAsb25lU2xpZGVQZXJPcGVuOiExLHRvdWNoTmF2aWdhdGlvbjohMCx0b3VjaEZvbGxvd0F4aXM6ITAsa2V5Ym9hcmROYXZpZ2F0aW9uOiEwLGNsb3NlT25PdXRzaWRlQ2xpY2s6ITAscGx1Z2luczohMSxwbHlyOntjc3M6XCJodHRwczovL2Nkbi5wbHlyLmlvLzMuNi4xMi9wbHlyLmNzc1wiLGpzOlwiaHR0cHM6Ly9jZG4ucGx5ci5pby8zLjYuMTIvcGx5ci5qc1wiLGNvbmZpZzp7cmF0aW86XCIxNjo5XCIsZnVsbHNjcmVlbjp7ZW5hYmxlZDohMCxpb3NOYXRpdmU6ITB9LHlvdXR1YmU6e25vQ29va2llOiEwLHJlbDowLHNob3dpbmZvOjAsaXZfbG9hZF9wb2xpY3k6M30sdmltZW86e2J5bGluZTohMSxwb3J0cmFpdDohMSx0aXRsZTohMSx0cmFuc3BhcmVudDohMX19fSxvcGVuRWZmZWN0Olwiem9vbVwiLGNsb3NlRWZmZWN0Olwiem9vbVwiLHNsaWRlRWZmZWN0Olwic2xpZGVcIixtb3JlVGV4dDpcIlNlZSBtb3JlXCIsbW9yZUxlbmd0aDo2MCxjc3NFZmVjdHM6e2ZhZGU6e2luOlwiZmFkZUluXCIsb3V0OlwiZmFkZU91dFwifSx6b29tOntpbjpcInpvb21JblwiLG91dDpcInpvb21PdXRcIn0sc2xpZGU6e2luOlwic2xpZGVJblJpZ2h0XCIsb3V0Olwic2xpZGVPdXRMZWZ0XCJ9LHNsaWRlQmFjazp7aW46XCJzbGlkZUluTGVmdFwiLG91dDpcInNsaWRlT3V0UmlnaHRcIn0sbm9uZTp7aW46XCJub25lXCIsb3V0Olwibm9uZVwifX0sc3ZnOntjbG9zZTonPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPjxnPjxnPjxwYXRoIGQ9XCJNNTA1Ljk0Myw2LjA1OGMtOC4wNzctOC4wNzctMjEuMTcyLTguMDc3LTI5LjI0OSwwTDYuMDU4LDQ3Ni42OTNjLTguMDc3LDguMDc3LTguMDc3LDIxLjE3MiwwLDI5LjI0OUMxMC4wOTYsNTA5Ljk4MiwxNS4zOSw1MTIsMjAuNjgzLDUxMmM1LjI5MywwLDEwLjU4Ni0yLjAxOSwxNC42MjUtNi4wNTlMNTA1Ljk0MywzNS4zMDZDNTE0LjAxOSwyNy4yMyw1MTQuMDE5LDE0LjEzNSw1MDUuOTQzLDYuMDU4elwiLz48L2c+PC9nPjxnPjxnPjxwYXRoIGQ9XCJNNTA1Ljk0Miw0NzYuNjk0TDM1LjMwNiw2LjA1OWMtOC4wNzYtOC4wNzctMjEuMTcyLTguMDc3LTI5LjI0OCwwYy04LjA3Nyw4LjA3Ni04LjA3NywyMS4xNzEsMCwyOS4yNDhsNDcwLjYzNiw0NzAuNjM2YzQuMDM4LDQuMDM5LDkuMzMyLDYuMDU4LDE0LjYyNSw2LjA1OGM1LjI5MywwLDEwLjU4Ny0yLjAxOSwxNC42MjQtNi4wNTdDNTE0LjAxOCw0OTcuODY2LDUxNC4wMTgsNDg0Ljc3MSw1MDUuOTQyLDQ3Ni42OTR6XCIvPjwvZz48L2c+PC9zdmc+JyxuZXh0Oic8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHZpZXdCb3g9XCIwIDAgNDc3LjE3NSA0NzcuMTc1XCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj4gPGc+PHBhdGggZD1cIk0zNjAuNzMxLDIyOS4wNzVsLTIyNS4xLTIyNS4xYy01LjMtNS4zLTEzLjgtNS4zLTE5LjEsMHMtNS4zLDEzLjgsMCwxOS4xbDIxNS41LDIxNS41bC0yMTUuNSwyMTUuNWMtNS4zLDUuMy01LjMsMTMuOCwwLDE5LjFjMi42LDIuNiw2LjEsNCw5LjUsNGMzLjQsMCw2LjktMS4zLDkuNS00bDIyNS4xLTIyNS4xQzM2NS45MzEsMjQyLjg3NSwzNjUuOTMxLDIzNC4yNzUsMzYwLjczMSwyMjkuMDc1elwiLz48L2c+PC9zdmc+JyxwcmV2Oic8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHZpZXdCb3g9XCIwIDAgNDc3LjE3NSA0NzcuMTc1XCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj48Zz48cGF0aCBkPVwiTTE0NS4xODgsMjM4LjU3NWwyMTUuNS0yMTUuNWM1LjMtNS4zLDUuMy0xMy44LDAtMTkuMXMtMTMuOC01LjMtMTkuMSwwbC0yMjUuMSwyMjUuMWMtNS4zLDUuMy01LjMsMTMuOCwwLDE5LjFsMjI1LjEsMjI1YzIuNiwyLjYsNi4xLDQsOS41LDRzNi45LTEuMyw5LjUtNGM1LjMtNS4zLDUuMy0xMy44LDAtMTkuMUwxNDUuMTg4LDIzOC41NzV6XCIvPjwvZz48L3N2Zz4nfSxzbGlkZUhUTUw6JzxkaXYgY2xhc3M9XCJnc2xpZGVcIj5cXG4gICAgPGRpdiBjbGFzcz1cImdzbGlkZS1pbm5lci1jb250ZW50XCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZ2lubmVyLWNvbnRhaW5lclwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnc2xpZGUtbWVkaWFcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ3NsaWRlLWRlc2NyaXB0aW9uXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnZGVzYy1pbm5lclwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVwiZ3NsaWRlLXRpdGxlXCI+PC9oND5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJnc2xpZGUtZGVzY1wiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj4nLGxpZ2h0Ym94SFRNTDonPGRpdiBpZD1cImdsaWdodGJveC1ib2R5XCIgY2xhc3M9XCJnbGlnaHRib3gtY29udGFpbmVyXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLWhpZGRlbj1cImZhbHNlXCI+XFxuICAgIDxkaXYgY2xhc3M9XCJnbG9hZGVyIHZpc2libGVcIj48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cImdvdmVybGF5XCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XCJnY29udGFpbmVyXCI+XFxuICAgIDxkaXYgaWQ9XCJnbGlnaHRib3gtc2xpZGVyXCIgY2xhc3M9XCJnc2xpZGVyXCI+PC9kaXY+XFxuICAgIDxidXR0b24gY2xhc3M9XCJnY2xvc2UgZ2J0blwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiIGRhdGEtdGFib3JkZXI9XCIzXCI+e2Nsb3NlU1ZHfTwvYnV0dG9uPlxcbiAgICA8YnV0dG9uIGNsYXNzPVwiZ3ByZXYgZ2J0blwiIGFyaWEtbGFiZWw9XCJQcmV2aW91c1wiIGRhdGEtdGFib3JkZXI9XCIyXCI+e3ByZXZTVkd9PC9idXR0b24+XFxuICAgIDxidXR0b24gY2xhc3M9XCJnbmV4dCBnYnRuXCIgYXJpYS1sYWJlbD1cIk5leHRcIiBkYXRhLXRhYm9yZGVyPVwiMVwiPntuZXh0U1ZHfTwvYnV0dG9uPlxcbjwvZGl2PlxcbjwvZGl2Pid9LGllPXMoKGZ1bmN0aW9uIGUoKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307aSh0aGlzLGUpLHRoaXMuY3VzdG9tT3B0aW9ucz10LHRoaXMuc2V0dGluZ3M9byh0ZSx0KSx0aGlzLmVmZmVjdHNDbGFzc2VzPXRoaXMuZ2V0QW5pbWF0aW9uQ2xhc3NlcygpLHRoaXMudmlkZW9QbGF5ZXJzPXt9LHRoaXMuYXBpRXZlbnRzPVtdLHRoaXMuZnVsbEVsZW1lbnRzTGlzdD0hMX0pLFt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuZ2V0U2VsZWN0b3IoKTt0JiYodGhpcy5iYXNlRXZlbnRzPWgoXCJjbGlja1wiLHtvbkVsZW1lbnQ6dCx3aXRoQ2FsbGJhY2s6ZnVuY3Rpb24odCxpKXt0LnByZXZlbnREZWZhdWx0KCksZS5vcGVuKGkpfX0pKSx0aGlzLmVsZW1lbnRzPXRoaXMuZ2V0RWxlbWVudHMoKX19LHtrZXk6XCJvcGVuXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bnVsbCx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpudWxsO2lmKDA9PT10aGlzLmVsZW1lbnRzLmxlbmd0aClyZXR1cm4hMTt0aGlzLmFjdGl2ZVNsaWRlPW51bGwsdGhpcy5wcmV2QWN0aXZlU2xpZGVJbmRleD1udWxsLHRoaXMucHJldkFjdGl2ZVNsaWRlPW51bGw7dmFyIGk9eih0KT90OnRoaXMuc2V0dGluZ3Muc3RhcnRBdDtpZihFKGUpKXt2YXIgbj1lLmdldEF0dHJpYnV0ZShcImRhdGEtZ2FsbGVyeVwiKTtuJiYodGhpcy5mdWxsRWxlbWVudHNMaXN0PXRoaXMuZWxlbWVudHMsdGhpcy5lbGVtZW50cz10aGlzLmdldEdhbGxlcnlFbGVtZW50cyh0aGlzLmVsZW1lbnRzLG4pKSxPKGkpJiYoaT10aGlzLmdldEVsZW1lbnRJbmRleChlKSk8MCYmKGk9MCl9eihpKXx8KGk9MCksdGhpcy5idWlsZCgpLHYodGhpcy5vdmVybGF5LFwibm9uZVwiPT09dGhpcy5zZXR0aW5ncy5vcGVuRWZmZWN0P1wibm9uZVwiOnRoaXMuc2V0dGluZ3MuY3NzRWZlY3RzLmZhZGUuaW4pO3ZhciBzPWRvY3VtZW50LmJvZHksbD13aW5kb3cuaW5uZXJXaWR0aC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7aWYobD4wKXt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7by50eXBlPVwidGV4dC9jc3NcIixvLmNsYXNzTmFtZT1cImdjc3Mtc3R5bGVzXCIsby5pbm5lclRleHQ9XCIuZ3Njcm9sbGJhci1maXhlciB7bWFyZ2luLXJpZ2h0OiBcIi5jb25jYXQobCxcInB4fVwiKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG8pLGQocyxcImdzY3JvbGxiYXItZml4ZXJcIil9ZChzLFwiZ2xpZ2h0Ym94LW9wZW5cIiksZChlZSxcImdsaWdodGJveC1vcGVuXCIpLEsmJihkKGRvY3VtZW50LmJvZHksXCJnbGlnaHRib3gtbW9iaWxlXCIpLHRoaXMuc2V0dGluZ3Muc2xpZGVFZmZlY3Q9XCJzbGlkZVwiKSx0aGlzLnNob3dTbGlkZShpLCEwKSwxPT09dGhpcy5lbGVtZW50cy5sZW5ndGg/KGQodGhpcy5wcmV2QnV0dG9uLFwiZ2xpZ2h0Ym94LWJ1dHRvbi1oaWRkZW5cIiksZCh0aGlzLm5leHRCdXR0b24sXCJnbGlnaHRib3gtYnV0dG9uLWhpZGRlblwiKSk6KGModGhpcy5wcmV2QnV0dG9uLFwiZ2xpZ2h0Ym94LWJ1dHRvbi1oaWRkZW5cIiksYyh0aGlzLm5leHRCdXR0b24sXCJnbGlnaHRib3gtYnV0dG9uLWhpZGRlblwiKSksdGhpcy5saWdodGJveE9wZW49ITAsdGhpcy50cmlnZ2VyKFwib3BlblwiKSxDKHRoaXMuc2V0dGluZ3Mub25PcGVuKSYmdGhpcy5zZXR0aW5ncy5vbk9wZW4oKSxRJiZ0aGlzLnNldHRpbmdzLnRvdWNoTmF2aWdhdGlvbiYmSih0aGlzKSx0aGlzLnNldHRpbmdzLmtleWJvYXJkTmF2aWdhdGlvbiYmWSh0aGlzKX19LHtrZXk6XCJvcGVuQXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTowO3RoaXMub3BlbihudWxsLGUpfX0se2tleTpcInNob3dTbGlkZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTowLGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtwKHRoaXMubG9hZGVyKSx0aGlzLmluZGV4PXBhcnNlSW50KHQpO3ZhciBuPXRoaXMuc2xpZGVzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuY3VycmVudFwiKTtuJiZjKG4sXCJjdXJyZW50XCIpLHRoaXMuc2xpZGVBbmltYXRlT3V0KCk7dmFyIHM9dGhpcy5zbGlkZXNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5nc2xpZGVcIilbdF07aWYodShzLFwibG9hZGVkXCIpKXRoaXMuc2xpZGVBbmltYXRlSW4ocyxpKSxtKHRoaXMubG9hZGVyKTtlbHNle3AodGhpcy5sb2FkZXIpO3ZhciBsPXRoaXMuZWxlbWVudHNbdF0sbz17aW5kZXg6dGhpcy5pbmRleCxzbGlkZTpzLHNsaWRlTm9kZTpzLHNsaWRlQ29uZmlnOmwuc2xpZGVDb25maWcsc2xpZGVJbmRleDp0aGlzLmluZGV4LHRyaWdnZXI6bC5ub2RlLHBsYXllcjpudWxsfTt0aGlzLnRyaWdnZXIoXCJzbGlkZV9iZWZvcmVfbG9hZFwiLG8pLGwuaW5zdGFuY2Uuc2V0Q29udGVudChzLChmdW5jdGlvbigpe20oZS5sb2FkZXIpLGUucmVzaXplKCksZS5zbGlkZUFuaW1hdGVJbihzLGkpLGUudHJpZ2dlcihcInNsaWRlX2FmdGVyX2xvYWRcIixvKX0pKX10aGlzLnNsaWRlRGVzY3JpcHRpb249cy5xdWVyeVNlbGVjdG9yKFwiLmdzbGlkZS1kZXNjcmlwdGlvblwiKSx0aGlzLnNsaWRlRGVzY3JpcHRpb25Db250YWluZWQ9dGhpcy5zbGlkZURlc2NyaXB0aW9uJiZ1KHRoaXMuc2xpZGVEZXNjcmlwdGlvbi5wYXJlbnROb2RlLFwiZ3NsaWRlLW1lZGlhXCIpLHRoaXMuc2V0dGluZ3MucHJlbG9hZCYmKHRoaXMucHJlbG9hZFNsaWRlKHQrMSksdGhpcy5wcmVsb2FkU2xpZGUodC0xKSksdGhpcy51cGRhdGVOYXZpZ2F0aW9uQ2xhc3NlcygpLHRoaXMuYWN0aXZlU2xpZGU9c319LHtrZXk6XCJwcmVsb2FkU2xpZGVcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKGU8MHx8ZT50aGlzLmVsZW1lbnRzLmxlbmd0aC0xKXJldHVybiExO2lmKE8odGhpcy5lbGVtZW50c1tlXSkpcmV0dXJuITE7dmFyIGk9dGhpcy5zbGlkZXNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5nc2xpZGVcIilbZV07aWYodShpLFwibG9hZGVkXCIpKXJldHVybiExO3ZhciBuPXRoaXMuZWxlbWVudHNbZV0scz1uLnR5cGUsbD17aW5kZXg6ZSxzbGlkZTppLHNsaWRlTm9kZTppLHNsaWRlQ29uZmlnOm4uc2xpZGVDb25maWcsc2xpZGVJbmRleDplLHRyaWdnZXI6bi5ub2RlLHBsYXllcjpudWxsfTt0aGlzLnRyaWdnZXIoXCJzbGlkZV9iZWZvcmVfbG9hZFwiLGwpLFwidmlkZW9cIj09PXN8fFwiZXh0ZXJuYWxcIj09PXM/c2V0VGltZW91dCgoZnVuY3Rpb24oKXtuLmluc3RhbmNlLnNldENvbnRlbnQoaSwoZnVuY3Rpb24oKXt0LnRyaWdnZXIoXCJzbGlkZV9hZnRlcl9sb2FkXCIsbCl9KSl9KSwyMDApOm4uaW5zdGFuY2Uuc2V0Q29udGVudChpLChmdW5jdGlvbigpe3QudHJpZ2dlcihcInNsaWRlX2FmdGVyX2xvYWRcIixsKX0pKX19LHtrZXk6XCJwcmV2U2xpZGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZ29Ub1NsaWRlKHRoaXMuaW5kZXgtMSl9fSx7a2V5OlwibmV4dFNsaWRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmdvVG9TbGlkZSh0aGlzLmluZGV4KzEpfX0se2tleTpcImdvVG9TbGlkZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXTtpZih0aGlzLnByZXZBY3RpdmVTbGlkZT10aGlzLmFjdGl2ZVNsaWRlLHRoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXg9dGhpcy5pbmRleCwhdGhpcy5sb29wKCkmJihlPDB8fGU+dGhpcy5lbGVtZW50cy5sZW5ndGgtMSkpcmV0dXJuITE7ZTwwP2U9dGhpcy5lbGVtZW50cy5sZW5ndGgtMTplPj10aGlzLmVsZW1lbnRzLmxlbmd0aCYmKGU9MCksdGhpcy5zaG93U2xpZGUoZSl9fSx7a2V5OlwiaW5zZXJ0U2xpZGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSx0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTotMTt0PDAmJih0PXRoaXMuZWxlbWVudHMubGVuZ3RoKTt2YXIgaT1uZXcgVihlLHRoaXMsdCksbj1pLmdldENvbmZpZygpLHM9byh7fSxuKSxsPWkuY3JlYXRlKCkscj10aGlzLmVsZW1lbnRzLmxlbmd0aC0xO3MuaW5kZXg9dCxzLm5vZGU9ITEscy5pbnN0YW5jZT1pLHMuc2xpZGVDb25maWc9bix0aGlzLmVsZW1lbnRzLnNwbGljZSh0LDAscyk7dmFyIGE9bnVsbCxoPW51bGw7aWYodGhpcy5zbGlkZXNDb250YWluZXIpe2lmKHQ+cil0aGlzLnNsaWRlc0NvbnRhaW5lci5hcHBlbmRDaGlsZChsKTtlbHNle3ZhciBkPXRoaXMuc2xpZGVzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZ3NsaWRlXCIpW3RdO3RoaXMuc2xpZGVzQ29udGFpbmVyLmluc2VydEJlZm9yZShsLGQpfSh0aGlzLnNldHRpbmdzLnByZWxvYWQmJjA9PXRoaXMuaW5kZXgmJjA9PXR8fHRoaXMuaW5kZXgtMT09dHx8dGhpcy5pbmRleCsxPT10KSYmdGhpcy5wcmVsb2FkU2xpZGUodCksMD09PXRoaXMuaW5kZXgmJjA9PT10JiYodGhpcy5pbmRleD0xKSx0aGlzLnVwZGF0ZU5hdmlnYXRpb25DbGFzc2VzKCksYT10aGlzLnNsaWRlc0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmdzbGlkZVwiKVt0XSxoPXRoaXMuZ2V0U2xpZGVQbGF5ZXJJbnN0YW5jZSh0KSxzLnNsaWRlTm9kZT1hfXRoaXMudHJpZ2dlcihcInNsaWRlX2luc2VydGVkXCIse2luZGV4OnQsc2xpZGU6YSxzbGlkZU5vZGU6YSxzbGlkZUNvbmZpZzpuLHNsaWRlSW5kZXg6dCx0cmlnZ2VyOm51bGwscGxheWVyOmh9KSxDKHRoaXMuc2V0dGluZ3Muc2xpZGVJbnNlcnRlZCkmJnRoaXMuc2V0dGluZ3Muc2xpZGVJbnNlcnRlZCh7aW5kZXg6dCxzbGlkZTphLHBsYXllcjpofSl9fSx7a2V5OlwicmVtb3ZlU2xpZGVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTotMTtpZihlPDB8fGU+dGhpcy5lbGVtZW50cy5sZW5ndGgtMSlyZXR1cm4hMTt2YXIgdD10aGlzLnNsaWRlc0NvbnRhaW5lciYmdGhpcy5zbGlkZXNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5nc2xpZGVcIilbZV07dCYmKHRoaXMuZ2V0QWN0aXZlU2xpZGVJbmRleCgpPT1lJiYoZT09dGhpcy5lbGVtZW50cy5sZW5ndGgtMT90aGlzLnByZXZTbGlkZSgpOnRoaXMubmV4dFNsaWRlKCkpLHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSksdGhpcy5lbGVtZW50cy5zcGxpY2UoZSwxKSx0aGlzLnRyaWdnZXIoXCJzbGlkZV9yZW1vdmVkXCIsZSksQyh0aGlzLnNldHRpbmdzLnNsaWRlUmVtb3ZlZCkmJnRoaXMuc2V0dGluZ3Muc2xpZGVSZW1vdmVkKGUpfX0se2tleTpcInNsaWRlQW5pbWF0ZUluXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLG49ZS5xdWVyeVNlbGVjdG9yKFwiLmdzbGlkZS1tZWRpYVwiKSxzPWUucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtZGVzY3JpcHRpb25cIiksbD17aW5kZXg6dGhpcy5wcmV2QWN0aXZlU2xpZGVJbmRleCxzbGlkZTp0aGlzLnByZXZBY3RpdmVTbGlkZSxzbGlkZU5vZGU6dGhpcy5wcmV2QWN0aXZlU2xpZGUsc2xpZGVJbmRleDp0aGlzLnByZXZBY3RpdmVTbGlkZSxzbGlkZUNvbmZpZzpPKHRoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXgpP251bGw6dGhpcy5lbGVtZW50c1t0aGlzLnByZXZBY3RpdmVTbGlkZUluZGV4XS5zbGlkZUNvbmZpZyx0cmlnZ2VyOk8odGhpcy5wcmV2QWN0aXZlU2xpZGVJbmRleCk/bnVsbDp0aGlzLmVsZW1lbnRzW3RoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXhdLm5vZGUscGxheWVyOnRoaXMuZ2V0U2xpZGVQbGF5ZXJJbnN0YW5jZSh0aGlzLnByZXZBY3RpdmVTbGlkZUluZGV4KX0sbz17aW5kZXg6dGhpcy5pbmRleCxzbGlkZTp0aGlzLmFjdGl2ZVNsaWRlLHNsaWRlTm9kZTp0aGlzLmFjdGl2ZVNsaWRlLHNsaWRlQ29uZmlnOnRoaXMuZWxlbWVudHNbdGhpcy5pbmRleF0uc2xpZGVDb25maWcsc2xpZGVJbmRleDp0aGlzLmluZGV4LHRyaWdnZXI6dGhpcy5lbGVtZW50c1t0aGlzLmluZGV4XS5ub2RlLHBsYXllcjp0aGlzLmdldFNsaWRlUGxheWVySW5zdGFuY2UodGhpcy5pbmRleCl9O2lmKG4ub2Zmc2V0V2lkdGg+MCYmcyYmKG0ocykscy5zdHlsZS5kaXNwbGF5PVwiXCIpLGMoZSx0aGlzLmVmZmVjdHNDbGFzc2VzKSx0KXYoZSx0aGlzLnNldHRpbmdzLmNzc0VmZWN0c1t0aGlzLnNldHRpbmdzLm9wZW5FZmZlY3RdLmluLChmdW5jdGlvbigpe2kuc2V0dGluZ3MuYXV0b3BsYXlWaWRlb3MmJmkuc2xpZGVQbGF5ZXJQbGF5KGUpLGkudHJpZ2dlcihcInNsaWRlX2NoYW5nZWRcIix7cHJldjpsLGN1cnJlbnQ6b30pLEMoaS5zZXR0aW5ncy5hZnRlclNsaWRlQ2hhbmdlKSYmaS5zZXR0aW5ncy5hZnRlclNsaWRlQ2hhbmdlLmFwcGx5KGksW2wsb10pfSkpO2Vsc2V7dmFyIHI9dGhpcy5zZXR0aW5ncy5zbGlkZUVmZmVjdCxhPVwibm9uZVwiIT09cj90aGlzLnNldHRpbmdzLmNzc0VmZWN0c1tyXS5pbjpyO3RoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXg+dGhpcy5pbmRleCYmXCJzbGlkZVwiPT10aGlzLnNldHRpbmdzLnNsaWRlRWZmZWN0JiYoYT10aGlzLnNldHRpbmdzLmNzc0VmZWN0cy5zbGlkZUJhY2suaW4pLHYoZSxhLChmdW5jdGlvbigpe2kuc2V0dGluZ3MuYXV0b3BsYXlWaWRlb3MmJmkuc2xpZGVQbGF5ZXJQbGF5KGUpLGkudHJpZ2dlcihcInNsaWRlX2NoYW5nZWRcIix7cHJldjpsLGN1cnJlbnQ6b30pLEMoaS5zZXR0aW5ncy5hZnRlclNsaWRlQ2hhbmdlKSYmaS5zZXR0aW5ncy5hZnRlclNsaWRlQ2hhbmdlLmFwcGx5KGksW2wsb10pfSkpfXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aS5yZXNpemUoZSl9KSwxMDApLGQoZSxcImN1cnJlbnRcIil9fSx7a2V5Olwic2xpZGVBbmltYXRlT3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZighdGhpcy5wcmV2QWN0aXZlU2xpZGUpcmV0dXJuITE7dmFyIGU9dGhpcy5wcmV2QWN0aXZlU2xpZGU7YyhlLHRoaXMuZWZmZWN0c0NsYXNzZXMpLGQoZSxcInByZXZcIik7dmFyIHQ9dGhpcy5zZXR0aW5ncy5zbGlkZUVmZmVjdCxpPVwibm9uZVwiIT09dD90aGlzLnNldHRpbmdzLmNzc0VmZWN0c1t0XS5vdXQ6dDt0aGlzLnNsaWRlUGxheWVyUGF1c2UoZSksdGhpcy50cmlnZ2VyKFwic2xpZGVfYmVmb3JlX2NoYW5nZVwiLHtwcmV2OntpbmRleDp0aGlzLnByZXZBY3RpdmVTbGlkZUluZGV4LHNsaWRlOnRoaXMucHJldkFjdGl2ZVNsaWRlLHNsaWRlTm9kZTp0aGlzLnByZXZBY3RpdmVTbGlkZSxzbGlkZUluZGV4OnRoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXgsc2xpZGVDb25maWc6Tyh0aGlzLnByZXZBY3RpdmVTbGlkZUluZGV4KT9udWxsOnRoaXMuZWxlbWVudHNbdGhpcy5wcmV2QWN0aXZlU2xpZGVJbmRleF0uc2xpZGVDb25maWcsdHJpZ2dlcjpPKHRoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXgpP251bGw6dGhpcy5lbGVtZW50c1t0aGlzLnByZXZBY3RpdmVTbGlkZUluZGV4XS5ub2RlLHBsYXllcjp0aGlzLmdldFNsaWRlUGxheWVySW5zdGFuY2UodGhpcy5wcmV2QWN0aXZlU2xpZGVJbmRleCl9LGN1cnJlbnQ6e2luZGV4OnRoaXMuaW5kZXgsc2xpZGU6dGhpcy5hY3RpdmVTbGlkZSxzbGlkZU5vZGU6dGhpcy5hY3RpdmVTbGlkZSxzbGlkZUluZGV4OnRoaXMuaW5kZXgsc2xpZGVDb25maWc6dGhpcy5lbGVtZW50c1t0aGlzLmluZGV4XS5zbGlkZUNvbmZpZyx0cmlnZ2VyOnRoaXMuZWxlbWVudHNbdGhpcy5pbmRleF0ubm9kZSxwbGF5ZXI6dGhpcy5nZXRTbGlkZVBsYXllckluc3RhbmNlKHRoaXMuaW5kZXgpfX0pLEModGhpcy5zZXR0aW5ncy5iZWZvcmVTbGlkZUNoYW5nZSkmJnRoaXMuc2V0dGluZ3MuYmVmb3JlU2xpZGVDaGFuZ2UuYXBwbHkodGhpcyxbe2luZGV4OnRoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXgsc2xpZGU6dGhpcy5wcmV2QWN0aXZlU2xpZGUscGxheWVyOnRoaXMuZ2V0U2xpZGVQbGF5ZXJJbnN0YW5jZSh0aGlzLnByZXZBY3RpdmVTbGlkZUluZGV4KX0se2luZGV4OnRoaXMuaW5kZXgsc2xpZGU6dGhpcy5hY3RpdmVTbGlkZSxwbGF5ZXI6dGhpcy5nZXRTbGlkZVBsYXllckluc3RhbmNlKHRoaXMuaW5kZXgpfV0pLHRoaXMucHJldkFjdGl2ZVNsaWRlSW5kZXg+dGhpcy5pbmRleCYmXCJzbGlkZVwiPT10aGlzLnNldHRpbmdzLnNsaWRlRWZmZWN0JiYoaT10aGlzLnNldHRpbmdzLmNzc0VmZWN0cy5zbGlkZUJhY2sub3V0KSx2KGUsaSwoZnVuY3Rpb24oKXt2YXIgdD1lLnF1ZXJ5U2VsZWN0b3IoXCIuZ2lubmVyLWNvbnRhaW5lclwiKSxpPWUucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtbWVkaWFcIiksbj1lLnF1ZXJ5U2VsZWN0b3IoXCIuZ3NsaWRlLWRlc2NyaXB0aW9uXCIpO3Quc3R5bGUudHJhbnNmb3JtPVwiXCIsaS5zdHlsZS50cmFuc2Zvcm09XCJcIixjKGksXCJncmVzZXRcIiksaS5zdHlsZS5vcGFjaXR5PVwiXCIsbiYmKG4uc3R5bGUub3BhY2l0eT1cIlwiKSxjKGUsXCJwcmV2XCIpfSkpfX0se2tleTpcImdldEFsbFBsYXllcnNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZpZGVvUGxheWVyc319LHtrZXk6XCJnZXRTbGlkZVBsYXllckluc3RhbmNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9XCJndmlkZW9cIitlLGk9dGhpcy5nZXRBbGxQbGF5ZXJzKCk7cmV0dXJuISghUChpLHQpfHwhaVt0XSkmJmlbdF19fSx7a2V5Olwic3RvcFNsaWRlVmlkZW9cIix2YWx1ZTpmdW5jdGlvbihlKXtpZihFKGUpKXt2YXIgdD1lLnF1ZXJ5U2VsZWN0b3IoXCIuZ3ZpZGVvLXdyYXBwZXJcIik7dCYmKGU9dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluZGV4XCIpKX1jb25zb2xlLmxvZyhcInN0b3BTbGlkZVZpZGVvIGlzIGRlcHJlY2F0ZWQsIHVzZSBzbGlkZVBsYXllclBhdXNlXCIpO3ZhciBpPXRoaXMuZ2V0U2xpZGVQbGF5ZXJJbnN0YW5jZShlKTtpJiZpLnBsYXlpbmcmJmkucGF1c2UoKX19LHtrZXk6XCJzbGlkZVBsYXllclBhdXNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoRShlKSl7dmFyIHQ9ZS5xdWVyeVNlbGVjdG9yKFwiLmd2aWRlby13cmFwcGVyXCIpO3QmJihlPXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbmRleFwiKSl9dmFyIGk9dGhpcy5nZXRTbGlkZVBsYXllckluc3RhbmNlKGUpO2kmJmkucGxheWluZyYmaS5wYXVzZSgpfX0se2tleTpcInBsYXlTbGlkZVZpZGVvXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoRShlKSl7dmFyIHQ9ZS5xdWVyeVNlbGVjdG9yKFwiLmd2aWRlby13cmFwcGVyXCIpO3QmJihlPXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbmRleFwiKSl9Y29uc29sZS5sb2coXCJwbGF5U2xpZGVWaWRlbyBpcyBkZXByZWNhdGVkLCB1c2Ugc2xpZGVQbGF5ZXJQbGF5XCIpO3ZhciBpPXRoaXMuZ2V0U2xpZGVQbGF5ZXJJbnN0YW5jZShlKTtpJiYhaS5wbGF5aW5nJiZpLnBsYXkoKX19LHtrZXk6XCJzbGlkZVBsYXllclBsYXlcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdDtpZighS3x8bnVsbCE9PSh0PXRoaXMuc2V0dGluZ3MucGx5ci5jb25maWcpJiZ2b2lkIDAhPT10JiZ0Lm11dGVkKXtpZihFKGUpKXt2YXIgaT1lLnF1ZXJ5U2VsZWN0b3IoXCIuZ3ZpZGVvLXdyYXBwZXJcIik7aSYmKGU9aS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluZGV4XCIpKX12YXIgbj10aGlzLmdldFNsaWRlUGxheWVySW5zdGFuY2UoZSk7biYmIW4ucGxheWluZyYmKG4ucGxheSgpLHRoaXMuc2V0dGluZ3MuYXV0b2ZvY3VzVmlkZW9zJiZuLmVsZW1lbnRzLmNvbnRhaW5lci5mb2N1cygpKX19fSx7a2V5Olwic2V0RWxlbWVudHNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMuc2V0dGluZ3MuZWxlbWVudHM9ITE7dmFyIGk9W107ZSYmZS5sZW5ndGgmJnIoZSwoZnVuY3Rpb24oZSxuKXt2YXIgcz1uZXcgVihlLHQsbiksbD1zLmdldENvbmZpZygpLHI9byh7fSxsKTtyLnNsaWRlQ29uZmlnPWwsci5pbnN0YW5jZT1zLHIuaW5kZXg9bixpLnB1c2gocil9KSksdGhpcy5lbGVtZW50cz1pLHRoaXMubGlnaHRib3hPcGVuJiYodGhpcy5zbGlkZXNDb250YWluZXIuaW5uZXJIVE1MPVwiXCIsdGhpcy5lbGVtZW50cy5sZW5ndGgmJihyKHRoaXMuZWxlbWVudHMsKGZ1bmN0aW9uKCl7dmFyIGU9eSh0LnNldHRpbmdzLnNsaWRlSFRNTCk7dC5zbGlkZXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZSl9KSksdGhpcy5zaG93U2xpZGUoMCwhMCkpKX19LHtrZXk6XCJnZXRFbGVtZW50SW5kZXhcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD0hMTtyZXR1cm4gcih0aGlzLmVsZW1lbnRzLChmdW5jdGlvbihpLG4pe2lmKFAoaSxcIm5vZGVcIikmJmkubm9kZT09ZSlyZXR1cm4gdD1uLCEwfSkpLHR9fSx7a2V5OlwiZ2V0RWxlbWVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1bXTt0aGlzLmVsZW1lbnRzPXRoaXMuZWxlbWVudHM/dGhpcy5lbGVtZW50czpbXSwhTyh0aGlzLnNldHRpbmdzLmVsZW1lbnRzKSYmQSh0aGlzLnNldHRpbmdzLmVsZW1lbnRzKSYmdGhpcy5zZXR0aW5ncy5lbGVtZW50cy5sZW5ndGgmJnIodGhpcy5zZXR0aW5ncy5lbGVtZW50cywoZnVuY3Rpb24oaSxuKXt2YXIgcz1uZXcgVihpLGUsbiksbD1zLmdldENvbmZpZygpLHI9byh7fSxsKTtyLm5vZGU9ITEsci5pbmRleD1uLHIuaW5zdGFuY2U9cyxyLnNsaWRlQ29uZmlnPWwsdC5wdXNoKHIpfSkpO3ZhciBpPSExO3JldHVybiB0aGlzLmdldFNlbGVjdG9yKCkmJihpPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5nZXRTZWxlY3RvcigpKSksaT8ocihpLChmdW5jdGlvbihpLG4pe3ZhciBzPW5ldyBWKGksZSxuKSxsPXMuZ2V0Q29uZmlnKCkscj1vKHt9LGwpO3Iubm9kZT1pLHIuaW5kZXg9bixyLmluc3RhbmNlPXMsci5zbGlkZUNvbmZpZz1sLHIuZ2FsbGVyeT1pLmdldEF0dHJpYnV0ZShcImRhdGEtZ2FsbGVyeVwiKSx0LnB1c2gocil9KSksdCk6dH19LHtrZXk6XCJnZXRHYWxsZXJ5RWxlbWVudHNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBlLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2FsbGVyeT09dH0pKX19LHtrZXk6XCJnZXRTZWxlY3RvclwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc2V0dGluZ3MuZWxlbWVudHMmJih0aGlzLnNldHRpbmdzLnNlbGVjdG9yJiZcImRhdGEtXCI9PXRoaXMuc2V0dGluZ3Muc2VsZWN0b3Iuc3Vic3RyaW5nKDAsNSk/XCIqW1wiLmNvbmNhdCh0aGlzLnNldHRpbmdzLnNlbGVjdG9yLFwiXVwiKTp0aGlzLnNldHRpbmdzLnNlbGVjdG9yKX19LHtrZXk6XCJnZXRBY3RpdmVTbGlkZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpZGVzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZ3NsaWRlXCIpW3RoaXMuaW5kZXhdfX0se2tleTpcImdldEFjdGl2ZVNsaWRlSW5kZXhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4fX0se2tleTpcImdldEFuaW1hdGlvbkNsYXNzZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPVtdO2Zvcih2YXIgdCBpbiB0aGlzLnNldHRpbmdzLmNzc0VmZWN0cylpZih0aGlzLnNldHRpbmdzLmNzc0VmZWN0cy5oYXNPd25Qcm9wZXJ0eSh0KSl7dmFyIGk9dGhpcy5zZXR0aW5ncy5jc3NFZmVjdHNbdF07ZS5wdXNoKFwiZ1wiLmNvbmNhdChpLmluKSksZS5wdXNoKFwiZ1wiLmNvbmNhdChpLm91dCkpfXJldHVybiBlLmpvaW4oXCIgXCIpfX0se2tleTpcImJ1aWxkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKHRoaXMuYnVpbHQpcmV0dXJuITE7dmFyIHQ9ZG9jdW1lbnQuYm9keS5jaGlsZE5vZGVzLGk9W107cih0LChmdW5jdGlvbihlKXtlLnBhcmVudE5vZGU9PWRvY3VtZW50LmJvZHkmJlwiI1wiIT09ZS5ub2RlTmFtZS5jaGFyQXQoMCkmJmUuaGFzQXR0cmlidXRlJiYhZS5oYXNBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSYmKGkucHVzaChlKSxlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpKX0pKTt2YXIgbj1QKHRoaXMuc2V0dGluZ3Muc3ZnLFwibmV4dFwiKT90aGlzLnNldHRpbmdzLnN2Zy5uZXh0OlwiXCIscz1QKHRoaXMuc2V0dGluZ3Muc3ZnLFwicHJldlwiKT90aGlzLnNldHRpbmdzLnN2Zy5wcmV2OlwiXCIsbD1QKHRoaXMuc2V0dGluZ3Muc3ZnLFwiY2xvc2VcIik/dGhpcy5zZXR0aW5ncy5zdmcuY2xvc2U6XCJcIixvPXRoaXMuc2V0dGluZ3MubGlnaHRib3hIVE1MO289eShvPShvPShvPW8ucmVwbGFjZSgve25leHRTVkd9L2csbikpLnJlcGxhY2UoL3twcmV2U1ZHfS9nLHMpKS5yZXBsYWNlKC97Y2xvc2VTVkd9L2csbCkpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobyk7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnbGlnaHRib3gtYm9keVwiKTt0aGlzLm1vZGFsPWE7dmFyIGM9YS5xdWVyeVNlbGVjdG9yKFwiLmdjbG9zZVwiKTt0aGlzLnByZXZCdXR0b249YS5xdWVyeVNlbGVjdG9yKFwiLmdwcmV2XCIpLHRoaXMubmV4dEJ1dHRvbj1hLnF1ZXJ5U2VsZWN0b3IoXCIuZ25leHRcIiksdGhpcy5vdmVybGF5PWEucXVlcnlTZWxlY3RvcihcIi5nb3ZlcmxheVwiKSx0aGlzLmxvYWRlcj1hLnF1ZXJ5U2VsZWN0b3IoXCIuZ2xvYWRlclwiKSx0aGlzLnNsaWRlc0NvbnRhaW5lcj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdsaWdodGJveC1zbGlkZXJcIiksdGhpcy5ib2R5SGlkZGVuQ2hpbGRFbG1zPWksdGhpcy5ldmVudHM9e30sZCh0aGlzLm1vZGFsLFwiZ2xpZ2h0Ym94LVwiK3RoaXMuc2V0dGluZ3Muc2tpbiksdGhpcy5zZXR0aW5ncy5jbG9zZUJ1dHRvbiYmYyYmKHRoaXMuZXZlbnRzLmNsb3NlPWgoXCJjbGlja1wiLHtvbkVsZW1lbnQ6Yyx3aXRoQ2FsbGJhY2s6ZnVuY3Rpb24odCxpKXt0LnByZXZlbnREZWZhdWx0KCksZS5jbG9zZSgpfX0pKSxjJiYhdGhpcy5zZXR0aW5ncy5jbG9zZUJ1dHRvbiYmYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpLHRoaXMubmV4dEJ1dHRvbiYmKHRoaXMuZXZlbnRzLm5leHQ9aChcImNsaWNrXCIse29uRWxlbWVudDp0aGlzLm5leHRCdXR0b24sd2l0aENhbGxiYWNrOmZ1bmN0aW9uKHQsaSl7dC5wcmV2ZW50RGVmYXVsdCgpLGUubmV4dFNsaWRlKCl9fSkpLHRoaXMucHJldkJ1dHRvbiYmKHRoaXMuZXZlbnRzLnByZXY9aChcImNsaWNrXCIse29uRWxlbWVudDp0aGlzLnByZXZCdXR0b24sd2l0aENhbGxiYWNrOmZ1bmN0aW9uKHQsaSl7dC5wcmV2ZW50RGVmYXVsdCgpLGUucHJldlNsaWRlKCl9fSkpLHRoaXMuc2V0dGluZ3MuY2xvc2VPbk91dHNpZGVDbGljayYmKHRoaXMuZXZlbnRzLm91dENsb3NlPWgoXCJjbGlja1wiLHtvbkVsZW1lbnQ6YSx3aXRoQ2FsbGJhY2s6ZnVuY3Rpb24odCxpKXtlLnByZXZlbnRPdXRzaWRlQ2xpY2t8fHUoZG9jdW1lbnQuYm9keSxcImdsaWdodGJveC1tb2JpbGVcIil8fGcodC50YXJnZXQsXCIuZ2lubmVyLWNvbnRhaW5lclwiKXx8Zyh0LnRhcmdldCxcIi5nYnRuXCIpfHx1KHQudGFyZ2V0LFwiZ25leHRcIil8fHUodC50YXJnZXQsXCJncHJldlwiKXx8ZS5jbG9zZSgpfX0pKSxyKHRoaXMuZWxlbWVudHMsKGZ1bmN0aW9uKHQsaSl7ZS5zbGlkZXNDb250YWluZXIuYXBwZW5kQ2hpbGQodC5pbnN0YW5jZS5jcmVhdGUoKSksdC5zbGlkZU5vZGU9ZS5zbGlkZXNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5nc2xpZGVcIilbaV19KSksUSYmZChkb2N1bWVudC5ib2R5LFwiZ2xpZ2h0Ym94LXRvdWNoXCIpLHRoaXMuZXZlbnRzLnJlc2l6ZT1oKFwicmVzaXplXCIse29uRWxlbWVudDp3aW5kb3csd2l0aENhbGxiYWNrOmZ1bmN0aW9uKCl7ZS5yZXNpemUoKX19KSx0aGlzLmJ1aWx0PSEwfX0se2tleTpcInJlc2l6ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOm51bGw7aWYoKGU9ZXx8dGhpcy5hY3RpdmVTbGlkZSkmJiF1KGUsXCJ6b29tZWRcIikpe3ZhciB0PXgoKSxpPWUucXVlcnlTZWxlY3RvcihcIi5ndmlkZW8td3JhcHBlclwiKSxuPWUucXVlcnlTZWxlY3RvcihcIi5nc2xpZGUtaW1hZ2VcIikscz10aGlzLnNsaWRlRGVzY3JpcHRpb24sbD10LndpZHRoLG89dC5oZWlnaHQ7aWYobDw9NzY4P2QoZG9jdW1lbnQuYm9keSxcImdsaWdodGJveC1tb2JpbGVcIik6Yyhkb2N1bWVudC5ib2R5LFwiZ2xpZ2h0Ym94LW1vYmlsZVwiKSxpfHxuKXt2YXIgcj0hMTtpZihzJiYodShzLFwiZGVzY3JpcHRpb24tYm90dG9tXCIpfHx1KHMsXCJkZXNjcmlwdGlvbi10b3BcIikpJiYhdShzLFwiZ2Fic29sdXRlXCIpJiYocj0hMCksbilpZihsPD03Njgpbi5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpO2Vsc2UgaWYocil7dmFyIGEsaD1zLm9mZnNldEhlaWdodCxnPW4ucXVlcnlTZWxlY3RvcihcImltZ1wiKSx2PXRoaXMuZWxlbWVudHNbdGhpcy5pbmRleF0ubm9kZSxmPW51bGwhPT0oYT12LmdldEF0dHJpYnV0ZShcImRhdGEtaGVpZ2h0XCIpKSYmdm9pZCAwIT09YT9hOlwiMTAwdmhcIjtnLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJtYXgtaGVpZ2h0OiBjYWxjKFwiLmNvbmNhdChmLFwiIC0gXCIpLmNvbmNhdChoLFwicHgpXCIpKSxzLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJtYXgtd2lkdGg6IFwiLmNvbmNhdChnLm9mZnNldFdpZHRoLFwicHg7XCIpKX1pZihpKXt2YXIgcD1QKHRoaXMuc2V0dGluZ3MucGx5ci5jb25maWcsXCJyYXRpb1wiKT90aGlzLnNldHRpbmdzLnBseXIuY29uZmlnLnJhdGlvOlwiXCI7aWYoIXApe3ZhciBtPWkuY2xpZW50V2lkdGgseT1pLmNsaWVudEhlaWdodCxiPW0veTtwPVwiXCIuY29uY2F0KG0vYixcIjpcIikuY29uY2F0KHkvYil9dmFyIFM9cC5zcGxpdChcIjpcIiksdz10aGlzLnNldHRpbmdzLnZpZGVvc1dpZHRoLFQ9dGhpcy5zZXR0aW5ncy52aWRlb3NXaWR0aCxDPShUPXoodyl8fC0xIT09dy5pbmRleE9mKFwicHhcIik/cGFyc2VJbnQodyk6LTEhPT13LmluZGV4T2YoXCJ2d1wiKT9sKnBhcnNlSW50KHcpLzEwMDotMSE9PXcuaW5kZXhPZihcInZoXCIpP28qcGFyc2VJbnQodykvMTAwOi0xIT09dy5pbmRleE9mKFwiJVwiKT9sKnBhcnNlSW50KHcpLzEwMDpwYXJzZUludChpLmNsaWVudFdpZHRoKSkvKHBhcnNlSW50KFNbMF0pL3BhcnNlSW50KFNbMV0pKTtpZihDPU1hdGguZmxvb3IoQyksciYmKG8tPXMub2Zmc2V0SGVpZ2h0KSxUPmx8fEM+b3x8bzxDJiZsPlQpe3ZhciBrPWkub2Zmc2V0V2lkdGgsRT1pLm9mZnNldEhlaWdodCxBPW8vRSxMPXt3aWR0aDprKkEsaGVpZ2h0OkUqQX07aS5wYXJlbnROb2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJtYXgtd2lkdGg6IFwiLmNvbmNhdChMLndpZHRoLFwicHhcIikpLHImJnMuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcIm1heC13aWR0aDogXCIuY29uY2F0KEwud2lkdGgsXCJweDtcIikpfWVsc2UgaS5wYXJlbnROb2RlLnN0eWxlLm1heFdpZHRoPVwiXCIuY29uY2F0KHcpLHImJnMuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcIm1heC13aWR0aDogXCIuY29uY2F0KHcsXCI7XCIpKX19fX19LHtrZXk6XCJyZWxvYWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW5pdCgpfX0se2tleTpcInVwZGF0ZU5hdmlnYXRpb25DbGFzc2VzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxvb3AoKTtjKHRoaXMubmV4dEJ1dHRvbixcImRpc2FibGVkXCIpLGModGhpcy5wcmV2QnV0dG9uLFwiZGlzYWJsZWRcIiksMD09dGhpcy5pbmRleCYmdGhpcy5lbGVtZW50cy5sZW5ndGgtMT09MD8oZCh0aGlzLnByZXZCdXR0b24sXCJkaXNhYmxlZFwiKSxkKHRoaXMubmV4dEJ1dHRvbixcImRpc2FibGVkXCIpKTowIT09dGhpcy5pbmRleHx8ZT90aGlzLmluZGV4IT09dGhpcy5lbGVtZW50cy5sZW5ndGgtMXx8ZXx8ZCh0aGlzLm5leHRCdXR0b24sXCJkaXNhYmxlZFwiKTpkKHRoaXMucHJldkJ1dHRvbixcImRpc2FibGVkXCIpfX0se2tleTpcImxvb3BcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPVAodGhpcy5zZXR0aW5ncyxcImxvb3BBdEVuZFwiKT90aGlzLnNldHRpbmdzLmxvb3BBdEVuZDpudWxsO3JldHVybiBlPVAodGhpcy5zZXR0aW5ncyxcImxvb3BcIik/dGhpcy5zZXR0aW5ncy5sb29wOmUsZX19LHtrZXk6XCJjbG9zZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZighdGhpcy5saWdodGJveE9wZW4pe2lmKHRoaXMuZXZlbnRzKXtmb3IodmFyIHQgaW4gdGhpcy5ldmVudHMpdGhpcy5ldmVudHMuaGFzT3duUHJvcGVydHkodCkmJnRoaXMuZXZlbnRzW3RdLmRlc3Ryb3koKTt0aGlzLmV2ZW50cz1udWxsfXJldHVybiExfWlmKHRoaXMuY2xvc2luZylyZXR1cm4hMTt0aGlzLmNsb3Npbmc9ITAsdGhpcy5zbGlkZVBsYXllclBhdXNlKHRoaXMuYWN0aXZlU2xpZGUpLHRoaXMuZnVsbEVsZW1lbnRzTGlzdCYmKHRoaXMuZWxlbWVudHM9dGhpcy5mdWxsRWxlbWVudHNMaXN0KSx0aGlzLmJvZHlIaWRkZW5DaGlsZEVsbXMubGVuZ3RoJiZyKHRoaXMuYm9keUhpZGRlbkNoaWxkRWxtcywoZnVuY3Rpb24oZSl7ZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKX0pKSxkKHRoaXMubW9kYWwsXCJnbGlnaHRib3gtY2xvc2luZ1wiKSx2KHRoaXMub3ZlcmxheSxcIm5vbmVcIj09dGhpcy5zZXR0aW5ncy5vcGVuRWZmZWN0P1wibm9uZVwiOnRoaXMuc2V0dGluZ3MuY3NzRWZlY3RzLmZhZGUub3V0KSx2KHRoaXMuYWN0aXZlU2xpZGUsdGhpcy5zZXR0aW5ncy5jc3NFZmVjdHNbdGhpcy5zZXR0aW5ncy5jbG9zZUVmZmVjdF0ub3V0LChmdW5jdGlvbigpe2lmKGUuYWN0aXZlU2xpZGU9bnVsbCxlLnByZXZBY3RpdmVTbGlkZUluZGV4PW51bGwsZS5wcmV2QWN0aXZlU2xpZGU9bnVsbCxlLmJ1aWx0PSExLGUuZXZlbnRzKXtmb3IodmFyIHQgaW4gZS5ldmVudHMpZS5ldmVudHMuaGFzT3duUHJvcGVydHkodCkmJmUuZXZlbnRzW3RdLmRlc3Ryb3koKTtlLmV2ZW50cz1udWxsfXZhciBpPWRvY3VtZW50LmJvZHk7YyhlZSxcImdsaWdodGJveC1vcGVuXCIpLGMoaSxcImdsaWdodGJveC1vcGVuIHRvdWNoaW5nIGdkZXNjLW9wZW4gZ2xpZ2h0Ym94LXRvdWNoIGdsaWdodGJveC1tb2JpbGUgZ3Njcm9sbGJhci1maXhlclwiKSxlLm1vZGFsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZS5tb2RhbCksZS50cmlnZ2VyKFwiY2xvc2VcIiksQyhlLnNldHRpbmdzLm9uQ2xvc2UpJiZlLnNldHRpbmdzLm9uQ2xvc2UoKTt2YXIgbj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmdjc3Mtc3R5bGVzXCIpO24mJm4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSxlLmxpZ2h0Ym94T3Blbj0hMSxlLmNsb3Npbmc9bnVsbH0pKX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNsb3NlKCksdGhpcy5jbGVhckFsbEV2ZW50cygpLHRoaXMuYmFzZUV2ZW50cyYmdGhpcy5iYXNlRXZlbnRzLmRlc3Ryb3koKX19LHtrZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtpZighZXx8IUModCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV2ZW50IG5hbWUgYW5kIGNhbGxiYWNrIG11c3QgYmUgZGVmaW5lZFwiKTt0aGlzLmFwaUV2ZW50cy5wdXNoKHtldnQ6ZSxvbmNlOmksY2FsbGJhY2s6dH0pfX0se2tleTpcIm9uY2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMub24oZSx0LCEwKX19LHtrZXk6XCJ0cmlnZ2VyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpudWxsLG49W107cih0aGlzLmFwaUV2ZW50cywoZnVuY3Rpb24odCxzKXt2YXIgbD10LmV2dCxvPXQub25jZSxyPXQuY2FsbGJhY2s7bD09ZSYmKHIoaSksbyYmbi5wdXNoKHMpKX0pKSxuLmxlbmd0aCYmcihuLChmdW5jdGlvbihlKXtyZXR1cm4gdC5hcGlFdmVudHMuc3BsaWNlKGUsMSl9KSl9fSx7a2V5OlwiY2xlYXJBbGxFdmVudHNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuYXBpRXZlbnRzLnNwbGljZSgwLHRoaXMuYXBpRXZlbnRzLmxlbmd0aCl9fSx7a2V5OlwidmVyc2lvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCIzLjMuMFwifX1dKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD1uZXcgaWUoZSk7cmV0dXJuIHQuaW5pdCgpLHR9fSkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/glightbox/dist/js/glightbox.min.js\n");

/***/ }),

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSPlugin: () => (/* binding */ CSSPlugin),\n/* harmony export */   _createElement: () => (/* binding */ _createElement),\n/* harmony export */   _getBBox: () => (/* binding */ _getBBox),\n/* harmony export */   checkPrefix: () => (/* binding */ _checkPropPrefix),\n/* harmony export */   \"default\": () => (/* binding */ CSSPlugin)\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"./node_modules/gsap/gsap-core.js\");\n/*!\n * CSSPlugin 3.12.5\n * https://gsap.com\n *\n * Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar _win,\n    _doc,\n    _docElement,\n    _pluginInitted,\n    _tempDiv,\n    _tempDivStyler,\n    _recentSetterPlugin,\n    _reverting,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _transformProps = {},\n    _RAD2DEG = 180 / Math.PI,\n    _DEG2RAD = Math.PI / 180,\n    _atan2 = Math.atan2,\n    _bigNum = 1e8,\n    _capsExp = /([A-Z])/g,\n    _horizontalExp = /(left|right|width|margin|padding|x)/i,\n    _complexExp = /[\\s,\\(]\\S/,\n    _propertyAliases = {\n  autoAlpha: \"opacity,visibility\",\n  scale: \"scaleX,scaleY\",\n  alpha: \"opacity\"\n},\n    _renderCSSProp = function _renderCSSProp(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n},\n    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n  var value = data.s + data.c * ratio;\n  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n},\n    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n  return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n},\n    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n},\n    _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n  return target.style[property] = value;\n},\n    _setterCSSProp = function _setterCSSProp(target, property, value) {\n  return target.style.setProperty(property, value);\n},\n    _setterTransform = function _setterTransform(target, property, value) {\n  return target._gsap[property] = value;\n},\n    _setterScale = function _setterScale(target, property, value) {\n  return target._gsap.scaleX = target._gsap.scaleY = value;\n},\n    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache.scaleX = cache.scaleY = value;\n  cache.renderTransform(ratio, cache);\n},\n    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache[property] = value;\n  cache.renderTransform(ratio, cache);\n},\n    _transformProp = \"transform\",\n    _transformOriginProp = _transformProp + \"Origin\",\n    _saveStyle = function _saveStyle(property, isNotCSS) {\n  var _this = this;\n\n  var target = this.target,\n      style = target.style,\n      cache = target._gsap;\n\n  if (property in _transformProps && style) {\n    this.tfm = this.tfm || {};\n\n    if (property !== \"transform\") {\n      property = _propertyAliases[property] || property;\n      ~property.indexOf(\",\") ? property.split(\",\").forEach(function (a) {\n        return _this.tfm[a] = _get(target, a);\n      }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to \"scaleX,scaleY\", thus we loop and apply them both.\n\n      property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\n    } else {\n      return _propertyAliases.transform.split(\",\").forEach(function (p) {\n        return _saveStyle.call(_this, p, isNotCSS);\n      });\n    }\n\n    if (this.props.indexOf(_transformProp) >= 0) {\n      return;\n    }\n\n    if (cache.svg) {\n      this.svgo = target.getAttribute(\"data-svg-origin\");\n      this.props.push(_transformOriginProp, isNotCSS, \"\");\n    }\n\n    property = _transformProp;\n  }\n\n  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n},\n    _removeIndependentTransforms = function _removeIndependentTransforms(style) {\n  if (style.translate) {\n    style.removeProperty(\"translate\");\n    style.removeProperty(\"scale\");\n    style.removeProperty(\"rotate\");\n  }\n},\n    _revertStyle = function _revertStyle() {\n  var props = this.props,\n      target = this.target,\n      style = target.style,\n      cache = target._gsap,\n      i,\n      p;\n\n  for (i = 0; i < props.length; i += 3) {\n    // stored like this: property, isNotCSS, value\n    props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n  }\n\n  if (this.tfm) {\n    for (p in this.tfm) {\n      cache[p] = this.tfm[p];\n    }\n\n    if (cache.svg) {\n      cache.renderTransform();\n      target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n    }\n\n    i = _reverting();\n\n    if ((!i || !i.isStart) && !style[_transformProp]) {\n      _removeIndependentTransforms(style);\n\n      if (cache.zOrigin && style[_transformOriginProp]) {\n        style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.\n\n        cache.zOrigin = 0;\n        cache.renderTransform();\n      }\n\n      cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.\n    }\n  }\n},\n    _getStyleSaver = function _getStyleSaver(target, properties) {\n  var saver = {\n    target: target,\n    props: [],\n    revert: _revertStyle,\n    save: _saveStyle\n  };\n  target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.\n\n  properties && properties.split(\",\").forEach(function (p) {\n    return saver.save(p);\n  });\n  return saver;\n},\n    _supports3D,\n    _createElement = function _createElement(type, ns) {\n  var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n\n  return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n},\n    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n  var cs = getComputedStyle(target);\n  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\"; //css variables may not need caps swapped out for dashes and lowercase.\n},\n    _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"),\n    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n  var e = element || _tempDiv,\n      s = e.style,\n      i = 5;\n\n  if (property in s && !preferPrefix) {\n    return property;\n  }\n\n  property = property.charAt(0).toUpperCase() + property.substr(1);\n\n  while (i-- && !(_prefixes[i] + property in s)) {}\n\n  return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n},\n    _initCore = function _initCore() {\n  if (_windowExists() && window.document) {\n    _win = window;\n    _doc = _win.document;\n    _docElement = _doc.documentElement;\n    _tempDiv = _createElement(\"div\") || {\n      style: {}\n    };\n    _tempDivStyler = _createElement(\"div\");\n    _transformProp = _checkPropPrefix(_transformProp);\n    _transformOriginProp = _transformProp + \"Origin\";\n    _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n\n    _supports3D = !!_checkPropPrefix(\"perspective\");\n    _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting;\n    _pluginInitted = 1;\n  }\n},\n    _getBBoxHack = function _getBBoxHack(swapIfPossible) {\n  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).\n  var svg = _createElement(\"svg\", this.ownerSVGElement && this.ownerSVGElement.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"),\n      oldParent = this.parentNode,\n      oldSibling = this.nextSibling,\n      oldCSS = this.style.cssText,\n      bbox;\n\n  _docElement.appendChild(svg);\n\n  svg.appendChild(this);\n  this.style.display = \"block\";\n\n  if (swapIfPossible) {\n    try {\n      bbox = this.getBBox();\n      this._gsapBBox = this.getBBox; //store the original\n\n      this.getBBox = _getBBoxHack;\n    } catch (e) {}\n  } else if (this._gsapBBox) {\n    bbox = this._gsapBBox();\n  }\n\n  if (oldParent) {\n    if (oldSibling) {\n      oldParent.insertBefore(this, oldSibling);\n    } else {\n      oldParent.appendChild(this);\n    }\n  }\n\n  _docElement.removeChild(svg);\n\n  this.style.cssText = oldCSS;\n  return bbox;\n},\n    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n  var i = attributesArray.length;\n\n  while (i--) {\n    if (target.hasAttribute(attributesArray[i])) {\n      return target.getAttribute(attributesArray[i]);\n    }\n  }\n},\n    _getBBox = function _getBBox(target) {\n  var bounds;\n\n  try {\n    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n  } catch (error) {\n    bounds = _getBBoxHack.call(target, true);\n  }\n\n  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.\n\n  return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n    x: +_getAttributeFallbacks(target, [\"x\", \"cx\", \"x1\"]) || 0,\n    y: +_getAttributeFallbacks(target, [\"y\", \"cy\", \"y1\"]) || 0,\n    width: 0,\n    height: 0\n  } : bounds;\n},\n    _isSVG = function _isSVG(e) {\n  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n},\n    //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n  if (property) {\n    var style = target.style,\n        first2Chars;\n\n    if (property in _transformProps && property !== _transformOriginProp) {\n      property = _transformProp;\n    }\n\n    if (style.removeProperty) {\n      first2Chars = property.substr(0, 2);\n\n      if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\n        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be \"ms-transform\" instead of \"-ms-transform\" for IE9, for example)\n        property = \"-\" + property;\n      }\n\n      style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\n    } else {\n      //note: old versions of IE use \"removeAttribute()\" instead of \"removeProperty()\"\n      style.removeAttribute(property);\n    }\n  }\n},\n    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n  plugin._pt = pt;\n  pt.b = beginning;\n  pt.e = end;\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _nonConvertibleUnits = {\n  deg: 1,\n  rad: 1,\n  turn: 1\n},\n    _nonStandardLayouts = {\n  grid: 1,\n  flex: 1\n},\n    //takes a single value like 20px and converts it to the unit specified, like \"%\", returning only the numeric amount.\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\n  var curValue = parseFloat(value) || 0,\n      curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\",\n      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n  style = _tempDiv.style,\n      horizontal = _horizontalExp.test(property),\n      isRootSVG = target.tagName.toLowerCase() === \"svg\",\n      measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"),\n      amount = 100,\n      toPixels = unit === \"px\",\n      toPercent = unit === \"%\",\n      px,\n      parent,\n      cache,\n      isSVG;\n\n  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n    return curValue;\n  }\n\n  curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n  isSVG = target.getCTM && _isSVG(target);\n\n  if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n    px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);\n  }\n\n  style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n  parent = ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n\n  if (isSVG) {\n    parent = (target.ownerSVGElement || {}).parentNode;\n  }\n\n  if (!parent || parent === _doc || !parent.appendChild) {\n    parent = _doc.body;\n  }\n\n  cache = parent._gsap;\n\n  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache) {\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);\n  } else {\n    if (toPercent && (property === \"height\" || property === \"width\")) {\n      // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.\n      var v = target.style[property];\n      target.style[property] = amount + unit;\n      px = target[measureProperty];\n      v ? target.style[property] = v : _removeProperty(target, property);\n    } else {\n      (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n      parent === target && (style.position = \"static\"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.\n\n      parent.appendChild(_tempDiv);\n      px = _tempDiv[measureProperty];\n      parent.removeChild(_tempDiv);\n      style.position = \"absolute\";\n    }\n\n    if (horizontal && toPercent) {\n      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);\n      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;\n      cache.width = parent[measureProperty];\n    }\n  }\n\n  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n},\n    _get = function _get(target, property, unit, uncache) {\n  var value;\n  _pluginInitted || _initCore();\n\n  if (property in _propertyAliases && property !== \"transform\") {\n    property = _propertyAliases[property];\n\n    if (~property.indexOf(\",\")) {\n      property = property.split(\",\")[0];\n    }\n  }\n\n  if (_transformProps[property] && property !== \"transform\") {\n    value = _parseTransform(target, uncache);\n    value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n  } else {\n    value = target.style[property];\n\n    if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === \"opacity\" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n    }\n  }\n\n  return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n},\n    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n  if (!start || start === \"none\") {\n    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style (\"clipPath\" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as \"none\" whereas WebkitClipPath reports accurately like \"ellipse(100% 0% at 50% 0%)\", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n    var p = _checkPropPrefix(prop, target, 1),\n        s = p && _getComputedProperty(target, p, 1);\n\n    if (s && s !== start) {\n      prop = p;\n      start = s;\n    } else if (prop === \"borderColor\") {\n      start = _getComputedProperty(target, \"borderTopColor\"); // Firefox bug: always reports \"borderColor\" as \"\", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n    }\n  }\n\n  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),\n      index = 0,\n      matchIndex = 0,\n      a,\n      result,\n      startValues,\n      startNum,\n      color,\n      startValue,\n      endValue,\n      endNum,\n      chunk,\n      endUnit,\n      startUnit,\n      endValues;\n  pt.b = start;\n  pt.e = end;\n  start += \"\"; // ensure values are strings\n\n  end += \"\";\n\n  if (end === \"auto\") {\n    startValue = target.style[prop];\n    target.style[prop] = end;\n    end = _getComputedProperty(target, prop) || end;\n    startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\n  }\n\n  a = [start, end];\n\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n\n\n  start = a[0];\n  end = a[1];\n  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n\n  if (endValues.length) {\n    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {\n      endValue = result[0];\n      chunk = end.substring(index, result.index);\n\n      if (color) {\n        color = (color + 1) % 5;\n      } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n        color = 1;\n      }\n\n      if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n        startNum = parseFloat(startValue) || 0;\n        startUnit = startValue.substr((startNum + \"\").length);\n        endValue.charAt(1) === \"=\" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);\n        endNum = parseFloat(endValue);\n        endUnit = endValue.substr((endNum + \"\").length);\n        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;\n\n        if (!endUnit) {\n          //if something like \"perspective:300\" is passed in and we must add a unit to the end\n          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;\n\n          if (index === end.length) {\n            end += endUnit;\n            pt.e += endUnit;\n          }\n        }\n\n        if (startUnit !== endUnit) {\n          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n\n\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : \",\",\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n          s: startNum,\n          c: endNum - startNum,\n          m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n        };\n      }\n    }\n\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n  } else {\n    pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n  }\n\n  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus \"this\" would refer to the plugin.\n\n  return pt;\n},\n    _keywordToPercent = {\n  top: \"0%\",\n  bottom: \"100%\",\n  left: \"0%\",\n  right: \"100%\",\n  center: \"50%\"\n},\n    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n  var split = value.split(\" \"),\n      x = split[0],\n      y = split[1] || \"50%\";\n\n  if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n    //the user provided them in the wrong order, so flip them\n    value = x;\n    x = y;\n    y = value;\n  }\n\n  split[0] = _keywordToPercent[x] || x;\n  split[1] = _keywordToPercent[y] || y;\n  return split.join(\" \");\n},\n    _renderClearProps = function _renderClearProps(ratio, data) {\n  if (data.tween && data.tween._time === data.tween._dur) {\n    var target = data.t,\n        style = target.style,\n        props = data.u,\n        cache = target._gsap,\n        prop,\n        clearTransforms,\n        i;\n\n    if (props === \"all\" || props === true) {\n      style.cssText = \"\";\n      clearTransforms = 1;\n    } else {\n      props = props.split(\",\");\n      i = props.length;\n\n      while (--i > -1) {\n        prop = props[i];\n\n        if (_transformProps[prop]) {\n          clearTransforms = 1;\n          prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n        }\n\n        _removeProperty(target, prop);\n      }\n    }\n\n    if (clearTransforms) {\n      _removeProperty(target, _transformProp);\n\n      if (cache) {\n        cache.svg && target.removeAttribute(\"transform\");\n\n        _parseTransform(target, 1); // force all the cached values back to \"normal\"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.\n\n\n        cache.uncache = 1;\n\n        _removeIndependentTransforms(style);\n      }\n    }\n  }\n},\n    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n  clearProps: function clearProps(plugin, target, property, endValue, tween) {\n    if (tween.data !== \"isFromStart\") {\n      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n      pt.u = endValue;\n      pt.pr = -10;\n      pt.tween = tween;\n\n      plugin._props.push(property);\n\n      return 1;\n    }\n  }\n  /* className feature (about 0.4kb gzipped).\n  , className(plugin, target, property, endValue, tween) {\n  \tlet _renderClassName = (ratio, data) => {\n  \t\t\tdata.css.render(ratio, data.css);\n  \t\t\tif (!ratio || ratio === 1) {\n  \t\t\t\tlet inline = data.rmv,\n  \t\t\t\t\ttarget = data.t,\n  \t\t\t\t\tp;\n  \t\t\t\ttarget.setAttribute(\"class\", ratio ? data.e : data.b);\n  \t\t\t\tfor (p in inline) {\n  \t\t\t\t\t_removeProperty(target, p);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t},\n  \t\t_getAllStyles = (target) => {\n  \t\t\tlet styles = {},\n  \t\t\t\tcomputed = getComputedStyle(target),\n  \t\t\t\tp;\n  \t\t\tfor (p in computed) {\n  \t\t\t\tif (isNaN(p) && p !== \"cssText\" && p !== \"length\") {\n  \t\t\t\t\tstyles[p] = computed[p];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t_setDefaults(styles, _parseTransform(target, 1));\n  \t\t\treturn styles;\n  \t\t},\n  \t\tstartClassList = target.getAttribute(\"class\"),\n  \t\tstyle = target.style,\n  \t\tcssText = style.cssText,\n  \t\tcache = target._gsap,\n  \t\tclassPT = cache.classPT,\n  \t\tinlineToRemoveAtEnd = {},\n  \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== \"=\") ? endValue : startClassList.replace(new RegExp(\"(?:\\\\s|^)\" + endValue.substr(2) + \"(?![\\\\w-])\"), \"\") + ((endValue.charAt(0) === \"+\") ? \" \" + endValue.substr(2) : \"\")},\n  \t\tchangingVars = {},\n  \t\tstartVars = _getAllStyles(target),\n  \t\ttransformRelated = /(transform|perspective)/i,\n  \t\tendVars, p;\n  \tif (classPT) {\n  \t\tclassPT.r(1, classPT.d);\n  \t\t_removeLinkedListItem(classPT.d.plugin, classPT, \"_pt\");\n  \t}\n  \ttarget.setAttribute(\"class\", data.e);\n  \tendVars = _getAllStyles(target, true);\n  \ttarget.setAttribute(\"class\", startClassList);\n  \tfor (p in endVars) {\n  \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\n  \t\t\tchangingVars[p] = endVars[p];\n  \t\t\tif (!style[p] && style[p] !== \"0\") {\n  \t\t\t\tinlineToRemoveAtEnd[p] = 1;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, \"className\", 0, 0, _renderClassName, data, 0, -11);\n  \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\n  \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).\n  \t}\n  \t_parseTransform(target, true); //to clear the caching of transforms\n  \tdata.css = new gsap.plugins.css();\n  \tdata.css.init(target, changingVars, tween);\n  \tplugin._props.push(...data.css._props);\n  \treturn 1;\n  }\n  */\n\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */\n_identity2DMatrix = [1, 0, 0, 1, 0, 0],\n    _rotationalProperties = {},\n    _isNullTransform = function _isNullTransform(value) {\n  return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n},\n    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n  var matrixString = _getComputedProperty(target, _transformProp);\n\n  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);\n},\n    _getMatrix = function _getMatrix(target, force2D) {\n  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),\n      style = target.style,\n      matrix = _getComputedTransformMatrixAsArray(target),\n      parent,\n      nextSibling,\n      temp,\n      addedToDOM;\n\n  if (cache.svg && target.getAttribute(\"transform\")) {\n    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like \"translate(50,60) rotate(135,0,0)\" are parsed because it mashes it into a matrix.\n\n    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n    return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not \"none\". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).\n    temp = style.display;\n    style.display = \"block\";\n    parent = target.parentNode;\n\n    if (!parent || !target.offsetParent) {\n      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375\n      addedToDOM = 1; //flag\n\n      nextSibling = target.nextElementSibling;\n\n      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n\n    }\n\n    matrix = _getComputedTransformMatrixAsArray(target);\n    temp ? style.display = temp : _removeProperty(target, \"display\");\n\n    if (addedToDOM) {\n      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n    }\n  }\n\n  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n},\n    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n  var cache = target._gsap,\n      matrix = matrixArray || _getMatrix(target, true),\n      xOriginOld = cache.xOrigin || 0,\n      yOriginOld = cache.yOrigin || 0,\n      xOffsetOld = cache.xOffset || 0,\n      yOffsetOld = cache.yOffset || 0,\n      a = matrix[0],\n      b = matrix[1],\n      c = matrix[2],\n      d = matrix[3],\n      tx = matrix[4],\n      ty = matrix[5],\n      originSplit = origin.split(\" \"),\n      xOrigin = parseFloat(originSplit[0]) || 0,\n      yOrigin = parseFloat(originSplit[1]) || 0,\n      bounds,\n      determinant,\n      x,\n      y;\n\n  if (!originIsAbsolute) {\n    bounds = _getBBox(target);\n    xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin); // if (!(\"xOrigin\" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration\n    // \txOrigin -= bounds.x;\n    // \tyOrigin -= bounds.y;\n    // }\n  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n    xOrigin = x;\n    yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.\n  }\n\n  if (smooth || smooth !== false && cache.smooth) {\n    tx = xOrigin - xOriginOld;\n    ty = yOrigin - yOriginOld;\n    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n  } else {\n    cache.xOffset = cache.yOffset = 0;\n  }\n\n  cache.xOrigin = xOrigin;\n  cache.yOrigin = yOrigin;\n  cache.smooth = !!smooth;\n  cache.origin = origin;\n  cache.originIsAbsolute = !!originIsAbsolute;\n  target.style[_transformOriginProp] = \"0px 0px\"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).\n\n  if (pluginToAddPropTweensTo) {\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n  }\n\n  target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n},\n    _parseTransform = function _parseTransform(target, uncache) {\n  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);\n\n  if (\"x\" in cache && !uncache && !cache.uncache) {\n    return cache;\n  }\n\n  var style = target.style,\n      invertedScaleX = cache.scaleX < 0,\n      px = \"px\",\n      deg = \"deg\",\n      cs = getComputedStyle(target),\n      origin = _getComputedProperty(target, _transformOriginProp) || \"0\",\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      rotation,\n      rotationX,\n      rotationY,\n      skewX,\n      skewY,\n      perspective,\n      xOrigin,\n      yOrigin,\n      matrix,\n      angle,\n      cos,\n      sin,\n      a,\n      b,\n      c,\n      d,\n      a12,\n      a22,\n      t1,\n      t2,\n      t3,\n      a13,\n      a23,\n      a33,\n      a42,\n      a43,\n      a32;\n  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n  scaleX = scaleY = 1;\n  cache.svg = !!(target.getCTM && _isSVG(target));\n\n  if (cs.translate) {\n    // accommodate independent transforms by combining them into normal ones.\n    if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n      style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n    }\n\n    style.scale = style.rotate = style.translate = \"none\";\n  }\n\n  matrix = _getMatrix(target, cache.svg);\n\n  if (cache.svg) {\n    if (cache.uncache) {\n      // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + \"px \" + (cache.yOrigin - bbox.y) + \"px\". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.\n      t2 = target.getBBox();\n      origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n      t1 = \"\";\n    } else {\n      t1 = !uncache && target.getAttribute(\"data-svg-origin\"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.\n    }\n\n    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n  }\n\n  xOrigin = cache.xOrigin || 0;\n  yOrigin = cache.yOrigin || 0;\n\n  if (matrix !== _identity2DMatrix) {\n    a = matrix[0]; //a11\n\n    b = matrix[1]; //a21\n\n    c = matrix[2]; //a31\n\n    d = matrix[3]; //a41\n\n    x = a12 = matrix[4];\n    y = a22 = matrix[5]; //2D matrix\n\n    if (matrix.length === 6) {\n      scaleX = Math.sqrt(a * a + b * b);\n      scaleY = Math.sqrt(d * d + c * c);\n      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).\n\n      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n\n      if (cache.svg) {\n        x -= xOrigin - (xOrigin * a + yOrigin * c);\n        y -= yOrigin - (xOrigin * b + yOrigin * d);\n      } //3D matrix\n\n    } else {\n      a32 = matrix[6];\n      a42 = matrix[7];\n      a13 = matrix[8];\n      a23 = matrix[9];\n      a33 = matrix[10];\n      a43 = matrix[11];\n      x = matrix[12];\n      y = matrix[13];\n      z = matrix[14];\n      angle = _atan2(a32, a33);\n      rotationX = angle * _RAD2DEG; //rotationX\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a12 * cos + a13 * sin;\n        t2 = a22 * cos + a23 * sin;\n        t3 = a32 * cos + a33 * sin;\n        a13 = a12 * -sin + a13 * cos;\n        a23 = a22 * -sin + a23 * cos;\n        a33 = a32 * -sin + a33 * cos;\n        a43 = a42 * -sin + a43 * cos;\n        a12 = t1;\n        a22 = t2;\n        a32 = t3;\n      } //rotationY\n\n\n      angle = _atan2(-c, a33);\n      rotationY = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a * cos - a13 * sin;\n        t2 = b * cos - a23 * sin;\n        t3 = c * cos - a33 * sin;\n        a43 = d * sin + a43 * cos;\n        a = t1;\n        b = t2;\n        c = t3;\n      } //rotationZ\n\n\n      angle = _atan2(b, a);\n      rotation = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        t1 = a * cos + b * sin;\n        t2 = a12 * cos + a22 * sin;\n        b = b * cos - a * sin;\n        a22 = a22 * cos - a12 * sin;\n        a = t1;\n        a12 = t2;\n      }\n\n      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n        rotationX = rotation = 0;\n        rotationY = 180 - rotationY;\n      }\n\n      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));\n      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));\n      angle = _atan2(a12, a22);\n      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n    }\n\n    if (cache.svg) {\n      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n      t1 = target.getAttribute(\"transform\");\n      cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n      t1 && target.setAttribute(\"transform\", t1);\n    }\n  }\n\n  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n    if (invertedScaleX) {\n      scaleX *= -1;\n      skewX += rotation <= 0 ? 180 : -180;\n      rotation += rotation <= 0 ? 180 : -180;\n    } else {\n      scaleY *= -1;\n      skewX += skewX <= 0 ? 180 : -180;\n    }\n  }\n\n  uncache = uncache || cache.uncache;\n  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n  cache.z = z + px;\n  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);\n  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);\n  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;\n  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;\n  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;\n  cache.skewX = skewX + deg;\n  cache.skewY = skewY + deg;\n  cache.transformPerspective = perspective + px;\n\n  if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\n    style[_transformOriginProp] = _firstTwoOnly(origin);\n  }\n\n  cache.xOffset = cache.yOffset = 0;\n  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;\n  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n  cache.uncache = 0;\n  return cache;\n},\n    _firstTwoOnly = function _firstTwoOnly(value) {\n  return (value = value.split(\" \"))[0] + \" \" + value[1];\n},\n    //for handling transformOrigin values, stripping out the 3rd dimension\n_addPxTranslate = function _addPxTranslate(target, start, value) {\n  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);\n  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n},\n    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n  cache.z = \"0px\";\n  cache.rotationY = cache.rotationX = \"0deg\";\n  cache.force3D = 0;\n\n  _renderCSSTransforms(ratio, cache);\n},\n    _zeroDeg = \"0deg\",\n    _zeroPx = \"0px\",\n    _endParenthesis = \") \",\n    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n  var _ref = cache || this,\n      xPercent = _ref.xPercent,\n      yPercent = _ref.yPercent,\n      x = _ref.x,\n      y = _ref.y,\n      z = _ref.z,\n      rotation = _ref.rotation,\n      rotationY = _ref.rotationY,\n      rotationX = _ref.rotationX,\n      skewX = _ref.skewX,\n      skewY = _ref.skewY,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      transformPerspective = _ref.transformPerspective,\n      force3D = _ref.force3D,\n      target = _ref.target,\n      zOrigin = _ref.zOrigin,\n      transforms = \"\",\n      use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n\n\n  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n    var angle = parseFloat(rotationY) * _DEG2RAD,\n        a13 = Math.sin(angle),\n        a33 = Math.cos(angle),\n        cos;\n\n    angle = parseFloat(rotationX) * _DEG2RAD;\n    cos = Math.cos(angle);\n    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n  }\n\n  if (transformPerspective !== _zeroPx) {\n    transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n  }\n\n  if (xPercent || yPercent) {\n    transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n  }\n\n  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n    transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n  }\n\n  if (rotation !== _zeroDeg) {\n    transforms += \"rotate(\" + rotation + _endParenthesis;\n  }\n\n  if (rotationY !== _zeroDeg) {\n    transforms += \"rotateY(\" + rotationY + _endParenthesis;\n  }\n\n  if (rotationX !== _zeroDeg) {\n    transforms += \"rotateX(\" + rotationX + _endParenthesis;\n  }\n\n  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n    transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n  }\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n  }\n\n  target.style[_transformProp] = transforms || \"translate(0, 0)\";\n},\n    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n  var _ref2 = cache || this,\n      xPercent = _ref2.xPercent,\n      yPercent = _ref2.yPercent,\n      x = _ref2.x,\n      y = _ref2.y,\n      rotation = _ref2.rotation,\n      skewX = _ref2.skewX,\n      skewY = _ref2.skewY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      target = _ref2.target,\n      xOrigin = _ref2.xOrigin,\n      yOrigin = _ref2.yOrigin,\n      xOffset = _ref2.xOffset,\n      yOffset = _ref2.yOffset,\n      forceCSS = _ref2.forceCSS,\n      tx = parseFloat(x),\n      ty = parseFloat(y),\n      a11,\n      a21,\n      a12,\n      a22,\n      temp;\n\n  rotation = parseFloat(rotation);\n  skewX = parseFloat(skewX);\n  skewY = parseFloat(skewY);\n\n  if (skewY) {\n    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n    skewY = parseFloat(skewY);\n    skewX += skewY;\n    rotation += skewY;\n  }\n\n  if (rotation || skewX) {\n    rotation *= _DEG2RAD;\n    skewX *= _DEG2RAD;\n    a11 = Math.cos(rotation) * scaleX;\n    a21 = Math.sin(rotation) * scaleX;\n    a12 = Math.sin(rotation - skewX) * -scaleY;\n    a22 = Math.cos(rotation - skewX) * scaleY;\n\n    if (skewX) {\n      skewY *= _DEG2RAD;\n      temp = Math.tan(skewX - skewY);\n      temp = Math.sqrt(1 + temp * temp);\n      a12 *= temp;\n      a22 *= temp;\n\n      if (skewY) {\n        temp = Math.tan(skewY);\n        temp = Math.sqrt(1 + temp * temp);\n        a11 *= temp;\n        a21 *= temp;\n      }\n    }\n\n    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);\n    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);\n    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);\n    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);\n  } else {\n    a11 = scaleX;\n    a22 = scaleY;\n    a21 = a12 = 0;\n  }\n\n  if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n    tx = _convertToUnit(target, \"x\", x, \"px\");\n    ty = _convertToUnit(target, \"y\", y, \"px\");\n  }\n\n  if (xOrigin || yOrigin || xOffset || yOffset) {\n    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n  }\n\n  if (xPercent || yPercent) {\n    //The SVG spec doesn't support percentage-based translation in the \"transform\" attribute, so we merge it into the translation to simulate it.\n    temp = target.getBBox();\n    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);\n    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);\n  }\n\n  temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n  target.setAttribute(\"transform\", temp);\n  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)\n},\n    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n  var cap = 360,\n      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),\n      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1),\n      change = endNum - startNum,\n      finalValue = startNum + change + \"deg\",\n      direction,\n      pt;\n\n  if (isString) {\n    direction = endValue.split(\"_\")[1];\n\n    if (direction === \"short\") {\n      change %= cap;\n\n      if (change !== change % (cap / 2)) {\n        change += change < 0 ? cap : -cap;\n      }\n    }\n\n    if (direction === \"cw\" && change < 0) {\n      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n    } else if (direction === \"ccw\" && change > 0) {\n      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n    }\n  }\n\n  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n  pt.e = finalValue;\n  pt.u = \"deg\";\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _assign = function _assign(target, source) {\n  // Internet Explorer doesn't have Object.assign(), so we recreate it here.\n  for (var p in source) {\n    target[p] = source[p];\n  }\n\n  return target;\n},\n    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n  //for handling cases where someone passes in a whole transform string, like transform: \"scale(2, 3) rotate(20deg) translateY(30em)\"\n  var startCache = _assign({}, target._gsap),\n      exclude = \"perspective,force3D,transformOrigin,svgOrigin\",\n      style = target.style,\n      endCache,\n      p,\n      startValue,\n      endValue,\n      startNum,\n      endNum,\n      startUnit,\n      endUnit;\n\n  if (startCache.svg) {\n    startValue = target.getAttribute(\"transform\");\n    target.setAttribute(\"transform\", \"\");\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n\n    _removeProperty(target, _transformProp);\n\n    target.setAttribute(\"transform\", startValue);\n  } else {\n    startValue = getComputedStyle(target)[_transformProp];\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n    style[_transformProp] = startValue;\n  }\n\n  for (p in _transformProps) {\n    startValue = startCache[p];\n    endValue = endCache[p];\n\n    if (startValue !== endValue && exclude.indexOf(p) < 0) {\n      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n      endNum = parseFloat(endValue);\n      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n      plugin._pt.u = endUnit || 0;\n\n      plugin._props.push(p);\n    }\n  }\n\n  _assign(endCache, startCache);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n\n\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"padding,margin,Width,Radius\", function (name, index) {\n  var t = \"Top\",\n      r = \"Right\",\n      b = \"Bottom\",\n      l = \"Left\",\n      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {\n    return index < 2 ? name + side : \"border\" + side + name;\n  });\n\n  _specialProps[index > 1 ? \"border\" + name : name] = function (plugin, target, property, endValue, tween) {\n    var a, vars;\n\n    if (arguments.length < 4) {\n      // getter, passed target, property, and unit (from _get())\n      a = props.map(function (prop) {\n        return _get(plugin, prop, property);\n      });\n      vars = a.join(\" \");\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\n    }\n\n    a = (endValue + \"\").split(\" \");\n    vars = {};\n    props.forEach(function (prop, i) {\n      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n    });\n    plugin.init(target, vars, tween);\n  };\n});\n\nvar CSSPlugin = {\n  name: \"css\",\n  register: _initCore,\n  targetTest: function targetTest(target) {\n    return target.style && target.nodeType;\n  },\n  init: function init(target, vars, tween, index, targets) {\n    var props = this._props,\n        style = target.style,\n        startAt = tween.vars.startAt,\n        startValue,\n        endValue,\n        endNum,\n        startNum,\n        type,\n        specialProp,\n        p,\n        startUnit,\n        endUnit,\n        relative,\n        isTransformRelated,\n        transformPropTween,\n        cache,\n        smooth,\n        hasPriority,\n        inlineProps;\n    _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps\n\n    this.styles = this.styles || _getStyleSaver(target);\n    inlineProps = this.styles.props;\n    this.tween = tween;\n\n    for (p in vars) {\n      if (p === \"autoRound\") {\n        continue;\n      }\n\n      endValue = vars[p];\n\n      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {\n        // plugins\n        continue;\n      }\n\n      type = typeof endValue;\n      specialProp = _specialProps[p];\n\n      if (type === \"function\") {\n        endValue = endValue.call(tween, index, target, targets);\n        type = typeof endValue;\n      }\n\n      if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);\n      }\n\n      if (specialProp) {\n        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n      } else if (p.substr(0, 2) === \"--\") {\n        //CSS variable\n        startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n        endValue += \"\";\n        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;\n\n        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {\n          // colors don't have units\n          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n        }\n\n        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n        this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n        props.push(p);\n        inlineProps.push(p, 0, style[p]);\n      } else if (type !== \"undefined\") {\n        if (startAt && p in startAt) {\n          // in case someone hard-codes a complex value as the start, like top: \"calc(2vh / 2)\". Without this, it'd use the computed value (always in px)\n          startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf(\"random(\") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));\n          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + \"\") || startValue === \"auto\" || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || \"\"); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.\n\n          (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p)); // can't work with relative values\n        } else {\n          startValue = _get(target, p);\n        }\n\n        startNum = parseFloat(startValue);\n        relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n        relative && (endValue = endValue.substr(2));\n        endNum = parseFloat(endValue);\n\n        if (p in _propertyAliases) {\n          if (p === \"autoAlpha\") {\n            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n            if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n              //if visibility is initially set to \"hidden\", we should interpret that as intent to make opacity 0 (a convenience)\n              startNum = 0;\n            }\n\n            inlineProps.push(\"visibility\", 0, style.visibility);\n\n            _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n          }\n\n          if (p !== \"scale\" && p !== \"transform\") {\n            p = _propertyAliases[p];\n            ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n          }\n        }\n\n        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n\n        if (isTransformRelated) {\n          this.styles.save(p);\n\n          if (!transformPropTween) {\n            cache = target._gsap;\n            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:\"translateX(50vw)\"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.\n\n            smooth = vars.smoothOrigin !== false && cache.smooth;\n            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n\n            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n          }\n\n          if (p === \"scale\") {\n            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n            this._pt.u = 0;\n            props.push(\"scaleY\", p);\n            p += \"X\";\n          } else if (p === \"transformOrigin\") {\n            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n            endValue = _convertKeywordsToPercentages(endValue); //in case something like \"left top\" or \"bottom right\" is passed in. Convert to percentages.\n\n            if (cache.svg) {\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n            } else {\n              endUnit = parseFloat(endValue.split(\" \")[2]) || 0; //handle the zOrigin separately!\n\n              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n\n              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n            }\n\n            continue;\n          } else if (p === \"svgOrigin\") {\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n\n            continue;\n          } else if (p in _rotationalProperties) {\n            _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);\n\n            continue;\n          } else if (p === \"smoothOrigin\") {\n            _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n\n            continue;\n          } else if (p === \"force3D\") {\n            cache[p] = endValue;\n            continue;\n          } else if (p === \"transform\") {\n            _addRawTransformPTs(this, endValue, target);\n\n            continue;\n          }\n        } else if (!(p in style)) {\n          p = _checkPropPrefix(p) || p;\n        }\n\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n          startUnit = (startValue + \"\").substr((startNum + \"\").length);\n          endNum || (endNum = 0); // protect against NaN\n\n          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);\n          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n          this._pt.u = endUnit || 0;\n\n          if (startUnit !== endUnit && endUnit !== \"%\") {\n            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a \"b\" (beginning) property and point to a render method that handles that. (performance optimization)\n            this._pt.b = startValue;\n            this._pt.r = _renderCSSPropWithBeginning;\n          }\n        } else if (!(p in style)) {\n          if (p in target) {\n            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.\n            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n          } else if (p !== \"parseTransform\") {\n            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);\n\n            continue;\n          }\n        } else {\n          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n        }\n\n        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));\n        props.push(p);\n      }\n    }\n\n    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);\n  },\n  render: function render(ratio, data) {\n    if (data.tween._time || !_reverting()) {\n      var pt = data._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n    } else {\n      data.styles.revert();\n    }\n  },\n  get: _get,\n  aliases: _propertyAliases,\n  getSetter: function getSetter(target, property, plugin) {\n    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like \"x\" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.\n    var p = _propertyAliases[property];\n    p && p.indexOf(\",\") < 0 && (property = p);\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);\n  },\n  core: {\n    _removeProperty: _removeProperty,\n    _getMatrix: _getMatrix\n  }\n};\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver;\n\n(function (positionAndScale, rotation, others, aliases) {\n  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + \",\" + rotation + \",\" + others, function (name) {\n    _transformProps[name] = 1;\n  });\n\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"deg\";\n    _rotationalProperties[name] = 1;\n  });\n\n  _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {\n    var split = name.split(\":\");\n    _propertyAliases[split[1]] = all[split[0]];\n  });\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function (name) {\n  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"px\";\n});\n\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFLDJEQUFZO0FBQ2QsSUFBSSxrREFBTztBQUNYO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQSxFQUFFLDJEQUFZO0FBQ2Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVELDJEQUFZO0FBQ1osRUFBRSxrREFBTztBQUNULENBQUM7O0FBRUQsK0NBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanM/OWNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENTU1BsdWdpbiAzLjEyLjVcbiAqIGh0dHBzOi8vZ3NhcC5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdTQVAgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBnc2FwLCBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgZ2V0VW5pdCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX2NoZWNrUGx1Z2luLCBfcmVwbGFjZVJhbmRvbSwgX3BsdWdpbnMsIEdTQ2FjaGUsIFByb3BUd2VlbiwgX2NvbmZpZywgX3RpY2tlciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfY29sb3JFeHAsIF9wYXJzZVJlbGF0aXZlLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSAvL2ZvciB0aGUgY29tbWVudGVkLW91dCBjbGFzc05hbWUgZmVhdHVyZS5cbn0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5cbnZhciBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX3BsdWdpbkluaXR0ZWQsXG4gICAgX3RlbXBEaXYsXG4gICAgX3RlbXBEaXZTdHlsZXIsXG4gICAgX3JlY2VudFNldHRlclBsdWdpbixcbiAgICBfcmV2ZXJ0aW5nLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3BzID0ge30sXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgIF9iaWdOdW0gPSAxZTgsXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgIF9ob3Jpem9udGFsRXhwID0gLyhsZWZ0fHJpZ2h0fHdpZHRofG1hcmdpbnxwYWRkaW5nfHgpL2ksXG4gICAgX2NvbXBsZXhFeHAgPSAvW1xccyxcXChdXFxTLyxcbiAgICBfcHJvcGVydHlBbGlhc2VzID0ge1xuICBhdXRvQWxwaGE6IFwib3BhY2l0eSx2aXNpYmlsaXR5XCIsXG4gIHNjYWxlOiBcInNjYWxlWCxzY2FsZVlcIixcbiAgYWxwaGE6IFwib3BhY2l0eVwiXG59LFxuICAgIF9yZW5kZXJDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wV2l0aEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJQcm9wV2l0aEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51IDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgLy9pZiB1bml0cyBjaGFuZ2UsIHdlIG5lZWQgYSB3YXkgdG8gcmVuZGVyIHRoZSBvcmlnaW5hbCB1bml0L3ZhbHVlIHdoZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nIChyYXRpbzowKVxuX3JlbmRlclJvdW5kZWRDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlclJvdW5kZWRDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEucyArIGRhdGEuYyAqIHJhdGlvO1xuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgfn4odmFsdWUgKyAodmFsdWUgPCAwID8gLS41IDogLjUpKSArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyAhPT0gMSA/IGRhdGEuYiA6IGRhdGEuZSwgZGF0YSk7XG59LFxuICAgIF9zZXR0ZXJDU1NTdHlsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NTdHlsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NQcm9wKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlID0gZnVuY3Rpb24gX3NldHRlclNjYWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAuc2NhbGVYID0gdGFyZ2V0Ll9nc2FwLnNjYWxlWSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclNjYWxlV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGVbcHJvcGVydHldID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG4gICAgX3NhdmVTdHlsZSA9IGZ1bmN0aW9uIF9zYXZlU3R5bGUocHJvcGVydHksIGlzTm90Q1NTKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0LFxuICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcblxuICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHN0eWxlKSB7XG4gICAgdGhpcy50Zm0gPSB0aGlzLnRmbSB8fCB7fTtcblxuICAgIGlmIChwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eTtcbiAgICAgIH5wcm9wZXJ0eS5pbmRleE9mKFwiLFwiKSA/IHByb3BlcnR5LnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy50Zm1bYV0gPSBfZ2V0KHRhcmdldCwgYSk7XG4gICAgICB9KSA6IHRoaXMudGZtW3Byb3BlcnR5XSA9IGNhY2hlLnggPyBjYWNoZVtwcm9wZXJ0eV0gOiBfZ2V0KHRhcmdldCwgcHJvcGVydHkpOyAvLyBub3RlOiBzY2FsZSB3b3VsZCBtYXAgdG8gXCJzY2FsZVgsc2NhbGVZXCIsIHRodXMgd2UgbG9vcCBhbmQgYXBwbHkgdGhlbSBib3RoLlxuXG4gICAgICBwcm9wZXJ0eSA9PT0gX3RyYW5zZm9ybU9yaWdpblByb3AgJiYgKHRoaXMudGZtLnpPcmlnaW4gPSBjYWNoZS56T3JpZ2luKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9wcm9wZXJ0eUFsaWFzZXMudHJhbnNmb3JtLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBfc2F2ZVN0eWxlLmNhbGwoX3RoaXMsIHAsIGlzTm90Q1NTKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLmluZGV4T2YoX3RyYW5zZm9ybVByb3ApID49IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICB0aGlzLnN2Z28gPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpO1xuICAgICAgdGhpcy5wcm9wcy5wdXNoKF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCBpc05vdENTUywgXCJcIik7XG4gICAgfVxuXG4gICAgcHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcbiAgfVxuXG4gIChzdHlsZSB8fCBpc05vdENTUykgJiYgdGhpcy5wcm9wcy5wdXNoKHByb3BlcnR5LCBpc05vdENTUywgc3R5bGVbcHJvcGVydHldKTtcbn0sXG4gICAgX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMoc3R5bGUpIHtcbiAgaWYgKHN0eWxlLnRyYW5zbGF0ZSkge1xuICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KFwidHJhbnNsYXRlXCIpO1xuICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KFwic2NhbGVcIik7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJyb3RhdGVcIik7XG4gIH1cbn0sXG4gICAgX3JldmVydFN0eWxlID0gZnVuY3Rpb24gX3JldmVydFN0eWxlKCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgaSxcbiAgICAgIHA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgLy8gc3RvcmVkIGxpa2UgdGhpczogcHJvcGVydHksIGlzTm90Q1NTLCB2YWx1ZVxuICAgIHByb3BzW2kgKyAxXSA/IHRhcmdldFtwcm9wc1tpXV0gPSBwcm9wc1tpICsgMl0gOiBwcm9wc1tpICsgMl0gPyBzdHlsZVtwcm9wc1tpXV0gPSBwcm9wc1tpICsgMl0gOiBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wc1tpXS5zdWJzdHIoMCwgMikgPT09IFwiLS1cIiA/IHByb3BzW2ldIDogcHJvcHNbaV0ucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBpZiAodGhpcy50Zm0pIHtcbiAgICBmb3IgKHAgaW4gdGhpcy50Zm0pIHtcbiAgICAgIGNhY2hlW3BdID0gdGhpcy50Zm1bcF07XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHRoaXMuc3ZnbyB8fCBcIlwiKTtcbiAgICB9XG5cbiAgICBpID0gX3JldmVydGluZygpO1xuXG4gICAgaWYgKCghaSB8fCAhaS5pc1N0YXJ0KSAmJiAhc3R5bGVbX3RyYW5zZm9ybVByb3BdKSB7XG4gICAgICBfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zKHN0eWxlKTtcblxuICAgICAgaWYgKGNhY2hlLnpPcmlnaW4gJiYgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdKSB7XG4gICAgICAgIHN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSArPSBcIiBcIiArIGNhY2hlLnpPcmlnaW4gKyBcInB4XCI7IC8vIHNpbmNlIHdlJ3JlIHVuY2FjaGluZywgd2UgbXVzdCBwdXQgdGhlIHpPcmlnaW4gYmFjayBpbnRvIHRoZSB0cmFuc2Zvcm1PcmlnaW4gc28gdGhhdCB3ZSBjYW4gcHVsbCBpdCBvdXQgYWNjdXJhdGVseSB3aGVuIHdlIHBhcnNlIGFnYWluLiBPdGhlcndpc2UsIHdlJ2QgbG9zZSB0aGUgeiBwb3J0aW9uIG9mIHRoZSBvcmlnaW4gc2luY2Ugd2UgZXh0cmFjdCBpdCB0byBwcm90ZWN0IGZyb20gU2FmYXJpIGJ1Z3MuXG5cbiAgICAgICAgY2FjaGUuek9yaWdpbiA9IDA7XG4gICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgfVxuXG4gICAgICBjYWNoZS51bmNhY2hlID0gMTsgLy8gaWYgaXQncyBhIHN0YXJ0QXQgdGhhdCdzIGJlaW5nIHJldmVydGVkIGluIHRoZSBfaW5pdFR3ZWVuKCkgb2YgdGhlIGNvcmUsIHdlIGRvbid0IG5lZWQgdG8gdW5jYWNoZSB0cmFuc2Zvcm1zLiBUaGlzIGlzIHB1cmVseSBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldFN0eWxlU2F2ZXIgPSBmdW5jdGlvbiBfZ2V0U3R5bGVTYXZlcih0YXJnZXQsIHByb3BlcnRpZXMpIHtcbiAgdmFyIHNhdmVyID0ge1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHByb3BzOiBbXSxcbiAgICByZXZlcnQ6IF9yZXZlcnRTdHlsZSxcbiAgICBzYXZlOiBfc2F2ZVN0eWxlXG4gIH07XG4gIHRhcmdldC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KTsgLy8ganVzdCBtYWtlIHN1cmUgdGhlcmUncyBhIF9nc2FwIGNhY2hlIGRlZmluZWQgYmVjYXVzZSB3ZSByZWFkIGZyb20gaXQgaW4gX3NhdmVTdHlsZSgpIGFuZCBpdCdzIG1vcmUgZWZmaWNpZW50IHRvIGp1c3QgY2hlY2sgaXQgaGVyZSBvbmNlLlxuXG4gIHByb3BlcnRpZXMgJiYgcHJvcGVydGllcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBzYXZlci5zYXZlKHApO1xuICB9KTtcbiAgcmV0dXJuIHNhdmVyO1xufSxcbiAgICBfc3VwcG9ydHMzRCxcbiAgICBfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KHR5cGUsIG5zKSB7XG4gIHZhciBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUygobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBzZXJ2ZXJzIHN3YXAgaW4gaHR0cHMgZm9yIGh0dHAgaW4gdGhlIG5hbWVzcGFjZSB3aGljaCBjYW4gYnJlYWsgdGhpbmdzLCBtYWtpbmcgXCJzdHlsZVwiIGluYWNjZXNzaWJsZS5cblxuICByZXR1cm4gZSAmJiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjAyMTUtcHJvYmxlbS11c2luZy10d2Vlbm1heC1pbi1zdGFuZGFsb25lLXNlbGYtY29udGFpbmluZy1zdmctZmlsZS1lcnItY2Fubm90LXNldC1wcm9wZXJ0eS1jc3N0ZXh0LW9mLXVuZGVmaW5lZC8pLlxufSxcbiAgICBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHNraXBQcmVmaXhGYWxsYmFjaykge1xuICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIHJldHVybiBjc1twcm9wZXJ0eV0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSB8fCAhc2tpcFByZWZpeEZhbGxiYWNrICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSkgfHwgcHJvcGVydHksIDEpIHx8IFwiXCI7IC8vY3NzIHZhcmlhYmxlcyBtYXkgbm90IG5lZWQgY2FwcyBzd2FwcGVkIG91dCBmb3IgZGFzaGVzIGFuZCBsb3dlcmNhc2UuXG59LFxuICAgIF9wcmVmaXhlcyA9IFwiTyxNb3osbXMsTXMsV2Via2l0XCIuc3BsaXQoXCIsXCIpLFxuICAgIF9jaGVja1Byb3BQcmVmaXggPSBmdW5jdGlvbiBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5LCBlbGVtZW50LCBwcmVmZXJQcmVmaXgpIHtcbiAgdmFyIGUgPSBlbGVtZW50IHx8IF90ZW1wRGl2LFxuICAgICAgcyA9IGUuc3R5bGUsXG4gICAgICBpID0gNTtcblxuICBpZiAocHJvcGVydHkgaW4gcyAmJiAhcHJlZmVyUHJlZml4KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5O1xuICB9XG5cbiAgcHJvcGVydHkgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcblxuICB3aGlsZSAoaS0tICYmICEoX3ByZWZpeGVzW2ldICsgcHJvcGVydHkgaW4gcykpIHt9XG5cbiAgcmV0dXJuIGkgPCAwID8gbnVsbCA6IChpID09PSAzID8gXCJtc1wiIDogaSA+PSAwID8gX3ByZWZpeGVzW2ldIDogXCJcIikgKyBwcm9wZXJ0eTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBpZiAoX3dpbmRvd0V4aXN0cygpICYmIHdpbmRvdy5kb2N1bWVudCkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IF93aW4uZG9jdW1lbnQ7XG4gICAgX2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpIHx8IHtcbiAgICAgIHN0eWxlOiB7fVxuICAgIH07XG4gICAgX3RlbXBEaXZTdHlsZXIgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoX3RyYW5zZm9ybVByb3ApO1xuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuICAgIF90ZW1wRGl2LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlci13aWR0aDowO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7cGFkZGluZzowXCI7IC8vbWFrZSBzdXJlIHRvIG92ZXJyaWRlIGNlcnRhaW4gcHJvcGVydGllcyB0aGF0IG1heSBjb250YW1pbmF0ZSBtZWFzdXJlbWVudHMsIGluIGNhc2UgdGhlIHVzZXIgaGFzIG92ZXJyZWFjaGluZyBzdHlsZSBzaGVldHMuXG5cbiAgICBfc3VwcG9ydHMzRCA9ICEhX2NoZWNrUHJvcFByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuICAgIF9yZXZlcnRpbmcgPSBnc2FwLmNvcmUucmV2ZXJ0aW5nO1xuICAgIF9wbHVnaW5Jbml0dGVkID0gMTtcbiAgfVxufSxcbiAgICBfZ2V0QkJveEhhY2sgPSBmdW5jdGlvbiBfZ2V0QkJveEhhY2soc3dhcElmUG9zc2libGUpIHtcbiAgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgdGhhdCBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IGdldEJCb3goKSBvbiBTVkcgZWxlbWVudHMgaW5zaWRlIGEgPGRlZnM+IGVsZW1lbnQgYW5kL29yIDxtYXNrPi4gV2UgdHJ5IGNyZWF0aW5nIGFuIFNWRywgYWRkaW5nIGl0IHRvIHRoZSBkb2N1bWVudEVsZW1lbnQgYW5kIHRvc3MgdGhlIGVsZW1lbnQgaW4gdGhlcmUgc28gdGhhdCBpdCdzIGRlZmluaXRlbHkgcGFydCBvZiB0aGUgcmVuZGVyaW5nIHRyZWUsIHRoZW4gZ3JhYiB0aGUgYmJveCBhbmQgaWYgaXQgd29ya3MsIHdlIGFjdHVhbGx5IHN3YXAgb3V0IHRoZSBvcmlnaW5hbCBnZXRCQm94KCkgbWV0aG9kIGZvciBvdXIgb3duIHRoYXQgZG9lcyB0aGVzZSBleHRyYSBzdGVwcyB3aGVuZXZlciBnZXRCQm94IGlzIG5lZWRlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBwZXJmb3JtYW5jZSBpcyBvcHRpbWFsIChvbmx5IGRvIGFsbCB0aGVzZSBleHRyYSBzdGVwcyB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5Li4ubW9zdCBlbGVtZW50cyBkb24ndCBuZWVkIGl0KS5cbiAgdmFyIHN2ZyA9IF9jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHRoaXMub3duZXJTVkdFbGVtZW50ICYmIHRoaXMub3duZXJTVkdFbGVtZW50LmdldEF0dHJpYnV0ZShcInhtbG5zXCIpIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiksXG4gICAgICBvbGRQYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG4gICAgICBvbGRTaWJsaW5nID0gdGhpcy5uZXh0U2libGluZyxcbiAgICAgIG9sZENTUyA9IHRoaXMuc3R5bGUuY3NzVGV4dCxcbiAgICAgIGJib3g7XG5cbiAgX2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcblxuICBzdmcuYXBwZW5kQ2hpbGQodGhpcyk7XG4gIHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICBpZiAoc3dhcElmUG9zc2libGUpIHtcbiAgICB0cnkge1xuICAgICAgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgdGhpcy5fZ3NhcEJCb3ggPSB0aGlzLmdldEJCb3g7IC8vc3RvcmUgdGhlIG9yaWdpbmFsXG5cbiAgICAgIHRoaXMuZ2V0QkJveCA9IF9nZXRCQm94SGFjaztcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9IGVsc2UgaWYgKHRoaXMuX2dzYXBCQm94KSB7XG4gICAgYmJveCA9IHRoaXMuX2dzYXBCQm94KCk7XG4gIH1cblxuICBpZiAob2xkUGFyZW50KSB7XG4gICAgaWYgKG9sZFNpYmxpbmcpIHtcbiAgICAgIG9sZFBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgb2xkU2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFBhcmVudC5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBfZG9jRWxlbWVudC5yZW1vdmVDaGlsZChzdmcpO1xuXG4gIHRoaXMuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgcmV0dXJuIGJib3g7XG59LFxuICAgIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3MgPSBmdW5jdGlvbiBfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgYXR0cmlidXRlc0FycmF5KSB7XG4gIHZhciBpID0gYXR0cmlidXRlc0FycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldEJCb3ggPSBmdW5jdGlvbiBfZ2V0QkJveCh0YXJnZXQpIHtcbiAgdmFyIGJvdW5kcztcblxuICB0cnkge1xuICAgIGJvdW5kcyA9IHRhcmdldC5nZXRCQm94KCk7IC8vRmlyZWZveCB0aHJvd3MgZXJyb3JzIGlmIHlvdSB0cnkgY2FsbGluZyBnZXRCQm94KCkgb24gYW4gU1ZHIGVsZW1lbnQgdGhhdCdzIG5vdCByZW5kZXJlZCAobGlrZSBpbiBhIDxzeW1ib2w+IG9yIDxkZWZzPikuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYxMjExOFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSk7XG4gIH1cblxuICBib3VuZHMgJiYgKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0KSB8fCB0YXJnZXQuZ2V0QkJveCA9PT0gX2dldEJCb3hIYWNrIHx8IChib3VuZHMgPSBfZ2V0QkJveEhhY2suY2FsbCh0YXJnZXQsIHRydWUpKTsgLy9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIG1pc3JlcG9ydCB0aGUgYm91bmRzIGlmIHRoZSBlbGVtZW50IGhhcyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHQgKGl0IGp1c3QgYXNzdW1lcyBpdCdzIGF0IHg6MCwgeTowKSwgdGh1cyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGdyYWIgdGhlIHBvc2l0aW9uIGluIHRoYXQgY2FzZS5cblxuICByZXR1cm4gYm91bmRzICYmICFib3VuZHMud2lkdGggJiYgIWJvdW5kcy54ICYmICFib3VuZHMueSA/IHtcbiAgICB4OiArX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIFtcInhcIiwgXCJjeFwiLCBcIngxXCJdKSB8fCAwLFxuICAgIHk6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieVwiLCBcImN5XCIsIFwieTFcIl0pIHx8IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0gOiBib3VuZHM7XG59LFxuICAgIF9pc1NWRyA9IGZ1bmN0aW9uIF9pc1NWRyhlKSB7XG4gIHJldHVybiAhIShlLmdldENUTSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkgJiYgX2dldEJCb3goZSkpO1xufSxcbiAgICAvL3JlcG9ydHMgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHIG9uIHdoaWNoIGdldEJCb3goKSBhY3R1YWxseSB3b3Jrc1xuX3JlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24gX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBmaXJzdDJDaGFycztcblxuICAgIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB7XG4gICAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgZmlyc3QyQ2hhcnMgPSBwcm9wZXJ0eS5zdWJzdHIoMCwgMik7XG5cbiAgICAgIGlmIChmaXJzdDJDaGFycyA9PT0gXCJtc1wiIHx8IHByb3BlcnR5LnN1YnN0cigwLCA2KSA9PT0gXCJ3ZWJraXRcIikge1xuICAgICAgICAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHByb3BlcnR5ID0gXCItXCIgKyBwcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoZmlyc3QyQ2hhcnMgPT09IFwiLS1cIiA/IHByb3BlcnR5IDogcHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQgPSBmdW5jdGlvbiBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpIHtcbiAgdmFyIHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBvbmx5U2V0QXRFbmQgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKTtcbiAgcGx1Z2luLl9wdCA9IHB0O1xuICBwdC5iID0gYmVnaW5uaW5nO1xuICBwdC5lID0gZW5kO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfbm9uQ29udmVydGlibGVVbml0cyA9IHtcbiAgZGVnOiAxLFxuICByYWQ6IDEsXG4gIHR1cm46IDFcbn0sXG4gICAgX25vblN0YW5kYXJkTGF5b3V0cyA9IHtcbiAgZ3JpZDogMSxcbiAgZmxleDogMVxufSxcbiAgICAvL3Rha2VzIGEgc2luZ2xlIHZhbHVlIGxpa2UgMjBweCBhbmQgY29udmVydHMgaXQgdG8gdGhlIHVuaXQgc3BlY2lmaWVkLCBsaWtlIFwiJVwiLCByZXR1cm5pbmcgb25seSB0aGUgbnVtZXJpYyBhbW91bnQuXG5fY29udmVydFRvVW5pdCA9IGZ1bmN0aW9uIF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSB7XG4gIHZhciBjdXJWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsXG4gICAgICBjdXJVbml0ID0gKHZhbHVlICsgXCJcIikudHJpbSgpLnN1YnN0cigoY3VyVmFsdWUgKyBcIlwiKS5sZW5ndGgpIHx8IFwicHhcIixcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgbGVhdmUgZXh0cmEgd2hpdGVzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIENTUyB2YXJpYWJsZXMsIGhlbmNlIHRoZSBuZWVkIHRvIHRyaW0oKVxuICBzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuICAgICAgaG9yaXpvbnRhbCA9IF9ob3Jpem9udGFsRXhwLnRlc3QocHJvcGVydHkpLFxuICAgICAgaXNSb290U1ZHID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIixcbiAgICAgIG1lYXN1cmVQcm9wZXJ0eSA9IChpc1Jvb3RTVkcgPyBcImNsaWVudFwiIDogXCJvZmZzZXRcIikgKyAoaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpLFxuICAgICAgYW1vdW50ID0gMTAwLFxuICAgICAgdG9QaXhlbHMgPSB1bml0ID09PSBcInB4XCIsXG4gICAgICB0b1BlcmNlbnQgPSB1bml0ID09PSBcIiVcIixcbiAgICAgIHB4LFxuICAgICAgcGFyZW50LFxuICAgICAgY2FjaGUsXG4gICAgICBpc1NWRztcblxuICBpZiAodW5pdCA9PT0gY3VyVW5pdCB8fCAhY3VyVmFsdWUgfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbdW5pdF0gfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbY3VyVW5pdF0pIHtcbiAgICByZXR1cm4gY3VyVmFsdWU7XG4gIH1cblxuICBjdXJVbml0ICE9PSBcInB4XCIgJiYgIXRvUGl4ZWxzICYmIChjdXJWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBcInB4XCIpKTtcbiAgaXNTVkcgPSB0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpO1xuXG4gIGlmICgodG9QZXJjZW50IHx8IGN1clVuaXQgPT09IFwiJVwiKSAmJiAoX3RyYW5zZm9ybVByb3BzW3Byb3BlcnR5XSB8fCB+cHJvcGVydHkuaW5kZXhPZihcImFkaXVzXCIpKSkge1xuICAgIHB4ID0gaXNTVkcgPyB0YXJnZXQuZ2V0QkJveCgpW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA6IHRhcmdldFttZWFzdXJlUHJvcGVydHldO1xuICAgIHJldHVybiBfcm91bmQodG9QZXJjZW50ID8gY3VyVmFsdWUgLyBweCAqIGFtb3VudCA6IGN1clZhbHVlIC8gMTAwICogcHgpO1xuICB9XG5cbiAgc3R5bGVbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gYW1vdW50ICsgKHRvUGl4ZWxzID8gY3VyVW5pdCA6IHVuaXQpO1xuICBwYXJlbnQgPSB+cHJvcGVydHkuaW5kZXhPZihcImFkaXVzXCIpIHx8IHVuaXQgPT09IFwiZW1cIiAmJiB0YXJnZXQuYXBwZW5kQ2hpbGQgJiYgIWlzUm9vdFNWRyA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gIGlmIChpc1NWRykge1xuICAgIHBhcmVudCA9ICh0YXJnZXQub3duZXJTVkdFbGVtZW50IHx8IHt9KS5wYXJlbnROb2RlO1xuICB9XG5cbiAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBfZG9jIHx8ICFwYXJlbnQuYXBwZW5kQ2hpbGQpIHtcbiAgICBwYXJlbnQgPSBfZG9jLmJvZHk7XG4gIH1cblxuICBjYWNoZSA9IHBhcmVudC5fZ3NhcDtcblxuICBpZiAoY2FjaGUgJiYgdG9QZXJjZW50ICYmIGNhY2hlLndpZHRoICYmIGhvcml6b250YWwgJiYgY2FjaGUudGltZSA9PT0gX3RpY2tlci50aW1lICYmICFjYWNoZS51bmNhY2hlKSB7XG4gICAgcmV0dXJuIF9yb3VuZChjdXJWYWx1ZSAvIGNhY2hlLndpZHRoICogYW1vdW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9QZXJjZW50ICYmIChwcm9wZXJ0eSA9PT0gXCJoZWlnaHRcIiB8fCBwcm9wZXJ0eSA9PT0gXCJ3aWR0aFwiKSkge1xuICAgICAgLy8gaWYgd2UncmUgZGVhbGluZyB3aXRoIHdpZHRoL2hlaWdodCB0aGF0J3MgaW5zaWRlIGEgY29udGFpbmVyIHdpdGggcGFkZGluZyBhbmQvb3IgaXQncyBhIGZsZXhib3gvZ3JpZCBjb250YWluZXIsIHdlIG11c3QgYXBwbHkgaXQgdG8gdGhlIHRhcmdldCBpdHNlbGYgcmF0aGVyIHRoYW4gdGhlIF90ZW1wRGl2IGluIG9yZGVyIHRvIGVuc3VyZSBjb21wbGV0ZSBhY2N1cmFjeSwgZmFjdG9yaW5nIGluIHRoZSBwYXJlbnQncyBwYWRkaW5nLlxuICAgICAgdmFyIHYgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuICAgICAgdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IGFtb3VudCArIHVuaXQ7XG4gICAgICBweCA9IHRhcmdldFttZWFzdXJlUHJvcGVydHldO1xuICAgICAgdiA/IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2IDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAodG9QZXJjZW50IHx8IGN1clVuaXQgPT09IFwiJVwiKSAmJiAhX25vblN0YW5kYXJkTGF5b3V0c1tfZ2V0Q29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQsIFwiZGlzcGxheVwiKV0gJiYgKHN0eWxlLnBvc2l0aW9uID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcInBvc2l0aW9uXCIpKTtcbiAgICAgIHBhcmVudCA9PT0gdGFyZ2V0ICYmIChzdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCIpOyAvLyBsaWtlIGZvciBib3JkZXJSYWRpdXMsIGlmIGl0J3MgYSAlIHdlIG11c3QgaGF2ZSBpdCByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0IGl0c2VsZiBidXQgdGhhdCBtYXkgbm90IGhhdmUgcG9zaXRpb246IHJlbGF0aXZlIG9yIHBvc2l0aW9uOiBhYnNvbHV0ZSBpbiB3aGljaCBjYXNlIGl0J2QgZ28gdXAgdGhlIGNoYWluIHVudGlsIGl0IGZpbmRzIGl0cyBvZmZzZXRQYXJlbnQgKGJhZCkuIHBvc2l0aW9uOiBzdGF0aWMgcHJvdGVjdHMgYWdhaW5zdCB0aGF0LlxuXG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgICAgcHggPSBfdGVtcERpdlttZWFzdXJlUHJvcGVydHldO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIH1cblxuICAgIGlmIChob3Jpem9udGFsICYmIHRvUGVyY2VudCkge1xuICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUocGFyZW50KTtcbiAgICAgIGNhY2hlLnRpbWUgPSBfdGlja2VyLnRpbWU7XG4gICAgICBjYWNoZS53aWR0aCA9IHBhcmVudFttZWFzdXJlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfcm91bmQodG9QaXhlbHMgPyBweCAqIGN1clZhbHVlIC8gYW1vdW50IDogcHggJiYgY3VyVmFsdWUgPyBhbW91bnQgLyBweCAqIGN1clZhbHVlIDogMCk7XG59LFxuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgdmFyIHZhbHVlO1xuICBfcGx1Z2luSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblxuICBpZiAocHJvcGVydHkgaW4gX3Byb3BlcnR5QWxpYXNlcyAmJiBwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgIHByb3BlcnR5ID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG5cbiAgICBpZiAofnByb3BlcnR5LmluZGV4T2YoXCIsXCIpKSB7XG4gICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnNwbGl0KFwiLFwiKVswXTtcbiAgICB9XG4gIH1cblxuICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BlcnR5XSAmJiBwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgIHZhbHVlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSk7XG4gICAgdmFsdWUgPSBwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IHZhbHVlW3Byb3BlcnR5XSA6IHZhbHVlLnN2ZyA/IHZhbHVlLm9yaWdpbiA6IF9maXJzdFR3b09ubHkoX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCkpICsgXCIgXCIgKyB2YWx1ZS56T3JpZ2luICsgXCJweFwiO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XTtcblxuICAgIGlmICghdmFsdWUgfHwgdmFsdWUgPT09IFwiYXV0b1wiIHx8IHVuY2FjaGUgfHwgfih2YWx1ZSArIFwiXCIpLmluZGV4T2YoXCJjYWxjKFwiKSkge1xuICAgICAgdmFsdWUgPSBfc3BlY2lhbFByb3BzW3Byb3BlcnR5XSAmJiBfc3BlY2lhbFByb3BzW3Byb3BlcnR5XSh0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB8fCBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkgfHwgKHByb3BlcnR5ID09PSBcIm9wYWNpdHlcIiA/IDEgOiAwKTsgLy8gbm90ZTogc29tZSBicm93c2VycywgbGlrZSBGaXJlZm94LCBkb24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSEgSW5zdGVhZCwgaXQgb25seSByZXBvcnRzIGV2ZXJ5IGNvcm5lciBsaWtlICBib3JkZXJUb3BMZWZ0UmFkaXVzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuaXQgJiYgIX4odmFsdWUgKyBcIlwiKS50cmltKCkuaW5kZXhPZihcIiBcIikgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkgKyB1bml0IDogdmFsdWU7XG59LFxuICAgIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcgPSBmdW5jdGlvbiBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCkge1xuICAvLyBub3RlOiB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSBcIm5vbmVcIikge1xuICAgIC8vIHNvbWUgYnJvd3NlcnMgbGlrZSBTYWZhcmkgYWN0dWFsbHkgUFJFRkVSIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBhbmQgbWlzLXJlcG9ydCB0aGUgdW5wcmVmaXhlZCB2YWx1ZSBsaWtlIGNsaXBQYXRoIChCVUcpLiBJbiBvdGhlciB3b3JkcywgZXZlbiB0aG91Z2ggY2xpcFBhdGggZXhpc3RzIGluIHRoZSBzdHlsZSAoXCJjbGlwUGF0aFwiIGluIHRhcmdldC5zdHlsZSkgYW5kIGl0J3Mgc2V0IGluIHRoZSBDU1MgcHJvcGVybHkgKGFsb25nIHdpdGggLXdlYmtpdC1jbGlwLXBhdGgpLCBTYWZhcmkgcmVwb3J0cyBjbGlwUGF0aCBhcyBcIm5vbmVcIiB3aGVyZWFzIFdlYmtpdENsaXBQYXRoIHJlcG9ydHMgYWNjdXJhdGVseSBsaWtlIFwiZWxsaXBzZSgxMDAlIDAlIGF0IDUwJSAwJSlcIiwgc28gaW4gdGhpcyBjYXNlIHdlIG11c3QgU1dJVENIIHRvIHVzaW5nIHRoZSBwcmVmaXhlZCBwcm9wZXJ0eSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMTgzMTAtY2xpcHBhdGgtZG9lc250LXdvcmstb24taW9zL1xuICAgIHZhciBwID0gX2NoZWNrUHJvcFByZWZpeChwcm9wLCB0YXJnZXQsIDEpLFxuICAgICAgICBzID0gcCAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHAsIDEpO1xuXG4gICAgaWYgKHMgJiYgcyAhPT0gc3RhcnQpIHtcbiAgICAgIHByb3AgPSBwO1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG4gICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzI0NTgzLWhvdy10by1yZXR1cm4tY29sb3JzLXRoYXQtaS1oYWQtYWZ0ZXItcmV2ZXJzZS9cbiAgICB9XG4gIH1cblxuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQuc3R5bGUsIHByb3AsIDAsIDEsIF9yZW5kZXJDb21wbGV4U3RyaW5nKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgYSxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YXJ0VmFsdWVzLFxuICAgICAgc3RhcnROdW0sXG4gICAgICBjb2xvcixcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIGVuZE51bSxcbiAgICAgIGNodW5rLFxuICAgICAgZW5kVW5pdCxcbiAgICAgIHN0YXJ0VW5pdCxcbiAgICAgIGVuZFZhbHVlcztcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvLyBlbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICBzdGFydFZhbHVlID0gdGFyZ2V0LnN0eWxlW3Byb3BdO1xuICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IGVuZDtcbiAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHx8IGVuZDtcbiAgICBzdGFydFZhbHVlID8gdGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnRWYWx1ZSA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICB9XG5cbiAgYSA9IFtzdGFydCwgZW5kXTtcblxuICBfY29sb3JTdHJpbmdGaWx0ZXIoYSk7IC8vIHBhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuIElmIGNvbG9ycyBhcmUgZm91bmQsIGl0IHJldHVybnMgdHJ1ZSBhbmQgdGhlbiB3ZSBtdXN0IG1hdGNoIHdoZXJlIHRoZSBjb2xvciBzaG93cyB1cCBvcmRlci13aXNlIGJlY2F1c2UgZm9yIHRoaW5ncyBsaWtlIGJveFNoYWRvdywgc29tZXRpbWVzIHRoZSBicm93c2VyIHByb3ZpZGVzIHRoZSBjb21wdXRlZCB2YWx1ZXMgd2l0aCB0aGUgY29sb3IgRklSU1QsIGJ1dCB0aGUgdXNlciBwcm92aWRlcyBpdCB3aXRoIHRoZSBjb2xvciBMQVNULCBzbyBmbGlwIHRoZW0gaWYgbmVjZXNzYXJ5LiBTYW1lIGZvciBkcm9wLXNoYWRvdygpLlxuXG5cbiAgc3RhcnQgPSBhWzBdO1xuICBlbmQgPSBhWzFdO1xuICBzdGFydFZhbHVlcyA9IHN0YXJ0Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gIGVuZFZhbHVlcyA9IGVuZC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuXG4gIGlmIChlbmRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgd2hpbGUgKHJlc3VsdCA9IF9udW1XaXRoVW5pdEV4cC5leGVjKGVuZCkpIHtcbiAgICAgIGVuZFZhbHVlID0gcmVzdWx0WzBdO1xuICAgICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcbiAgICAgICAgY29sb3IgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kVmFsdWUgIT09IChzdGFydFZhbHVlID0gc3RhcnRWYWx1ZXNbbWF0Y2hJbmRleCsrXSB8fCBcIlwiKSkge1xuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSkgfHwgMDtcbiAgICAgICAgc3RhcnRVbml0ID0gc3RhcnRWYWx1ZS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoZW5kVmFsdWUgPSBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgZW5kVmFsdWUpICsgc3RhcnRVbml0KTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIGVuZFVuaXQgPSBlbmRWYWx1ZS5zdWJzdHIoKGVuZE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIGluZGV4ID0gX251bVdpdGhVbml0RXhwLmxhc3RJbmRleCAtIGVuZFVuaXQubGVuZ3RoO1xuXG4gICAgICAgIGlmICghZW5kVW5pdCkge1xuICAgICAgICAgIC8vaWYgc29tZXRoaW5nIGxpa2UgXCJwZXJzcGVjdGl2ZTozMDBcIiBpcyBwYXNzZWQgaW4gYW5kIHdlIG11c3QgYWRkIGEgdW5pdCB0byB0aGUgZW5kXG4gICAgICAgICAgZW5kVW5pdCA9IGVuZFVuaXQgfHwgX2NvbmZpZy51bml0c1twcm9wXSB8fCBzdGFydFVuaXQ7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IGVuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCArPSBlbmRVbml0O1xuICAgICAgICAgICAgcHQuZSArPSBlbmRVbml0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQpIHtcbiAgICAgICAgICBzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgfHwgMDtcbiAgICAgICAgfSAvLyB0aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG5cbiAgICAgICAgcHQuX3B0ID0ge1xuICAgICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgICAgYzogZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICAgICAgbTogY29sb3IgJiYgY29sb3IgPCA0IHx8IHByb3AgPT09IFwiekluZGV4XCIgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcbiAgfSBlbHNlIHtcbiAgICBwdC5yID0gcHJvcCA9PT0gXCJkaXNwbGF5XCIgJiYgZW5kID09PSBcIm5vbmVcIiA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWU7XG4gIH1cblxuICBfcmVsRXhwLnRlc3QoZW5kKSAmJiAocHQuZSA9IDApOyAvL2lmIHRoZSBlbmQgc3RyaW5nIGNvbnRhaW5zIHJlbGF0aXZlIHZhbHVlcyBvciBkeW5hbWljIHJhbmRvbSguLi4pIHZhbHVlcywgZGVsZXRlIHRoZSBlbmQgaXQgc28gdGhhdCBvbiB0aGUgZmluYWwgcmVuZGVyIHdlIGRvbid0IGFjdHVhbGx5IHNldCBpdCB0byB0aGUgc3RyaW5nIHdpdGggKz0gb3IgLT0gY2hhcmFjdGVycyAoZm9yY2VzIGl0IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCB2YWx1ZSkuXG5cbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGFub3RoZXIgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2tleXdvcmRUb1BlcmNlbnQgPSB7XG4gIHRvcDogXCIwJVwiLFxuICBib3R0b206IFwiMTAwJVwiLFxuICBsZWZ0OiBcIjAlXCIsXG4gIHJpZ2h0OiBcIjEwMCVcIixcbiAgY2VudGVyOiBcIjUwJVwiXG59LFxuICAgIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzID0gZnVuY3Rpb24gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXModmFsdWUpIHtcbiAgdmFyIHNwbGl0ID0gdmFsdWUuc3BsaXQoXCIgXCIpLFxuICAgICAgeCA9IHNwbGl0WzBdLFxuICAgICAgeSA9IHNwbGl0WzFdIHx8IFwiNTAlXCI7XG5cbiAgaWYgKHggPT09IFwidG9wXCIgfHwgeCA9PT0gXCJib3R0b21cIiB8fCB5ID09PSBcImxlZnRcIiB8fCB5ID09PSBcInJpZ2h0XCIpIHtcbiAgICAvL3RoZSB1c2VyIHByb3ZpZGVkIHRoZW0gaW4gdGhlIHdyb25nIG9yZGVyLCBzbyBmbGlwIHRoZW1cbiAgICB2YWx1ZSA9IHg7XG4gICAgeCA9IHk7XG4gICAgeSA9IHZhbHVlO1xuICB9XG5cbiAgc3BsaXRbMF0gPSBfa2V5d29yZFRvUGVyY2VudFt4XSB8fCB4O1xuICBzcGxpdFsxXSA9IF9rZXl3b3JkVG9QZXJjZW50W3ldIHx8IHk7XG4gIHJldHVybiBzcGxpdC5qb2luKFwiIFwiKTtcbn0sXG4gICAgX3JlbmRlckNsZWFyUHJvcHMgPSBmdW5jdGlvbiBfcmVuZGVyQ2xlYXJQcm9wcyhyYXRpbywgZGF0YSkge1xuICBpZiAoZGF0YS50d2VlbiAmJiBkYXRhLnR3ZWVuLl90aW1lID09PSBkYXRhLnR3ZWVuLl9kdXIpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZGF0YS50LFxuICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgcHJvcHMgPSBkYXRhLnUsXG4gICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgICBwcm9wLFxuICAgICAgICBjbGVhclRyYW5zZm9ybXMsXG4gICAgICAgIGk7XG5cbiAgICBpZiAocHJvcHMgPT09IFwiYWxsXCIgfHwgcHJvcHMgPT09IHRydWUpIHtcbiAgICAgIHN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICAgIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcF0pIHtcbiAgICAgICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICAgIHByb3AgPSBwcm9wID09PSBcInRyYW5zZm9ybU9yaWdpblwiID8gX3RyYW5zZm9ybU9yaWdpblByb3AgOiBfdHJhbnNmb3JtUHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGVhclRyYW5zZm9ybXMpIHtcbiAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlLnN2ZyAmJiB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXG4gICAgICAgIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpOyAvLyBmb3JjZSBhbGwgdGhlIGNhY2hlZCB2YWx1ZXMgYmFjayB0byBcIm5vcm1hbFwiL2lkZW50aXR5LCBvdGhlcndpc2UgaWYgdGhlcmUncyBhbm90aGVyIHR3ZWVuIHRoYXQncyBhbHJlYWR5IHNldCB0byByZW5kZXIgdHJhbnNmb3JtcyBvbiB0aGlzIGVsZW1lbnQsIGl0IGNvdWxkIGRpc3BsYXkgdGhlIHdyb25nIHZhbHVlcy5cblxuXG4gICAgICAgIGNhY2hlLnVuY2FjaGUgPSAxO1xuXG4gICAgICAgIF9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMoc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICAvLyBub3RlOiBzcGVjaWFsUHJvcHMgc2hvdWxkIHJldHVybiAxIGlmIChhbmQgb25seSBpZikgdGhleSBoYXZlIGEgbm9uLXplcm8gcHJpb3JpdHkuIEl0IGluZGljYXRlcyB3ZSBuZWVkIHRvIHNvcnQgdGhlIGxpbmtlZCBsaXN0LlxuX3NwZWNpYWxQcm9wcyA9IHtcbiAgY2xlYXJQcm9wczogZnVuY3Rpb24gY2xlYXJQcm9wcyhwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIGlmICh0d2Vlbi5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHtcbiAgICAgIHZhciBwdCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDAsIF9yZW5kZXJDbGVhclByb3BzKTtcbiAgICAgIHB0LnUgPSBlbmRWYWx1ZTtcbiAgICAgIHB0LnByID0gLTEwO1xuICAgICAgcHQudHdlZW4gPSB0d2VlbjtcblxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIC8qIGNsYXNzTmFtZSBmZWF0dXJlIChhYm91dCAwLjRrYiBnemlwcGVkKS5cbiAgLCBjbGFzc05hbWUocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgXHRsZXQgX3JlbmRlckNsYXNzTmFtZSA9IChyYXRpbywgZGF0YSkgPT4ge1xuICBcdFx0XHRkYXRhLmNzcy5yZW5kZXIocmF0aW8sIGRhdGEuY3NzKTtcbiAgXHRcdFx0aWYgKCFyYXRpbyB8fCByYXRpbyA9PT0gMSkge1xuICBcdFx0XHRcdGxldCBpbmxpbmUgPSBkYXRhLnJtdixcbiAgXHRcdFx0XHRcdHRhcmdldCA9IGRhdGEudCxcbiAgXHRcdFx0XHRcdHA7XG4gIFx0XHRcdFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iKTtcbiAgXHRcdFx0XHRmb3IgKHAgaW4gaW5saW5lKSB7XG4gIFx0XHRcdFx0XHRfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0sXG4gIFx0XHRfZ2V0QWxsU3R5bGVzID0gKHRhcmdldCkgPT4ge1xuICBcdFx0XHRsZXQgc3R5bGVzID0ge30sXG4gIFx0XHRcdFx0Y29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCksXG4gIFx0XHRcdFx0cDtcbiAgXHRcdFx0Zm9yIChwIGluIGNvbXB1dGVkKSB7XG4gIFx0XHRcdFx0aWYgKGlzTmFOKHApICYmIHAgIT09IFwiY3NzVGV4dFwiICYmIHAgIT09IFwibGVuZ3RoXCIpIHtcbiAgXHRcdFx0XHRcdHN0eWxlc1twXSA9IGNvbXB1dGVkW3BdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0XHRfc2V0RGVmYXVsdHMoc3R5bGVzLCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKSk7XG4gIFx0XHRcdHJldHVybiBzdHlsZXM7XG4gIFx0XHR9LFxuICBcdFx0c3RhcnRDbGFzc0xpc3QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIiksXG4gIFx0XHRzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgXHRcdGNzc1RleHQgPSBzdHlsZS5jc3NUZXh0LFxuICBcdFx0Y2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gIFx0XHRjbGFzc1BUID0gY2FjaGUuY2xhc3NQVCxcbiAgXHRcdGlubGluZVRvUmVtb3ZlQXRFbmQgPSB7fSxcbiAgXHRcdGRhdGEgPSB7dDp0YXJnZXQsIHBsdWdpbjpwbHVnaW4sIHJtdjppbmxpbmVUb1JlbW92ZUF0RW5kLCBiOnN0YXJ0Q2xhc3NMaXN0LCBlOihlbmRWYWx1ZS5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IGVuZFZhbHVlIDogc3RhcnRDbGFzc0xpc3QucmVwbGFjZShuZXcgUmVnRXhwKFwiKD86XFxcXHN8XilcIiArIGVuZFZhbHVlLnN1YnN0cigyKSArIFwiKD8hW1xcXFx3LV0pXCIpLCBcIlwiKSArICgoZW5kVmFsdWUuY2hhckF0KDApID09PSBcIitcIikgPyBcIiBcIiArIGVuZFZhbHVlLnN1YnN0cigyKSA6IFwiXCIpfSxcbiAgXHRcdGNoYW5naW5nVmFycyA9IHt9LFxuICBcdFx0c3RhcnRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQpLFxuICBcdFx0dHJhbnNmb3JtUmVsYXRlZCA9IC8odHJhbnNmb3JtfHBlcnNwZWN0aXZlKS9pLFxuICBcdFx0ZW5kVmFycywgcDtcbiAgXHRpZiAoY2xhc3NQVCkge1xuICBcdFx0Y2xhc3NQVC5yKDEsIGNsYXNzUFQuZCk7XG4gIFx0XHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0oY2xhc3NQVC5kLnBsdWdpbiwgY2xhc3NQVCwgXCJfcHRcIik7XG4gIFx0fVxuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkYXRhLmUpO1xuICBcdGVuZFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCwgdHJ1ZSk7XG4gIFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHN0YXJ0Q2xhc3NMaXN0KTtcbiAgXHRmb3IgKHAgaW4gZW5kVmFycykge1xuICBcdFx0aWYgKGVuZFZhcnNbcF0gIT09IHN0YXJ0VmFyc1twXSAmJiAhdHJhbnNmb3JtUmVsYXRlZC50ZXN0KHApKSB7XG4gIFx0XHRcdGNoYW5naW5nVmFyc1twXSA9IGVuZFZhcnNbcF07XG4gIFx0XHRcdGlmICghc3R5bGVbcF0gJiYgc3R5bGVbcF0gIT09IFwiMFwiKSB7XG4gIFx0XHRcdFx0aW5saW5lVG9SZW1vdmVBdEVuZFtwXSA9IDE7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIFx0Y2FjaGUuY2xhc3NQVCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgXCJjbGFzc05hbWVcIiwgMCwgMCwgX3JlbmRlckNsYXNzTmFtZSwgZGF0YSwgMCwgLTExKTtcbiAgXHRpZiAoc3R5bGUuY3NzVGV4dCAhPT0gY3NzVGV4dCkgeyAvL29ubHkgYXBwbHkgaWYgdGhpbmdzIGNoYW5nZS4gT3RoZXJ3aXNlLCBpbiBjYXNlcyBsaWtlIGEgYmFja2dyb3VuZC1pbWFnZSB0aGF0J3MgcHVsbGVkIGR5bmFtaWNhbGx5LCBpdCBjb3VsZCBjYXVzZSBhIHJlZnJlc2guIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1XG4gICAgICBhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZztcblxuICAgICAgX2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KTsgLy93ZSBtdXN0IGFkZCBpdCB0byB0aGUgRE9NIGluIG9yZGVyIHRvIGdldCB2YWx1ZXMgcHJvcGVybHlcblxuICAgIH1cblxuICAgIG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KTtcbiAgICB0ZW1wID8gc3R5bGUuZGlzcGxheSA9IHRlbXAgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBcImRpc3BsYXlcIik7XG5cbiAgICBpZiAoYWRkZWRUb0RPTSkge1xuICAgICAgbmV4dFNpYmxpbmcgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgbmV4dFNpYmxpbmcpIDogcGFyZW50ID8gcGFyZW50LmFwcGVuZENoaWxkKHRhcmdldCkgOiBfZG9jRWxlbWVudC5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JjZTJEICYmIG1hdHJpeC5sZW5ndGggPiA2ID8gW21hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSwgbWF0cml4WzEyXSwgbWF0cml4WzEzXV0gOiBtYXRyaXg7XG59LFxuICAgIF9hcHBseVNWR09yaWdpbiA9IGZ1bmN0aW9uIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIG9yaWdpbiwgb3JpZ2luSXNBYnNvbHV0ZSwgc21vb3RoLCBtYXRyaXhBcnJheSwgcGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgbWF0cml4ID0gbWF0cml4QXJyYXkgfHwgX2dldE1hdHJpeCh0YXJnZXQsIHRydWUpLFxuICAgICAgeE9yaWdpbk9sZCA9IGNhY2hlLnhPcmlnaW4gfHwgMCxcbiAgICAgIHlPcmlnaW5PbGQgPSBjYWNoZS55T3JpZ2luIHx8IDAsXG4gICAgICB4T2Zmc2V0T2xkID0gY2FjaGUueE9mZnNldCB8fCAwLFxuICAgICAgeU9mZnNldE9sZCA9IGNhY2hlLnlPZmZzZXQgfHwgMCxcbiAgICAgIGEgPSBtYXRyaXhbMF0sXG4gICAgICBiID0gbWF0cml4WzFdLFxuICAgICAgYyA9IG1hdHJpeFsyXSxcbiAgICAgIGQgPSBtYXRyaXhbM10sXG4gICAgICB0eCA9IG1hdHJpeFs0XSxcbiAgICAgIHR5ID0gbWF0cml4WzVdLFxuICAgICAgb3JpZ2luU3BsaXQgPSBvcmlnaW4uc3BsaXQoXCIgXCIpLFxuICAgICAgeE9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luU3BsaXRbMF0pIHx8IDAsXG4gICAgICB5T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFsxXSkgfHwgMCxcbiAgICAgIGJvdW5kcyxcbiAgICAgIGRldGVybWluYW50LFxuICAgICAgeCxcbiAgICAgIHk7XG5cbiAgaWYgKCFvcmlnaW5Jc0Fic29sdXRlKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3godGFyZ2V0KTtcbiAgICB4T3JpZ2luID0gYm91bmRzLnggKyAofm9yaWdpblNwbGl0WzBdLmluZGV4T2YoXCIlXCIpID8geE9yaWdpbiAvIDEwMCAqIGJvdW5kcy53aWR0aCA6IHhPcmlnaW4pO1xuICAgIHlPcmlnaW4gPSBib3VuZHMueSArICh+KG9yaWdpblNwbGl0WzFdIHx8IG9yaWdpblNwbGl0WzBdKS5pbmRleE9mKFwiJVwiKSA/IHlPcmlnaW4gLyAxMDAgKiBib3VuZHMuaGVpZ2h0IDogeU9yaWdpbik7IC8vIGlmICghKFwieE9yaWdpblwiIGluIGNhY2hlKSAmJiAoeE9yaWdpbiB8fCB5T3JpZ2luKSkgeyAvLyBhZGRlZCBpbiAzLjEyLjMsIHJldmVydGVkIGluIDMuMTIuNDsgcmVxdWlyZXMgbW9yZSBleHBsb3JhdGlvblxuICAgIC8vIFx0eE9yaWdpbiAtPSBib3VuZHMueDtcbiAgICAvLyBcdHlPcmlnaW4gLT0gYm91bmRzLnk7XG4gICAgLy8gfVxuICB9IGVsc2UgaWYgKG1hdHJpeCAhPT0gX2lkZW50aXR5MkRNYXRyaXggJiYgKGRldGVybWluYW50ID0gYSAqIGQgLSBiICogYykpIHtcbiAgICAvL2lmIGl0J3MgemVybyAobGlrZSBpZiBzY2FsZVggYW5kIHNjYWxlWSBhcmUgemVybyksIHNraXAgaXQgdG8gYXZvaWQgZXJyb3JzIHdpdGggZGl2aWRpbmcgYnkgemVyby5cbiAgICB4ID0geE9yaWdpbiAqIChkIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqICgtYyAvIGRldGVybWluYW50KSArIChjICogdHkgLSBkICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgeSA9IHhPcmlnaW4gKiAoLWIgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKGEgLyBkZXRlcm1pbmFudCkgLSAoYSAqIHR5IC0gYiAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHhPcmlnaW4gPSB4O1xuICAgIHlPcmlnaW4gPSB5OyAvLyB0aGVvcnk6IHdlIG9ubHkgaGFkIHRvIGRvIHRoaXMgZm9yIHNtb290aGluZyBhbmQgaXQgYXNzdW1lcyB0aGF0IHRoZSBwcmV2aW91cyBvbmUgd2FzIG5vdCBvcmlnaW5Jc0Fic29sdXRlLlxuICB9XG5cbiAgaWYgKHNtb290aCB8fCBzbW9vdGggIT09IGZhbHNlICYmIGNhY2hlLnNtb290aCkge1xuICAgIHR4ID0geE9yaWdpbiAtIHhPcmlnaW5PbGQ7XG4gICAgdHkgPSB5T3JpZ2luIC0geU9yaWdpbk9sZDtcbiAgICBjYWNoZS54T2Zmc2V0ID0geE9mZnNldE9sZCArICh0eCAqIGEgKyB0eSAqIGMpIC0gdHg7XG4gICAgY2FjaGUueU9mZnNldCA9IHlPZmZzZXRPbGQgKyAodHggKiBiICsgdHkgKiBkKSAtIHR5O1xuICB9IGVsc2Uge1xuICAgIGNhY2hlLnhPZmZzZXQgPSBjYWNoZS55T2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGNhY2hlLnhPcmlnaW4gPSB4T3JpZ2luO1xuICBjYWNoZS55T3JpZ2luID0geU9yaWdpbjtcbiAgY2FjaGUuc21vb3RoID0gISFzbW9vdGg7XG4gIGNhY2hlLm9yaWdpbiA9IG9yaWdpbjtcbiAgY2FjaGUub3JpZ2luSXNBYnNvbHV0ZSA9ICEhb3JpZ2luSXNBYnNvbHV0ZTtcbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiMHB4IDBweFwiOyAvL290aGVyd2lzZSwgaWYgc29tZW9uZSBzZXRzICBhbiBvcmlnaW4gdmlhIENTUywgaXQgd2lsbCBsaWtlbHkgaW50ZXJmZXJlIHdpdGggdGhlIFNWRyB0cmFuc2Zvcm0gYXR0cmlidXRlIG9uZXMgKGJlY2F1c2UgcmVtZW1iZXIsIHdlJ3JlIGJha2luZyB0aGUgb3JpZ2luIGludG8gdGhlIG1hdHJpeCgpIHZhbHVlKS5cblxuICBpZiAocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8pIHtcbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9yaWdpblwiLCB4T3JpZ2luT2xkLCB4T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T3JpZ2luXCIsIHlPcmlnaW5PbGQsIHlPcmlnaW4pO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPZmZzZXRcIiwgeE9mZnNldE9sZCwgY2FjaGUueE9mZnNldCk7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9mZnNldFwiLCB5T2Zmc2V0T2xkLCBjYWNoZS55T2Zmc2V0KTtcbiAgfVxuXG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgeE9yaWdpbiArIFwiIFwiICsgeU9yaWdpbik7XG59LFxuICAgIF9wYXJzZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHVuY2FjaGUpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IG5ldyBHU0NhY2hlKHRhcmdldCk7XG5cbiAgaWYgKFwieFwiIGluIGNhY2hlICYmICF1bmNhY2hlICYmICFjYWNoZS51bmNhY2hlKSB7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgaW52ZXJ0ZWRTY2FsZVggPSBjYWNoZS5zY2FsZVggPCAwLFxuICAgICAgcHggPSBcInB4XCIsXG4gICAgICBkZWcgPSBcImRlZ1wiLFxuICAgICAgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCksXG4gICAgICBvcmlnaW4gPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB8fCBcIjBcIixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeixcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcm90YXRpb25YLFxuICAgICAgcm90YXRpb25ZLFxuICAgICAgc2tld1gsXG4gICAgICBza2V3WSxcbiAgICAgIHBlcnNwZWN0aXZlLFxuICAgICAgeE9yaWdpbixcbiAgICAgIHlPcmlnaW4sXG4gICAgICBtYXRyaXgsXG4gICAgICBhbmdsZSxcbiAgICAgIGNvcyxcbiAgICAgIHNpbixcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgYyxcbiAgICAgIGQsXG4gICAgICBhMTIsXG4gICAgICBhMjIsXG4gICAgICB0MSxcbiAgICAgIHQyLFxuICAgICAgdDMsXG4gICAgICBhMTMsXG4gICAgICBhMjMsXG4gICAgICBhMzMsXG4gICAgICBhNDIsXG4gICAgICBhNDMsXG4gICAgICBhMzI7XG4gIHggPSB5ID0geiA9IHJvdGF0aW9uID0gcm90YXRpb25YID0gcm90YXRpb25ZID0gc2tld1ggPSBza2V3WSA9IHBlcnNwZWN0aXZlID0gMDtcbiAgc2NhbGVYID0gc2NhbGVZID0gMTtcbiAgY2FjaGUuc3ZnID0gISEodGFyZ2V0LmdldENUTSAmJiBfaXNTVkcodGFyZ2V0KSk7XG5cbiAgaWYgKGNzLnRyYW5zbGF0ZSkge1xuICAgIC8vIGFjY29tbW9kYXRlIGluZGVwZW5kZW50IHRyYW5zZm9ybXMgYnkgY29tYmluaW5nIHRoZW0gaW50byBub3JtYWwgb25lcy5cbiAgICBpZiAoY3MudHJhbnNsYXRlICE9PSBcIm5vbmVcIiB8fCBjcy5zY2FsZSAhPT0gXCJub25lXCIgfHwgY3Mucm90YXRlICE9PSBcIm5vbmVcIikge1xuICAgICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKGNzLnRyYW5zbGF0ZSAhPT0gXCJub25lXCIgPyBcInRyYW5zbGF0ZTNkKFwiICsgKGNzLnRyYW5zbGF0ZSArIFwiIDAgMFwiKS5zcGxpdChcIiBcIikuc2xpY2UoMCwgMykuam9pbihcIiwgXCIpICsgXCIpIFwiIDogXCJcIikgKyAoY3Mucm90YXRlICE9PSBcIm5vbmVcIiA/IFwicm90YXRlKFwiICsgY3Mucm90YXRlICsgXCIpIFwiIDogXCJcIikgKyAoY3Muc2NhbGUgIT09IFwibm9uZVwiID8gXCJzY2FsZShcIiArIGNzLnNjYWxlLnNwbGl0KFwiIFwiKS5qb2luKFwiLFwiKSArIFwiKSBcIiA6IFwiXCIpICsgKGNzW190cmFuc2Zvcm1Qcm9wXSAhPT0gXCJub25lXCIgPyBjc1tfdHJhbnNmb3JtUHJvcF0gOiBcIlwiKTtcbiAgICB9XG5cbiAgICBzdHlsZS5zY2FsZSA9IHN0eWxlLnJvdGF0ZSA9IHN0eWxlLnRyYW5zbGF0ZSA9IFwibm9uZVwiO1xuICB9XG5cbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIGlmIChjYWNoZS51bmNhY2hlKSB7XG4gICAgICAvLyBpZiBjYWNoZS51bmNhY2hlIGlzIHRydWUgKGFuZCBtYXliZSBpZiBvcmlnaW4gaXMgMCwwKSwgd2UgbmVlZCB0byBzZXQgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAoY2FjaGUueE9yaWdpbiAtIGJib3gueCkgKyBcInB4IFwiICsgKGNhY2hlLnlPcmlnaW4gLSBiYm94LnkpICsgXCJweFwiLiBQcmV2aW91c2x5IHdlIGxldCB0aGUgZGF0YS1zdmctb3JpZ2luIHN0YXkgaW5zdGVhZCwgYnV0IHdoZW4gaW50cm9kdWNpbmcgcmV2ZXJ0KCksIGl0IGNvbXBsaWNhdGVkIHRoaW5ncy5cbiAgICAgIHQyID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgICAgIG9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gLSB0Mi54ICsgXCJweCBcIiArIChjYWNoZS55T3JpZ2luIC0gdDIueSkgKyBcInB4XCI7XG4gICAgICB0MSA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQxID0gIXVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTsgLy8gIFJlbWVtYmVyLCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGluY29uc2lzdGVuY2llcyB3ZSBhbHdheXMgZm9yY2UgU1ZHIGVsZW1lbnRzJyB0cmFuc2Zvcm1PcmlnaW4gdG8gMCwwIGFuZCBvZmZzZXQgdGhlIHRyYW5zbGF0aW9uIGFjY29yZGluZ2x5LlxuICAgIH1cblxuICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xuICB9XG5cbiAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcbiAgeU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblxuICBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuICAgIGEgPSBtYXRyaXhbMF07IC8vYTExXG5cbiAgICBiID0gbWF0cml4WzFdOyAvL2EyMVxuXG4gICAgYyA9IG1hdHJpeFsyXTsgLy9hMzFcblxuICAgIGQgPSBtYXRyaXhbM107IC8vYTQxXG5cbiAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xuICAgIHkgPSBhMjIgPSBtYXRyaXhbNV07IC8vMkQgbWF0cml4XG5cbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgc2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuICAgICAgcm90YXRpb24gPSBhIHx8IGIgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cbiAgICAgIHNrZXdYID0gYyB8fCBkID8gX2F0YW4yKGMsIGQpICogX1JBRDJERUcgKyByb3RhdGlvbiA6IDA7XG4gICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguYWJzKE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKSk7XG5cbiAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgeCAtPSB4T3JpZ2luIC0gKHhPcmlnaW4gKiBhICsgeU9yaWdpbiAqIGMpO1xuICAgICAgICB5IC09IHlPcmlnaW4gLSAoeE9yaWdpbiAqIGIgKyB5T3JpZ2luICogZCk7XG4gICAgICB9IC8vM0QgbWF0cml4XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYTMyID0gbWF0cml4WzZdO1xuICAgICAgYTQyID0gbWF0cml4WzddO1xuICAgICAgYTEzID0gbWF0cml4WzhdO1xuICAgICAgYTIzID0gbWF0cml4WzldO1xuICAgICAgYTMzID0gbWF0cml4WzEwXTtcbiAgICAgIGE0MyA9IG1hdHJpeFsxMV07XG4gICAgICB4ID0gbWF0cml4WzEyXTtcbiAgICAgIHkgPSBtYXRyaXhbMTNdO1xuICAgICAgeiA9IG1hdHJpeFsxNF07XG4gICAgICBhbmdsZSA9IF9hdGFuMihhMzIsIGEzMyk7XG4gICAgICByb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHOyAvL3JvdGF0aW9uWFxuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgdDEgPSBhMTIgKiBjb3MgKyBhMTMgKiBzaW47XG4gICAgICAgIHQyID0gYTIyICogY29zICsgYTIzICogc2luO1xuICAgICAgICB0MyA9IGEzMiAqIGNvcyArIGEzMyAqIHNpbjtcbiAgICAgICAgYTEzID0gYTEyICogLXNpbiArIGExMyAqIGNvcztcbiAgICAgICAgYTIzID0gYTIyICogLXNpbiArIGEyMyAqIGNvcztcbiAgICAgICAgYTMzID0gYTMyICogLXNpbiArIGEzMyAqIGNvcztcbiAgICAgICAgYTQzID0gYTQyICogLXNpbiArIGE0MyAqIGNvcztcbiAgICAgICAgYTEyID0gdDE7XG4gICAgICAgIGEyMiA9IHQyO1xuICAgICAgICBhMzIgPSB0MztcbiAgICAgIH0gLy9yb3RhdGlvbllcblxuXG4gICAgICBhbmdsZSA9IF9hdGFuMigtYywgYTMzKTtcbiAgICAgIHJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGEgKiBjb3MgLSBhMTMgKiBzaW47XG4gICAgICAgIHQyID0gYiAqIGNvcyAtIGEyMyAqIHNpbjtcbiAgICAgICAgdDMgPSBjICogY29zIC0gYTMzICogc2luO1xuICAgICAgICBhNDMgPSBkICogc2luICsgYTQzICogY29zO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGIgPSB0MjtcbiAgICAgICAgYyA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWlxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKGIsIGEpO1xuICAgICAgcm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyArIGIgKiBzaW47XG4gICAgICAgIHQyID0gYTEyICogY29zICsgYTIyICogc2luO1xuICAgICAgICBiID0gYiAqIGNvcyAtIGEgKiBzaW47XG4gICAgICAgIGEyMiA9IGEyMiAqIGNvcyAtIGExMiAqIHNpbjtcbiAgICAgICAgYSA9IHQxO1xuICAgICAgICBhMTIgPSB0MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uWCAmJiBNYXRoLmFicyhyb3RhdGlvblgpICsgTWF0aC5hYnMocm90YXRpb24pID4gMzU5LjkpIHtcbiAgICAgICAgLy93aGVuIHJvdGF0aW9uWSBpcyBzZXQsIGl0IHdpbGwgb2Z0ZW4gYmUgcGFyc2VkIGFzIDE4MCBkZWdyZWVzIGRpZmZlcmVudCB0aGFuIGl0IHNob3VsZCBiZSwgYW5kIHJvdGF0aW9uWCBhbmQgcm90YXRpb24gYm90aCBiZWluZyAxODAgKGl0IGxvb2tzIHRoZSBzYW1lKSwgc28gd2UgYWRqdXN0IGZvciB0aGF0IGhlcmUuXG4gICAgICAgIHJvdGF0aW9uWCA9IHJvdGF0aW9uID0gMDtcbiAgICAgICAgcm90YXRpb25ZID0gMTgwIC0gcm90YXRpb25ZO1xuICAgICAgfVxuXG4gICAgICBzY2FsZVggPSBfcm91bmQoTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYykpO1xuICAgICAgc2NhbGVZID0gX3JvdW5kKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMzIgKiBhMzIpKTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGExMiwgYTIyKTtcbiAgICAgIHNrZXdYID0gTWF0aC5hYnMoYW5nbGUpID4gMC4wMDAyID8gYW5nbGUgKiBfUkFEMkRFRyA6IDA7XG4gICAgICBwZXJzcGVjdGl2ZSA9IGE0MyA/IDEgLyAoYTQzIDwgMCA/IC1hNDMgOiBhNDMpIDogMDtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAvL3NlbnNlIGlmIHRoZXJlIGFyZSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9uIGFuIFNWRyBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB3aGVuIHJlbmRlcmluZy4gVGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaXMgbW9yZSByZWxpYWJsZSBjcm9zcy1icm93c2VyLCBidXQgd2UgY2FuJ3QganVzdCByZW1vdmUgdGhlIENTUyBvbmVzIGJlY2F1c2UgdGhleSBtYXkgYmUgYXBwbGllZCBpbiBhIENTUyBydWxlIHNvbWV3aGVyZSAobm90IGp1c3QgaW5saW5lKS5cbiAgICAgIHQxID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgIGNhY2hlLmZvcmNlQ1NTID0gdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIlwiKSB8fCAhX2lzTnVsbFRyYW5zZm9ybShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKSk7XG4gICAgICB0MSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHQxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc2tld1gpID4gOTAgJiYgTWF0aC5hYnMoc2tld1gpIDwgMjcwKSB7XG4gICAgaWYgKGludmVydGVkU2NhbGVYKSB7XG4gICAgICBzY2FsZVggKj0gLTE7XG4gICAgICBza2V3WCArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcbiAgICAgIHJvdGF0aW9uICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZVkgKj0gLTE7XG4gICAgICBza2V3WCArPSBza2V3WCA8PSAwID8gMTgwIDogLTE4MDtcbiAgICB9XG4gIH1cblxuICB1bmNhY2hlID0gdW5jYWNoZSB8fCBjYWNoZS51bmNhY2hlO1xuICBjYWNoZS54ID0geCAtICgoY2FjaGUueFBlcmNlbnQgPSB4ICYmICghdW5jYWNoZSAmJiBjYWNoZS54UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0V2lkdGggLyAyKSA9PT0gTWF0aC5yb3VuZCgteCkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldFdpZHRoICogY2FjaGUueFBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuICBjYWNoZS55ID0geSAtICgoY2FjaGUueVBlcmNlbnQgPSB5ICYmICghdW5jYWNoZSAmJiBjYWNoZS55UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0SGVpZ2h0IC8gMikgPT09IE1hdGgucm91bmQoLXkpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRIZWlnaHQgKiBjYWNoZS55UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnogPSB6ICsgcHg7XG4gIGNhY2hlLnNjYWxlWCA9IF9yb3VuZChzY2FsZVgpO1xuICBjYWNoZS5zY2FsZVkgPSBfcm91bmQoc2NhbGVZKTtcbiAgY2FjaGUucm90YXRpb24gPSBfcm91bmQocm90YXRpb24pICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblggPSBfcm91bmQocm90YXRpb25YKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25ZID0gX3JvdW5kKHJvdGF0aW9uWSkgKyBkZWc7XG4gIGNhY2hlLnNrZXdYID0gc2tld1ggKyBkZWc7XG4gIGNhY2hlLnNrZXdZID0gc2tld1kgKyBkZWc7XG4gIGNhY2hlLnRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmUgKyBweDtcblxuICBpZiAoY2FjaGUuek9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luLnNwbGl0KFwiIFwiKVsyXSkgfHwgIXVuY2FjaGUgJiYgY2FjaGUuek9yaWdpbiB8fCAwKSB7XG4gICAgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gX2ZpcnN0VHdvT25seShvcmlnaW4pO1xuICB9XG5cbiAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICBjYWNoZS5mb3JjZTNEID0gX2NvbmZpZy5mb3JjZTNEO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gPSBjYWNoZS5zdmcgPyBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA6IF9zdXBwb3J0czNEID8gX3JlbmRlckNTU1RyYW5zZm9ybXMgOiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zO1xuICBjYWNoZS51bmNhY2hlID0gMDtcbiAgcmV0dXJuIGNhY2hlO1xufSxcbiAgICBfZmlyc3RUd29Pbmx5ID0gZnVuY3Rpb24gX2ZpcnN0VHdvT25seSh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlID0gdmFsdWUuc3BsaXQoXCIgXCIpKVswXSArIFwiIFwiICsgdmFsdWVbMV07XG59LFxuICAgIC8vZm9yIGhhbmRsaW5nIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMsIHN0cmlwcGluZyBvdXQgdGhlIDNyZCBkaW1lbnNpb25cbl9hZGRQeFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgdW5pdCA9IGdldFVuaXQoc3RhcnQpO1xuICByZXR1cm4gX3JvdW5kKHBhcnNlRmxvYXQoc3RhcnQpICsgcGFyc2VGbG9hdChfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieFwiLCB2YWx1ZSArIFwicHhcIiwgdW5pdCkpKSArIHVuaXQ7XG59LFxuICAgIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICBjYWNoZS56ID0gXCIwcHhcIjtcbiAgY2FjaGUucm90YXRpb25ZID0gY2FjaGUucm90YXRpb25YID0gXCIwZGVnXCI7XG4gIGNhY2hlLmZvcmNlM0QgPSAwO1xuXG4gIF9yZW5kZXJDU1NUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF96ZXJvRGVnID0gXCIwZGVnXCIsXG4gICAgX3plcm9QeCA9IFwiMHB4XCIsXG4gICAgX2VuZFBhcmVudGhlc2lzID0gXCIpIFwiLFxuICAgIF9yZW5kZXJDU1NUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIHZhciBfcmVmID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZi54UGVyY2VudCxcbiAgICAgIHlQZXJjZW50ID0gX3JlZi55UGVyY2VudCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgeiA9IF9yZWYueixcbiAgICAgIHJvdGF0aW9uID0gX3JlZi5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uWSA9IF9yZWYucm90YXRpb25ZLFxuICAgICAgcm90YXRpb25YID0gX3JlZi5yb3RhdGlvblgsXG4gICAgICBza2V3WCA9IF9yZWYuc2tld1gsXG4gICAgICBza2V3WSA9IF9yZWYuc2tld1ksXG4gICAgICBzY2FsZVggPSBfcmVmLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgICAgdHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBfcmVmLnRyYW5zZm9ybVBlcnNwZWN0aXZlLFxuICAgICAgZm9yY2UzRCA9IF9yZWYuZm9yY2UzRCxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgek9yaWdpbiA9IF9yZWYuek9yaWdpbixcbiAgICAgIHRyYW5zZm9ybXMgPSBcIlwiLFxuICAgICAgdXNlM0QgPSBmb3JjZTNEID09PSBcImF1dG9cIiAmJiByYXRpbyAmJiByYXRpbyAhPT0gMSB8fCBmb3JjZTNEID09PSB0cnVlOyAvLyBTYWZhcmkgaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGl0IG5vdCB0byByZW5kZXIgM0QgdHJhbnNmb3JtLW9yaWdpbiB2YWx1ZXMgcHJvcGVybHksIHNvIHdlIGZvcmNlIHRoZSB6IG9yaWdpbiB0byAwLCByZWNvcmQgaXQgaW4gdGhlIGNhY2hlLCBhbmQgdGhlbiBkbyB0aGUgbWF0aCBoZXJlIHRvIG9mZnNldCB0aGUgdHJhbnNsYXRlIHZhbHVlcyBhY2NvcmRpbmdseSAoYmFzaWNhbGx5IGRvIHRoZSAzRCB0cmFuc2Zvcm0tb3JpZ2luIHBhcnQgbWFudWFsbHkpXG5cblxuICBpZiAoek9yaWdpbiAmJiAocm90YXRpb25YICE9PSBfemVyb0RlZyB8fCByb3RhdGlvblkgIT09IF96ZXJvRGVnKSkge1xuICAgIHZhciBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25ZKSAqIF9ERUcyUkFELFxuICAgICAgICBhMTMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGEzMyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgY29zO1xuXG4gICAgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWCkgKiBfREVHMlJBRDtcbiAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgeCA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHgsIGExMyAqIGNvcyAqIC16T3JpZ2luKTtcbiAgICB5ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeSwgLU1hdGguc2luKGFuZ2xlKSAqIC16T3JpZ2luKTtcbiAgICB6ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeiwgYTMzICogY29zICogLXpPcmlnaW4gKyB6T3JpZ2luKTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSAhPT0gX3plcm9QeCkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJwZXJzcGVjdGl2ZShcIiArIHRyYW5zZm9ybVBlcnNwZWN0aXZlICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInRyYW5zbGF0ZShcIiArIHhQZXJjZW50ICsgXCIlLCBcIiArIHlQZXJjZW50ICsgXCIlKSBcIjtcbiAgfVxuXG4gIGlmICh1c2UzRCB8fCB4ICE9PSBfemVyb1B4IHx8IHkgIT09IF96ZXJvUHggfHwgeiAhPT0gX3plcm9QeCkge1xuICAgIHRyYW5zZm9ybXMgKz0geiAhPT0gX3plcm9QeCB8fCB1c2UzRCA/IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiLCBcIiArIHogKyBcIikgXCIgOiBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGUoXCIgKyByb3RhdGlvbiArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblkgIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVkoXCIgKyByb3RhdGlvblkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb25YICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVYKFwiICsgcm90YXRpb25YICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHNrZXdYICE9PSBfemVyb0RlZyB8fCBza2V3WSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwic2tldyhcIiArIHNrZXdYICsgXCIsIFwiICsgc2tld1kgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJzY2FsZShcIiArIHNjYWxlWCArIFwiLCBcIiArIHNjYWxlWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zIHx8IFwidHJhbnNsYXRlKDAsIDApXCI7XG59LFxuICAgIF9yZW5kZXJTVkdUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlclNWR1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIHZhciBfcmVmMiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICB4UGVyY2VudCA9IF9yZWYyLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmMi55UGVyY2VudCxcbiAgICAgIHggPSBfcmVmMi54LFxuICAgICAgeSA9IF9yZWYyLnksXG4gICAgICByb3RhdGlvbiA9IF9yZWYyLnJvdGF0aW9uLFxuICAgICAgc2tld1ggPSBfcmVmMi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZjIuc2tld1ksXG4gICAgICBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB4T3JpZ2luID0gX3JlZjIueE9yaWdpbixcbiAgICAgIHlPcmlnaW4gPSBfcmVmMi55T3JpZ2luLFxuICAgICAgeE9mZnNldCA9IF9yZWYyLnhPZmZzZXQsXG4gICAgICB5T2Zmc2V0ID0gX3JlZjIueU9mZnNldCxcbiAgICAgIGZvcmNlQ1NTID0gX3JlZjIuZm9yY2VDU1MsXG4gICAgICB0eCA9IHBhcnNlRmxvYXQoeCksXG4gICAgICB0eSA9IHBhcnNlRmxvYXQoeSksXG4gICAgICBhMTEsXG4gICAgICBhMjEsXG4gICAgICBhMTIsXG4gICAgICBhMjIsXG4gICAgICB0ZW1wO1xuXG4gIHJvdGF0aW9uID0gcGFyc2VGbG9hdChyb3RhdGlvbik7XG4gIHNrZXdYID0gcGFyc2VGbG9hdChza2V3WCk7XG4gIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG5cbiAgaWYgKHNrZXdZKSB7XG4gICAgLy9mb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgY29tYmluZSBhbGwgc2tld2luZyBpbnRvIHRoZSBza2V3WCBhbmQgcm90YXRpb24gdmFsdWVzLiBSZW1lbWJlciwgYSBza2V3WSBvZiAxMCBkZWdyZWVzIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgZGVncmVlcyBwbHVzIGEgc2tld1ggb2YgMTAgZGVncmVlcy5cbiAgICBza2V3WSA9IHBhcnNlRmxvYXQoc2tld1kpO1xuICAgIHNrZXdYICs9IHNrZXdZO1xuICAgIHJvdGF0aW9uICs9IHNrZXdZO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uIHx8IHNrZXdYKSB7XG4gICAgcm90YXRpb24gKj0gX0RFRzJSQUQ7XG4gICAgc2tld1ggKj0gX0RFRzJSQUQ7XG4gICAgYTExID0gTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYO1xuICAgIGEyMSA9IE1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWDtcbiAgICBhMTIgPSBNYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIC1zY2FsZVk7XG4gICAgYTIyID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG5cbiAgICBpZiAoc2tld1gpIHtcbiAgICAgIHNrZXdZICo9IF9ERUcyUkFEO1xuICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdYIC0gc2tld1kpO1xuICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgYTEyICo9IHRlbXA7XG4gICAgICBhMjIgKj0gdGVtcDtcblxuICAgICAgaWYgKHNrZXdZKSB7XG4gICAgICAgIHRlbXAgPSBNYXRoLnRhbihza2V3WSk7XG4gICAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcbiAgICAgICAgYTExICo9IHRlbXA7XG4gICAgICAgIGEyMSAqPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGExMSA9IF9yb3VuZChhMTEpO1xuICAgIGEyMSA9IF9yb3VuZChhMjEpO1xuICAgIGExMiA9IF9yb3VuZChhMTIpO1xuICAgIGEyMiA9IF9yb3VuZChhMjIpO1xuICB9IGVsc2Uge1xuICAgIGExMSA9IHNjYWxlWDtcbiAgICBhMjIgPSBzY2FsZVk7XG4gICAgYTIxID0gYTEyID0gMDtcbiAgfVxuXG4gIGlmICh0eCAmJiAhfih4ICsgXCJcIikuaW5kZXhPZihcInB4XCIpIHx8IHR5ICYmICF+KHkgKyBcIlwiKS5pbmRleE9mKFwicHhcIikpIHtcbiAgICB0eCA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHgsIFwicHhcIik7XG4gICAgdHkgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieVwiLCB5LCBcInB4XCIpO1xuICB9XG5cbiAgaWYgKHhPcmlnaW4gfHwgeU9yaWdpbiB8fCB4T2Zmc2V0IHx8IHlPZmZzZXQpIHtcbiAgICB0eCA9IF9yb3VuZCh0eCArIHhPcmlnaW4gLSAoeE9yaWdpbiAqIGExMSArIHlPcmlnaW4gKiBhMTIpICsgeE9mZnNldCk7XG4gICAgdHkgPSBfcm91bmQodHkgKyB5T3JpZ2luIC0gKHhPcmlnaW4gKiBhMjEgKyB5T3JpZ2luICogYTIyKSArIHlPZmZzZXQpO1xuICB9XG5cbiAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgLy9UaGUgU1ZHIHNwZWMgZG9lc24ndCBzdXBwb3J0IHBlcmNlbnRhZ2UtYmFzZWQgdHJhbnNsYXRpb24gaW4gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBzbyB3ZSBtZXJnZSBpdCBpbnRvIHRoZSB0cmFuc2xhdGlvbiB0byBzaW11bGF0ZSBpdC5cbiAgICB0ZW1wID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB0eCA9IF9yb3VuZCh0eCArIHhQZXJjZW50IC8gMTAwICogdGVtcC53aWR0aCk7XG4gICAgdHkgPSBfcm91bmQodHkgKyB5UGVyY2VudCAvIDEwMCAqIHRlbXAuaGVpZ2h0KTtcbiAgfVxuXG4gIHRlbXAgPSBcIm1hdHJpeChcIiArIGExMSArIFwiLFwiICsgYTIxICsgXCIsXCIgKyBhMTIgKyBcIixcIiArIGEyMiArIFwiLFwiICsgdHggKyBcIixcIiArIHR5ICsgXCIpXCI7XG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGVtcCk7XG4gIGZvcmNlQ1NTICYmICh0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdGVtcCk7IC8vc29tZSBicm93c2VycyBwcmlvcml0aXplIENTUyB0cmFuc2Zvcm1zIG92ZXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUuIFdoZW4gd2Ugc2Vuc2UgdGhhdCB0aGUgdXNlciBoYXMgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCwgd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB0aGlzIHdheSAob3RoZXJ3aXNlIHNvbWUgYnJvd3NlciBzaW1wbHkgd29uJ3QgcmVuZGVyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGNoYW5nZXMhKVxufSxcbiAgICBfYWRkUm90YXRpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGVuZFZhbHVlKSB7XG4gIHZhciBjYXAgPSAzNjAsXG4gICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKSAqIChpc1N0cmluZyAmJiB+ZW5kVmFsdWUuaW5kZXhPZihcInJhZFwiKSA/IF9SQUQyREVHIDogMSksXG4gICAgICBjaGFuZ2UgPSBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwdDtcblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBkaXJlY3Rpb24gPSBlbmRWYWx1ZS5zcGxpdChcIl9cIilbMV07XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInNob3J0XCIpIHtcbiAgICAgIGNoYW5nZSAlPSBjYXA7XG5cbiAgICAgIGlmIChjaGFuZ2UgIT09IGNoYW5nZSAlIChjYXAgLyAyKSkge1xuICAgICAgICBjaGFuZ2UgKz0gY2hhbmdlIDwgMCA/IGNhcCA6IC1jYXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJjd1wiICYmIGNoYW5nZSA8IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgKyBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiY2N3XCIgJiYgY2hhbmdlID4gMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9XG4gIH1cblxuICBwbHVnaW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBjaGFuZ2UsIF9yZW5kZXJQcm9wV2l0aEVuZCk7XG4gIHB0LmUgPSBmaW5hbFZhbHVlO1xuICBwdC51ID0gXCJkZWdcIjtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2Fzc2lnbiA9IGZ1bmN0aW9uIF9hc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCBoYXZlIE9iamVjdC5hc3NpZ24oKSwgc28gd2UgcmVjcmVhdGUgaXQgaGVyZS5cbiAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICB0YXJnZXRbcF0gPSBzb3VyY2VbcF07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSxcbiAgICBfYWRkUmF3VHJhbnNmb3JtUFRzID0gZnVuY3Rpb24gX2FkZFJhd1RyYW5zZm9ybVBUcyhwbHVnaW4sIHRyYW5zZm9ybXMsIHRhcmdldCkge1xuICAvL2ZvciBoYW5kbGluZyBjYXNlcyB3aGVyZSBzb21lb25lIHBhc3NlcyBpbiBhIHdob2xlIHRyYW5zZm9ybSBzdHJpbmcsIGxpa2UgdHJhbnNmb3JtOiBcInNjYWxlKDIsIDMpIHJvdGF0ZSgyMGRlZykgdHJhbnNsYXRlWSgzMGVtKVwiXG4gIHZhciBzdGFydENhY2hlID0gX2Fzc2lnbih7fSwgdGFyZ2V0Ll9nc2FwKSxcbiAgICAgIGV4Y2x1ZGUgPSBcInBlcnNwZWN0aXZlLGZvcmNlM0QsdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpblwiLFxuICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBlbmRDYWNoZSxcbiAgICAgIHAsXG4gICAgICBzdGFydFZhbHVlLFxuICAgICAgZW5kVmFsdWUsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGVuZE51bSxcbiAgICAgIHN0YXJ0VW5pdCxcbiAgICAgIGVuZFVuaXQ7XG5cbiAgaWYgKHN0YXJ0Q2FjaGUuc3ZnKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIlwiKTtcbiAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuICAgIGVuZENhY2hlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG5cbiAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0YXJ0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0VmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldClbX3RyYW5zZm9ybVByb3BdO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcbiAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBzdGFydFZhbHVlO1xuICB9XG5cbiAgZm9yIChwIGluIF90cmFuc2Zvcm1Qcm9wcykge1xuICAgIHN0YXJ0VmFsdWUgPSBzdGFydENhY2hlW3BdO1xuICAgIGVuZFZhbHVlID0gZW5kQ2FjaGVbcF07XG5cbiAgICBpZiAoc3RhcnRWYWx1ZSAhPT0gZW5kVmFsdWUgJiYgZXhjbHVkZS5pbmRleE9mKHApIDwgMCkge1xuICAgICAgLy90d2VlbmluZyB0byBubyBwZXJzcGVjdGl2ZSBnaXZlcyB2ZXJ5IHVuaW50dWl0aXZlIHJlc3VsdHMgLSBqdXN0IGtlZXAgdGhlIHNhbWUgcGVyc3BlY3RpdmUgaW4gdGhhdCBjYXNlLlxuICAgICAgc3RhcnRVbml0ID0gZ2V0VW5pdChzdGFydFZhbHVlKTtcbiAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgIHN0YXJ0TnVtID0gc3RhcnRVbml0ICE9PSBlbmRVbml0ID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSA6IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgIHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIGVuZENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgIHBsdWdpbi5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxuXG4gIF9hc3NpZ24oZW5kQ2FjaGUsIHN0YXJ0Q2FjaGUpO1xufTsgLy8gaGFuZGxlIHNwbGl0dGluZyBhcGFydCBwYWRkaW5nLCBtYXJnaW4sIGJvcmRlcldpZHRoLCBhbmQgYm9yZGVyUmFkaXVzIGludG8gdGhlaXIgNCBjb21wb25lbnRzLiBGaXJlZm94LCBmb3IgZXhhbXBsZSwgd29uJ3QgcmVwb3J0IGJvcmRlclJhZGl1cyBjb3JyZWN0bHkgLSBpdCB3aWxsIG9ubHkgZG8gYm9yZGVyVG9wTGVmdFJhZGl1cyBhbmQgdGhlIG90aGVyIGNvcm5lcnMuIFdlIGFsc28gd2FudCB0byBoYW5kbGUgcGFkZGluZ1RvcCwgbWFyZ2luTGVmdCwgYm9yZGVyUmlnaHRXaWR0aCwgZXRjLlxuXG5cbl9mb3JFYWNoTmFtZShcInBhZGRpbmcsbWFyZ2luLFdpZHRoLFJhZGl1c1wiLCBmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgdmFyIHQgPSBcIlRvcFwiLFxuICAgICAgciA9IFwiUmlnaHRcIixcbiAgICAgIGIgPSBcIkJvdHRvbVwiLFxuICAgICAgbCA9IFwiTGVmdFwiLFxuICAgICAgcHJvcHMgPSAoaW5kZXggPCAzID8gW3QsIHIsIGIsIGxdIDogW3QgKyBsLCB0ICsgciwgYiArIHIsIGIgKyBsXSkubWFwKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIGluZGV4IDwgMiA/IG5hbWUgKyBzaWRlIDogXCJib3JkZXJcIiArIHNpZGUgKyBuYW1lO1xuICB9KTtcblxuICBfc3BlY2lhbFByb3BzW2luZGV4ID4gMSA/IFwiYm9yZGVyXCIgKyBuYW1lIDogbmFtZV0gPSBmdW5jdGlvbiAocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICB2YXIgYSwgdmFycztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkge1xuICAgICAgLy8gZ2V0dGVyLCBwYXNzZWQgdGFyZ2V0LCBwcm9wZXJ0eSwgYW5kIHVuaXQgKGZyb20gX2dldCgpKVxuICAgICAgYSA9IHByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gX2dldChwbHVnaW4sIHByb3AsIHByb3BlcnR5KTtcbiAgICAgIH0pO1xuICAgICAgdmFycyA9IGEuam9pbihcIiBcIik7XG4gICAgICByZXR1cm4gdmFycy5zcGxpdChhWzBdKS5sZW5ndGggPT09IDUgPyBhWzBdIDogdmFycztcbiAgICB9XG5cbiAgICBhID0gKGVuZFZhbHVlICsgXCJcIikuc3BsaXQoXCIgXCIpO1xuICAgIHZhcnMgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICByZXR1cm4gdmFyc1twcm9wXSA9IGFbaV0gPSBhW2ldIHx8IGFbKGkgLSAxKSAvIDIgfCAwXTtcbiAgICB9KTtcbiAgICBwbHVnaW4uaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKTtcbiAgfTtcbn0pO1xuXG5leHBvcnQgdmFyIENTU1BsdWdpbiA9IHtcbiAgbmFtZTogXCJjc3NcIixcbiAgcmVnaXN0ZXI6IF9pbml0Q29yZSxcbiAgdGFyZ2V0VGVzdDogZnVuY3Rpb24gdGFyZ2V0VGVzdCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnN0eWxlICYmIHRhcmdldC5ub2RlVHlwZTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzLFxuICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgc3RhcnRBdCA9IHR3ZWVuLnZhcnMuc3RhcnRBdCxcbiAgICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgICAgZW5kVmFsdWUsXG4gICAgICAgIGVuZE51bSxcbiAgICAgICAgc3RhcnROdW0sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHNwZWNpYWxQcm9wLFxuICAgICAgICBwLFxuICAgICAgICBzdGFydFVuaXQsXG4gICAgICAgIGVuZFVuaXQsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQsXG4gICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbixcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgaGFzUHJpb3JpdHksXG4gICAgICAgIGlubGluZVByb3BzO1xuICAgIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpOyAvLyB3ZSBtYXkgY2FsbCBpbml0KCkgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgcGx1Z2luIGluc3RhbmNlLCBsaWtlIHdoZW4gYWRkaW5nIHNwZWNpYWwgcHJvcGVydGllcywgc28gbWFrZSBzdXJlIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgcmV2ZXJ0IGRhdGEgb3IgaW5saW5lUHJvcHNcblxuICAgIHRoaXMuc3R5bGVzID0gdGhpcy5zdHlsZXMgfHwgX2dldFN0eWxlU2F2ZXIodGFyZ2V0KTtcbiAgICBpbmxpbmVQcm9wcyA9IHRoaXMuc3R5bGVzLnByb3BzO1xuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpZiAocCA9PT0gXCJhdXRvUm91bmRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xuXG4gICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkge1xuICAgICAgICAvLyBwbHVnaW5zXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZW9mIGVuZFZhbHVlO1xuICAgICAgc3BlY2lhbFByb3AgPSBfc3BlY2lhbFByb3BzW3BdO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgICBlbmRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKGVuZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWNpYWxQcm9wKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH0gZWxzZSBpZiAocC5zdWJzdHIoMCwgMikgPT09IFwiLS1cIikge1xuICAgICAgICAvL0NTUyB2YXJpYWJsZVxuICAgICAgICBzdGFydFZhbHVlID0gKGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIikudHJpbSgpO1xuICAgICAgICBlbmRWYWx1ZSArPSBcIlwiO1xuICAgICAgICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICAgICAgICBpZiAoIV9jb2xvckV4cC50ZXN0KHN0YXJ0VmFsdWUpKSB7XG4gICAgICAgICAgLy8gY29sb3JzIGRvbid0IGhhdmUgdW5pdHNcbiAgICAgICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XG4gICAgICAgIHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICAgIGlubGluZVByb3BzLnB1c2gocCwgMCwgc3R5bGVbcF0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzdGFydEF0ICYmIHAgaW4gc3RhcnRBdCkge1xuICAgICAgICAgIC8vIGluIGNhc2Ugc29tZW9uZSBoYXJkLWNvZGVzIGEgY29tcGxleCB2YWx1ZSBhcyB0aGUgc3RhcnQsIGxpa2UgdG9wOiBcImNhbGMoMnZoIC8gMilcIi4gV2l0aG91dCB0aGlzLCBpdCdkIHVzZSB0aGUgY29tcHV0ZWQgdmFsdWUgKGFsd2F5cyBpbiBweClcbiAgICAgICAgICBzdGFydFZhbHVlID0gdHlwZW9mIHN0YXJ0QXRbcF0gPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QXRbcF0uY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiBzdGFydEF0W3BdO1xuICAgICAgICAgIF9pc1N0cmluZyhzdGFydFZhbHVlKSAmJiB+c3RhcnRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSAmJiAoc3RhcnRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKHN0YXJ0VmFsdWUpKTtcbiAgICAgICAgICBnZXRVbml0KHN0YXJ0VmFsdWUgKyBcIlwiKSB8fCBzdGFydFZhbHVlID09PSBcImF1dG9cIiB8fCAoc3RhcnRWYWx1ZSArPSBfY29uZmlnLnVuaXRzW3BdIHx8IGdldFVuaXQoX2dldCh0YXJnZXQsIHApKSB8fCBcIlwiKTsgLy8gZm9yIGNhc2VzIHdoZW4gc29tZW9uZSBwYXNzZXMgaW4gYSB1bml0bGVzcyB2YWx1ZSBsaWtlIHt4OiAxMDB9OyBpZiB3ZSB0cnkgc2V0dGluZyB0cmFuc2xhdGUoMTAwLCAwcHgpIGl0IHdvbid0IHdvcmsuXG5cbiAgICAgICAgICAoc3RhcnRWYWx1ZSArIFwiXCIpLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgKHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCkpOyAvLyBjYW4ndCB3b3JrIHdpdGggcmVsYXRpdmUgdmFsdWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgICAgcmVsYXRpdmUgPSB0eXBlID09PSBcInN0cmluZ1wiICYmIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgZW5kVmFsdWUuc3Vic3RyKDAsIDIpO1xuICAgICAgICByZWxhdGl2ZSAmJiAoZW5kVmFsdWUgPSBlbmRWYWx1ZS5zdWJzdHIoMikpO1xuICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcblxuICAgICAgICBpZiAocCBpbiBfcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgICAgICAgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcbiAgICAgICAgICAgIC8vc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgYWxvbmcgd2l0aCBvcGFjaXR5LiBXZSBzdGlsbCBhbGxvdyB0aGUgb3BhY2l0eSB2YWx1ZSB0byBwYXNzIHRocm91Z2ggYW5kIGdldCB0d2VlbmVkLlxuICAgICAgICAgICAgaWYgKHN0YXJ0TnVtID09PSAxICYmIF9nZXQodGFyZ2V0LCBcInZpc2liaWxpdHlcIikgPT09IFwiaGlkZGVuXCIgJiYgZW5kTnVtKSB7XG4gICAgICAgICAgICAgIC8vaWYgdmlzaWJpbGl0eSBpcyBpbml0aWFsbHkgc2V0IHRvIFwiaGlkZGVuXCIsIHdlIHNob3VsZCBpbnRlcnByZXQgdGhhdCBhcyBpbnRlbnQgdG8gbWFrZSBvcGFjaXR5IDAgKGEgY29udmVuaWVuY2UpXG4gICAgICAgICAgICAgIHN0YXJ0TnVtID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5saW5lUHJvcHMucHVzaChcInZpc2liaWxpdHlcIiwgMCwgc3R5bGUudmlzaWJpbGl0eSk7XG5cbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcbiAgICAgICAgICAgIH5wLmluZGV4T2YoXCIsXCIpICYmIChwID0gcC5zcGxpdChcIixcIilbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCA9IHAgaW4gX3RyYW5zZm9ybVByb3BzOyAvLy0tLSBUUkFOU0ZPUk0tUkVMQVRFRCAtLS1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXMuc2F2ZShwKTtcblxuICAgICAgICAgIGlmICghdHJhbnNmb3JtUHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgICAgICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSAmJiAhdmFycy5wYXJzZVRyYW5zZm9ybSB8fCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB2YXJzLnBhcnNlVHJhbnNmb3JtKTsgLy8gaWYsIGZvciBleGFtcGxlLCBnc2FwLnNldCguLi4ge3RyYW5zZm9ybTpcInRyYW5zbGF0ZVgoNTB2dylcIn0pLCB0aGUgX2dldCgpIGNhbGwgZG9lc24ndCBwYXJzZSB0aGUgdHJhbnNmb3JtLCB0aHVzIGNhY2hlLnJlbmRlclRyYW5zZm9ybSB3b24ndCBiZSBzZXQgeWV0IHNvIGZvcmNlIHRoZSBwYXJzaW5nIG9mIHRoZSB0cmFuc2Zvcm0gaGVyZS5cblxuICAgICAgICAgICAgc21vb3RoID0gdmFycy5zbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIGNhY2hlLnNtb290aDtcbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbiA9IHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgc3R5bGUsIF90cmFuc2Zvcm1Qcm9wLCAwLCAxLCBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0sIGNhY2hlLCAwLCAtMSk7IC8vdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCwgY3JlYXRlIHRoZSByZW5kZXJpbmcgUHJvcFR3ZWVuIHNvIHRoYXQgaXQgcnVucyBMQVNUIChpbiB0aGUgbGlua2VkIGxpc3QsIHdlIGtlZXAgYWRkaW5nIHRvIHRoZSBiZWdpbm5pbmcpXG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2Vlbi5kZXAgPSAxOyAvL2ZsYWcgaXQgYXMgZGVwZW5kZW50IHNvIHRoYXQgaWYgdGhpbmdzIGdldCBraWxsZWQvb3ZlcndyaXR0ZW4gYW5kIHRoaXMgaXMgdGhlIG9ubHkgUHJvcFR3ZWVuIGxlZnQsIHdlIGNhbiBzYWZlbHkga2lsbCB0aGUgd2hvbGUgdHdlZW4uXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBjYWNoZSwgXCJzY2FsZVlcIiwgY2FjaGUuc2NhbGVZLCAocmVsYXRpdmUgPyBfcGFyc2VSZWxhdGl2ZShjYWNoZS5zY2FsZVksIHJlbGF0aXZlICsgZW5kTnVtKSA6IGVuZE51bSkgLSBjYWNoZS5zY2FsZVkgfHwgMCwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgICAgICAgdGhpcy5fcHQudSA9IDA7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKFwic2NhbGVZXCIsIHApO1xuICAgICAgICAgICAgcCArPSBcIlhcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIGlubGluZVByb3BzLnB1c2goX3RyYW5zZm9ybU9yaWdpblByb3AsIDAsIHN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSk7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKGVuZFZhbHVlKTsgLy9pbiBjYXNlIHNvbWV0aGluZyBsaWtlIFwibGVmdCB0b3BcIiBvciBcImJvdHRvbSByaWdodFwiIGlzIHBhc3NlZCBpbi4gQ29udmVydCB0byBwZXJjZW50YWdlcy5cblxuICAgICAgICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMCwgc21vb3RoLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZFVuaXQgPSBwYXJzZUZsb2F0KGVuZFZhbHVlLnNwbGl0KFwiIFwiKVsyXSkgfHwgMDsgLy9oYW5kbGUgdGhlIHpPcmlnaW4gc2VwYXJhdGVseSFcblxuICAgICAgICAgICAgICBlbmRVbml0ICE9PSBjYWNoZS56T3JpZ2luICYmIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInpPcmlnaW5cIiwgY2FjaGUuek9yaWdpbiwgZW5kVW5pdCk7XG5cbiAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIHAsIF9maXJzdFR3b09ubHkoc3RhcnRWYWx1ZSksIF9maXJzdFR3b09ubHkoZW5kVmFsdWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG4gICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCByZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZFZhbHVlKSA6IGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInNtb290aE9yaWdpblwiKSB7XG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcbiAgICAgICAgICAgIGNhY2hlW3BdID0gZW5kVmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHModGhpcywgZW5kVmFsdWUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgcCA9IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIHAgaW4gc3R5bGUpIHtcbiAgICAgICAgICBzdGFydFVuaXQgPSAoc3RhcnRWYWx1ZSArIFwiXCIpLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICAgIGVuZE51bSB8fCAoZW5kTnVtID0gMCk7IC8vIHByb3RlY3QgYWdhaW5zdCBOYU5cblxuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKSB8fCAocCBpbiBfY29uZmlnLnVuaXRzID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG4gICAgICAgICAgc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkpO1xuICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gc3RhcnROdW0sICFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgdGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgZW5kVW5pdCAhPT0gXCIlXCIpIHtcbiAgICAgICAgICAgIC8vd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmV2ZXJ0IGl0IHRvIHRoZSBPTEQvT1JJR0lOQUwgdmFsdWUgKHdpdGggdGhvc2UgdW5pdHMpLiBXZSByZWNvcmQgdGhhdCBhcyBhIFwiYlwiIChiZWdpbm5pbmcpIHByb3BlcnR5IGFuZCBwb2ludCB0byBhIHJlbmRlciBtZXRob2QgdGhhdCBoYW5kbGVzIHRoYXQuIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgICAgICAgICB0aGlzLl9wdC5iID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXQncyBub3QgYSBzdHlsZSAtIGl0IGNvdWxkIGJlIGEgcHJvcGVydHkgYWRkZWQgZGlyZWN0bHkgdG8gYW4gZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlJ2xsIHRyeSB0byBhbmltYXRlIHRoYXQuXG4gICAgICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUgfHwgdGFyZ2V0W3BdLCByZWxhdGl2ZSA/IHJlbGF0aXZlICsgZW5kVmFsdWUgOiBlbmRWYWx1ZSwgaW5kZXgsIHRhcmdldHMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCAhPT0gXCJwYXJzZVRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBfbWlzc2luZ1BsdWdpbihwLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBzdGFydFZhbHVlLCByZWxhdGl2ZSA/IHJlbGF0aXZlICsgZW5kVmFsdWUgOiBlbmRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKHAgaW4gc3R5bGUgPyBpbmxpbmVQcm9wcy5wdXNoKHAsIDAsIHN0eWxlW3BdKSA6IGlubGluZVByb3BzLnB1c2gocCwgMSwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0pKTtcbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHRoaXMpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIGlmIChkYXRhLnR3ZWVuLl90aW1lIHx8ICFfcmV2ZXJ0aW5nKCkpIHtcbiAgICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuc3R5bGVzLnJldmVydCgpO1xuICAgIH1cbiAgfSxcbiAgZ2V0OiBfZ2V0LFxuICBhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxuICBnZXRTZXR0ZXI6IGZ1bmN0aW9uIGdldFNldHRlcih0YXJnZXQsIHByb3BlcnR5LCBwbHVnaW4pIHtcbiAgICAvL3JldHVybnMgYSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRhcmdldCwgcHJvcGVydHksIHZhbHVlIGFuZCBhcHBsaWVzIGl0IGFjY29yZGluZ2x5LiBSZW1lbWJlciwgcHJvcGVydGllcyBsaWtlIFwieFwiIGFyZW4ndCBhcyBzaW1wbGUgYXMgdGFyZ2V0LnN0eWxlLnByb3BlcnR5ID0gdmFsdWUgYmVjYXVzZSB0aGV5J3ZlIGdvdCB0byBiZSBhcHBsaWVkIHRvIGEgcHJveHkgb2JqZWN0IGFuZCB0aGVuIG1lcmdlZCBpbnRvIGEgdHJhbnNmb3JtIHN0cmluZyBpbiBhIHJlbmRlcmVyLlxuICAgIHZhciBwID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG4gICAgcCAmJiBwLmluZGV4T2YoXCIsXCIpIDwgMCAmJiAocHJvcGVydHkgPSBwKTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGFyZ2V0Ll9nc2FwLnggfHwgX2dldCh0YXJnZXQsIFwieFwiKSkgPyBwbHVnaW4gJiYgX3JlY2VudFNldHRlclBsdWdpbiA9PT0gcGx1Z2luID8gcHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZSA6IF9zZXR0ZXJUcmFuc2Zvcm0gOiAoX3JlY2VudFNldHRlclBsdWdpbiA9IHBsdWdpbiB8fCB7fSkgJiYgKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIDogX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIpIDogdGFyZ2V0LnN0eWxlICYmICFfaXNVbmRlZmluZWQodGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSkgPyBfc2V0dGVyQ1NTU3R5bGUgOiB+cHJvcGVydHkuaW5kZXhPZihcIi1cIikgPyBfc2V0dGVyQ1NTUHJvcCA6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIH0sXG4gIGNvcmU6IHtcbiAgICBfcmVtb3ZlUHJvcGVydHk6IF9yZW1vdmVQcm9wZXJ0eSxcbiAgICBfZ2V0TWF0cml4OiBfZ2V0TWF0cml4XG4gIH1cbn07XG5nc2FwLnV0aWxzLmNoZWNrUHJlZml4ID0gX2NoZWNrUHJvcFByZWZpeDtcbmdzYXAuY29yZS5nZXRTdHlsZVNhdmVyID0gX2dldFN0eWxlU2F2ZXI7XG5cbihmdW5jdGlvbiAocG9zaXRpb25BbmRTY2FsZSwgcm90YXRpb24sIG90aGVycywgYWxpYXNlcykge1xuICB2YXIgYWxsID0gX2ZvckVhY2hOYW1lKHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uICsgXCIsXCIgKyBvdGhlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX3RyYW5zZm9ybVByb3BzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX2ZvckVhY2hOYW1lKHJvdGF0aW9uLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9jb25maWcudW5pdHNbbmFtZV0gPSBcImRlZ1wiO1xuICAgIF9yb3RhdGlvbmFsUHJvcGVydGllc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9wcm9wZXJ0eUFsaWFzZXNbYWxsWzEzXV0gPSBwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbjtcblxuICBfZm9yRWFjaE5hbWUoYWxpYXNlcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3BsaXQgPSBuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBfcHJvcGVydHlBbGlhc2VzW3NwbGl0WzFdXSA9IGFsbFtzcGxpdFswXV07XG4gIH0pO1xufSkoXCJ4LHkseixzY2FsZSxzY2FsZVgsc2NhbGVZLHhQZXJjZW50LHlQZXJjZW50XCIsIFwicm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxza2V3WCxza2V3WVwiLCBcInRyYW5zZm9ybSx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLGZvcmNlM0Qsc21vb3RoT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsIFwiMDp0cmFuc2xhdGVYLDE6dHJhbnNsYXRlWSwyOnRyYW5zbGF0ZVosODpyb3RhdGUsODpyb3RhdGlvblosODpyb3RhdGVaLDk6cm90YXRlWCwxMDpyb3RhdGVZXCIpO1xuXG5fZm9yRWFjaE5hbWUoXCJ4LHkseix0b3AscmlnaHQsYm90dG9tLGxlZnQsd2lkdGgsaGVpZ2h0LGZvbnRTaXplLHBhZGRpbmcsbWFyZ2luLHBlcnNwZWN0aXZlXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIF9jb25maWcudW5pdHNbbmFtZV0gPSBcInB4XCI7XG59KTtcblxuZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pO1xuZXhwb3J0IHsgQ1NTUGx1Z2luIGFzIGRlZmF1bHQsIF9nZXRCQm94LCBfY3JlYXRlRWxlbWVudCwgX2NoZWNrUHJvcFByZWZpeCBhcyBjaGVja1ByZWZpeCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/CSSPlugin.js\n");

/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   Back: () => (/* binding */ Back),\n/* harmony export */   Bounce: () => (/* binding */ Bounce),\n/* harmony export */   Circ: () => (/* binding */ Circ),\n/* harmony export */   Cubic: () => (/* binding */ Cubic),\n/* harmony export */   Elastic: () => (/* binding */ Elastic),\n/* harmony export */   Expo: () => (/* binding */ Expo),\n/* harmony export */   GSCache: () => (/* binding */ GSCache),\n/* harmony export */   Linear: () => (/* binding */ Linear),\n/* harmony export */   Power0: () => (/* binding */ Power0),\n/* harmony export */   Power1: () => (/* binding */ Power1),\n/* harmony export */   Power2: () => (/* binding */ Power2),\n/* harmony export */   Power3: () => (/* binding */ Power3),\n/* harmony export */   Power4: () => (/* binding */ Power4),\n/* harmony export */   PropTween: () => (/* binding */ PropTween),\n/* harmony export */   Quad: () => (/* binding */ Quad),\n/* harmony export */   Quart: () => (/* binding */ Quart),\n/* harmony export */   Quint: () => (/* binding */ Quint),\n/* harmony export */   Sine: () => (/* binding */ Sine),\n/* harmony export */   SteppedEase: () => (/* binding */ SteppedEase),\n/* harmony export */   Strong: () => (/* binding */ Strong),\n/* harmony export */   Timeline: () => (/* binding */ Timeline),\n/* harmony export */   TimelineLite: () => (/* binding */ Timeline),\n/* harmony export */   TimelineMax: () => (/* binding */ Timeline),\n/* harmony export */   Tween: () => (/* binding */ Tween),\n/* harmony export */   TweenLite: () => (/* binding */ Tween),\n/* harmony export */   TweenMax: () => (/* binding */ Tween),\n/* harmony export */   _checkPlugin: () => (/* binding */ _checkPlugin),\n/* harmony export */   _colorExp: () => (/* binding */ _colorExp),\n/* harmony export */   _colorStringFilter: () => (/* binding */ _colorStringFilter),\n/* harmony export */   _config: () => (/* binding */ _config),\n/* harmony export */   _forEachName: () => (/* binding */ _forEachName),\n/* harmony export */   _getCache: () => (/* binding */ _getCache),\n/* harmony export */   _getProperty: () => (/* binding */ _getProperty),\n/* harmony export */   _getSetter: () => (/* binding */ _getSetter),\n/* harmony export */   _isString: () => (/* binding */ _isString),\n/* harmony export */   _isUndefined: () => (/* binding */ _isUndefined),\n/* harmony export */   _missingPlugin: () => (/* binding */ _missingPlugin),\n/* harmony export */   _numExp: () => (/* binding */ _numExp),\n/* harmony export */   _numWithUnitExp: () => (/* binding */ _numWithUnitExp),\n/* harmony export */   _parseRelative: () => (/* binding */ _parseRelative),\n/* harmony export */   _plugins: () => (/* binding */ _plugins),\n/* harmony export */   _relExp: () => (/* binding */ _relExp),\n/* harmony export */   _removeLinkedListItem: () => (/* binding */ _removeLinkedListItem),\n/* harmony export */   _renderComplexString: () => (/* binding */ _renderComplexString),\n/* harmony export */   _replaceRandom: () => (/* binding */ _replaceRandom),\n/* harmony export */   _round: () => (/* binding */ _round),\n/* harmony export */   _roundModifier: () => (/* binding */ _roundModifier),\n/* harmony export */   _setDefaults: () => (/* binding */ _setDefaults),\n/* harmony export */   _sortPropTweensByPriority: () => (/* binding */ _sortPropTweensByPriority),\n/* harmony export */   _ticker: () => (/* binding */ _ticker),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   \"default\": () => (/* binding */ gsap),\n/* harmony export */   distribute: () => (/* binding */ distribute),\n/* harmony export */   getUnit: () => (/* binding */ getUnit),\n/* harmony export */   gsap: () => (/* binding */ gsap),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   mapRange: () => (/* binding */ mapRange),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   selector: () => (/* binding */ selector),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   snap: () => (/* binding */ snap),\n/* harmony export */   splitColor: () => (/* binding */ splitColor),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   unitize: () => (/* binding */ unitize),\n/* harmony export */   wrap: () => (/* binding */ wrap),\n/* harmony export */   wrapYoyo: () => (/* binding */ wrapYoyo)\n/* harmony export */ });\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/*!\n * GSAP 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _config = {\n  autoSleep: 120,\n  force3D: \"auto\",\n  nullTargetWarn: 1,\n  units: {\n    lineHeight: \"\"\n  }\n},\n    _defaults = {\n  duration: .5,\n  overwrite: false,\n  delay: 0\n},\n    _suppressOverwrites,\n    _reverting,\n    _context,\n    _bigNum = 1e8,\n    _tinyNum = 1 / _bigNum,\n    _2PI = Math.PI * 2,\n    _HALF_PI = _2PI / 4,\n    _gsID = 0,\n    _sqrt = Math.sqrt,\n    _cos = Math.cos,\n    _sin = Math.sin,\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === \"undefined\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _isNotFalse = function _isNotFalse(value) {\n  return value !== false;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _isFuncOrString = function _isFuncOrString(value) {\n  return _isFunction(value) || _isString(value);\n},\n    _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function () {},\n    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n_isArray = Array.isArray,\n    _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi,\n    //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g,\n    _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi,\n    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.\n_relExp = /[+-]=-?[.\\d]+/,\n    _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi,\n    // previously /[#\\-+.]*\\b[a-z\\d\\-=+%.]+/gi but didn't catch special characters.\n_unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i,\n    _globalTimeline,\n    _win,\n    _coreInitted,\n    _doc,\n    _globals = {},\n    _installScope = {},\n    _coreReady,\n    _install = function _install(scope) {\n  return (_installScope = _merge(scope, _globals)) && gsap;\n},\n    _missingPlugin = function _missingPlugin(property, value) {\n  return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n},\n    _warn = function _warn(message, suppress) {\n  return !suppress && console.warn(message);\n},\n    _addGlobal = function _addGlobal(name, obj) {\n  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n},\n    _emptyFunc = function _emptyFunc() {\n  return 0;\n},\n    _startAtRevertConfig = {\n  suppressEvents: true,\n  isStart: true,\n  kill: false\n},\n    _revertConfigNoKill = {\n  suppressEvents: true,\n  kill: false\n},\n    _revertConfig = {\n  suppressEvents: true\n},\n    _reservedProps = {},\n    _lazyTweens = [],\n    _lazyLookup = {},\n    _lastRenderedFrame,\n    _plugins = {},\n    _effects = {},\n    _nextGCFrame = 30,\n    _harnessPlugins = [],\n    _callbackNames = \"\",\n    _harness = function _harness(targets) {\n  var target = targets[0],\n      harnessPlugin,\n      i;\n  _isObject(target) || _isFunction(target) || (targets = [targets]);\n\n  if (!(harnessPlugin = (target._gsap || {}).harness)) {\n    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n    i = _harnessPlugins.length;\n\n    while (i-- && !_harnessPlugins[i].targetTest(target)) {}\n\n    harnessPlugin = _harnessPlugins[i];\n  }\n\n  i = targets.length;\n\n  while (i--) {\n    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n  }\n\n  return targets;\n},\n    _getCache = function _getCache(target) {\n  return target._gsap || _harness(toArray(target))[0]._gsap;\n},\n    _getProperty = function _getProperty(target, property, v) {\n  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n},\n    _forEachName = function _forEachName(names, func) {\n  return (names = names.split(\",\")).forEach(func) || names;\n},\n    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _roundPrecise = function _roundPrecise(value) {\n  return Math.round(value * 10000000) / 10000000 || 0;\n},\n    // increased precision mostly for timing values.\n_parseRelative = function _parseRelative(start, value) {\n  var operator = value.charAt(0),\n      end = parseFloat(value.substr(2));\n  start = parseFloat(start);\n  return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n},\n    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.\n  var l = toFind.length,\n      i = 0;\n\n  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}\n\n  return i < l;\n},\n    _lazyRender = function _lazyRender() {\n  var l = _lazyTweens.length,\n      a = _lazyTweens.slice(0),\n      i,\n      tween;\n\n  _lazyLookup = {};\n  _lazyTweens.length = 0;\n\n  for (i = 0; i < l; i++) {\n    tween = a[i];\n    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n  }\n},\n    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n  _lazyTweens.length && !_reverting && _lazyRender();\n  animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));\n  _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n},\n    _numericIfPossible = function _numericIfPossible(value) {\n  var n = parseFloat(value);\n  return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n},\n    _passThrough = function _passThrough(p) {\n  return p;\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n  return function (obj, defaults) {\n    for (var p in defaults) {\n      p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n    }\n  };\n},\n    _merge = function _merge(base, toMerge) {\n  for (var p in toMerge) {\n    base[p] = toMerge[p];\n  }\n\n  return base;\n},\n    _mergeDeep = function _mergeDeep(base, toMerge) {\n  for (var p in toMerge) {\n    p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n  }\n\n  return base;\n},\n    _copyExcluding = function _copyExcluding(obj, excluding) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    p in excluding || (copy[p] = obj[p]);\n  }\n\n  return copy;\n},\n    _inheritDefaults = function _inheritDefaults(vars) {\n  var parent = vars.parent || _globalTimeline,\n      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n\n  if (_isNotFalse(vars.inherit)) {\n    while (parent) {\n      func(vars, parent.vars.defaults);\n      parent = parent.parent || parent._dp;\n    }\n  }\n\n  return vars;\n},\n    _arraysMatch = function _arraysMatch(a1, a2) {\n  var i = a1.length,\n      match = i === a2.length;\n\n  while (match && i-- && a1[i] === a2[i]) {}\n\n  return i < 0;\n},\n    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n\n  var prev = parent[lastProp],\n      t;\n\n  if (sortBy) {\n    t = child[sortBy];\n\n    while (prev && prev[sortBy] > t) {\n      prev = prev._prev;\n    }\n  }\n\n  if (prev) {\n    child._next = prev._next;\n    prev._next = child;\n  } else {\n    child._next = parent[firstProp];\n    parent[firstProp] = child;\n  }\n\n  if (child._next) {\n    child._next._prev = child;\n  } else {\n    parent[lastProp] = child;\n  }\n\n  child._prev = prev;\n  child.parent = child._dp = parent;\n  return child;\n},\n    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n\n  var prev = child._prev,\n      next = child._next;\n\n  if (prev) {\n    prev._next = next;\n  } else if (parent[firstProp] === child) {\n    parent[firstProp] = next;\n  }\n\n  if (next) {\n    next._prev = prev;\n  } else if (parent[lastProp] === child) {\n    parent[lastProp] = prev;\n  }\n\n  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.\n},\n    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n  child._act = 0;\n},\n    _uncache = function _uncache(animation, child) {\n  if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n    var a = animation;\n\n    while (a) {\n      a._dirty = 1;\n      a = a.parent;\n    }\n  }\n\n  return animation;\n},\n    _recacheAncestors = function _recacheAncestors(animation) {\n  var parent = animation.parent;\n\n  while (parent && parent.parent) {\n    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\n    parent._dirty = 1;\n    parent.totalDuration();\n    parent = parent.parent;\n  }\n\n  return animation;\n},\n    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\n  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n},\n    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n},\n    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n},\n    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n  var whole = Math.floor(tTime /= cycleDuration);\n  return tTime && whole === tTime ? whole - 1 : whole;\n},\n    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n},\n    _setEnd = function _setEnd(animation) {\n  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n},\n    _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.\n  var parent = animation._dp;\n\n  if (parent && parent.smoothChildTiming && animation._ts) {\n    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n\n    _setEnd(animation);\n\n    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n  }\n\n  return animation;\n},\n\n/*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/\n_postAddChecks = function _postAddChecks(timeline, child) {\n  var t;\n\n  if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\n    // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).\n    t = _parentToChildTotalTime(timeline.rawTime(), child);\n\n    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n      child.render(t, true);\n    }\n  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.\n\n\n  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n    //in case any of the ancestors had completed but should now be enabled...\n    if (timeline._dur < timeline.duration()) {\n      t = timeline;\n\n      while (t._dp) {\n        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n\n        t = t._dp;\n      }\n    }\n\n    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.\n  }\n},\n    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n  child.parent && _removeFromParent(child);\n  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\n  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n\n  _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n\n  _isFromOrFromStart(child) || (timeline._recent = child);\n  skipChecks || _postAddChecks(timeline, child);\n  timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)\n\n  return timeline;\n},\n    _scrollTrigger = function _scrollTrigger(animation, trigger) {\n  return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n},\n    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\n  _initTween(tween, time, tTime);\n\n  if (!tween._initted) {\n    return 1;\n  }\n\n  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n    _lazyTweens.push(tween);\n\n    tween._lazy = [tTime, suppressEvents];\n    return 1;\n  }\n},\n    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n  var parent = _ref.parent;\n  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n},\n    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0\n_isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n  var data = _ref2.data;\n  return data === \"isFromStart\" || data === \"isStart\";\n},\n    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n  var prevRatio = tween.ratio,\n      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,\n      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the \"startAt\" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any \"from\" and \"fromTo\" startAt tweens are rendered the first time at a ratio of 1.\n  repeatDelay = tween._rDelay,\n      tTime = 0,\n      pt,\n      iteration,\n      prevIteration;\n\n  if (repeatDelay && tween._repeat) {\n    // in case there's a zero-duration tween that has a repeat with a repeatDelay\n    tTime = _clamp(0, tween._tDur, totalTime);\n    iteration = _animationCycle(tTime, repeatDelay);\n    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n\n    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n      // if iteration changed\n      prevRatio = 1 - ratio;\n      tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n    }\n  }\n\n  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n      return;\n    }\n\n    prevIteration = tween._zTime;\n    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.\n\n    tween.ratio = ratio;\n    tween._from && (ratio = 1 - ratio);\n    tween._time = 0;\n    tween._tTime = tTime;\n    pt = tween._pt;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n    tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n\n    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n      ratio && _removeFromParent(tween, 1);\n\n      if (!suppressEvents && !_reverting) {\n        _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n\n        tween._prom && tween._prom();\n      }\n    }\n  } else if (!tween._zTime) {\n    tween._zTime = totalTime;\n  }\n},\n    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n  var child;\n\n  if (time > prevTime) {\n    child = animation._first;\n\n    while (child && child._start <= time) {\n      if (child.data === \"isPause\" && child._start > prevTime) {\n        return child;\n      }\n\n      child = child._next;\n    }\n  } else {\n    child = animation._last;\n\n    while (child && child._start >= time) {\n      if (child.data === \"isPause\" && child._start < prevTime) {\n        return child;\n      }\n\n      child = child._prev;\n    }\n  }\n},\n    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n  var repeat = animation._repeat,\n      dur = _roundPrecise(duration) || 0,\n      totalProgress = animation._tTime / animation._tDur;\n  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n  animation._dur = dur;\n  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n  animation.parent && _setEnd(animation);\n  skipUncache || _uncache(animation.parent, animation);\n  return animation;\n},\n    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n},\n    _zeroPosition = {\n  _start: 0,\n  endTime: _emptyFunc,\n  totalDuration: _emptyFunc\n},\n    _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n  var labels = animation.labels,\n      recent = animation._recent || _zeroPosition,\n      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\n      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.\n  i,\n      offset,\n      isPercent;\n\n  if (_isString(position) && (isNaN(position) || position in labels)) {\n    //if the string is a number like \"1\", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).\n    offset = position.charAt(0);\n    isPercent = position.substr(-1) === \"%\";\n    i = position.indexOf(\"=\");\n\n    if (offset === \"<\" || offset === \">\") {\n      i >= 0 && (position = position.replace(/=/, \"\"));\n      return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n    }\n\n    if (i < 0) {\n      position in labels || (labels[position] = clippedDuration);\n      return labels[position];\n    }\n\n    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n\n    if (isPercent && percentAnimation) {\n      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n    }\n\n    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n  }\n\n  return position == null ? clippedDuration : +position;\n},\n    _createTweenType = function _createTweenType(type, params, timeline) {\n  var isLegacy = _isNumber(params[1]),\n      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),\n      vars = params[varsIndex],\n      irVars,\n      parent;\n\n  isLegacy && (vars.duration = params[1]);\n  vars.parent = timeline;\n\n  if (type) {\n    irVars = vars;\n    parent = timeline;\n\n    while (parent && !(\"immediateRender\" in irVars)) {\n      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.\n      irVars = parent.vars.defaults || {};\n      parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n    }\n\n    vars.immediateRender = _isNotFalse(irVars.immediateRender);\n    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // \"from\" vars\n  }\n\n  return new Tween(params[0], vars, params[varsIndex + 1]);\n},\n    _conditionalReturn = function _conditionalReturn(value, func) {\n  return value || value === 0 ? func(value) : func;\n},\n    _clamp = function _clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n},\n    getUnit = function getUnit(value, v) {\n  return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n},\n    // note: protect against padded numbers as strings, like \"100.100\". That shouldn't return \"00\" as the unit. If it's numeric, return no unit.\nclamp = function clamp(min, max, value) {\n  return _conditionalReturn(value, function (v) {\n    return _clamp(min, max, v);\n  });\n},\n    _slice = [].slice,\n    _isArrayLike = function _isArrayLike(value, nonEmpty) {\n  return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n},\n    _flatten = function _flatten(ar, leaveStrings, accumulator) {\n  if (accumulator === void 0) {\n    accumulator = [];\n  }\n\n  return ar.forEach(function (value) {\n    var _accumulator;\n\n    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n  }) || accumulator;\n},\n    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.\ntoArray = function toArray(value, scope, leaveStrings) {\n  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\n},\n    selector = function selector(value) {\n  value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n  return function (v) {\n    var el = value.current || value.nativeElement || value;\n    return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n  };\n},\n    shuffle = function shuffle(a) {\n  return a.sort(function () {\n    return .5 - Math.random();\n  });\n},\n    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\ndistribute = function distribute(v) {\n  if (_isFunction(v)) {\n    return v;\n  }\n\n  var vars = _isObject(v) ? v : {\n    each: v\n  },\n      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\n  ease = _parseEase(vars.ease),\n      from = vars.from || 0,\n      base = parseFloat(vars.base) || 0,\n      cache = {},\n      isDecimal = from > 0 && from < 1,\n      ratios = isNaN(from) || isDecimal,\n      axis = vars.axis,\n      ratioX = from,\n      ratioY = from;\n\n  if (_isString(from)) {\n    ratioX = ratioY = {\n      center: .5,\n      edges: .5,\n      end: 1\n    }[from] || 0;\n  } else if (!isDecimal && ratios) {\n    ratioX = from[0];\n    ratioY = from[1];\n  }\n\n  return function (i, target, a) {\n    var l = (a || vars).length,\n        distances = cache[l],\n        originX,\n        originY,\n        x,\n        y,\n        d,\n        j,\n        max,\n        min,\n        wrapAt;\n\n    if (!distances) {\n      wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [1, _bigNum])[1];\n\n      if (!wrapAt) {\n        max = -_bigNum;\n\n        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}\n\n        wrapAt < l && wrapAt--;\n      }\n\n      distances = cache[l] = [];\n      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n      max = 0;\n      min = _bigNum;\n\n      for (j = 0; j < l; j++) {\n        x = j % wrapAt - originX;\n        y = originY - (j / wrapAt | 0);\n        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n        d > max && (max = d);\n        d < min && (min = d);\n      }\n\n      from === \"random\" && shuffle(distances);\n      distances.max = max - min;\n      distances.min = min;\n      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n      distances.b = l < 0 ? base - l : base;\n      distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n\n      ease = ease && l < 0 ? _invertEase(ease) : ease;\n    }\n\n    l = (distances[i] - distances.min) / distances.max || 0;\n    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n  };\n},\n    _roundModifier = function _roundModifier(v) {\n  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n  var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())\n\n  return function (raw) {\n    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n\n    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n  };\n},\n    snap = function snap(snapTo, value) {\n  var isArray = _isArray(snapTo),\n      radius,\n      is2D;\n\n  if (!isArray && _isObject(snapTo)) {\n    radius = isArray = snapTo.radius || _bigNum;\n\n    if (snapTo.values) {\n      snapTo = toArray(snapTo.values);\n\n      if (is2D = !_isNumber(snapTo[0])) {\n        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.\n      }\n    } else {\n      snapTo = _roundModifier(snapTo.increment);\n    }\n  }\n\n  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {\n    is2D = snapTo(raw);\n    return Math.abs(is2D - raw) <= radius ? is2D : raw;\n  } : function (raw) {\n    var x = parseFloat(is2D ? raw.x : raw),\n        y = parseFloat(is2D ? raw.y : 0),\n        min = _bigNum,\n        closest = 0,\n        i = snapTo.length,\n        dx,\n        dy;\n\n    while (i--) {\n      if (is2D) {\n        dx = snapTo[i].x - x;\n        dy = snapTo[i].y - y;\n        dx = dx * dx + dy * dy;\n      } else {\n        dx = Math.abs(snapTo[i] - x);\n      }\n\n      if (dx < min) {\n        min = dx;\n        closest = i;\n      }\n    }\n\n    closest = !radius || min <= radius ? snapTo[closest] : raw;\n    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n  });\n},\n    random = function random(min, max, roundingIncrement, returnFunction) {\n  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {\n    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n  });\n},\n    pipe = function pipe() {\n  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\n    functions[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    return functions.reduce(function (v, f) {\n      return f(v);\n    }, value);\n  };\n},\n    unitize = function unitize(func, unit) {\n  return function (value) {\n    return func(parseFloat(value)) + (unit || getUnit(value));\n  };\n},\n    normalize = function normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n},\n    _wrapArray = function _wrapArray(a, wrapper, value) {\n  return _conditionalReturn(value, function (index) {\n    return a[~~wrapper(index)];\n  });\n},\n    wrap = function wrap(min, max, value) {\n  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n  var range = max - min;\n  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {\n    return (range + (value - min) % range) % range + min;\n  });\n},\n    wrapYoyo = function wrapYoyo(min, max, value) {\n  var range = max - min,\n      total = range * 2;\n  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {\n    value = (total + (value - min) % total) % total || 0;\n    return min + (value > range ? total - value : value);\n  });\n},\n    _replaceRandom = function _replaceRandom(value) {\n  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n  var prev = 0,\n      s = \"\",\n      i,\n      nums,\n      end,\n      isArray;\n\n  while (~(i = value.indexOf(\"random(\", prev))) {\n    end = value.indexOf(\")\", i);\n    isArray = value.charAt(i + 7) === \"[\";\n    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n    prev = end + 1;\n  }\n\n  return s + value.substr(prev, value.length - prev);\n},\n    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n  var inRange = inMax - inMin,\n      outRange = outMax - outMin;\n  return _conditionalReturn(value, function (value) {\n    return outMin + ((value - inMin) / inRange * outRange || 0);\n  });\n},\n    interpolate = function interpolate(start, end, progress, mutate) {\n  var func = isNaN(start + end) ? 0 : function (p) {\n    return (1 - p) * start + p * end;\n  };\n\n  if (!func) {\n    var isString = _isString(start),\n        master = {},\n        p,\n        i,\n        interpolators,\n        l,\n        il;\n\n    progress === true && (mutate = 1) && (progress = null);\n\n    if (isString) {\n      start = {\n        p: start\n      };\n      end = {\n        p: end\n      };\n    } else if (_isArray(start) && !_isArray(end)) {\n      interpolators = [];\n      l = start.length;\n      il = l - 2;\n\n      for (i = 1; i < l; i++) {\n        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n      }\n\n      l--;\n\n      func = function func(p) {\n        p *= l;\n        var i = Math.min(il, ~~p);\n        return interpolators[i](p - i);\n      };\n\n      progress = end;\n    } else if (!mutate) {\n      start = _merge(_isArray(start) ? [] : {}, start);\n    }\n\n    if (!interpolators) {\n      for (p in end) {\n        _addPropTween.call(master, start, p, \"get\", end[p]);\n      }\n\n      func = function func(p) {\n        return _renderPropTweens(p, master) || (isString ? start.p : start);\n      };\n    }\n  }\n\n  return _conditionalReturn(progress, func);\n},\n    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n  //used for nextLabel() and previousLabel()\n  var labels = timeline.labels,\n      min = _bigNum,\n      p,\n      distance,\n      label;\n\n  for (p in labels) {\n    distance = labels[p] - fromTime;\n\n    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n      label = p;\n      min = distance;\n    }\n  }\n\n  return label;\n},\n    _callback = function _callback(animation, type, executeLazyFirst) {\n  var v = animation.vars,\n      callback = v[type],\n      prevContext = _context,\n      context = animation._ctx,\n      params,\n      scope,\n      result;\n\n  if (!callback) {\n    return;\n  }\n\n  params = v[type + \"Params\"];\n  scope = v.callbackScope || animation;\n  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n\n  context && (_context = context);\n  result = params ? callback.apply(scope, params) : callback.call(scope);\n  _context = prevContext;\n  return result;\n},\n    _interrupt = function _interrupt(animation) {\n  _removeFromParent(animation);\n\n  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n  animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n  return animation;\n},\n    _quickTween,\n    _registerPluginQueue = [],\n    _createPlugin = function _createPlugin(config) {\n  if (!config) return;\n  config = !config.name && config[\"default\"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n\n  if (_windowExists() || config.headless) {\n    // edge case: some build tools may pass in a null/undefined value\n    var name = config.name,\n        isFunc = _isFunction(config),\n        Plugin = name && !isFunc && config.init ? function () {\n      this._props = [];\n    } : config,\n        //in case someone passes in an object that's not a plugin, like CustomEase\n    instanceDefaults = {\n      init: _emptyFunc,\n      render: _renderPropTweens,\n      add: _addPropTween,\n      kill: _killPropTweensOf,\n      modifier: _addPluginModifier,\n      rawVars: 0\n    },\n        statics = {\n      targetTest: 0,\n      get: 0,\n      getSetter: _getSetter,\n      aliases: {},\n      register: 0\n    };\n\n    _wake();\n\n    if (config !== Plugin) {\n      if (_plugins[name]) {\n        return;\n      }\n\n      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n\n\n      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n\n\n      _plugins[Plugin.prop = name] = Plugin;\n\n      if (config.targetTest) {\n        _harnessPlugins.push(Plugin);\n\n        _reservedProps[name] = 1;\n      }\n\n      name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\"; //for the global name. \"motionPath\" should become MotionPathPlugin\n    }\n\n    _addGlobal(name, Plugin);\n\n    config.register && config.register(gsap, Plugin, PropTween);\n  } else {\n    _registerPluginQueue.push(config);\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */\n_255 = 255,\n    _colorLookup = {\n  aqua: [0, _255, _255],\n  lime: [0, _255, 0],\n  silver: [192, 192, 192],\n  black: [0, 0, 0],\n  maroon: [128, 0, 0],\n  teal: [0, 128, 128],\n  blue: [0, 0, _255],\n  navy: [0, 0, 128],\n  white: [_255, _255, _255],\n  olive: [128, 128, 0],\n  yellow: [_255, _255, 0],\n  orange: [_255, 165, 0],\n  gray: [128, 128, 128],\n  purple: [128, 0, 128],\n  green: [0, 128, 0],\n  red: [_255, 0, 0],\n  pink: [_255, 192, 203],\n  cyan: [0, _255, _255],\n  transparent: [_255, _255, _255, 0]\n},\n    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:\n// let ctx = _doc.createElement(\"canvas\").getContext(\"2d\");\n// _forEachName(\"aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan\", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});\n_hue = function _hue(h, m1, m2) {\n  h += h < 0 ? 1 : h > 1 ? -1 : 0;\n  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n},\n    splitColor = function splitColor(v, toHSL, forceAlpha) {\n  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\n      r,\n      g,\n      b,\n      h,\n      s,\n      l,\n      max,\n      min,\n      d,\n      wasHSL;\n\n  if (!a) {\n    if (v.substr(-1) === \",\") {\n      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:\"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)\" - in this example \"blue,\" has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.\n      v = v.substr(0, v.length - 1);\n    }\n\n    if (_colorLookup[v]) {\n      a = _colorLookup[v];\n    } else if (v.charAt(0) === \"#\") {\n      if (v.length < 6) {\n        //for shorthand like #9F0 or #9F0F (could have alpha)\n        r = v.charAt(1);\n        g = v.charAt(2);\n        b = v.charAt(3);\n        v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n      }\n\n      if (v.length === 9) {\n        // hex with alpha, like #fd5e53ff\n        a = parseInt(v.substr(1, 6), 16);\n        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\n      }\n\n      v = parseInt(v.substr(1), 16);\n      a = [v >> 16, v >> 8 & _255, v & _255];\n    } else if (v.substr(0, 3) === \"hsl\") {\n      a = wasHSL = v.match(_strictNumExp);\n\n      if (!toHSL) {\n        h = +a[0] % 360 / 360;\n        s = +a[1] / 100;\n        l = +a[2] / 100;\n        g = l <= .5 ? l * (s + 1) : l + s - l * s;\n        r = l * 2 - g;\n        a.length > 3 && (a[3] *= 1); //cast as number\n\n        a[0] = _hue(h + 1 / 3, r, g);\n        a[1] = _hue(h, r, g);\n        a[2] = _hue(h - 1 / 3, r, g);\n      } else if (~v.indexOf(\"=\")) {\n        //if relative values are found, just return the raw strings with the relative prefixes in place.\n        a = v.match(_numExp);\n        forceAlpha && a.length < 4 && (a[3] = 1);\n        return a;\n      }\n    } else {\n      a = v.match(_strictNumExp) || _colorLookup.transparent;\n    }\n\n    a = a.map(Number);\n  }\n\n  if (toHSL && !wasHSL) {\n    r = a[0] / _255;\n    g = a[1] / _255;\n    b = a[2] / _255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n      h *= 60;\n    }\n\n    a[0] = ~~(h + .5);\n    a[1] = ~~(s * 100 + .5);\n    a[2] = ~~(l * 100 + .5);\n  }\n\n  forceAlpha && a.length < 4 && (a[3] = 1);\n  return a;\n},\n    _colorOrderData = function _colorOrderData(v) {\n  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a \"c\" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n  var values = [],\n      c = [],\n      i = -1;\n  v.split(_colorExp).forEach(function (v) {\n    var a = v.match(_numWithUnitExp) || [];\n    values.push.apply(values, a);\n    c.push(i += a.length + 1);\n  });\n  values.c = c;\n  return values;\n},\n    _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n  var result = \"\",\n      colors = (s + result).match(_colorExp),\n      type = toHSL ? \"hsla(\" : \"rgba(\",\n      i = 0,\n      c,\n      shell,\n      d,\n      l;\n\n  if (!colors) {\n    return s;\n  }\n\n  colors = colors.map(function (color) {\n    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n  });\n\n  if (orderMatchData) {\n    d = _colorOrderData(s);\n    c = orderMatchData.c;\n\n    if (c.join(result) !== d.c.join(result)) {\n      shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n      l = shell.length - 1;\n\n      for (; i < l; i++) {\n        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n      }\n    }\n  }\n\n  if (!shell) {\n    shell = s.split(_colorExp);\n    l = shell.length - 1;\n\n    for (; i < l; i++) {\n      result += shell[i] + colors[i];\n    }\n  }\n\n  return result + shell[l];\n},\n    _colorExp = function () {\n  var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\",\n      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n  p;\n\n  for (p in _colorLookup) {\n    s += \"|\" + p + \"\\\\b\";\n  }\n\n  return new RegExp(s + \")\", \"gi\");\n}(),\n    _hslExp = /hsl[a]?\\(/,\n    _colorStringFilter = function _colorStringFilter(a) {\n  var combined = a.join(\" \"),\n      toHSL;\n  _colorExp.lastIndex = 0;\n\n  if (_colorExp.test(combined)) {\n    toHSL = _hslExp.test(combined);\n    a[1] = _formatColors(a[1], toHSL);\n    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n\n    return true;\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */\n_tickerActive,\n    _ticker = function () {\n  var _getTime = Date.now,\n      _lagThreshold = 500,\n      _adjustedLag = 33,\n      _startTime = _getTime(),\n      _lastUpdate = _startTime,\n      _gap = 1000 / 240,\n      _nextTime = _gap,\n      _listeners = [],\n      _id,\n      _req,\n      _raf,\n      _self,\n      _delta,\n      _i,\n      _tick = function _tick(v) {\n    var elapsed = _getTime() - _lastUpdate,\n        manual = v === true,\n        overlap,\n        dispatch,\n        time,\n        frame;\n\n    (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\n    _lastUpdate += elapsed;\n    time = _lastUpdate - _startTime;\n    overlap = time - _nextTime;\n\n    if (overlap > 0 || manual) {\n      frame = ++_self.frame;\n      _delta = time - _self.time * 1000;\n      _self.time = time = time / 1000;\n      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n      dispatch = 1;\n    }\n\n    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\n\n    if (dispatch) {\n      for (_i = 0; _i < _listeners.length; _i++) {\n        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.\n        _listeners[_i](time, _delta, frame, v);\n      }\n    }\n  };\n\n  _self = {\n    time: 0,\n    frame: 0,\n    tick: function tick() {\n      _tick(true);\n    },\n    deltaRatio: function deltaRatio(fps) {\n      return _delta / (1000 / (fps || 60));\n    },\n    wake: function wake() {\n      if (_coreReady) {\n        if (!_coreInitted && _windowExists()) {\n          _win = _coreInitted = window;\n          _doc = _win.document || {};\n          _globals.gsap = gsap;\n          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n\n          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n\n          _registerPluginQueue.forEach(_createPlugin);\n        }\n\n        _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\n        _id && _self.sleep();\n\n        _req = _raf || function (f) {\n          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n        };\n\n        _tickerActive = 1;\n\n        _tick(2);\n      }\n    },\n    sleep: function sleep() {\n      (_raf ? cancelAnimationFrame : clearTimeout)(_id);\n      _tickerActive = 0;\n      _req = _emptyFunc;\n    },\n    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n      _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited\n\n      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n    },\n    fps: function fps(_fps) {\n      _gap = 1000 / (_fps || 240);\n      _nextTime = _self.time * 1000 + _gap;\n    },\n    add: function add(callback, once, prioritize) {\n      var func = once ? function (t, d, f, v) {\n        callback(t, d, f, v);\n\n        _self.remove(func);\n      } : callback;\n\n      _self.remove(callback);\n\n      _listeners[prioritize ? \"unshift\" : \"push\"](func);\n\n      _wake();\n\n      return func;\n    },\n    remove: function remove(callback, i) {\n      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n    },\n    _listeners: _listeners\n  };\n  return _self;\n}(),\n    _wake = function _wake() {\n  return !_tickerActive && _ticker.wake();\n},\n    //also ensures the core classes are initialized.\n\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/\n_easeMap = {},\n    _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\n    _quotesExp = /[\"']/g,\n    _parseObjectInString = function _parseObjectInString(value) {\n  //takes a string like \"{wiggles:10, type:anticipate})\" and turns it into a real object. Notice it ends in \")\" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n  var obj = {},\n      split = value.substr(1, value.length - 3).split(\":\"),\n      key = split[0],\n      i = 1,\n      l = split.length,\n      index,\n      val,\n      parsedVal;\n\n  for (; i < l; i++) {\n    val = split[i];\n    index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n    parsedVal = val.substr(0, index);\n    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n    key = val.substr(index + 1).trim();\n  }\n\n  return obj;\n},\n    _valueInParentheses = function _valueInParentheses(value) {\n  var open = value.indexOf(\"(\") + 1,\n      close = value.indexOf(\")\"),\n      nested = value.indexOf(\"(\", open);\n  return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n},\n    _configEaseFromString = function _configEaseFromString(name) {\n  //name can be a string like \"elastic.out(1,0.5)\", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n  var split = (name + \"\").split(\"(\"),\n      ease = _easeMap[split[0]];\n  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n},\n    _invertEase = function _invertEase(ease) {\n  return function (p) {\n    return 1 - ease(1 - p);\n  };\n},\n    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n  var child = timeline._first,\n      ease;\n\n  while (child) {\n    if (child instanceof Timeline) {\n      _propagateYoyoEase(child, isYoyo);\n    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n      if (child.timeline) {\n        _propagateYoyoEase(child.timeline, isYoyo);\n      } else {\n        ease = child._ease;\n        child._ease = child._yEase;\n        child._yEase = ease;\n        child._yoyo = isYoyo;\n      }\n    }\n\n    child = child._next;\n  }\n},\n    _parseEase = function _parseEase(ease, defaultEase) {\n  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n},\n    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n  if (easeOut === void 0) {\n    easeOut = function easeOut(p) {\n      return 1 - easeIn(1 - p);\n    };\n  }\n\n  if (easeInOut === void 0) {\n    easeInOut = function easeInOut(p) {\n      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n    };\n  }\n\n  var ease = {\n    easeIn: easeIn,\n    easeOut: easeOut,\n    easeInOut: easeInOut\n  },\n      lowercaseName;\n\n  _forEachName(names, function (name) {\n    _easeMap[name] = _globals[name] = ease;\n    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n\n    for (var p in ease) {\n      _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n    }\n  });\n\n  return ease;\n},\n    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n  return function (p) {\n    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n  };\n},\n    _configElastic = function _configElastic(type, amplitude, period) {\n  var p1 = amplitude >= 1 ? amplitude : 1,\n      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.\n  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\n      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\n      easeOut = function easeOut(p) {\n    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n  },\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  p2 = _2PI / p2; //precalculate to optimize\n\n  ease.config = function (amplitude, period) {\n    return _configElastic(type, amplitude, period);\n  };\n\n  return ease;\n},\n    _configBack = function _configBack(type, overshoot) {\n  if (overshoot === void 0) {\n    overshoot = 1.70158;\n  }\n\n  var easeOut = function easeOut(p) {\n    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n  },\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  ease.config = function (overshoot) {\n    return _configBack(type, overshoot);\n  };\n\n  return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n\n\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function (name, i) {\n  var power = i < 5 ? i + 1 : i;\n\n  _insertEase(name + \",Power\" + (power - 1), i ? function (p) {\n    return Math.pow(p, power);\n  } : function (p) {\n    return p;\n  }, function (p) {\n    return 1 - Math.pow(1 - p, power);\n  }, function (p) {\n    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n  });\n});\n\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n\n(function (n, c) {\n  var n1 = 1 / c,\n      n2 = 2 * n1,\n      n3 = 2.5 * n1,\n      easeOut = function easeOut(p) {\n    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n  };\n\n  _insertEase(\"Bounce\", function (p) {\n    return 1 - easeOut(1 - p);\n  }, easeOut);\n})(7.5625, 2.75);\n\n_insertEase(\"Expo\", function (p) {\n  return p ? Math.pow(2, 10 * (p - 1)) : 0;\n});\n\n_insertEase(\"Circ\", function (p) {\n  return -(_sqrt(1 - p * p) - 1);\n});\n\n_insertEase(\"Sine\", function (p) {\n  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n  config: function config(steps, immediateStart) {\n    if (steps === void 0) {\n      steps = 1;\n    }\n\n    var p1 = 1 / steps,\n        p2 = steps + (immediateStart ? 0 : 1),\n        p3 = immediateStart ? 1 : 0,\n        max = 1 - _tinyNum;\n    return function (p) {\n      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n    };\n  }\n};\n_defaults.ease = _easeMap[\"quad.out\"];\n\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function (name) {\n  return _callbackNames += name + \",\" + name + \"Params,\";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */\n\n\nvar GSCache = function GSCache(target, harness) {\n  this.id = _gsID++;\n  target._gsap = this;\n  this.target = target;\n  this.harness = harness;\n  this.get = harness ? harness.get : _getProperty;\n  this.set = harness ? harness.getSetter : _getSetter;\n};\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */\n\nvar Animation = /*#__PURE__*/function () {\n  function Animation(vars) {\n    this.vars = vars;\n    this._delay = +vars.delay || 0;\n\n    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.\n      this._rDelay = vars.repeatDelay || 0;\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n    }\n\n    this._ts = 1;\n\n    _setDuration(this, +vars.duration, 1, 1);\n\n    this.data = vars.data;\n\n    if (_context) {\n      this._ctx = _context;\n\n      _context.data.push(this);\n    }\n\n    _tickerActive || _ticker.wake();\n  }\n\n  var _proto = Animation.prototype;\n\n  _proto.delay = function delay(value) {\n    if (value || value === 0) {\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n      this._delay = value;\n      return this;\n    }\n\n    return this._delay;\n  };\n\n  _proto.duration = function duration(value) {\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n  };\n\n  _proto.totalDuration = function totalDuration(value) {\n    if (!arguments.length) {\n      return this._tDur;\n    }\n\n    this._dirty = 0;\n    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n  };\n\n  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n    _wake();\n\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    var parent = this._dp;\n\n    if (parent && parent.smoothChildTiming && this._ts) {\n      _alignPlayhead(this, _totalTime);\n\n      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n\n      while (parent && parent.parent) {\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n          parent.totalTime(parent._tTime, true);\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.\n        _addToTimeline(this._dp, this, this._start - this._delay);\n      }\n    }\n\n    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)\n      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause\n      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)\n      //   this._lock = 1;\n\n      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\n      //}\n\n    }\n\n    return this;\n  };\n\n  _proto.time = function time(value, suppressEvents) {\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n  };\n\n  _proto.totalProgress = function totalProgress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;\n  };\n\n  _proto.progress = function progress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\n  };\n\n  _proto.iteration = function iteration(value, suppressEvents) {\n    var cycleDuration = this.duration() + this._rDelay;\n\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n  } // potential future addition:\n  // isPlayingBackwards() {\n  // \tlet animation = this,\n  // \t\torientation = 1; // 1 = forward, -1 = backward\n  // \twhile (animation) {\n  // \t\torientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;\n  // \t\tanimation = animation.parent;\n  // \t}\n  // \treturn orientation < 0;\n  // }\n  ;\n\n  _proto.timeScale = function timeScale(value, suppressEvents) {\n    if (!arguments.length) {\n      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.\n    }\n\n    if (this._rts === value) {\n      return this;\n    }\n\n    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.\n    //(+value < 0 && this._rts >= 0) && _callback(this, \"onReverse\", true);\n    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n\n    this._rts = +value || 0;\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n\n    this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);\n\n    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.\n\n\n    return _recacheAncestors(this);\n  };\n\n  _proto.paused = function paused(value) {\n    if (!arguments.length) {\n      return this._ps;\n    }\n\n    if (this._ps !== value) {\n      this._ps = value;\n\n      if (value) {\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.\n\n        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the \"real\" timeScale as _rts (recorded time scale)\n      } else {\n        _wake();\n\n        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.\n\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.\n      }\n    }\n\n    return this;\n  };\n\n  _proto.startTime = function startTime(value) {\n    if (arguments.length) {\n      this._start = value;\n      var parent = this.parent || this._dp;\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n      return this;\n    }\n\n    return this._start;\n  };\n\n  _proto.endTime = function endTime(includeRepeats) {\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n  };\n\n  _proto.rawTime = function rawTime(wrapRepeats) {\n    var parent = this.parent || this._dp; // _dp = detached parent\n\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n  };\n\n  _proto.revert = function revert(config) {\n    if (config === void 0) {\n      config = _revertConfig;\n    }\n\n    var prevIsReverting = _reverting;\n    _reverting = config;\n\n    if (this._initted || this._startAt) {\n      this.timeline && this.timeline.revert(config);\n      this.totalTime(-0.01, config.suppressEvents);\n    }\n\n    this.data !== \"nested\" && config.kill !== false && this.kill();\n    _reverting = prevIsReverting;\n    return this;\n  };\n\n  _proto.globalTime = function globalTime(rawTime) {\n    var animation = this,\n        time = arguments.length ? rawTime : animation.rawTime();\n\n    while (animation) {\n      time = animation._start + time / (Math.abs(animation._ts) || 1);\n      animation = animation._dp;\n    }\n\n    return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). \"_sat\" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().\n  };\n\n  _proto.repeat = function repeat(value) {\n    if (arguments.length) {\n      this._repeat = value === Infinity ? -2 : value;\n      return _onUpdateTotalDuration(this);\n    }\n\n    return this._repeat === -2 ? Infinity : this._repeat;\n  };\n\n  _proto.repeatDelay = function repeatDelay(value) {\n    if (arguments.length) {\n      var time = this._time;\n      this._rDelay = value;\n\n      _onUpdateTotalDuration(this);\n\n      return time ? this.time(time) : this;\n    }\n\n    return this._rDelay;\n  };\n\n  _proto.yoyo = function yoyo(value) {\n    if (arguments.length) {\n      this._yoyo = value;\n      return this;\n    }\n\n    return this._yoyo;\n  };\n\n  _proto.seek = function seek(position, suppressEvents) {\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n  };\n\n  _proto.restart = function restart(includeDelay, suppressEvents) {\n    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n  };\n\n  _proto.play = function play(from, suppressEvents) {\n    from != null && this.seek(from, suppressEvents);\n    return this.reversed(false).paused(false);\n  };\n\n  _proto.reverse = function reverse(from, suppressEvents) {\n    from != null && this.seek(from || this.totalDuration(), suppressEvents);\n    return this.reversed(true).paused(false);\n  };\n\n  _proto.pause = function pause(atTime, suppressEvents) {\n    atTime != null && this.seek(atTime, suppressEvents);\n    return this.paused(true);\n  };\n\n  _proto.resume = function resume() {\n    return this.paused(false);\n  };\n\n  _proto.reversed = function reversed(value) {\n    if (arguments.length) {\n      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n\n      return this;\n    }\n\n    return this._rts < 0;\n  };\n\n  _proto.invalidate = function invalidate() {\n    this._initted = this._act = 0;\n    this._zTime = -_tinyNum;\n    return this;\n  };\n\n  _proto.isActive = function isActive() {\n    var parent = this.parent || this._dp,\n        start = this._start,\n        rawTime;\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n  };\n\n  _proto.eventCallback = function eventCallback(type, callback, params) {\n    var vars = this.vars;\n\n    if (arguments.length > 1) {\n      if (!callback) {\n        delete vars[type];\n      } else {\n        vars[type] = callback;\n        params && (vars[type + \"Params\"] = params);\n        type === \"onUpdate\" && (this._onUpdate = callback);\n      }\n\n      return this;\n    }\n\n    return vars[type];\n  };\n\n  _proto.then = function then(onFulfilled) {\n    var self = this;\n    return new Promise(function (resolve) {\n      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\n          _resolve = function _resolve() {\n        var _then = self.then;\n        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n\n        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n        resolve(f);\n        self.then = _then;\n      };\n\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n        _resolve();\n      } else {\n        self._prom = _resolve;\n      }\n    });\n  };\n\n  _proto.kill = function kill() {\n    _interrupt(this);\n  };\n\n  return Animation;\n}();\n\n_setDefaults(Animation.prototype, {\n  _time: 0,\n  _start: 0,\n  _end: 0,\n  _tTime: 0,\n  _tDur: 0,\n  _dirty: 0,\n  _repeat: 0,\n  _yoyo: false,\n  parent: null,\n  _initted: false,\n  _rDelay: 0,\n  _ts: 1,\n  _dp: 0,\n  ratio: 0,\n  _zTime: -_tinyNum,\n  _prom: 0,\n  _ps: false,\n  _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */\n\n\nvar Timeline = /*#__PURE__*/function (_Animation) {\n  _inheritsLoose(Timeline, _Animation);\n\n  function Timeline(vars, position) {\n    var _this;\n\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    _this = _Animation.call(this, vars) || this;\n    _this.labels = {};\n    _this.smoothChildTiming = !!vars.smoothChildTiming;\n    _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n    _this._sort = _isNotFalse(vars.sortChildren);\n    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n    vars.reversed && _this.reverse();\n    vars.paused && _this.paused(true);\n    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n    return _this;\n  }\n\n  var _proto2 = Timeline.prototype;\n\n  _proto2.to = function to(targets, vars, position) {\n    _createTweenType(0, arguments, this);\n\n    return this;\n  };\n\n  _proto2.from = function from(targets, vars, position) {\n    _createTweenType(1, arguments, this);\n\n    return this;\n  };\n\n  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n    _createTweenType(2, arguments, this);\n\n    return this;\n  };\n\n  _proto2.set = function set(targets, vars, position) {\n    vars.duration = 0;\n    vars.parent = this;\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n    vars.immediateRender = !!vars.immediateRender;\n    new Tween(targets, vars, _parsePosition(this, position), 1);\n    return this;\n  };\n\n  _proto2.call = function call(callback, params, position) {\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n  } //ONLY for backward compatibility! Maybe delete?\n  ;\n\n  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.duration = duration;\n    vars.stagger = vars.stagger || stagger;\n    vars.onComplete = onCompleteAll;\n    vars.onCompleteParams = onCompleteAllParams;\n    vars.parent = this;\n    new Tween(targets, vars, _parsePosition(this, position));\n    return this;\n  };\n\n  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.runBackwards = 1;\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    toVars.startAt = fromVars;\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._dirty ? this.totalDuration() : this._tDur,\n        dur = this._dur,\n        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),\n        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.\n    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\n        time,\n        child,\n        next,\n        iteration,\n        cycleDuration,\n        prevPaused,\n        pauseTween,\n        timeScale,\n        prevStart,\n        prevIteration,\n        yoyo,\n        isYoyo;\n    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n\n    if (tTime !== this._tTime || force || crossingStart) {\n      if (prevTime !== this._time && dur) {\n        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).\n        tTime += this._time - prevTime;\n        totalTime += this._time - prevTime;\n      }\n\n      time = tTime;\n      prevStart = this._start;\n      timeScale = this._ts;\n      prevPaused = !timeScale;\n\n      if (crossingStart) {\n        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\n      }\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        yoyo = this._yoyo;\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n\n          time > dur && (time = dur);\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the \"repeatDelay\" portion\n\n        if (yoyo && iteration & 1) {\n          time = dur - time;\n          isYoyo = 1;\n        }\n        /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */\n\n\n        if (iteration !== prevIteration && !this._lock) {\n          var rewinding = yoyo && prevIteration & 1,\n              doesWrap = rewinding === (yoyo && iteration & 1);\n          iteration < prevIteration && (rewinding = !rewinding);\n          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.\n\n          this._lock = 1;\n          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.\n\n          !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n\n          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.\n            return this;\n          }\n\n          dur = this._dur; // in case the duration changed in the onRepeat\n\n          tDur = this._tDur;\n\n          if (doesWrap) {\n            this._lock = 2;\n            prevTime = rewinding ? dur : -0.0001;\n            this.render(prevTime, true);\n            this.vars.repeatRefresh && !isYoyo && this.invalidate();\n          }\n\n          this._lock = 0;\n\n          if (!this._ts && !prevPaused) {\n            return this;\n          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.\n\n\n          _propagateYoyoEase(this, isYoyo);\n        }\n      }\n\n      if (this._hasPause && !this._forcing && this._lock < 2) {\n        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n\n        if (pauseTween) {\n          tTime -= time - (time = pauseTween._start);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n\n      if (!this._initted) {\n        this._onUpdate = this.vars.onUpdate;\n        this._initted = 1;\n        this._zTime = totalTime;\n        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n      }\n\n      if (!prevTime && time && !suppressEvents && !iteration) {\n        _callback(this, \"onStart\");\n\n        if (this._tTime !== tTime) {\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n          return this;\n        }\n      }\n\n      if (time >= prevTime && totalTime >= 0) {\n        child = this._first;\n\n        while (child) {\n          next = child._next;\n\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      } else {\n        child = this._last;\n        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n\n        while (child) {\n          next = child._prev;\n\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      }\n\n      if (pauseTween && !suppressEvents) {\n        this.pause();\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n\n        if (this._ts) {\n          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).\n          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.\n\n          _setEnd(this);\n\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\n        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.\n        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n          _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto2.add = function add(child, position) {\n    var _this2 = this;\n\n    _isNumber(position) || (position = _parsePosition(this, position, child));\n\n    if (!(child instanceof Animation)) {\n      if (_isArray(child)) {\n        child.forEach(function (obj) {\n          return _this2.add(obj, position);\n        });\n        return this;\n      }\n\n      if (_isString(child)) {\n        return this.addLabel(child, position);\n      }\n\n      if (_isFunction(child)) {\n        child = Tween.delayedCall(0, child);\n      } else {\n        return this;\n      }\n    }\n\n    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!\n  };\n\n  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n    if (nested === void 0) {\n      nested = true;\n    }\n\n    if (tweens === void 0) {\n      tweens = true;\n    }\n\n    if (timelines === void 0) {\n      timelines = true;\n    }\n\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = -_bigNum;\n    }\n\n    var a = [],\n        child = this._first;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        if (child instanceof Tween) {\n          tweens && a.push(child);\n        } else {\n          timelines && a.push(child);\n          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n        }\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  };\n\n  _proto2.getById = function getById(id) {\n    var animations = this.getChildren(1, 1, 1),\n        i = animations.length;\n\n    while (i--) {\n      if (animations[i].vars.id === id) {\n        return animations[i];\n      }\n    }\n  };\n\n  _proto2.remove = function remove(child) {\n    if (_isString(child)) {\n      return this.removeLabel(child);\n    }\n\n    if (_isFunction(child)) {\n      return this.killTweensOf(child);\n    }\n\n    _removeLinkedListItem(this, child);\n\n    if (child === this._recent) {\n      this._recent = this._last;\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    this._forcing = 1;\n\n    if (!this._dp && this._ts) {\n      //special case for the global timeline (or any other that has no parent or detached parent).\n      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n    }\n\n    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n\n    this._forcing = 0;\n    return this;\n  };\n\n  _proto2.addLabel = function addLabel(label, position) {\n    this.labels[label] = _parsePosition(this, position);\n    return this;\n  };\n\n  _proto2.removeLabel = function removeLabel(label) {\n    delete this.labels[label];\n    return this;\n  };\n\n  _proto2.addPause = function addPause(position, callback, params) {\n    var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n    t.data = \"isPause\";\n    this._hasPause = 1;\n    return _addToTimeline(this, t, _parsePosition(this, position));\n  };\n\n  _proto2.removePause = function removePause(position) {\n    var child = this._first;\n    position = _parsePosition(this, position);\n\n    while (child) {\n      if (child._start === position && child.data === \"isPause\") {\n        _removeFromParent(child);\n      }\n\n      child = child._next;\n    }\n  };\n\n  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    var tweens = this.getTweensOf(targets, onlyActive),\n        i = tweens.length;\n\n    while (i--) {\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n    }\n\n    return this;\n  };\n\n  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n    var a = [],\n        parsedTargets = toArray(targets),\n        child = this._first,\n        isGlobalTime = _isNumber(onlyActive),\n        // a number is interpreted as a global time. If the animation spans\n    children;\n\n    while (child) {\n      if (child instanceof Tween) {\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.\n          a.push(child);\n        }\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n        a.push.apply(a, children);\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  } // potential future feature - targets() on timelines\n  // targets() {\n  // \tlet result = [];\n  // \tthis.getChildren(true, true, false).forEach(t => result.push(...t.targets()));\n  // \treturn result.filter((v, i) => result.indexOf(v) === i);\n  // }\n  ;\n\n  _proto2.tweenTo = function tweenTo(position, vars) {\n    vars = vars || {};\n\n    var tl = this,\n        endTime = _parsePosition(tl, position),\n        _vars = vars,\n        startAt = _vars.startAt,\n        _onStart = _vars.onStart,\n        onStartParams = _vars.onStartParams,\n        immediateRender = _vars.immediateRender,\n        initted,\n        tween = Tween.to(tl, _setDefaults({\n      ease: vars.ease || \"none\",\n      lazy: false,\n      immediateRender: false,\n      time: endTime,\n      overwrite: \"auto\",\n      duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n      onStart: function onStart() {\n        tl.pause();\n\n        if (!initted) {\n          var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n          initted = 1;\n        }\n\n        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.\n      }\n    }, vars));\n\n    return immediateRender ? tween.render(0) : tween;\n  };\n\n  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n    return this.tweenTo(toPosition, _setDefaults({\n      startAt: {\n        time: _parsePosition(this, fromPosition)\n      }\n    }, vars));\n  };\n\n  _proto2.recent = function recent() {\n    return this._recent;\n  };\n\n  _proto2.nextLabel = function nextLabel(afterTime) {\n    if (afterTime === void 0) {\n      afterTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\n  };\n\n  _proto2.previousLabel = function previousLabel(beforeTime) {\n    if (beforeTime === void 0) {\n      beforeTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n  };\n\n  _proto2.currentLabel = function currentLabel(value) {\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n  };\n\n  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = 0;\n    }\n\n    var child = this._first,\n        labels = this.labels,\n        p;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        child._start += amount;\n        child._end += amount;\n      }\n\n      child = child._next;\n    }\n\n    if (adjustLabels) {\n      for (p in labels) {\n        if (labels[p] >= ignoreBeforeTime) {\n          labels[p] += amount;\n        }\n      }\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.invalidate = function invalidate(soft) {\n    var child = this._first;\n    this._lock = 0;\n\n    while (child) {\n      child.invalidate(soft);\n      child = child._next;\n    }\n\n    return _Animation.prototype.invalidate.call(this, soft);\n  };\n\n  _proto2.clear = function clear(includeLabels) {\n    if (includeLabels === void 0) {\n      includeLabels = true;\n    }\n\n    var child = this._first,\n        next;\n\n    while (child) {\n      next = child._next;\n      this.remove(child);\n      child = next;\n    }\n\n    this._dp && (this._time = this._tTime = this._pTime = 0);\n    includeLabels && (this.labels = {});\n    return _uncache(this);\n  };\n\n  _proto2.totalDuration = function totalDuration(value) {\n    var max = 0,\n        self = this,\n        child = self._last,\n        prevStart = _bigNum,\n        prev,\n        start,\n        parent;\n\n    if (arguments.length) {\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n    }\n\n    if (self._dirty) {\n      parent = self.parent;\n\n      while (child) {\n        prev = child._prev; //record it here in case the tween changes position in the sequence...\n\n        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.\n\n        start = child._start;\n\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\n          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n        } else {\n          prevStart = start;\n        }\n\n        if (start < 0 && child._ts) {\n          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n          max -= start;\n\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n            self._start += start / self._ts;\n            self._time -= start;\n            self._tTime -= start;\n          }\n\n          self.shiftChildren(-start, false, -1e999);\n          prevStart = 0;\n        }\n\n        child._end > max && child._ts && (max = child._end);\n        child = prev;\n      }\n\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n\n      self._dirty = 0;\n    }\n\n    return self._tDur;\n  };\n\n  Timeline.updateRoot = function updateRoot(time) {\n    if (_globalTimeline._ts) {\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n\n      _lastRenderedFrame = _ticker.frame;\n    }\n\n    if (_ticker.frame >= _nextGCFrame) {\n      _nextGCFrame += _config.autoSleep || 120;\n      var child = _globalTimeline._first;\n      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\n        while (child && !child._ts) {\n          child = child._next;\n        }\n\n        child || _ticker.sleep();\n      }\n    }\n  };\n\n  return Timeline;\n}(Animation);\n\n_setDefaults(Timeline.prototype, {\n  _lock: 0,\n  _hasPause: 0,\n  _forcing: 0\n});\n\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\n      index = 0,\n      matchIndex = 0,\n      result,\n      startNums,\n      color,\n      endNum,\n      chunk,\n      startNum,\n      hasRandom,\n      a;\n  pt.b = start;\n  pt.e = end;\n  start += \"\"; //ensure values are strings\n\n  end += \"\";\n\n  if (hasRandom = ~end.indexOf(\"random(\")) {\n    end = _replaceRandom(end);\n  }\n\n  if (stringFilter) {\n    a = [start, end];\n    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n\n    start = a[0];\n    end = a[1];\n  }\n\n  startNums = start.match(_complexStringNumExp) || [];\n\n  while (result = _complexStringNumExp.exec(end)) {\n    endNum = result[0];\n    chunk = end.substring(index, result.index);\n\n    if (color) {\n      color = (color + 1) % 5;\n    } else if (chunk.substr(-5) === \"rgba(\") {\n      color = 1;\n    }\n\n    if (endNum !== startNums[matchIndex++]) {\n      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n\n      pt._pt = {\n        _next: pt._pt,\n        p: chunk || matchIndex === 1 ? chunk : \",\",\n        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n        s: startNum,\n        c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n        m: color && color < 4 ? Math.round : 0\n      };\n      index = _complexStringNumExp.lastIndex;\n    }\n  }\n\n  pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n\n  pt.fp = funcParam;\n\n  if (_relExp.test(end) || hasRandom) {\n    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n  }\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n\n  return pt;\n},\n    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n  _isFunction(end) && (end = end(index || 0, target, targets));\n  var currentValue = target[prop],\n      parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](),\n      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\n      pt;\n\n  if (_isString(end)) {\n    if (~end.indexOf(\"random(\")) {\n      end = _replaceRandom(end);\n    }\n\n    if (end.charAt(1) === \"=\") {\n      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n\n      if (pt || pt === 0) {\n        // to avoid isNaN, like if someone passes in a value like \"!= whatever\"\n        end = pt;\n      }\n    }\n  }\n\n  if (!optional || parsedStart !== end || _forceAllPropTweens) {\n    if (!isNaN(parsedStart * end) && end !== \"\") {\n      // fun fact: any number multiplied by \"\" is evaluated as the number 0!\n      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n      funcParam && (pt.fp = funcParam);\n      modifier && pt.modifier(modifier, this, target);\n      return this._pt = pt;\n    }\n\n    !currentValue && !(prop in target) && _missingPlugin(prop, end);\n    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n  }\n},\n    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with \"random()\" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n\n  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n  }\n\n  var copy = {},\n      p;\n\n  for (p in vars) {\n    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n  }\n\n  return copy;\n},\n    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n  var plugin, pt, ptLookup, i;\n\n  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n    if (tween !== _quickTween) {\n      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.\n\n      i = plugin._props.length;\n\n      while (i--) {\n        ptLookup[plugin._props[i]] = pt;\n      }\n    }\n  }\n\n  return plugin;\n},\n    _overwritingTween,\n    //store a reference temporarily so we can avoid overwriting itself.\n_forceAllPropTweens,\n    _initTween = function _initTween(tween, time, tTime) {\n  var vars = tween.vars,\n      ease = vars.ease,\n      startAt = vars.startAt,\n      immediateRender = vars.immediateRender,\n      lazy = vars.lazy,\n      onUpdate = vars.onUpdate,\n      runBackwards = vars.runBackwards,\n      yoyoEase = vars.yoyoEase,\n      keyframes = vars.keyframes,\n      autoRevert = vars.autoRevert,\n      dur = tween._dur,\n      prevStartAt = tween._startAt,\n      targets = tween._targets,\n      parent = tween.parent,\n      fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets,\n      autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites,\n      tl = tween.timeline,\n      cleanVars,\n      i,\n      p,\n      pt,\n      target,\n      hasPriority,\n      gsData,\n      harness,\n      plugin,\n      ptLookup,\n      index,\n      harnessVars,\n      overwritten;\n  tl && (!keyframes || !ease) && (ease = \"none\");\n  tween._ease = _parseEase(ease, _defaults.ease);\n  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n\n  if (yoyoEase && tween._yoyo && !tween._repeat) {\n    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n    yoyoEase = tween._yEase;\n    tween._yEase = tween._ease;\n    tween._ease = yoyoEase;\n  }\n\n  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n\n  if (!tl || keyframes && !vars.stagger) {\n    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.\n    harness = targets[0] ? _getCache(targets[0]).harness : 0;\n    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an \"x\" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n\n    cleanVars = _copyExcluding(vars, _reservedProps);\n\n    if (prevStartAt) {\n      prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.\n\n      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a \"startAt\" (not \"from()\" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)\n      // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for \"startAt\" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.\n\n      prevStartAt._lazy = 0;\n    }\n\n    if (startAt) {\n      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n        data: \"isStart\",\n        overwrite: false,\n        parent: parent,\n        immediateRender: true,\n        lazy: !prevStartAt && _isNotFalse(lazy),\n        startAt: null,\n        delay: 0,\n        onUpdate: onUpdate && function () {\n          return _callback(tween, \"onUpdate\");\n        },\n        stagger: 0\n      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n\n\n      tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.\n\n      tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween\n\n      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.\n\n      if (immediateRender) {\n        if (dur && time <= 0 && tTime <= 0) {\n          // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.\n          time && (tween._zTime = time);\n          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\n        }\n      }\n    } else if (runBackwards && dur) {\n      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n      if (!prevStartAt) {\n        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\n\n        p = _setDefaults({\n          overwrite: false,\n          data: \"isFromStart\",\n          //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n          immediateRender: immediateRender,\n          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n          stagger: 0,\n          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\n\n        }, cleanVars);\n        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n\n        _removeFromParent(tween._startAt = Tween.set(targets, p));\n\n        tween._startAt._dp = 0; // don't allow it to get put back into root timeline!\n\n        tween._startAt._sat = tween; // used in globalTime()\n\n        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n        tween._zTime = time;\n\n        if (!immediateRender) {\n          _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded\n\n        } else if (!time) {\n          return;\n        }\n      }\n    }\n\n    tween._pt = tween._ptCache = 0;\n    lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n\n    for (i = 0; i < targets.length; i++) {\n      target = targets[i];\n      gsData = target._gsap || _harness(targets)[i]._gsap;\n      tween._ptLookup[i] = ptLookup = {};\n      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n\n      index = fullTargets === targets ? i : fullTargets.indexOf(target);\n\n      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n        plugin._props.forEach(function (name) {\n          ptLookup[name] = pt;\n        });\n\n        plugin.priority && (hasPriority = 1);\n      }\n\n      if (!harness || harnessVars) {\n        for (p in cleanVars) {\n          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n            plugin.priority && (hasPriority = 1);\n          } else {\n            ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n          }\n        }\n      }\n\n      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n\n      if (autoOverwrite && tween._pt) {\n        _overwritingTween = tween;\n\n        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!\n\n\n        overwritten = !tween.parent;\n        _overwritingTween = 0;\n      }\n\n      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n    }\n\n    hasPriority && _sortPropTweensByPriority(tween);\n    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.\n  }\n\n  tween._onUpdate = onUpdate;\n  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n\n  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the \"before\" state for any staggered/delayed animations thus when the following tween initializes, it'll use the \"before\" state instead of the \"after\" state as the initial values.\n},\n    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\n  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],\n      pt,\n      rootPT,\n      lookup,\n      i;\n\n  if (!ptCache) {\n    ptCache = tween._ptCache[property] = [];\n    lookup = tween._ptLookup;\n    i = tween._targets.length;\n\n    while (i--) {\n      pt = lookup[i][property];\n\n      if (pt && pt.d && pt.d._pt) {\n        // it's a plugin, so find the nested PropTween\n        pt = pt.d._pt;\n\n        while (pt && pt.p !== property && pt.fp !== property) {\n          // \"fp\" is functionParam for things like setting CSS variables which require .setProperty(\"--var-name\", value)\n          pt = pt._next;\n        }\n      }\n\n      if (!pt) {\n        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this\n        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo(\"x\", 200) for example.\n        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.\n\n        tween.vars[property] = \"+=0\";\n\n        _initTween(tween, time);\n\n        _forceAllPropTweens = 0;\n        return skipRecursion ? _warn(property + \" not eligible for reset\") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().\n      }\n\n      ptCache.push(pt);\n    }\n  }\n\n  i = ptCache.length;\n\n  while (i--) {\n    rootPT = ptCache[i];\n    pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.\n\n    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n    pt.c = value - pt.s;\n    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)\n\n    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)\n  }\n},\n    _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n  var harness = targets[0] ? _getCache(targets[0]).harness : 0,\n      propertyAliases = harness && harness.aliases,\n      copy,\n      p,\n      i,\n      aliases;\n\n  if (!propertyAliases) {\n    return vars;\n  }\n\n  copy = _merge({}, vars);\n\n  for (p in propertyAliases) {\n    if (p in copy) {\n      aliases = propertyAliases[p].split(\",\");\n      i = aliases.length;\n\n      while (i--) {\n        copy[aliases[i]] = copy[p];\n      }\n    }\n  }\n\n  return copy;\n},\n    // parses multiple formats, like {\"0%\": {x: 100}, {\"50%\": {x: -20}} and { x: {\"0%\": 100, \"50%\": -20} }, and an \"ease\" can be set on any object. We populate an \"allProps\" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a \"t\" (time), \"v\", (value), and \"e\" (ease) property. This allows us to piece together a timeline later.\n_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n  var ease = obj.ease || easeEach || \"power1.inOut\",\n      p,\n      a;\n\n  if (_isArray(obj)) {\n    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease\n\n    obj.forEach(function (value, i) {\n      return a.push({\n        t: i / (obj.length - 1) * 100,\n        v: value,\n        e: ease\n      });\n    });\n  } else {\n    for (p in obj) {\n      a = allProps[p] || (allProps[p] = []);\n      p === \"ease\" || a.push({\n        t: parseFloat(prop),\n        v: obj[p],\n        e: ease\n      });\n    }\n  }\n},\n    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n},\n    _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\",\n    _staggerPropsToSkip = {};\n\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function (name) {\n  return _staggerPropsToSkip[name] = 1;\n});\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar Tween = /*#__PURE__*/function (_Animation2) {\n  _inheritsLoose(Tween, _Animation2);\n\n  function Tween(targets, vars, position, skipInherit) {\n    var _this3;\n\n    if (typeof vars === \"number\") {\n      position.duration = vars;\n      vars = position;\n      position = null;\n    }\n\n    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n    var _this3$vars = _this3.vars,\n        duration = _this3$vars.duration,\n        delay = _this3$vars.delay,\n        immediateRender = _this3$vars.immediateRender,\n        stagger = _this3$vars.stagger,\n        overwrite = _this3$vars.overwrite,\n        keyframes = _this3$vars.keyframes,\n        defaults = _this3$vars.defaults,\n        scrollTrigger = _this3$vars.scrollTrigger,\n        yoyoEase = _this3$vars.yoyoEase,\n        parent = vars.parent || _globalTimeline,\n        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [targets] : toArray(targets),\n        tl,\n        i,\n        copy,\n        l,\n        p,\n        curTarget,\n        staggerFunc,\n        staggerVarsToMerge;\n    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\n    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n\n    _this3._overwrite = overwrite;\n\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n      vars = _this3.vars;\n      tl = _this3.timeline = new Timeline({\n        data: \"nested\",\n        defaults: defaults || {},\n        targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.\n\n      tl.kill();\n      tl.parent = tl._dp = _assertThisInitialized(_this3);\n      tl._start = 0;\n\n      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n        l = parsedTargets.length;\n        staggerFunc = stagger && distribute(stagger);\n\n        if (_isObject(stagger)) {\n          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n          for (p in stagger) {\n            if (~_staggerTweenProps.indexOf(p)) {\n              staggerVarsToMerge || (staggerVarsToMerge = {});\n              staggerVarsToMerge[p] = stagger[p];\n            }\n          }\n        }\n\n        for (i = 0; i < l; i++) {\n          copy = _copyExcluding(vars, _staggerPropsToSkip);\n          copy.stagger = 0;\n          yoyoEase && (copy.yoyoEase = yoyoEase);\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n\n          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n\n          if (!stagger && l === 1 && copy.delay) {\n            // if someone does delay:\"random(1, 5)\", repeat:-1, for example, the delay shouldn't be inside the repeat.\n            _this3._delay = delay = copy.delay;\n            _this3._start += delay;\n            copy.delay = 0;\n          }\n\n          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n          tl._ease = _easeMap.none;\n        }\n\n        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!\n      } else if (keyframes) {\n        _inheritDefaults(_setDefaults(tl.vars.defaults, {\n          ease: \"none\"\n        }));\n\n        tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n        var time = 0,\n            a,\n            kf,\n            v;\n\n        if (_isArray(keyframes)) {\n          keyframes.forEach(function (frame) {\n            return tl.to(parsedTargets, frame, \">\");\n          });\n          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.\n        } else {\n          copy = {};\n\n          for (p in keyframes) {\n            p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n          }\n\n          for (p in copy) {\n            a = copy[p].sort(function (a, b) {\n              return a.t - b.t;\n            });\n            time = 0;\n\n            for (i = 0; i < a.length; i++) {\n              kf = a[i];\n              v = {\n                ease: kf.e,\n                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n              };\n              v[p] = kf.v;\n              tl.to(parsedTargets, v, time);\n              time += v.duration;\n            }\n          }\n\n          tl.duration() < duration && tl.to({}, {\n            duration: duration - tl.duration()\n          }); // in case keyframes didn't go to 100%\n        }\n      }\n\n      duration || _this3.duration(duration = tl.duration());\n    } else {\n      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n    }\n\n    if (overwrite === true && !_suppressOverwrites) {\n      _overwritingTween = _assertThisInitialized(_this3);\n\n      _globalTimeline.killTweensOf(parsedTargets);\n\n      _overwritingTween = 0;\n    }\n\n    _addToTimeline(parent, _assertThisInitialized(_this3), position);\n\n    vars.reversed && _this3.reverse();\n    vars.paused && _this3.paused(true);\n\n    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n      _this3._tTime = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n\n      _this3.render(Math.max(0, -delay) || 0); //in case delay is negative\n\n    }\n\n    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n    return _this3;\n  }\n\n  var _proto3 = Tween.prototype;\n\n  _proto3.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._tDur,\n        dur = this._dur,\n        isNegative = totalTime < 0,\n        tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n        time,\n        pt,\n        iteration,\n        cycleDuration,\n        prevIteration,\n        isYoyo,\n        ratio,\n        timeline,\n        yoyoEase;\n\n    if (!dur) {\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {\n      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n      time = tTime;\n      timeline = this.timeline;\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && isNegative) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n\n          if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {\n            time = dur;\n            iteration--;\n          }\n\n          time > dur && (time = dur);\n        }\n\n        isYoyo = this._yoyo && iteration & 1;\n\n        if (isYoyo) {\n          yoyoEase = this._yEase;\n          time = dur - time;\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n\n        if (time === prevTime && !force && this._initted && iteration === prevIteration) {\n          //could be during the repeatDelay part. No need to render and fire callbacks.\n          this._tTime = tTime;\n          return this;\n        }\n\n        if (iteration !== prevIteration) {\n          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {\n            // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).\n            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.\n\n            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n          }\n        }\n      }\n\n      if (!this._initted) {\n        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.\n\n          return this;\n        }\n\n        if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\n          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!\n          return this;\n        }\n\n        if (dur !== this._dur) {\n          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n\n      if (!this._act && this._ts) {\n        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n\n        this._lazy = 0;\n      }\n\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n\n      if (this._from) {\n        this.ratio = ratio = 1 - ratio;\n      }\n\n      if (time && !prevTime && !suppressEvents && !iteration) {\n        _callback(this, \"onStart\");\n\n        if (this._tTime !== tTime) {\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n          return this;\n        }\n      }\n\n      pt = this._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n\n      timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n\n      if (this._onUpdate && !suppressEvents) {\n        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n\n        _callback(this, \"onUpdate\");\n      }\n\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n          _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto3.targets = function targets() {\n    return this._targets;\n  };\n\n  _proto3.invalidate = function invalidate(soft) {\n    // \"soft\" gives us a way to clear out everything EXCEPT the recorded pre-\"from\" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the \"from\" values would persist and then on the next render, the from() tweens would initialize and the current value would match the \"from\" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.\n    (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n    this._ptLookup = [];\n    this.timeline && this.timeline.invalidate(soft);\n    return _Animation2.prototype.invalidate.call(this, soft);\n  };\n\n  _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\n    _tickerActive || _ticker.wake();\n    this._ts || this.play();\n    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),\n        ratio;\n    this._initted || _initTween(this, time);\n    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.\n    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.\n    // if (_isObject(property)) { // performance optimization\n    // \tfor (p in property) {\n    // \t\tif (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {\n    // \t\t\treturn this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n    // \t\t}\n    // \t}\n    // } else {\n\n    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\n      return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n    } //}\n\n\n    _alignPlayhead(this, 0);\n\n    this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n    return this.render(0);\n  };\n\n  _proto3.kill = function kill(targets, vars) {\n    if (vars === void 0) {\n      vars = \"all\";\n    }\n\n    if (!targets && (!vars || vars === \"all\")) {\n      this._lazy = this._pt = 0;\n      return this.parent ? _interrupt(this) : this;\n    }\n\n    if (this.timeline) {\n      var tDur = this.timeline.totalDuration();\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.\n\n      return this;\n    }\n\n    var parsedTargets = this._targets,\n        killingTargets = targets ? toArray(targets) : parsedTargets,\n        propTweenLookup = this._ptLookup,\n        firstPT = this._pt,\n        overwrittenProps,\n        curLookup,\n        curOverwriteProps,\n        props,\n        p,\n        pt,\n        i;\n\n    if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n      vars === \"all\" && (this._pt = 0);\n      return _interrupt(this);\n    }\n\n    overwrittenProps = this._op = this._op || [];\n\n    if (vars !== \"all\") {\n      //so people can pass in a comma-delimited list of property names\n      if (_isString(vars)) {\n        p = {};\n\n        _forEachName(vars, function (name) {\n          return p[name] = 1;\n        });\n\n        vars = p;\n      }\n\n      vars = _addAliasesToVars(parsedTargets, vars);\n    }\n\n    i = parsedTargets.length;\n\n    while (i--) {\n      if (~killingTargets.indexOf(parsedTargets[i])) {\n        curLookup = propTweenLookup[i];\n\n        if (vars === \"all\") {\n          overwrittenProps[i] = vars;\n          props = curLookup;\n          curOverwriteProps = {};\n        } else {\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n          props = vars;\n        }\n\n        for (p in props) {\n          pt = curLookup && curLookup[p];\n\n          if (pt) {\n            if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n              _removeLinkedListItem(this, pt, \"_pt\");\n            }\n\n            delete curLookup[p];\n          }\n\n          if (curOverwriteProps !== \"all\") {\n            curOverwriteProps[p] = 1;\n          }\n        }\n      }\n    }\n\n    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\n\n    return this;\n  };\n\n  Tween.to = function to(targets, vars) {\n    return new Tween(targets, vars, arguments[2]);\n  };\n\n  Tween.from = function from(targets, vars) {\n    return _createTweenType(1, arguments);\n  };\n\n  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n    return new Tween(callback, 0, {\n      immediateRender: false,\n      lazy: false,\n      overwrite: false,\n      delay: delay,\n      onComplete: callback,\n      onReverseComplete: callback,\n      onCompleteParams: params,\n      onReverseCompleteParams: params,\n      callbackScope: scope\n    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)\n  };\n\n  Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n    return _createTweenType(2, arguments);\n  };\n\n  Tween.set = function set(targets, vars) {\n    vars.duration = 0;\n    vars.repeatDelay || (vars.repeat = 0);\n    return new Tween(targets, vars);\n  };\n\n  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\n  };\n\n  return Tween;\n}(Animation);\n\n_setDefaults(Tween.prototype, {\n  _targets: [],\n  _lazy: 0,\n  _startAt: 0,\n  _op: 0,\n  _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)\n// _forEachName(\"to,from,fromTo,set,call,add,addLabel,addPause\", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n\n\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function (name) {\n  Tween[name] = function () {\n    var tl = new Timeline(),\n        params = _slice.call(arguments, 0);\n\n    params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n    return tl[name].apply(tl, params);\n  };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _setterPlain = function _setterPlain(target, property, value) {\n  return target[property] = value;\n},\n    _setterFunc = function _setterFunc(target, property, value) {\n  return target[property](value);\n},\n    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n  return target[property](data.fp, value);\n},\n    _setterAttribute = function _setterAttribute(target, property, value) {\n  return target.setAttribute(property, value);\n},\n    _getSetter = function _getSetter(target, property) {\n  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n},\n    _renderPlain = function _renderPlain(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\n},\n    _renderBoolean = function _renderBoolean(ratio, data) {\n  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n},\n    _renderComplexString = function _renderComplexString(ratio, data) {\n  var pt = data._pt,\n      s = \"\";\n\n  if (!ratio && data.b) {\n    //b = beginning string\n    s = data.b;\n  } else if (ratio === 1 && data.e) {\n    //e = ending string\n    s = data.e;\n  } else {\n    while (pt) {\n      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the \"p\" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n\n      pt = pt._next;\n    }\n\n    s += data.c; //we use the \"c\" of the PropTween to store the final chunk of non-numeric text.\n  }\n\n  data.set(data.t, data.p, s, data);\n},\n    _renderPropTweens = function _renderPropTweens(ratio, data) {\n  var pt = data._pt;\n\n  while (pt) {\n    pt.r(ratio, pt.d);\n    pt = pt._next;\n  }\n},\n    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n  var pt = this._pt,\n      next;\n\n  while (pt) {\n    next = pt._next;\n    pt.p === property && pt.modifier(modifier, tween, target);\n    pt = next;\n  }\n},\n    _killPropTweensOf = function _killPropTweensOf(property) {\n  var pt = this._pt,\n      hasNonDependentRemaining,\n      next;\n\n  while (pt) {\n    next = pt._next;\n\n    if (pt.p === property && !pt.op || pt.op === property) {\n      _removeLinkedListItem(this, pt, \"_pt\");\n    } else if (!pt.dep) {\n      hasNonDependentRemaining = 1;\n    }\n\n    pt = next;\n  }\n\n  return !hasNonDependentRemaining;\n},\n    _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n},\n    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n  var pt = parent._pt,\n      next,\n      pt2,\n      first,\n      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n\n  while (pt) {\n    next = pt._next;\n    pt2 = first;\n\n    while (pt2 && pt2.pr > pt.pr) {\n      pt2 = pt2._next;\n    }\n\n    if (pt._prev = pt2 ? pt2._prev : last) {\n      pt._prev._next = pt;\n    } else {\n      first = pt;\n    }\n\n    if (pt._next = pt2) {\n      pt2._prev = pt;\n    } else {\n      last = pt;\n    }\n\n    pt = next;\n  }\n\n  parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\n\n\nvar PropTween = /*#__PURE__*/function () {\n  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n    this.t = target;\n    this.s = start;\n    this.c = change;\n    this.p = prop;\n    this.r = renderer || _renderPlain;\n    this.d = data || this;\n    this.set = setter || _setterPlain;\n    this.pr = priority || 0;\n    this._next = next;\n\n    if (next) {\n      next._prev = this;\n    }\n  }\n\n  var _proto4 = PropTween.prototype;\n\n  _proto4.modifier = function modifier(func, tween, target) {\n    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n\n    this.set = _setterWithModifier;\n    this.m = func;\n    this.mt = target; //modifier target\n\n    this.tween = tween;\n  };\n\n  return PropTween;\n}(); //Initialization tasks\n\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function (name) {\n  return _reservedProps[name] = 1;\n});\n\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n  sortChildren: false,\n  defaults: _defaults,\n  autoRemoveChildren: true,\n  id: \"root\",\n  smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\n\nvar _media = [],\n    _listeners = {},\n    _emptyArray = [],\n    _lastMediaTime = 0,\n    _contextID = 0,\n    _dispatch = function _dispatch(type) {\n  return (_listeners[type] || _emptyArray).map(function (f) {\n    return f();\n  });\n},\n    _onMediaChange = function _onMediaChange() {\n  var time = Date.now(),\n      matches = [];\n\n  if (time - _lastMediaTime > 2) {\n    _dispatch(\"matchMediaInit\");\n\n    _media.forEach(function (c) {\n      var queries = c.queries,\n          conditions = c.conditions,\n          match,\n          p,\n          anyMatch,\n          toggled;\n\n      for (p in queries) {\n        match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n\n        match && (anyMatch = 1);\n\n        if (match !== conditions[p]) {\n          conditions[p] = match;\n          toggled = 1;\n        }\n      }\n\n      if (toggled) {\n        c.revert();\n        anyMatch && matches.push(c);\n      }\n    });\n\n    _dispatch(\"matchMediaRevert\");\n\n    matches.forEach(function (c) {\n      return c.onMatch(c, function (func) {\n        return c.add(null, func);\n      });\n    });\n    _lastMediaTime = time;\n\n    _dispatch(\"matchMedia\");\n  }\n};\n\nvar Context = /*#__PURE__*/function () {\n  function Context(func, scope) {\n    this.selector = scope && selector(scope);\n    this.data = [];\n    this._r = []; // returned/cleanup functions\n\n    this.isReverted = false;\n    this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because \"this\" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely\n\n    func && this.add(func);\n  }\n\n  var _proto5 = Context.prototype;\n\n  _proto5.add = function add(name, func, scope) {\n    // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.\n    // if (name && _isFunction(name.revert)) {\n    // \tthis.data.push(name);\n    // \treturn (name._ctx = this);\n    // }\n    if (_isFunction(name)) {\n      scope = func;\n      func = name;\n      name = _isFunction;\n    }\n\n    var self = this,\n        f = function f() {\n      var prev = _context,\n          prevSelector = self.selector,\n          result;\n      prev && prev !== self && prev.data.push(self);\n      scope && (self.selector = selector(scope));\n      _context = self;\n      result = func.apply(self, arguments);\n      _isFunction(result) && self._r.push(result);\n      _context = prev;\n      self.selector = prevSelector;\n      self.isReverted = false;\n      return result;\n    };\n\n    self.last = f;\n    return name === _isFunction ? f(self, function (func) {\n      return self.add(null, func);\n    }) : name ? self[name] = f : f;\n  };\n\n  _proto5.ignore = function ignore(func) {\n    var prev = _context;\n    _context = null;\n    func(this);\n    _context = prev;\n  };\n\n  _proto5.getTweens = function getTweens() {\n    var a = [];\n    this.data.forEach(function (e) {\n      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n    });\n    return a;\n  };\n\n  _proto5.clear = function clear() {\n    this._r.length = this.data.length = 0;\n  };\n\n  _proto5.kill = function kill(revert, matchMedia) {\n    var _this4 = this;\n\n    if (revert) {\n      (function () {\n        var tweens = _this4.getTweens(),\n            i = _this4.data.length,\n            t;\n\n        while (i--) {\n          // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.\n          t = _this4.data[i];\n\n          if (t.data === \"isFlip\") {\n            t.revert();\n            t.getChildren(true, true, false).forEach(function (tween) {\n              return tweens.splice(tweens.indexOf(tween), 1);\n            });\n          }\n        } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort\n\n\n        tweens.map(function (t) {\n          return {\n            g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,\n            t: t\n          };\n        }).sort(function (a, b) {\n          return b.g - a.g || -Infinity;\n        }).forEach(function (o) {\n          return o.t.revert(revert);\n        }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the \" || -1\" in the sort keeps the order properly.\n\n        i = _this4.data.length;\n\n        while (i--) {\n          // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first\n          t = _this4.data[i];\n\n          if (t instanceof Timeline) {\n            if (t.data !== \"nested\") {\n              t.scrollTrigger && t.scrollTrigger.revert();\n              t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens\n            }\n          } else {\n            !(t instanceof Tween) && t.revert && t.revert(revert);\n          }\n        }\n\n        _this4._r.forEach(function (f) {\n          return f(revert, _this4);\n        });\n\n        _this4.isReverted = true;\n      })();\n    } else {\n      this.data.forEach(function (e) {\n        return e.kill && e.kill();\n      });\n    }\n\n    this.clear();\n\n    if (matchMedia) {\n      var i = _media.length;\n\n      while (i--) {\n        // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.\n        _media[i].id === this.id && _media.splice(i, 1);\n      }\n    }\n  };\n\n  _proto5.revert = function revert(config) {\n    this.kill(config || {});\n  };\n\n  return Context;\n}();\n\nvar MatchMedia = /*#__PURE__*/function () {\n  function MatchMedia(scope) {\n    this.contexts = [];\n    this.scope = scope;\n    _context && _context.data.push(this);\n  }\n\n  var _proto6 = MatchMedia.prototype;\n\n  _proto6.add = function add(conditions, func, scope) {\n    _isObject(conditions) || (conditions = {\n      matches: conditions\n    });\n    var context = new Context(0, scope || this.scope),\n        cond = context.conditions = {},\n        mq,\n        p,\n        active;\n    _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()\n\n    this.contexts.push(context);\n    func = context.add(\"onMatch\", func);\n    context.queries = conditions;\n\n    for (p in conditions) {\n      if (p === \"all\") {\n        active = 1;\n      } else {\n        mq = _win.matchMedia(conditions[p]);\n\n        if (mq) {\n          _media.indexOf(context) < 0 && _media.push(context);\n          (cond[p] = mq.matches) && (active = 1);\n          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n        }\n      }\n    }\n\n    active && func(context, function (f) {\n      return context.add(null, f);\n    });\n    return this;\n  } // refresh() {\n  // \tlet time = _lastMediaTime,\n  // \t\tmedia = _media;\n  // \t_lastMediaTime = -1;\n  // \t_media = this.contexts;\n  // \t_onMediaChange();\n  // \t_lastMediaTime = time;\n  // \t_media = media;\n  // }\n  ;\n\n  _proto6.revert = function revert(config) {\n    this.kill(config || {});\n  };\n\n  _proto6.kill = function kill(revert) {\n    this.contexts.forEach(function (c) {\n      return c.kill(revert, true);\n    });\n  };\n\n  return MatchMedia;\n}();\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _gsap = {\n  registerPlugin: function registerPlugin() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args.forEach(function (config) {\n      return _createPlugin(config);\n    });\n  },\n  timeline: function timeline(vars) {\n    return new Timeline(vars);\n  },\n  getTweensOf: function getTweensOf(targets, onlyActive) {\n    return _globalTimeline.getTweensOf(targets, onlyActive);\n  },\n  getProperty: function getProperty(target, property, unit, uncache) {\n    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n\n    var getter = _getCache(target || {}).get,\n        format = unit ? _passThrough : _numericIfPossible;\n\n    unit === \"native\" && (unit = \"\");\n    return !target ? target : !property ? function (property, unit, uncache) {\n      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n  },\n  quickSetter: function quickSetter(target, property, unit) {\n    target = toArray(target);\n\n    if (target.length > 1) {\n      var setters = target.map(function (t) {\n        return gsap.quickSetter(t, property, unit);\n      }),\n          l = setters.length;\n      return function (value) {\n        var i = l;\n\n        while (i--) {\n          setters[i](value);\n        }\n      };\n    }\n\n    target = target[0] || {};\n\n    var Plugin = _plugins[property],\n        cache = _getCache(target),\n        p = cache.harness && (cache.harness.aliases || {})[property] || property,\n        // in case it's an alias, like \"rotate\" for \"rotation\".\n    setter = Plugin ? function (value) {\n      var p = new Plugin();\n      _quickTween._pt = 0;\n      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\n      p.render(1, p);\n      _quickTween._pt && _renderPropTweens(1, _quickTween);\n    } : cache.set(target, p);\n\n    return Plugin ? setter : function (value) {\n      return setter(target, p, unit ? value + unit : value, cache, 1);\n    };\n  },\n  quickTo: function quickTo(target, property, vars) {\n    var _merge2;\n\n    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = \"+=0.1\", _merge2.paused = true, _merge2), vars || {})),\n        func = function func(value, start, startIsRelative) {\n      return tween.resetTo(property, value, start, startIsRelative);\n    };\n\n    func.tween = tween;\n    return func;\n  },\n  isTweening: function isTweening(targets) {\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\n  },\n  defaults: function defaults(value) {\n    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n    return _mergeDeep(_defaults, value || {});\n  },\n  config: function config(value) {\n    return _mergeDeep(_config, value || {});\n  },\n  registerEffect: function registerEffect(_ref3) {\n    var name = _ref3.name,\n        effect = _ref3.effect,\n        plugins = _ref3.plugins,\n        defaults = _ref3.defaults,\n        extendTimeline = _ref3.extendTimeline;\n    (plugins || \"\").split(\",\").forEach(function (pluginName) {\n      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n    });\n\n    _effects[name] = function (targets, vars, tl) {\n      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n    };\n\n    if (extendTimeline) {\n      Timeline.prototype[name] = function (targets, vars, position) {\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n      };\n    }\n  },\n  registerEase: function registerEase(name, ease) {\n    _easeMap[name] = _parseEase(ease);\n  },\n  parseEase: function parseEase(ease, defaultEase) {\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n  },\n  getById: function getById(id) {\n    return _globalTimeline.getById(id);\n  },\n  exportRoot: function exportRoot(vars, includeDelayedCalls) {\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    var tl = new Timeline(vars),\n        child,\n        next;\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n\n    _globalTimeline.remove(tl);\n\n    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).\n\n    tl._time = tl._tTime = _globalTimeline._time;\n    child = _globalTimeline._first;\n\n    while (child) {\n      next = child._next;\n\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n        _addToTimeline(tl, child, child._start - child._delay);\n      }\n\n      child = next;\n    }\n\n    _addToTimeline(_globalTimeline, tl, 0);\n\n    return tl;\n  },\n  context: function context(func, scope) {\n    return func ? new Context(func, scope) : _context;\n  },\n  matchMedia: function matchMedia(scope) {\n    return new MatchMedia(scope);\n  },\n  matchMediaRefresh: function matchMediaRefresh() {\n    return _media.forEach(function (c) {\n      var cond = c.conditions,\n          found,\n          p;\n\n      for (p in cond) {\n        if (cond[p]) {\n          cond[p] = false;\n          found = 1;\n        }\n      }\n\n      found && c.revert();\n    }) || _onMediaChange();\n  },\n  addEventListener: function addEventListener(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n  },\n  removeEventListener: function removeEventListener(type, callback) {\n    var a = _listeners[type],\n        i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n  },\n  utils: {\n    wrap: wrap,\n    wrapYoyo: wrapYoyo,\n    distribute: distribute,\n    random: random,\n    snap: snap,\n    normalize: normalize,\n    getUnit: getUnit,\n    clamp: clamp,\n    splitColor: splitColor,\n    toArray: toArray,\n    selector: selector,\n    mapRange: mapRange,\n    pipe: pipe,\n    unitize: unitize,\n    interpolate: interpolate,\n    shuffle: shuffle\n  },\n  install: _install,\n  effects: _effects,\n  ticker: _ticker,\n  updateRoot: Timeline.updateRoot,\n  plugins: _plugins,\n  globalTimeline: _globalTimeline,\n  core: {\n    PropTween: PropTween,\n    globals: _addGlobal,\n    Tween: Tween,\n    Timeline: Timeline,\n    Animation: Animation,\n    getCache: _getCache,\n    _removeLinkedListItem: _removeLinkedListItem,\n    reverting: function reverting() {\n      return _reverting;\n    },\n    context: function context(toAdd) {\n      if (toAdd && _context) {\n        _context.data.push(toAdd);\n\n        toAdd._ctx = _context;\n      }\n\n      return _context;\n    },\n    suppressOverwrites: function suppressOverwrites(value) {\n      return _suppressOverwrites = value;\n    }\n  }\n};\n\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function (name) {\n  return _gsap[name] = Tween[name];\n});\n\n_ticker.add(Timeline.updateRoot);\n\n_quickTween = _gsap.to({}, {\n  duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\n\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n  var pt = plugin._pt;\n\n  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n    pt = pt._next;\n  }\n\n  return pt;\n},\n    _addModifiers = function _addModifiers(tween, modifiers) {\n  var targets = tween._targets,\n      p,\n      i,\n      pt;\n\n  for (p in modifiers) {\n    i = targets.length;\n\n    while (i--) {\n      pt = tween._ptLookup[i][p];\n\n      if (pt && (pt = pt.d)) {\n        if (pt._pt) {\n          // is a plugin\n          pt = _getPluginPropTween(pt, p);\n        }\n\n        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n      }\n    }\n  }\n},\n    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n  return {\n    name: name,\n    rawVars: 1,\n    //don't pre-process function-based values or \"random()\" strings.\n    init: function init(target, vars, tween) {\n      tween._onInit = function (tween) {\n        var temp, p;\n\n        if (_isString(vars)) {\n          temp = {};\n\n          _forEachName(vars, function (name) {\n            return temp[name] = 1;\n          }); //if the user passes in a comma-delimited list of property names to roundProps, like \"x,y\", we round to whole numbers.\n\n\n          vars = temp;\n        }\n\n        if (modifier) {\n          temp = {};\n\n          for (p in vars) {\n            temp[p] = modifier(vars[p]);\n          }\n\n          vars = temp;\n        }\n\n        _addModifiers(tween, vars);\n      };\n    }\n  };\n}; //register core plugins\n\n\nvar gsap = _gsap.registerPlugin({\n  name: \"attr\",\n  init: function init(target, vars, tween, index, targets) {\n    var p, pt, v;\n    this.tween = tween;\n\n    for (p in vars) {\n      v = target.getAttribute(p) || \"\";\n      pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n      pt.op = p;\n      pt.b = v; // record the beginning value so we can revert()\n\n      this._props.push(p);\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt;\n\n    while (pt) {\n      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)\n\n      pt = pt._next;\n    }\n  }\n}, {\n  name: \"endArray\",\n  init: function init(target, value) {\n    var i = value.length;\n\n    while (i--) {\n      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n    }\n  }\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\n\nTween.version = Timeline.version = gsap.version = \"3.12.5\";\n_coreReady = 1;\n_windowExists() && _wake();\nvar Power0 = _easeMap.Power0,\n    Power1 = _easeMap.Power1,\n    Power2 = _easeMap.Power2,\n    Power3 = _easeMap.Power3,\n    Power4 = _easeMap.Power4,\n    Linear = _easeMap.Linear,\n    Quad = _easeMap.Quad,\n    Cubic = _easeMap.Cubic,\n    Quart = _easeMap.Quart,\n    Quint = _easeMap.Quint,\n    Strong = _easeMap.Strong,\n    Elastic = _easeMap.Elastic,\n    Back = _easeMap.Back,\n    SteppedEase = _easeMap.SteppedEase,\n    Bounce = _easeMap.Bounce,\n    Sine = _easeMap.Sine,\n    Expo = _easeMap.Expo,\n    Circ = _easeMap.Circ;\n\n //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLGdEQUFnRCwwREFBMEQsMkNBQTJDOztBQUVySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsK0pBQStKO0FBQy9KO0FBQ0E7O0FBRUEsU0FBUywyQ0FBMkM7O0FBRXBEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwySUFBMkk7QUFDM0k7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25ELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7O0FBRWpFLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FB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TTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvRUFBb0UsSUFBSSxFQUFFLElBQUk7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFGQUFxRjs7QUFFckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0Qiw4RUFBOEU7QUFDcEksY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTs7QUFFSixrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvRUFBb0U7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsMkJBQTJCO0FBQzNCOztBQUVBLHlEQUF5RDtBQUN6RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd01BQXdNO0FBQ3hNOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBHQUEwRztBQUMxRyxzR0FBc0c7QUFDdEc7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTs7QUFFaEU7O0FBRUEsbUJBQW1COzs7QUFHbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFOztBQUU3RSxrQ0FBa0M7QUFDbEMsUUFBUTtBQUNSOztBQUVBLDhCQUE4Qjs7QUFFOUIsK01BQStNO0FBQy9NO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkU7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRGQUE0Rjs7QUFFNUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0tBQWdLOztBQUVoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBcUQsNk5BQTZOLE9BQU8sV0FBVyxLQUFLO0FBQy9UOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbVFBQW1ROztBQUVuUTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUg7O0FBRXpIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRzs7O0FBR2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0k7QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1SUFBdUk7O0FBRXhJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtSjtBQUNxSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vbm9kZV9tb2R1bGVzL2dzYXAvZ3NhcC1jb3JlLmpzP2E1Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIEdTQVAgMy4xMi41XG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9jb25maWcgPSB7XG4gIGF1dG9TbGVlcDogMTIwLFxuICBmb3JjZTNEOiBcImF1dG9cIixcbiAgbnVsbFRhcmdldFdhcm46IDEsXG4gIHVuaXRzOiB7XG4gICAgbGluZUhlaWdodDogXCJcIlxuICB9XG59LFxuICAgIF9kZWZhdWx0cyA9IHtcbiAgZHVyYXRpb246IC41LFxuICBvdmVyd3JpdGU6IGZhbHNlLFxuICBkZWxheTogMFxufSxcbiAgICBfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgIF9yZXZlcnRpbmcsXG4gICAgX2NvbnRleHQsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuICAgIF8yUEkgPSBNYXRoLlBJICogMixcbiAgICBfSEFMRl9QSSA9IF8yUEkgLyA0LFxuICAgIF9nc0lEID0gMCxcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX3NpbiA9IE1hdGguc2luLFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2lzTm90RmFsc2UgPSBmdW5jdGlvbiBfaXNOb3RGYWxzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc0Z1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9pc0Z1bmNPclN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpIHx8IF9pc1N0cmluZyh2YWx1ZSk7XG59LFxuICAgIF9pc1R5cGVkQXJyYXkgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgLy8gbm90ZTogSUUxMCBoYXMgQXJyYXlCdWZmZXIsIGJ1dCBOT1QgQXJyYXlCdWZmZXIuaXNWaWV3KCkuXG5faXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX3N0cmljdE51bUV4cCA9IC8oPzotP1xcLj9cXGR8XFwuKSsvZ2ksXG4gICAgLy9vbmx5IG51bWJlcnMgKGluY2x1ZGluZyBuZWdhdGl2ZXMgYW5kIGRlY2ltYWxzKSBidXQgTk9UIHJlbGF0aXZlIHZhbHVlcy5cbl9udW1FeHAgPSAvWy0rPS5dKlxcZCtbLmVcXC0rXSpcXGQqW2VcXC0rXSpcXGQqL2csXG4gICAgLy9maW5kcyBhbnkgbnVtYmVycywgaW5jbHVkaW5nIG9uZXMgdGhhdCBzdGFydCB3aXRoICs9IG9yIC09LCBuZWdhdGl2ZSBudW1iZXJzLCBhbmQgb25lcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgMWUtOC5cbl9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXG4gICAgX2NvbXBsZXhTdHJpbmdOdW1FeHAgPSAvWy0rPS5dKlxcZCtcXC4/XFxkKig/OmUtfGVcXCspP1xcZCovZ2ksXG4gICAgLy9kdXBsaWNhdGUgc28gdGhhdCB3aGlsZSB3ZSdyZSBsb29waW5nIHRocm91Z2ggbWF0Y2hlcyBmcm9tIGV4ZWMoKSwgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgbGFzdEluZGV4IG9mIF9udW1FeHAgd2hpY2ggd2UgdXNlIHRvIHNlYXJjaCBmb3IgY29sb3JzIHRvby5cbl9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxuICAgIF9kZWxpbWl0ZWRWYWx1ZUV4cCA9IC9bXiwnXCJcXFtcXF1cXHNdKy9naSxcbiAgICAvLyBwcmV2aW91c2x5IC9bI1xcLSsuXSpcXGJbYS16XFxkXFwtPSslLl0rL2dpIGJ1dCBkaWRuJ3QgY2F0Y2ggc3BlY2lhbCBjaGFyYWN0ZXJzLlxuX3VuaXRFeHAgPSAvXlsrXFwtPWVcXHNcXGRdKlxcZCtbLlxcZF0qKFthLXpdKnwlKVxccyokL2ksXG4gICAgX2dsb2JhbFRpbWVsaW5lLFxuICAgIF93aW4sXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9kb2MsXG4gICAgX2dsb2JhbHMgPSB7fSxcbiAgICBfaW5zdGFsbFNjb3BlID0ge30sXG4gICAgX2NvcmVSZWFkeSxcbiAgICBfaW5zdGFsbCA9IGZ1bmN0aW9uIF9pbnN0YWxsKHNjb3BlKSB7XG4gIHJldHVybiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwO1xufSxcbiAgICBfbWlzc2luZ1BsdWdpbiA9IGZ1bmN0aW9uIF9taXNzaW5nUGx1Z2luKHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgXCJzZXQgdG9cIiwgdmFsdWUsIFwiTWlzc2luZyBwbHVnaW4/IGdzYXAucmVnaXN0ZXJQbHVnaW4oKVwiKTtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlLCBzdXBwcmVzcykge1xuICByZXR1cm4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2FkZEdsb2JhbCA9IGZ1bmN0aW9uIF9hZGRHbG9iYWwobmFtZSwgb2JqKSB7XG4gIHJldHVybiBuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikgfHwgX2dsb2JhbHM7XG59LFxuICAgIF9lbXB0eUZ1bmMgPSBmdW5jdGlvbiBfZW1wdHlGdW5jKCkge1xuICByZXR1cm4gMDtcbn0sXG4gICAgX3N0YXJ0QXRSZXZlcnRDb25maWcgPSB7XG4gIHN1cHByZXNzRXZlbnRzOiB0cnVlLFxuICBpc1N0YXJ0OiB0cnVlLFxuICBraWxsOiBmYWxzZVxufSxcbiAgICBfcmV2ZXJ0Q29uZmlnTm9LaWxsID0ge1xuICBzdXBwcmVzc0V2ZW50czogdHJ1ZSxcbiAga2lsbDogZmFsc2Vcbn0sXG4gICAgX3JldmVydENvbmZpZyA9IHtcbiAgc3VwcHJlc3NFdmVudHM6IHRydWVcbn0sXG4gICAgX3Jlc2VydmVkUHJvcHMgPSB7fSxcbiAgICBfbGF6eVR3ZWVucyA9IFtdLFxuICAgIF9sYXp5TG9va3VwID0ge30sXG4gICAgX2xhc3RSZW5kZXJlZEZyYW1lLFxuICAgIF9wbHVnaW5zID0ge30sXG4gICAgX2VmZmVjdHMgPSB7fSxcbiAgICBfbmV4dEdDRnJhbWUgPSAzMCxcbiAgICBfaGFybmVzc1BsdWdpbnMgPSBbXSxcbiAgICBfY2FsbGJhY2tOYW1lcyA9IFwiXCIsXG4gICAgX2hhcm5lc3MgPSBmdW5jdGlvbiBfaGFybmVzcyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdLFxuICAgICAgaGFybmVzc1BsdWdpbixcbiAgICAgIGk7XG4gIF9pc09iamVjdCh0YXJnZXQpIHx8IF9pc0Z1bmN0aW9uKHRhcmdldCkgfHwgKHRhcmdldHMgPSBbdGFyZ2V0c10pO1xuXG4gIGlmICghKGhhcm5lc3NQbHVnaW4gPSAodGFyZ2V0Ll9nc2FwIHx8IHt9KS5oYXJuZXNzKSkge1xuICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRhcmdldCB3aXRoIGEgaGFybmVzcy4gV2UgYXNzdW1lIHRhcmdldHMgcGFzc2VkIGludG8gYW4gYW5pbWF0aW9uIHdpbGwgYmUgb2Ygc2ltaWxhciB0eXBlLCBtZWFuaW5nIHRoZSBzYW1lIGtpbmQgb2YgaGFybmVzcyBjYW4gYmUgdXNlZCBmb3IgdGhlbSBhbGwgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcbiAgICBpID0gX2hhcm5lc3NQbHVnaW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0gJiYgIV9oYXJuZXNzUGx1Z2luc1tpXS50YXJnZXRUZXN0KHRhcmdldCkpIHt9XG5cbiAgICBoYXJuZXNzUGx1Z2luID0gX2hhcm5lc3NQbHVnaW5zW2ldO1xuICB9XG5cbiAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0YXJnZXRzW2ldICYmICh0YXJnZXRzW2ldLl9nc2FwIHx8ICh0YXJnZXRzW2ldLl9nc2FwID0gbmV3IEdTQ2FjaGUodGFyZ2V0c1tpXSwgaGFybmVzc1BsdWdpbikpKSB8fCB0YXJnZXRzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzO1xufSxcbiAgICBfZ2V0Q2FjaGUgPSBmdW5jdGlvbiBfZ2V0Q2FjaGUodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModG9BcnJheSh0YXJnZXQpKVswXS5fZ3NhcDtcbn0sXG4gICAgX2dldFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHYpIHtcbiAgcmV0dXJuICh2ID0gdGFyZ2V0W3Byb3BlcnR5XSkgJiYgX2lzRnVuY3Rpb24odikgPyB0YXJnZXRbcHJvcGVydHldKCkgOiBfaXNVbmRlZmluZWQodikgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKHByb3BlcnR5KSB8fCB2O1xufSxcbiAgICBfZm9yRWFjaE5hbWUgPSBmdW5jdGlvbiBfZm9yRWFjaE5hbWUobmFtZXMsIGZ1bmMpIHtcbiAgcmV0dXJuIChuYW1lcyA9IG5hbWVzLnNwbGl0KFwiLFwiKSkuZm9yRWFjaChmdW5jKSB8fCBuYW1lcztcbn0sXG4gICAgLy9zcGxpdCBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIG5hbWVzIGludG8gYW4gYXJyYXksIHRoZW4gcnVuIGEgZm9yRWFjaCgpIGZ1bmN0aW9uIGFuZCByZXR1cm4gdGhlIHNwbGl0IGFycmF5ICh0aGlzIGlzIGp1c3QgYSB3YXkgdG8gY29uc29saWRhdGUvc2hvcnRlbiBzb21lIGNvZGUpLlxuX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfcm91bmRQcmVjaXNlID0gZnVuY3Rpb24gX3JvdW5kUHJlY2lzZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMDAwKSAvIDEwMDAwMDAwIHx8IDA7XG59LFxuICAgIC8vIGluY3JlYXNlZCBwcmVjaXNpb24gbW9zdGx5IGZvciB0aW1pbmcgdmFsdWVzLlxuX3BhcnNlUmVsYXRpdmUgPSBmdW5jdGlvbiBfcGFyc2VSZWxhdGl2ZShzdGFydCwgdmFsdWUpIHtcbiAgdmFyIG9wZXJhdG9yID0gdmFsdWUuY2hhckF0KDApLFxuICAgICAgZW5kID0gcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoMikpO1xuICBzdGFydCA9IHBhcnNlRmxvYXQoc3RhcnQpO1xuICByZXR1cm4gb3BlcmF0b3IgPT09IFwiK1wiID8gc3RhcnQgKyBlbmQgOiBvcGVyYXRvciA9PT0gXCItXCIgPyBzdGFydCAtIGVuZCA6IG9wZXJhdG9yID09PSBcIipcIiA/IHN0YXJ0ICogZW5kIDogc3RhcnQgLyBlbmQ7XG59LFxuICAgIF9hcnJheUNvbnRhaW5zQW55ID0gZnVuY3Rpb24gX2FycmF5Q29udGFpbnNBbnkodG9TZWFyY2gsIHRvRmluZCkge1xuICAvL3NlYXJjaGVzIG9uZSBhcnJheSB0byBmaW5kIG1hdGNoZXMgZm9yIGFueSBvZiB0aGUgaXRlbXMgaW4gdGhlIHRvRmluZCBhcnJheS4gQXMgc29vbiBhcyBvbmUgaXMgZm91bmQsIGl0IHJldHVybnMgdHJ1ZS4gSXQgZG9lcyBOT1QgcmV0dXJuIGFsbCB0aGUgbWF0Y2hlczsgaXQncyBzaW1wbHkgYSBib29sZWFuIHNlYXJjaC5cbiAgdmFyIGwgPSB0b0ZpbmQubGVuZ3RoLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yICg7IHRvU2VhcmNoLmluZGV4T2YodG9GaW5kW2ldKSA8IDAgJiYgKytpIDwgbDspIHt9XG5cbiAgcmV0dXJuIGkgPCBsO1xufSxcbiAgICBfbGF6eVJlbmRlciA9IGZ1bmN0aW9uIF9sYXp5UmVuZGVyKCkge1xuICB2YXIgbCA9IF9sYXp5VHdlZW5zLmxlbmd0aCxcbiAgICAgIGEgPSBfbGF6eVR3ZWVucy5zbGljZSgwKSxcbiAgICAgIGksXG4gICAgICB0d2VlbjtcblxuICBfbGF6eUxvb2t1cCA9IHt9O1xuICBfbGF6eVR3ZWVucy5sZW5ndGggPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB0d2VlbiA9IGFbaV07XG4gICAgdHdlZW4gJiYgdHdlZW4uX2xhenkgJiYgKHR3ZWVuLnJlbmRlcih0d2Vlbi5fbGF6eVswXSwgdHdlZW4uX2xhenlbMV0sIHRydWUpLl9sYXp5ID0gMCk7XG4gIH1cbn0sXG4gICAgX2xhenlTYWZlUmVuZGVyID0gZnVuY3Rpb24gX2xhenlTYWZlUmVuZGVyKGFuaW1hdGlvbiwgdGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiAhX3JldmVydGluZyAmJiBfbGF6eVJlbmRlcigpO1xuICBhbmltYXRpb24ucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSB8fCBfcmV2ZXJ0aW5nICYmIHRpbWUgPCAwICYmIChhbmltYXRpb24uX2luaXR0ZWQgfHwgYW5pbWF0aW9uLl9zdGFydEF0KSk7XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiAhX3JldmVydGluZyAmJiBfbGF6eVJlbmRlcigpOyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gc29tZW9uZSBjYWxscyBzZWVrKCkgb3IgdGltZSgpIG9yIHByb2dyZXNzKCksIHRoZXkgZXhwZWN0IGFuIGltbWVkaWF0ZSByZW5kZXIuXG59LFxuICAgIF9udW1lcmljSWZQb3NzaWJsZSA9IGZ1bmN0aW9uIF9udW1lcmljSWZQb3NzaWJsZSh2YWx1ZSkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICByZXR1cm4gKG4gfHwgbiA9PT0gMCkgJiYgKHZhbHVlICsgXCJcIikubWF0Y2goX2RlbGltaXRlZFZhbHVlRXhwKS5sZW5ndGggPCAyID8gbiA6IF9pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS50cmltKCkgOiB2YWx1ZTtcbn0sXG4gICAgX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24gX3Bhc3NUaHJvdWdoKHApIHtcbiAgcmV0dXJuIHA7XG59LFxuICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBwIGluIG9iaiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX3NldEtleWZyYW1lRGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhleGNsdWRlRHVyYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGRlZmF1bHRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgICAgcCBpbiBvYmogfHwgcCA9PT0gXCJkdXJhdGlvblwiICYmIGV4Y2x1ZGVEdXJhdGlvbiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICAgIH1cbiAgfTtcbn0sXG4gICAgX21lcmdlID0gZnVuY3Rpb24gX21lcmdlKGJhc2UsIHRvTWVyZ2UpIHtcbiAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgYmFzZVtwXSA9IHRvTWVyZ2VbcF07XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX21lcmdlRGVlcCA9IGZ1bmN0aW9uIF9tZXJnZURlZXAoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBwICE9PSBcIl9fcHJvdG9fX1wiICYmIHAgIT09IFwiY29uc3RydWN0b3JcIiAmJiBwICE9PSBcInByb3RvdHlwZVwiICYmIChiYXNlW3BdID0gX2lzT2JqZWN0KHRvTWVyZ2VbcF0pID8gX21lcmdlRGVlcChiYXNlW3BdIHx8IChiYXNlW3BdID0ge30pLCB0b01lcmdlW3BdKSA6IHRvTWVyZ2VbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59LFxuICAgIF9jb3B5RXhjbHVkaW5nID0gZnVuY3Rpb24gX2NvcHlFeGNsdWRpbmcob2JqLCBleGNsdWRpbmcpIHtcbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIG9iaikge1xuICAgIHAgaW4gZXhjbHVkaW5nIHx8IChjb3B5W3BdID0gb2JqW3BdKTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfaW5oZXJpdERlZmF1bHRzID0gZnVuY3Rpb24gX2luaGVyaXREZWZhdWx0cyh2YXJzKSB7XG4gIHZhciBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICBmdW5jID0gdmFycy5rZXlmcmFtZXMgPyBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhfaXNBcnJheSh2YXJzLmtleWZyYW1lcykpIDogX3NldERlZmF1bHRzO1xuXG4gIGlmIChfaXNOb3RGYWxzZSh2YXJzLmluaGVyaXQpKSB7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgZnVuYyh2YXJzLCBwYXJlbnQudmFycy5kZWZhdWx0cyk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50IHx8IHBhcmVudC5fZHA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9hcnJheXNNYXRjaCA9IGZ1bmN0aW9uIF9hcnJheXNNYXRjaChhMSwgYTIpIHtcbiAgdmFyIGkgPSBhMS5sZW5ndGgsXG4gICAgICBtYXRjaCA9IGkgPT09IGEyLmxlbmd0aDtcblxuICB3aGlsZSAobWF0Y2ggJiYgaS0tICYmIGExW2ldID09PSBhMltpXSkge31cblxuICByZXR1cm4gaSA8IDA7XG59LFxuICAgIF9hZGRMaW5rZWRMaXN0SXRlbSA9IGZ1bmN0aW9uIF9hZGRMaW5rZWRMaXN0SXRlbShwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AsIGxhc3RQcm9wLCBzb3J0QnkpIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IHBhcmVudFtsYXN0UHJvcF0sXG4gICAgICB0O1xuXG4gIGlmIChzb3J0QnkpIHtcbiAgICB0ID0gY2hpbGRbc29ydEJ5XTtcblxuICAgIHdoaWxlIChwcmV2ICYmIHByZXZbc29ydEJ5XSA+IHQpIHtcbiAgICAgIHByZXYgPSBwcmV2Ll9wcmV2O1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgY2hpbGQuX25leHQgPSBwcmV2Ll9uZXh0O1xuICAgIHByZXYuX25leHQgPSBjaGlsZDtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZC5fbmV4dCA9IHBhcmVudFtmaXJzdFByb3BdO1xuICAgIHBhcmVudFtmaXJzdFByb3BdID0gY2hpbGQ7XG4gIH1cblxuICBpZiAoY2hpbGQuX25leHQpIHtcbiAgICBjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGNoaWxkLl9wcmV2ID0gcHJldjtcbiAgY2hpbGQucGFyZW50ID0gY2hpbGQuX2RwID0gcGFyZW50O1xuICByZXR1cm4gY2hpbGQ7XG59LFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSA9IGZ1bmN0aW9uIF9yZW1vdmVMaW5rZWRMaXN0SXRlbShwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AsIGxhc3RQcm9wKSB7XG4gIGlmIChmaXJzdFByb3AgPT09IHZvaWQgMCkge1xuICAgIGZpcnN0UHJvcCA9IFwiX2ZpcnN0XCI7XG4gIH1cblxuICBpZiAobGFzdFByb3AgPT09IHZvaWQgMCkge1xuICAgIGxhc3RQcm9wID0gXCJfbGFzdFwiO1xuICB9XG5cbiAgdmFyIHByZXYgPSBjaGlsZC5fcHJldixcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICBpZiAocHJldikge1xuICAgIHByZXYuX25leHQgPSBuZXh0O1xuICB9IGVsc2UgaWYgKHBhcmVudFtmaXJzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtmaXJzdFByb3BdID0gbmV4dDtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5fcHJldiA9IHByZXY7XG4gIH0gZWxzZSBpZiAocGFyZW50W2xhc3RQcm9wXSA9PT0gY2hpbGQpIHtcbiAgICBwYXJlbnRbbGFzdFByb3BdID0gcHJldjtcbiAgfVxuXG4gIGNoaWxkLl9uZXh0ID0gY2hpbGQuX3ByZXYgPSBjaGlsZC5wYXJlbnQgPSBudWxsOyAvLyBkb24ndCBkZWxldGUgdGhlIF9kcCBqdXN0IHNvIHdlIGNhbiByZXZlcnQgaWYgbmVjZXNzYXJ5LiBCdXQgcGFyZW50IHNob3VsZCBiZSBudWxsIHRvIGluZGljYXRlIHRoZSBpdGVtIGlzbid0IGluIGEgbGlua2VkIGxpc3QuXG59LFxuICAgIF9yZW1vdmVGcm9tUGFyZW50ID0gZnVuY3Rpb24gX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQsIG9ubHlJZlBhcmVudEhhc0F1dG9SZW1vdmUpIHtcbiAgY2hpbGQucGFyZW50ICYmICghb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSB8fCBjaGlsZC5wYXJlbnQuYXV0b1JlbW92ZUNoaWxkcmVuKSAmJiBjaGlsZC5wYXJlbnQucmVtb3ZlICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICBjaGlsZC5fYWN0ID0gMDtcbn0sXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG4gICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICB3aGlsZSAoYSkge1xuICAgICAgYS5fZGlydHkgPSAxO1xuICAgICAgYSA9IGEucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfcmV3aW5kU3RhcnRBdCA9IGZ1bmN0aW9uIF9yZXdpbmRTdGFydEF0KHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICByZXR1cm4gdHdlZW4uX3N0YXJ0QXQgJiYgKF9yZXZlcnRpbmcgPyB0d2Vlbi5fc3RhcnRBdC5yZXZlcnQoX3JldmVydENvbmZpZ05vS2lsbCkgOiB0d2Vlbi52YXJzLmltbWVkaWF0ZVJlbmRlciAmJiAhdHdlZW4udmFycy5hdXRvUmV2ZXJ0IHx8IHR3ZWVuLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIGZvcmNlKSk7XG59LFxuICAgIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyA9IGZ1bmN0aW9uIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgcmV0dXJuICFhbmltYXRpb24gfHwgYW5pbWF0aW9uLl90cyAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uLnBhcmVudCk7XG59LFxuICAgIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbiA9IGZ1bmN0aW9uIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbihhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKGFuaW1hdGlvbi5fdFRpbWUsIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpICsgYW5pbWF0aW9uLl9yRGVsYXkpICogYW5pbWF0aW9uIDogMDtcbn0sXG4gICAgLy8gZmVlZCBpbiB0aGUgdG90YWxUaW1lIGFuZCBjeWNsZUR1cmF0aW9uIGFuZCBpdCdsbCByZXR1cm4gdGhlIGN5Y2xlIChpdGVyYXRpb24gbWludXMgMSkgYW5kIGlmIHRoZSBwbGF5aGVhZCBpcyBleGFjdGx5IGF0IHRoZSB2ZXJ5IEVORCwgaXQgd2lsbCBOT1QgYnVtcCB1cCB0byB0aGUgbmV4dCBjeWNsZS5cbl9hbmltYXRpb25DeWNsZSA9IGZ1bmN0aW9uIF9hbmltYXRpb25DeWNsZSh0VGltZSwgY3ljbGVEdXJhdGlvbikge1xuICB2YXIgd2hvbGUgPSBNYXRoLmZsb29yKHRUaW1lIC89IGN5Y2xlRHVyYXRpb24pO1xuICByZXR1cm4gdFRpbWUgJiYgd2hvbGUgPT09IHRUaW1lID8gd2hvbGUgLSAxIDogd2hvbGU7XG59LFxuICAgIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lID0gZnVuY3Rpb24gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50VGltZSwgY2hpbGQpIHtcbiAgcmV0dXJuIChwYXJlbnRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyArIChjaGlsZC5fdHMgPj0gMCA/IDAgOiBjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cik7XG59LFxuICAgIF9zZXRFbmQgPSBmdW5jdGlvbiBfc2V0RW5kKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uLl9lbmQgPSBfcm91bmRQcmVjaXNlKGFuaW1hdGlvbi5fc3RhcnQgKyAoYW5pbWF0aW9uLl90RHVyIC8gTWF0aC5hYnMoYW5pbWF0aW9uLl90cyB8fCBhbmltYXRpb24uX3J0cyB8fCBfdGlueU51bSkgfHwgMCkpO1xufSxcbiAgICBfYWxpZ25QbGF5aGVhZCA9IGZ1bmN0aW9uIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgdG90YWxUaW1lKSB7XG4gIC8vIGFkanVzdHMgdGhlIGFuaW1hdGlvbidzIF9zdGFydCBhbmQgX2VuZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHRvdGFsVGltZSAob25seSBpZiB0aGUgcGFyZW50J3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSBhbmQgdGhlIGFuaW1hdGlvbiBpc24ndCBwYXVzZWQpLiBJdCBkb2Vzbid0IGRvIGFueSByZW5kZXJpbmcgb3IgZm9yY2luZyB0aGluZ3MgYmFjayBpbnRvIHBhcmVudCB0aW1lbGluZXMsIGV0Yy4gLSB0aGF0J3Mgd2hhdCB0b3RhbFRpbWUoKSBpcyBmb3IuXG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24uX2RwO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcbiAgICBhbmltYXRpb24uX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShwYXJlbnQuX3RpbWUgLSAoYW5pbWF0aW9uLl90cyA+IDAgPyB0b3RhbFRpbWUgLyBhbmltYXRpb24uX3RzIDogKChhbmltYXRpb24uX2RpcnR5ID8gYW5pbWF0aW9uLnRvdGFsRHVyYXRpb24oKSA6IGFuaW1hdGlvbi5fdER1cikgLSB0b3RhbFRpbWUpIC8gLWFuaW1hdGlvbi5fdHMpKTtcblxuICAgIF9zZXRFbmQoYW5pbWF0aW9uKTtcblxuICAgIHBhcmVudC5fZGlydHkgfHwgX3VuY2FjaGUocGFyZW50LCBhbmltYXRpb24pOyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuXG4vKlxuX3RvdGFsVGltZVRvVGltZSA9IChjbGFtcGVkVG90YWxUaW1lLCBkdXJhdGlvbiwgcmVwZWF0LCByZXBlYXREZWxheSwgeW95bykgPT4ge1xuXHRsZXQgY3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgcmVwZWF0RGVsYXksXG5cdFx0dGltZSA9IF9yb3VuZChjbGFtcGVkVG90YWxUaW1lICUgY3ljbGVEdXJhdGlvbik7XG5cdGlmICh0aW1lID4gZHVyYXRpb24pIHtcblx0XHR0aW1lID0gZHVyYXRpb247XG5cdH1cblx0cmV0dXJuICh5b3lvICYmICh+fihjbGFtcGVkVG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgJiAxKSkgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xufSxcbiovXG5fcG9zdEFkZENoZWNrcyA9IGZ1bmN0aW9uIF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCkge1xuICB2YXIgdDtcblxuICBpZiAoY2hpbGQuX3RpbWUgfHwgIWNoaWxkLl9kdXIgJiYgY2hpbGQuX2luaXR0ZWQgfHwgY2hpbGQuX3N0YXJ0IDwgdGltZWxpbmUuX3RpbWUgJiYgKGNoaWxkLl9kdXIgfHwgIWNoaWxkLmFkZCkpIHtcbiAgICAvLyBpbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydCBpcyBtb3ZlZCBvbiBhIHR3ZWVuIHRoYXQgaGFzIGFscmVhZHkgcmVuZGVyZWQsIG9yIGlmIGl0J3MgYmVpbmcgaW5zZXJ0ZWQgaW50byBhIHRpbWVsaW5lIEJFRk9SRSB3aGVyZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5LiBJbWFnaW5lIGl0J3MgYXQgaXRzIGVuZCBzdGF0ZSwgdGhlbiB0aGUgc3RhcnRUaW1lIGlzIG1vdmVkIFdBWSBsYXRlciAoYWZ0ZXIgdGhlIGVuZCBvZiB0aGlzIHRpbWVsaW5lKSwgaXQgc2hvdWxkIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLiBTcGVjaWFsIGNhc2U6IGlmIGl0J3MgYSB0aW1lbGluZSAoaGFzIC5hZGQoKSBtZXRob2QpIGFuZCBubyBkdXJhdGlvbiwgd2UgY2FuIHNraXAgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIHVzZXIgbWF5IGJlIHBvcHVsYXRpbmcgaXQgQUZURVIgYWRkaW5nIGl0IHRvIGEgcGFyZW50IHRpbWVsaW5lICh1bmNvbnZlbnRpb25hbCwgYnV0IHBvc3NpYmxlLCBhbmQgd2Ugd291bGRuJ3Qgd2FudCBpdCB0byBnZXQgcmVtb3ZlZCBpZiB0aGUgcGFyZW50J3MgYXV0b1JlbW92ZUNoaWxkcmVuIGlzIHRydWUpLlxuICAgIHQgPSBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lbGluZS5yYXdUaW1lKCksIGNoaWxkKTtcblxuICAgIGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG4gICAgICBjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXG5cbiAgaWYgKF91bmNhY2hlKHRpbWVsaW5lLCBjaGlsZCkuX2RwICYmIHRpbWVsaW5lLl9pbml0dGVkICYmIHRpbWVsaW5lLl90aW1lID49IHRpbWVsaW5lLl9kdXIgJiYgdGltZWxpbmUuX3RzKSB7XG4gICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuICAgIGlmICh0aW1lbGluZS5fZHVyIDwgdGltZWxpbmUuZHVyYXRpb24oKSkge1xuICAgICAgdCA9IHRpbWVsaW5lO1xuXG4gICAgICB3aGlsZSAodC5fZHApIHtcbiAgICAgICAgdC5yYXdUaW1lKCkgPj0gMCAmJiB0LnRvdGFsVGltZSh0Ll90VGltZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LiBJZiBpdCdzIGN1cnJlbnRseSB6ZXJvLCB0aG91Z2gsIGl0IG1heSBub3QgYmUgc2NoZWR1bGVkIHRvIHJlbmRlciB1bnRpbCBsYXRlciBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgaXQgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBwbGF5aGVhZCBwb3NpdGlvbi4gT25seSBtb3ZlIHRvIGNhdGNoIHVwIHdpdGggdGhlIHBsYXloZWFkLlxuXG4gICAgICAgIHQgPSB0Ll9kcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lbGluZS5felRpbWUgPSAtX3RpbnlOdW07IC8vIGhlbHBzIGVuc3VyZSB0aGF0IHRoZSBuZXh0IHJlbmRlcigpIHdpbGwgYmUgZm9yY2VkIChjcm9zc2luZ1N0YXJ0ID0gdHJ1ZSBpbiByZW5kZXIoKSksIGV2ZW4gaWYgdGhlIGR1cmF0aW9uIGhhc24ndCBjaGFuZ2VkICh3ZSdyZSBhZGRpbmcgYSBjaGlsZCB3aGljaCB3b3VsZCBuZWVkIHRvIGdldCByZW5kZXJlZCkuIERlZmluaXRlbHkgYW4gZWRnZSBjYXNlLiBOb3RlOiB3ZSBNVVNUIGRvIHRoaXMgQUZURVIgdGhlIGxvb3AgYWJvdmUgd2hlcmUgdGhlIHRvdGFsVGltZSgpIG1pZ2h0IHRyaWdnZXIgYSByZW5kZXIoKSBiZWNhdXNlIHRoaXMgX2FkZFRvVGltZWxpbmUoKSBtZXRob2QgZ2V0cyBjYWxsZWQgZnJvbSB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBCRUZPUkUgdHdlZW5zIGV2ZW4gcmVjb3JkIHRoZWlyIHRhcmdldHMsIGV0Yy4gc28gd2Ugd291bGRuJ3Qgd2FudCB0aGluZ3MgdG8gZ2V0IHRyaWdnZXJlZCBpbiB0aGUgd3Jvbmcgb3JkZXIuXG4gIH1cbn0sXG4gICAgX2FkZFRvVGltZWxpbmUgPSBmdW5jdGlvbiBfYWRkVG9UaW1lbGluZSh0aW1lbGluZSwgY2hpbGQsIHBvc2l0aW9uLCBza2lwQ2hlY2tzKSB7XG4gIGNoaWxkLnBhcmVudCAmJiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCk7XG4gIGNoaWxkLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoKF9pc051bWJlcihwb3NpdGlvbikgPyBwb3NpdGlvbiA6IHBvc2l0aW9uIHx8IHRpbWVsaW5lICE9PSBfZ2xvYmFsVGltZWxpbmUgPyBfcGFyc2VQb3NpdGlvbih0aW1lbGluZSwgcG9zaXRpb24sIGNoaWxkKSA6IHRpbWVsaW5lLl90aW1lKSArIGNoaWxkLl9kZWxheSk7XG4gIGNoaWxkLl9lbmQgPSBfcm91bmRQcmVjaXNlKGNoaWxkLl9zdGFydCArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBNYXRoLmFicyhjaGlsZC50aW1lU2NhbGUoKSkgfHwgMCkpO1xuXG4gIF9hZGRMaW5rZWRMaXN0SXRlbSh0aW1lbGluZSwgY2hpbGQsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGltZWxpbmUuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG5cbiAgX2lzRnJvbU9yRnJvbVN0YXJ0KGNoaWxkKSB8fCAodGltZWxpbmUuX3JlY2VudCA9IGNoaWxkKTtcbiAgc2tpcENoZWNrcyB8fCBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpO1xuICB0aW1lbGluZS5fdHMgPCAwICYmIF9hbGlnblBsYXloZWFkKHRpbWVsaW5lLCB0aW1lbGluZS5fdFRpbWUpOyAvLyBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBuZXcgY2hpbGQgbWFrZXMgaXQgbG9uZ2VyLCB3ZSBtYXkgbmVlZCB0byBhZGp1c3QgdGhlIHBhcmVudCdzIF9zdGFydCAocHVzaCBpdCBiYWNrKVxuXG4gIHJldHVybiB0aW1lbGluZTtcbn0sXG4gICAgX3Njcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2Nyb2xsVHJpZ2dlcihhbmltYXRpb24sIHRyaWdnZXIpIHtcbiAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcbn0sXG4gICAgX2F0dGVtcHRJbml0VHdlZW4gPSBmdW5jdGlvbiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzLCB0VGltZSkge1xuICBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lLCB0VGltZSk7XG5cbiAgaWYgKCF0d2Vlbi5faW5pdHRlZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKCFmb3JjZSAmJiB0d2Vlbi5fcHQgJiYgIV9yZXZlcnRpbmcgJiYgKHR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5ICE9PSBmYWxzZSB8fCAhdHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkpICYmIF9sYXN0UmVuZGVyZWRGcmFtZSAhPT0gX3RpY2tlci5mcmFtZSkge1xuICAgIF9sYXp5VHdlZW5zLnB1c2godHdlZW4pO1xuXG4gICAgdHdlZW4uX2xhenkgPSBbdFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChfcmVmKSB7XG4gIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xufSxcbiAgICAvLyBjaGVjayBwYXJlbnQncyBfbG9jayBiZWNhdXNlIHdoZW4gYSB0aW1lbGluZSByZXBlYXRzL3lveW9zIGFuZCBkb2VzIGl0cyBhcnRpZmljaWFsIHdyYXBwaW5nLCB3ZSBzaG91bGRuJ3QgZm9yY2UgdGhlIHJhdGlvIGJhY2sgdG8gMFxuX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgcmV0dXJuIGRhdGEgPT09IFwiaXNGcm9tU3RhcnRcIiB8fCBkYXRhID09PSBcImlzU3RhcnRcIjtcbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLiBFZGdlIGNhc2U6IGlmIGEgZnJvbSgpIG9yIGZyb21UbygpIHN0YWdnZXIgdHdlZW4gaXMgcGxhY2VkIGxhdGVyIGluIGEgdGltZWxpbmUsIHRoZSBcInN0YXJ0QXRcIiB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGNvdWxkIGluaXRpYWxseSByZW5kZXIgYXQgYSB0aW1lIHdoZW4gdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGlzIHRlY2huaWNhbGx5IEJFRk9SRSB3aGVyZSB0aGlzIHR3ZWVuIGlzLCBzbyBtYWtlIHN1cmUgdGhhdCBhbnkgXCJmcm9tXCIgYW5kIFwiZnJvbVRvXCIgc3RhcnRBdCB0d2VlbnMgYXJlIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lIGF0IGEgcmF0aW8gb2YgMS5cbiAgcmVwZWF0RGVsYXkgPSB0d2Vlbi5fckRlbGF5LFxuICAgICAgdFRpbWUgPSAwLFxuICAgICAgcHQsXG4gICAgICBpdGVyYXRpb24sXG4gICAgICBwcmV2SXRlcmF0aW9uO1xuXG4gIGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy8gaW4gY2FzZSB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiB0aGF0IGhhcyBhIHJlcGVhdCB3aXRoIGEgcmVwZWF0RGVsYXlcbiAgICB0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcbiAgICBpdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIHJlcGVhdERlbGF5KTtcbiAgICB0d2Vlbi5feW95byAmJiBpdGVyYXRpb24gJiAxICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG5cbiAgICBpZiAoaXRlcmF0aW9uICE9PSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSkpIHtcbiAgICAgIC8vIGlmIGl0ZXJhdGlvbiBjaGFuZ2VkXG4gICAgICBwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IF9yZXZlcnRpbmcgfHwgZm9yY2UgfHwgdHdlZW4uX3pUaW1lID09PSBfdGlueU51bSB8fCAhdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkge1xuICAgIGlmICghdHdlZW4uX2luaXR0ZWQgJiYgX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzLCB0VGltZSkpIHtcbiAgICAgIC8vIGlmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2SXRlcmF0aW9uID0gdHdlZW4uX3pUaW1lO1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApOyAvLyB3aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgIHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7IC8vIGlmIGl0IHdhcyByZW5kZXJlZCBwcmV2aW91c2x5IGF0IGV4YWN0bHkgMCAoX3pUaW1lKSBhbmQgbm93IHRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcgYXdheSwgRE9OJ1QgZmlyZSBjYWxsYmFja3Mgb3RoZXJ3aXNlIHRoZXknbGwgc2VlbSBsaWtlIGR1cGxpY2F0ZXMuXG5cbiAgICB0d2Vlbi5yYXRpbyA9IHJhdGlvO1xuICAgIHR3ZWVuLl9mcm9tICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG4gICAgdHdlZW4uX3RpbWUgPSAwO1xuICAgIHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuICAgIHB0ID0gdHdlZW4uX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgdG90YWxUaW1lIDwgMCAmJiBfcmV3aW5kU3RhcnRBdCh0d2VlbiwgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgdHJ1ZSk7XG4gICAgdHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG4gICAgdFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcblxuICAgIGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xuXG4gICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICFfcmV2ZXJ0aW5nKSB7XG4gICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZTtcbiAgfVxufSxcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XG4gIHZhciBjaGlsZDtcblxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuICAgICAgaWYgKGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlLCBsZWF2ZVBsYXloZWFkKSB7XG4gIHZhciByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcbiAgICAgIGR1ciA9IF9yb3VuZFByZWNpc2UoZHVyYXRpb24pIHx8IDAsXG4gICAgICB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cjtcbiAgdG90YWxQcm9ncmVzcyAmJiAhbGVhdmVQbGF5aGVhZCAmJiAoYW5pbWF0aW9uLl90aW1lICo9IGR1ciAvIGFuaW1hdGlvbi5fZHVyKTtcbiAgYW5pbWF0aW9uLl9kdXIgPSBkdXI7XG4gIGFuaW1hdGlvbi5fdER1ciA9ICFyZXBlYXQgPyBkdXIgOiByZXBlYXQgPCAwID8gMWUxMCA6IF9yb3VuZFByZWNpc2UoZHVyICogKHJlcGVhdCArIDEpICsgYW5pbWF0aW9uLl9yRGVsYXkgKiByZXBlYXQpO1xuICB0b3RhbFByb2dyZXNzID4gMCAmJiAhbGVhdmVQbGF5aGVhZCAmJiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIGFuaW1hdGlvbi5fdFRpbWUgPSBhbmltYXRpb24uX3REdXIgKiB0b3RhbFByb2dyZXNzKTtcbiAgYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gIHNraXBVbmNhY2hlIHx8IF91bmNhY2hlKGFuaW1hdGlvbi5wYXJlbnQsIGFuaW1hdGlvbik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xufSxcbiAgICBfemVyb1Bvc2l0aW9uID0ge1xuICBfc3RhcnQ6IDAsXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmMsXG4gIHRvdGFsRHVyYXRpb246IF9lbXB0eUZ1bmNcbn0sXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLCBwZXJjZW50QW5pbWF0aW9uKSB7XG4gIHZhciBsYWJlbHMgPSBhbmltYXRpb24ubGFiZWxzLFxuICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gIGksXG4gICAgICBvZmZzZXQsXG4gICAgICBpc1BlcmNlbnQ7XG5cbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cbiAgICBvZmZzZXQgPSBwb3NpdGlvbi5jaGFyQXQoMCk7XG4gICAgaXNQZXJjZW50ID0gcG9zaXRpb24uc3Vic3RyKC0xKSA9PT0gXCIlXCI7XG4gICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gXCI8XCIgfHwgb2Zmc2V0ID09PSBcIj5cIikge1xuICAgICAgaSA+PSAwICYmIChwb3NpdGlvbiA9IHBvc2l0aW9uLnJlcGxhY2UoLz0vLCBcIlwiKSk7XG4gICAgICByZXR1cm4gKG9mZnNldCA9PT0gXCI8XCIgPyByZWNlbnQuX3N0YXJ0IDogcmVjZW50LmVuZFRpbWUocmVjZW50Ll9yZXBlYXQgPj0gMCkpICsgKHBhcnNlRmxvYXQocG9zaXRpb24uc3Vic3RyKDEpKSB8fCAwKSAqIChpc1BlcmNlbnQgPyAoaSA8IDAgPyByZWNlbnQgOiBwZXJjZW50QW5pbWF0aW9uKS50b3RhbER1cmF0aW9uKCkgLyAxMDAgOiAxKTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHBvc2l0aW9uIGluIGxhYmVscyB8fCAobGFiZWxzW3Bvc2l0aW9uXSA9IGNsaXBwZWREdXJhdGlvbik7XG4gICAgICByZXR1cm4gbGFiZWxzW3Bvc2l0aW9uXTtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KHBvc2l0aW9uLmNoYXJBdChpIC0gMSkgKyBwb3NpdGlvbi5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChpc1BlcmNlbnQgJiYgcGVyY2VudEFuaW1hdGlvbikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IC8gMTAwICogKF9pc0FycmF5KHBlcmNlbnRBbmltYXRpb24pID8gcGVyY2VudEFuaW1hdGlvblswXSA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaSA+IDEgPyBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLnN1YnN0cigwLCBpIC0gMSksIHBlcmNlbnRBbmltYXRpb24pICsgb2Zmc2V0IDogY2xpcHBlZER1cmF0aW9uICsgb2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uID09IG51bGwgPyBjbGlwcGVkRHVyYXRpb24gOiArcG9zaXRpb247XG59LFxuICAgIF9jcmVhdGVUd2VlblR5cGUgPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW5UeXBlKHR5cGUsIHBhcmFtcywgdGltZWxpbmUpIHtcbiAgdmFyIGlzTGVnYWN5ID0gX2lzTnVtYmVyKHBhcmFtc1sxXSksXG4gICAgICB2YXJzSW5kZXggPSAoaXNMZWdhY3kgPyAyIDogMSkgKyAodHlwZSA8IDIgPyAwIDogMSksXG4gICAgICB2YXJzID0gcGFyYW1zW3ZhcnNJbmRleF0sXG4gICAgICBpclZhcnMsXG4gICAgICBwYXJlbnQ7XG5cbiAgaXNMZWdhY3kgJiYgKHZhcnMuZHVyYXRpb24gPSBwYXJhbXNbMV0pO1xuICB2YXJzLnBhcmVudCA9IHRpbWVsaW5lO1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaXJWYXJzID0gdmFycztcbiAgICBwYXJlbnQgPSB0aW1lbGluZTtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgIShcImltbWVkaWF0ZVJlbmRlclwiIGluIGlyVmFycykpIHtcbiAgICAgIC8vIGluaGVyaXRhbmNlIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGJ1dCBzb21lb25lIG1heSBoYXZlIHNldCBhIGRlZmF1bHQgaW4gYW4gYW5jZXN0b3IgdGltZWxpbmUuIFdlIGNvdWxkIGRvIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIpIGJ1dCB0aGF0J2QgZXhhY3QgYSBzbGlnaHQgcGVyZm9ybWFuY2UgcGVuYWx0eSBiZWNhdXNlIF9pbmhlcml0RGVmYXVsdHMoKSBhbHNvIHJ1bnMgaW4gdGhlIFR3ZWVuIGNvbnN0cnVjdG9yLiBXZSdyZSBwYXlpbmcgYSBzbWFsbCBrYiBwcmljZSBoZXJlIHRvIGdhaW4gc3BlZWQuXG4gICAgICBpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcbiAgICAgIHBhcmVudCA9IF9pc05vdEZhbHNlKHBhcmVudC52YXJzLmluaGVyaXQpICYmIHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShpclZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICB0eXBlIDwgMiA/IHZhcnMucnVuQmFja3dhcmRzID0gMSA6IHZhcnMuc3RhcnRBdCA9IHBhcmFtc1t2YXJzSW5kZXggLSAxXTsgLy8gXCJmcm9tXCIgdmFyc1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUd2VlbihwYXJhbXNbMF0sIHZhcnMsIHBhcmFtc1t2YXJzSW5kZXggKyAxXSk7XG59LFxuICAgIF9jb25kaXRpb25hbFJldHVybiA9IGZ1bmN0aW9uIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuYykge1xuICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBmdW5jKHZhbHVlKSA6IGZ1bmM7XG59LFxuICAgIF9jbGFtcCA9IGZ1bmN0aW9uIF9jbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbn0sXG4gICAgZ2V0VW5pdCA9IGZ1bmN0aW9uIGdldFVuaXQodmFsdWUsIHYpIHtcbiAgcmV0dXJuICFfaXNTdHJpbmcodmFsdWUpIHx8ICEodiA9IF91bml0RXhwLmV4ZWModmFsdWUpKSA/IFwiXCIgOiB2WzFdO1xufSxcbiAgICAvLyBub3RlOiBwcm90ZWN0IGFnYWluc3QgcGFkZGVkIG51bWJlcnMgYXMgc3RyaW5ncywgbGlrZSBcIjEwMC4xMDBcIi4gVGhhdCBzaG91bGRuJ3QgcmV0dXJuIFwiMDBcIiBhcyB0aGUgdW5pdC4gSWYgaXQncyBudW1lcmljLCByZXR1cm4gbm8gdW5pdC5cbmNsYW1wID0gZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIF9jbGFtcChtaW4sIG1heCwgdik7XG4gIH0pO1xufSxcbiAgICBfc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBfaXNBcnJheUxpa2UodmFsdWUsIG5vbkVtcHR5KSB7XG4gIHJldHVybiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWUpICYmIFwibGVuZ3RoXCIgaW4gdmFsdWUgJiYgKCFub25FbXB0eSAmJiAhdmFsdWUubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCAtIDEgaW4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlWzBdKSkgJiYgIXZhbHVlLm5vZGVUeXBlICYmIHZhbHVlICE9PSBfd2luO1xufSxcbiAgICBfZmxhdHRlbiA9IGZ1bmN0aW9uIF9mbGF0dGVuKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yKSB7XG4gIGlmIChhY2N1bXVsYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfYWNjdW11bGF0b3I7XG5cbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzIHx8IF9pc0FycmF5TGlrZSh2YWx1ZSwgMSkgPyAoX2FjY3VtdWxhdG9yID0gYWNjdW11bGF0b3IpLnB1c2guYXBwbHkoX2FjY3VtdWxhdG9yLCB0b0FycmF5KHZhbHVlKSkgOiBhY2N1bXVsYXRvci5wdXNoKHZhbHVlKTtcbiAgfSkgfHwgYWNjdW11bGF0b3I7XG59LFxuICAgIC8vdGFrZXMgYW55IHZhbHVlIGFuZCByZXR1cm5zIGFuIGFycmF5LiBJZiBpdCdzIGEgc3RyaW5nIChhbmQgbGVhdmVTdHJpbmdzIGlzbid0IHRydWUpLCBpdCdsbCB1c2UgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIGFuZCBjb252ZXJ0IHRoYXQgdG8gYW4gYXJyYXkuIEl0J2xsIGFsc28gYWNjZXB0IGl0ZXJhYmxlcyBsaWtlIGpRdWVyeSBvYmplY3RzLlxudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUsIHNjb3BlLCBsZWF2ZVN0cmluZ3MpIHtcbiAgcmV0dXJuIF9jb250ZXh0ICYmICFzY29wZSAmJiBfY29udGV4dC5zZWxlY3RvciA/IF9jb250ZXh0LnNlbGVjdG9yKHZhbHVlKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgIWxlYXZlU3RyaW5ncyAmJiAoX2NvcmVJbml0dGVkIHx8ICFfd2FrZSgpKSA/IF9zbGljZS5jYWxsKChzY29wZSB8fCBfZG9jKS5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSwgMCkgOiBfaXNBcnJheSh2YWx1ZSkgPyBfZmxhdHRlbih2YWx1ZSwgbGVhdmVTdHJpbmdzKSA6IF9pc0FycmF5TGlrZSh2YWx1ZSkgPyBfc2xpY2UuY2FsbCh2YWx1ZSwgMCkgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXTtcbn0sXG4gICAgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3Rvcih2YWx1ZSkge1xuICB2YWx1ZSA9IHRvQXJyYXkodmFsdWUpWzBdIHx8IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGVsID0gdmFsdWUuY3VycmVudCB8fCB2YWx1ZS5uYXRpdmVFbGVtZW50IHx8IHZhbHVlO1xuICAgIHJldHVybiB0b0FycmF5KHYsIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlbCA6IGVsID09PSB2YWx1ZSA/IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiB2YWx1ZSk7XG4gIH07XG59LFxuICAgIHNodWZmbGUgPSBmdW5jdGlvbiBzaHVmZmxlKGEpIHtcbiAgcmV0dXJuIGEuc29ydChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIC41IC0gTWF0aC5yYW5kb20oKTtcbiAgfSk7XG59LFxuICAgIC8vIGFsdGVybmF0aXZlIHRoYXQncyBhIGJpdCBmYXN0ZXIgYW5kIG1vcmUgcmVsaWFibHkgZGl2ZXJzZSBidXQgYmlnZ2VyOiAgIGZvciAobGV0IGosIHYsIGkgPSBhLmxlbmd0aDsgaTsgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGkpLCB2ID0gYVstLWldLCBhW2ldID0gYVtqXSwgYVtqXSA9IHYpOyByZXR1cm4gYTtcbi8vZm9yIGRpc3RyaWJ1dGluZyB2YWx1ZXMgYWNyb3NzIGFuIGFycmF5LiBDYW4gYWNjZXB0IGEgbnVtYmVyLCBhIGZ1bmN0aW9uIG9yIChtb3N0IGNvbW1vbmx5KSBhIGZ1bmN0aW9uIHdoaWNoIGNhbiBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoge2Jhc2UsIGFtb3VudCwgZnJvbSwgZWFzZSwgZ3JpZCwgYXhpcywgbGVuZ3RoLCBlYWNofS4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6IGluZGV4LCB0YXJnZXQsIGFycmF5LiBSZWNvZ25pemVzIHRoZSBmb2xsb3dpbmdcbmRpc3RyaWJ1dGUgPSBmdW5jdGlvbiBkaXN0cmlidXRlKHYpIHtcbiAgaWYgKF9pc0Z1bmN0aW9uKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICB2YXIgdmFycyA9IF9pc09iamVjdCh2KSA/IHYgOiB7XG4gICAgZWFjaDogdlxuICB9LFxuICAgICAgLy9uOjEgaXMganVzdCB0byBpbmRpY2F0ZSB2IHdhcyBhIG51bWJlcjsgd2UgbGV2ZXJhZ2UgdGhhdCBsYXRlciB0byBzZXQgdiBhY2NvcmRpbmcgdG8gdGhlIGxlbmd0aCB3ZSBnZXQuIElmIGEgbnVtYmVyIGlzIHBhc3NlZCBpbiwgd2UgdHJlYXQgaXQgbGlrZSB0aGUgb2xkIHN0YWdnZXIgdmFsdWUgd2hlcmUgMC4xLCBmb3IgZXhhbXBsZSwgd291bGQgbWVhbiB0aGF0IHRoaW5ncyB3b3VsZCBiZSBkaXN0cmlidXRlZCB3aXRoIDAuMSBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgcmF0aGVyIHRoYW4gYSB0b3RhbCBcImFtb3VudFwiIHRoYXQncyBjaHVua2VkIG91dCBhbW9uZyB0aGVtIGFsbC5cbiAgZWFzZSA9IF9wYXJzZUVhc2UodmFycy5lYXNlKSxcbiAgICAgIGZyb20gPSB2YXJzLmZyb20gfHwgMCxcbiAgICAgIGJhc2UgPSBwYXJzZUZsb2F0KHZhcnMuYmFzZSkgfHwgMCxcbiAgICAgIGNhY2hlID0ge30sXG4gICAgICBpc0RlY2ltYWwgPSBmcm9tID4gMCAmJiBmcm9tIDwgMSxcbiAgICAgIHJhdGlvcyA9IGlzTmFOKGZyb20pIHx8IGlzRGVjaW1hbCxcbiAgICAgIGF4aXMgPSB2YXJzLmF4aXMsXG4gICAgICByYXRpb1ggPSBmcm9tLFxuICAgICAgcmF0aW9ZID0gZnJvbTtcblxuICBpZiAoX2lzU3RyaW5nKGZyb20pKSB7XG4gICAgcmF0aW9YID0gcmF0aW9ZID0ge1xuICAgICAgY2VudGVyOiAuNSxcbiAgICAgIGVkZ2VzOiAuNSxcbiAgICAgIGVuZDogMVxuICAgIH1bZnJvbV0gfHwgMDtcbiAgfSBlbHNlIGlmICghaXNEZWNpbWFsICYmIHJhdGlvcykge1xuICAgIHJhdGlvWCA9IGZyb21bMF07XG4gICAgcmF0aW9ZID0gZnJvbVsxXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaSwgdGFyZ2V0LCBhKSB7XG4gICAgdmFyIGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdLFxuICAgICAgICBvcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBkLFxuICAgICAgICBqLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgd3JhcEF0O1xuXG4gICAgaWYgKCFkaXN0YW5jZXMpIHtcbiAgICAgIHdyYXBBdCA9IHZhcnMuZ3JpZCA9PT0gXCJhdXRvXCIgPyAwIDogKHZhcnMuZ3JpZCB8fCBbMSwgX2JpZ051bV0pWzFdO1xuXG4gICAgICBpZiAoIXdyYXBBdCkge1xuICAgICAgICBtYXggPSAtX2JpZ051bTtcblxuICAgICAgICB3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHt9XG5cbiAgICAgICAgd3JhcEF0IDwgbCAmJiB3cmFwQXQtLTtcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0gPSBbXTtcbiAgICAgIG9yaWdpblggPSByYXRpb3MgPyBNYXRoLm1pbih3cmFwQXQsIGwpICogcmF0aW9YIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xuICAgICAgb3JpZ2luWSA9IHdyYXBBdCA9PT0gX2JpZ051bSA/IDAgOiByYXRpb3MgPyBsICogcmF0aW9ZIC8gd3JhcEF0IC0gLjUgOiBmcm9tIC8gd3JhcEF0IHwgMDtcbiAgICAgIG1heCA9IDA7XG4gICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIHggPSBqICUgd3JhcEF0IC0gb3JpZ2luWDtcbiAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICBkaXN0YW5jZXNbal0gPSBkID0gIWF4aXMgPyBfc3FydCh4ICogeCArIHkgKiB5KSA6IE1hdGguYWJzKGF4aXMgPT09IFwieVwiID8geSA6IHgpO1xuICAgICAgICBkID4gbWF4ICYmIChtYXggPSBkKTtcbiAgICAgICAgZCA8IG1pbiAmJiAobWluID0gZCk7XG4gICAgICB9XG5cbiAgICAgIGZyb20gPT09IFwicmFuZG9tXCIgJiYgc2h1ZmZsZShkaXN0YW5jZXMpO1xuICAgICAgZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcbiAgICAgIGRpc3RhbmNlcy5taW4gPSBtaW47XG4gICAgICBkaXN0YW5jZXMudiA9IGwgPSAocGFyc2VGbG9hdCh2YXJzLmFtb3VudCkgfHwgcGFyc2VGbG9hdCh2YXJzLmVhY2gpICogKHdyYXBBdCA+IGwgPyBsIC0gMSA6ICFheGlzID8gTWF0aC5tYXgod3JhcEF0LCBsIC8gd3JhcEF0KSA6IGF4aXMgPT09IFwieVwiID8gbCAvIHdyYXBBdCA6IHdyYXBBdCkgfHwgMCkgKiAoZnJvbSA9PT0gXCJlZGdlc1wiID8gLTEgOiAxKTtcbiAgICAgIGRpc3RhbmNlcy5iID0gbCA8IDAgPyBiYXNlIC0gbCA6IGJhc2U7XG4gICAgICBkaXN0YW5jZXMudSA9IGdldFVuaXQodmFycy5hbW91bnQgfHwgdmFycy5lYWNoKSB8fCAwOyAvL3VuaXRcblxuICAgICAgZWFzZSA9IGVhc2UgJiYgbCA8IDAgPyBfaW52ZXJ0RWFzZShlYXNlKSA6IGVhc2U7XG4gICAgfVxuXG4gICAgbCA9IChkaXN0YW5jZXNbaV0gLSBkaXN0YW5jZXMubWluKSAvIGRpc3RhbmNlcy5tYXggfHwgMDtcbiAgICByZXR1cm4gX3JvdW5kUHJlY2lzZShkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gTWF0aC5wb3coMTAsICgodiArIFwiXCIpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGgpOyAvL3RvIGF2b2lkIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChsaWtlIDI0ICogMC4xID09IDIuNDAwMDAwMDAwMDAwMDAwNCksIHdlIGNob3Agb2ZmIGF0IGEgc3BlY2lmaWMgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIChtdWNoIGZhc3RlciB0aGFuIHRvRml4ZWQoKSlcblxuICByZXR1cm4gZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciBuID0gX3JvdW5kUHJlY2lzZShNYXRoLnJvdW5kKHBhcnNlRmxvYXQocmF3KSAvIHYpICogdiAqIHApO1xuXG4gICAgcmV0dXJuIChuIC0gbiAlIDEpIC8gcCArIChfaXNOdW1iZXIocmF3KSA/IDAgOiBnZXRVbml0KHJhdykpOyAvLyBuIC0gbiAlIDEgcmVwbGFjZXMgTWF0aC5mbG9vcigpIGluIG9yZGVyIHRvIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZXMgcHJvcGVybHkuIEZvciBleGFtcGxlLCBNYXRoLmZsb29yKC0xNTAuMDAwMDAwMDAwMDAwMDMpIGlzIDE1MSFcbiAgfTtcbn0sXG4gICAgc25hcCA9IGZ1bmN0aW9uIHNuYXAoc25hcFRvLCB2YWx1ZSkge1xuICB2YXIgaXNBcnJheSA9IF9pc0FycmF5KHNuYXBUbyksXG4gICAgICByYWRpdXMsXG4gICAgICBpczJEO1xuXG4gIGlmICghaXNBcnJheSAmJiBfaXNPYmplY3Qoc25hcFRvKSkge1xuICAgIHJhZGl1cyA9IGlzQXJyYXkgPSBzbmFwVG8ucmFkaXVzIHx8IF9iaWdOdW07XG5cbiAgICBpZiAoc25hcFRvLnZhbHVlcykge1xuICAgICAgc25hcFRvID0gdG9BcnJheShzbmFwVG8udmFsdWVzKTtcblxuICAgICAgaWYgKGlzMkQgPSAhX2lzTnVtYmVyKHNuYXBUb1swXSkpIHtcbiAgICAgICAgcmFkaXVzICo9IHJhZGl1czsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gd2UgZG9uJ3QgaGF2ZSB0byBNYXRoLnNxcnQoKSBpbiB0aGUgbG9vcC5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc25hcFRvID0gX3JvdW5kTW9kaWZpZXIoc25hcFRvLmluY3JlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgIWlzQXJyYXkgPyBfcm91bmRNb2RpZmllcihzbmFwVG8pIDogX2lzRnVuY3Rpb24oc25hcFRvKSA/IGZ1bmN0aW9uIChyYXcpIHtcbiAgICBpczJEID0gc25hcFRvKHJhdyk7XG4gICAgcmV0dXJuIE1hdGguYWJzKGlzMkQgLSByYXcpIDw9IHJhZGl1cyA/IGlzMkQgOiByYXc7XG4gIH0gOiBmdW5jdGlvbiAocmF3KSB7XG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueCA6IHJhdyksXG4gICAgICAgIHkgPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueSA6IDApLFxuICAgICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgaSA9IHNuYXBUby5sZW5ndGgsXG4gICAgICAgIGR4LFxuICAgICAgICBkeTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChpczJEKSB7XG4gICAgICAgIGR4ID0gc25hcFRvW2ldLnggLSB4O1xuICAgICAgICBkeSA9IHNuYXBUb1tpXS55IC0geTtcbiAgICAgICAgZHggPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMoc25hcFRvW2ldIC0geCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkeCA8IG1pbikge1xuICAgICAgICBtaW4gPSBkeDtcbiAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VzdCA9ICFyYWRpdXMgfHwgbWluIDw9IHJhZGl1cyA/IHNuYXBUb1tjbG9zZXN0XSA6IHJhdztcbiAgICByZXR1cm4gaXMyRCB8fCBjbG9zZXN0ID09PSByYXcgfHwgX2lzTnVtYmVyKHJhdykgPyBjbG9zZXN0IDogY2xvc2VzdCArIGdldFVuaXQocmF3KTtcbiAgfSk7XG59LFxuICAgIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgcm91bmRpbmdJbmNyZW1lbnQsIHJldHVybkZ1bmN0aW9uKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4oX2lzQXJyYXkobWluKSA/ICFtYXggOiByb3VuZGluZ0luY3JlbWVudCA9PT0gdHJ1ZSA/ICEhKHJvdW5kaW5nSW5jcmVtZW50ID0gMCkgOiAhcmV0dXJuRnVuY3Rpb24sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQXJyYXkobWluKSA/IG1pblt+fihNYXRoLnJhbmRvbSgpICogbWluLmxlbmd0aCldIDogKHJvdW5kaW5nSW5jcmVtZW50ID0gcm91bmRpbmdJbmNyZW1lbnQgfHwgMWUtNSkgJiYgKHJldHVybkZ1bmN0aW9uID0gcm91bmRpbmdJbmNyZW1lbnQgPCAxID8gTWF0aC5wb3coMTAsIChyb3VuZGluZ0luY3JlbWVudCArIFwiXCIpLmxlbmd0aCAtIDIpIDogMSkgJiYgTWF0aC5mbG9vcihNYXRoLnJvdW5kKChtaW4gLSByb3VuZGluZ0luY3JlbWVudCAvIDIgKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIHJvdW5kaW5nSW5jcmVtZW50ICogLjk5KSkgLyByb3VuZGluZ0luY3JlbWVudCkgKiByb3VuZGluZ0luY3JlbWVudCAqIHJldHVybkZ1bmN0aW9uKSAvIHJldHVybkZ1bmN0aW9uO1xuICB9KTtcbn0sXG4gICAgcGlwZSA9IGZ1bmN0aW9uIHBpcGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3Rpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbnMucmVkdWNlKGZ1bmN0aW9uICh2LCBmKSB7XG4gICAgICByZXR1cm4gZih2KTtcbiAgICB9LCB2YWx1ZSk7XG4gIH07XG59LFxuICAgIHVuaXRpemUgPSBmdW5jdGlvbiB1bml0aXplKGZ1bmMsIHVuaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHBhcnNlRmxvYXQodmFsdWUpKSArICh1bml0IHx8IGdldFVuaXQodmFsdWUpKTtcbiAgfTtcbn0sXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gbWFwUmFuZ2UobWluLCBtYXgsIDAsIDEsIHZhbHVlKTtcbn0sXG4gICAgX3dyYXBBcnJheSA9IGZ1bmN0aW9uIF93cmFwQXJyYXkoYSwgd3JhcHBlciwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIGFbfn53cmFwcGVyKGluZGV4KV07XG4gIH0pO1xufSxcbiAgICB3cmFwID0gZnVuY3Rpb24gd3JhcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgLy8gTk9URTogd3JhcCgpIENBTk5PVCBiZSBhbiBhcnJvdyBmdW5jdGlvbiEgQSB2ZXJ5IG9kZCBjb21waWxpbmcgYnVnIGNhdXNlcyBwcm9ibGVtcyAodW5yZWxhdGVkIHRvIEdTQVApLlxuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG4gIHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXAoMCwgbWluLmxlbmd0aCksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAocmFuZ2UgKyAodmFsdWUgLSBtaW4pICUgcmFuZ2UpICUgcmFuZ2UgKyBtaW47XG4gIH0pO1xufSxcbiAgICB3cmFwWW95byA9IGZ1bmN0aW9uIHdyYXBZb3lvKG1pbiwgbWF4LCB2YWx1ZSkge1xuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW4sXG4gICAgICB0b3RhbCA9IHJhbmdlICogMjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcFlveW8oMCwgbWluLmxlbmd0aCAtIDEpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9ICh0b3RhbCArICh2YWx1ZSAtIG1pbikgJSB0b3RhbCkgJSB0b3RhbCB8fCAwO1xuICAgIHJldHVybiBtaW4gKyAodmFsdWUgPiByYW5nZSA/IHRvdGFsIC0gdmFsdWUgOiB2YWx1ZSk7XG4gIH0pO1xufSxcbiAgICBfcmVwbGFjZVJhbmRvbSA9IGZ1bmN0aW9uIF9yZXBsYWNlUmFuZG9tKHZhbHVlKSB7XG4gIC8vcmVwbGFjZXMgYWxsIG9jY3VycmVuY2VzIG9mIHJhbmRvbSguLi4pIGluIGEgc3RyaW5nIHdpdGggdGhlIGNhbGN1bGF0ZWQgcmFuZG9tIHZhbHVlLiBjYW4gYmUgYSByYW5nZSBsaWtlIHJhbmRvbSgtMTAwLCAxMDAsIDUpIG9yIGFuIGFycmF5IGxpa2UgcmFuZG9tKFswLCAxMDAsIDUwMF0pXG4gIHZhciBwcmV2ID0gMCxcbiAgICAgIHMgPSBcIlwiLFxuICAgICAgaSxcbiAgICAgIG51bXMsXG4gICAgICBlbmQsXG4gICAgICBpc0FycmF5O1xuXG4gIHdoaWxlICh+KGkgPSB2YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiLCBwcmV2KSkpIHtcbiAgICBlbmQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBpKTtcbiAgICBpc0FycmF5ID0gdmFsdWUuY2hhckF0KGkgKyA3KSA9PT0gXCJbXCI7XG4gICAgbnVtcyA9IHZhbHVlLnN1YnN0cihpICsgNywgZW5kIC0gaSAtIDcpLm1hdGNoKGlzQXJyYXkgPyBfZGVsaW1pdGVkVmFsdWVFeHAgOiBfc3RyaWN0TnVtRXhwKTtcbiAgICBzICs9IHZhbHVlLnN1YnN0cihwcmV2LCBpIC0gcHJldikgKyByYW5kb20oaXNBcnJheSA/IG51bXMgOiArbnVtc1swXSwgaXNBcnJheSA/IDAgOiArbnVtc1sxXSwgK251bXNbMl0gfHwgMWUtNSk7XG4gICAgcHJldiA9IGVuZCArIDE7XG4gIH1cblxuICByZXR1cm4gcyArIHZhbHVlLnN1YnN0cihwcmV2LCB2YWx1ZS5sZW5ndGggLSBwcmV2KTtcbn0sXG4gICAgbWFwUmFuZ2UgPSBmdW5jdGlvbiBtYXBSYW5nZShpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4LCB2YWx1ZSkge1xuICB2YXIgaW5SYW5nZSA9IGluTWF4IC0gaW5NaW4sXG4gICAgICBvdXRSYW5nZSA9IG91dE1heCAtIG91dE1pbjtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG91dE1pbiArICgodmFsdWUgLSBpbk1pbikgLyBpblJhbmdlICogb3V0UmFuZ2UgfHwgMCk7XG4gIH0pO1xufSxcbiAgICBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCBlbmQsIHByb2dyZXNzLCBtdXRhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc05hTihzdGFydCArIGVuZCkgPyAwIDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gKDEgLSBwKSAqIHN0YXJ0ICsgcCAqIGVuZDtcbiAgfTtcblxuICBpZiAoIWZ1bmMpIHtcbiAgICB2YXIgaXNTdHJpbmcgPSBfaXNTdHJpbmcoc3RhcnQpLFxuICAgICAgICBtYXN0ZXIgPSB7fSxcbiAgICAgICAgcCxcbiAgICAgICAgaSxcbiAgICAgICAgaW50ZXJwb2xhdG9ycyxcbiAgICAgICAgbCxcbiAgICAgICAgaWw7XG5cbiAgICBwcm9ncmVzcyA9PT0gdHJ1ZSAmJiAobXV0YXRlID0gMSkgJiYgKHByb2dyZXNzID0gbnVsbCk7XG5cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHN0YXJ0ID0ge1xuICAgICAgICBwOiBzdGFydFxuICAgICAgfTtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgcDogZW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2lzQXJyYXkoc3RhcnQpICYmICFfaXNBcnJheShlbmQpKSB7XG4gICAgICBpbnRlcnBvbGF0b3JzID0gW107XG4gICAgICBsID0gc3RhcnQubGVuZ3RoO1xuICAgICAgaWwgPSBsIC0gMjtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnRlcnBvbGF0b3JzLnB1c2goaW50ZXJwb2xhdGUoc3RhcnRbaSAtIDFdLCBzdGFydFtpXSkpOyAvL2J1aWxkIHRoZSBpbnRlcnBvbGF0b3JzIHVwIGZyb250IGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG1hbnkgdGltZXMsIGl0IGNhbiBqdXN0IHJldXNlIHRoZW0uXG4gICAgICB9XG5cbiAgICAgIGwtLTtcblxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xuICAgICAgICBwICo9IGw7XG4gICAgICAgIHZhciBpID0gTWF0aC5taW4oaWwsIH5+cCk7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0b3JzW2ldKHAgLSBpKTtcbiAgICAgIH07XG5cbiAgICAgIHByb2dyZXNzID0gZW5kO1xuICAgIH0gZWxzZSBpZiAoIW11dGF0ZSkge1xuICAgICAgc3RhcnQgPSBfbWVyZ2UoX2lzQXJyYXkoc3RhcnQpID8gW10gOiB7fSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghaW50ZXJwb2xhdG9ycykge1xuICAgICAgZm9yIChwIGluIGVuZCkge1xuICAgICAgICBfYWRkUHJvcFR3ZWVuLmNhbGwobWFzdGVyLCBzdGFydCwgcCwgXCJnZXRcIiwgZW5kW3BdKTtcbiAgICAgIH1cblxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xuICAgICAgICByZXR1cm4gX3JlbmRlclByb3BUd2VlbnMocCwgbWFzdGVyKSB8fCAoaXNTdHJpbmcgPyBzdGFydC5wIDogc3RhcnQpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHByb2dyZXNzLCBmdW5jKTtcbn0sXG4gICAgX2dldExhYmVsSW5EaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aW1lbGluZSwgZnJvbVRpbWUsIGJhY2t3YXJkKSB7XG4gIC8vdXNlZCBmb3IgbmV4dExhYmVsKCkgYW5kIHByZXZpb3VzTGFiZWwoKVxuICB2YXIgbGFiZWxzID0gdGltZWxpbmUubGFiZWxzLFxuICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgIHAsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGxhYmVsO1xuXG4gIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICBkaXN0YW5jZSA9IGxhYmVsc1twXSAtIGZyb21UaW1lO1xuXG4gICAgaWYgKGRpc3RhbmNlIDwgMCA9PT0gISFiYWNrd2FyZCAmJiBkaXN0YW5jZSAmJiBtaW4gPiAoZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSkpKSB7XG4gICAgICBsYWJlbCA9IHA7XG4gICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWw7XG59LFxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhhbmltYXRpb24sIHR5cGUsIGV4ZWN1dGVMYXp5Rmlyc3QpIHtcbiAgdmFyIHYgPSBhbmltYXRpb24udmFycyxcbiAgICAgIGNhbGxiYWNrID0gdlt0eXBlXSxcbiAgICAgIHByZXZDb250ZXh0ID0gX2NvbnRleHQsXG4gICAgICBjb250ZXh0ID0gYW5pbWF0aW9uLl9jdHgsXG4gICAgICBwYXJhbXMsXG4gICAgICBzY29wZSxcbiAgICAgIHJlc3VsdDtcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcGFyYW1zID0gdlt0eXBlICsgXCJQYXJhbXNcIl07XG4gIHNjb3BlID0gdi5jYWxsYmFja1Njb3BlIHx8IGFuaW1hdGlvbjtcbiAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cbiAgY29udGV4dCAmJiAoX2NvbnRleHQgPSBjb250ZXh0KTtcbiAgcmVzdWx0ID0gcGFyYW1zID8gY2FsbGJhY2suYXBwbHkoc2NvcGUsIHBhcmFtcykgOiBjYWxsYmFjay5jYWxsKHNjb3BlKTtcbiAgX2NvbnRleHQgPSBwcmV2Q29udGV4dDtcbiAgcmV0dXJuIHJlc3VsdDtcbn0sXG4gICAgX2ludGVycnVwdCA9IGZ1bmN0aW9uIF9pbnRlcnJ1cHQoYW5pbWF0aW9uKSB7XG4gIF9yZW1vdmVGcm9tUGFyZW50KGFuaW1hdGlvbik7XG5cbiAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgJiYgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIua2lsbCghIV9yZXZlcnRpbmcpO1xuICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3F1aWNrVHdlZW4sXG4gICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUgPSBbXSxcbiAgICBfY3JlYXRlUGx1Z2luID0gZnVuY3Rpb24gX2NyZWF0ZVBsdWdpbihjb25maWcpIHtcbiAgaWYgKCFjb25maWcpIHJldHVybjtcbiAgY29uZmlnID0gIWNvbmZpZy5uYW1lICYmIGNvbmZpZ1tcImRlZmF1bHRcIl0gfHwgY29uZmlnOyAvLyBVTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cbiAgaWYgKF93aW5kb3dFeGlzdHMoKSB8fCBjb25maWcuaGVhZGxlc3MpIHtcbiAgICAvLyBlZGdlIGNhc2U6IHNvbWUgYnVpbGQgdG9vbHMgbWF5IHBhc3MgaW4gYSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuICAgIHZhciBuYW1lID0gY29uZmlnLm5hbWUsXG4gICAgICAgIGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG4gICAgICAgIFBsdWdpbiA9IG5hbWUgJiYgIWlzRnVuYyAmJiBjb25maWcuaW5pdCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3Byb3BzID0gW107XG4gICAgfSA6IGNvbmZpZyxcbiAgICAgICAgLy9pbiBjYXNlIHNvbWVvbmUgcGFzc2VzIGluIGFuIG9iamVjdCB0aGF0J3Mgbm90IGEgcGx1Z2luLCBsaWtlIEN1c3RvbUVhc2VcbiAgICBpbnN0YW5jZURlZmF1bHRzID0ge1xuICAgICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICAgIHJlbmRlcjogX3JlbmRlclByb3BUd2VlbnMsXG4gICAgICBhZGQ6IF9hZGRQcm9wVHdlZW4sXG4gICAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICAgIG1vZGlmaWVyOiBfYWRkUGx1Z2luTW9kaWZpZXIsXG4gICAgICByYXdWYXJzOiAwXG4gICAgfSxcbiAgICAgICAgc3RhdGljcyA9IHtcbiAgICAgIHRhcmdldFRlc3Q6IDAsXG4gICAgICBnZXQ6IDAsXG4gICAgICBnZXRTZXR0ZXI6IF9nZXRTZXR0ZXIsXG4gICAgICBhbGlhc2VzOiB7fSxcbiAgICAgIHJlZ2lzdGVyOiAwXG4gICAgfTtcblxuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICAgIGlmIChfcGx1Z2luc1tuYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9zZXREZWZhdWx0cyhQbHVnaW4sIF9zZXREZWZhdWx0cyhfY29weUV4Y2x1ZGluZyhjb25maWcsIGluc3RhbmNlRGVmYXVsdHMpLCBzdGF0aWNzKSk7IC8vc3RhdGljIG1ldGhvZHNcblxuXG4gICAgICBfbWVyZ2UoUGx1Z2luLnByb3RvdHlwZSwgX21lcmdlKGluc3RhbmNlRGVmYXVsdHMsIF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgc3RhdGljcykpKTsgLy9pbnN0YW5jZSBtZXRob2RzXG5cblxuICAgICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcblxuICAgICAgaWYgKGNvbmZpZy50YXJnZXRUZXN0KSB7XG4gICAgICAgIF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XG5cbiAgICAgICAgX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICAgICAgfVxuXG4gICAgICBuYW1lID0gKG5hbWUgPT09IFwiY3NzXCIgPyBcIkNTU1wiIDogbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKSArIFwiUGx1Z2luXCI7IC8vZm9yIHRoZSBnbG9iYWwgbmFtZS4gXCJtb3Rpb25QYXRoXCIgc2hvdWxkIGJlY29tZSBNb3Rpb25QYXRoUGx1Z2luXG4gICAgfVxuXG4gICAgX2FkZEdsb2JhbChuYW1lLCBQbHVnaW4pO1xuXG4gICAgY29uZmlnLnJlZ2lzdGVyICYmIGNvbmZpZy5yZWdpc3Rlcihnc2FwLCBQbHVnaW4sIFByb3BUd2Vlbik7XG4gIH0gZWxzZSB7XG4gICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUucHVzaChjb25maWcpO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENPTE9SU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXzI1NSA9IDI1NSxcbiAgICBfY29sb3JMb29rdXAgPSB7XG4gIGFxdWE6IFswLCBfMjU1LCBfMjU1XSxcbiAgbGltZTogWzAsIF8yNTUsIDBdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgYmx1ZTogWzAsIDAsIF8yNTVdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgd2hpdGU6IFtfMjU1LCBfMjU1LCBfMjU1XSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxuICBvcmFuZ2U6IFtfMjU1LCAxNjUsIDBdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICByZWQ6IFtfMjU1LCAwLCAwXSxcbiAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcbiAgY3lhbjogWzAsIF8yNTUsIF8yNTVdLFxuICB0cmFuc3BhcmVudDogW18yNTUsIF8yNTUsIF8yNTUsIDBdXG59LFxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBpZGVhIHRvIHJlcGxhY2UgdGhlIGhhcmQtY29kZWQgY29sb3IgbmFtZSB2YWx1ZXMgLSBwdXQgdGhpcyBpbiB0aGUgdGlja2VyLndha2UoKSB3aGVyZSB3ZSBzZXQgdGhlIF9kb2M6XG4vLyBsZXQgY3R4ID0gX2RvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcbi8vIF9mb3JFYWNoTmFtZShcImFxdWEsbGltZSxzaWx2ZXIsYmxhY2ssbWFyb29uLHRlYWwsYmx1ZSxuYXZ5LHdoaXRlLG9saXZlLHllbGxvdyxvcmFuZ2UsZ3JheSxwdXJwbGUsZ3JlZW4scmVkLHBpbmssY3lhblwiLCBjb2xvciA9PiB7Y3R4LmZpbGxTdHlsZSA9IGNvbG9yOyBfY29sb3JMb29rdXBbY29sb3JdID0gc3BsaXRDb2xvcihjdHguZmlsbFN0eWxlKX0pO1xuX2h1ZSA9IGZ1bmN0aW9uIF9odWUoaCwgbTEsIG0yKSB7XG4gIGggKz0gaCA8IDAgPyAxIDogaCA+IDEgPyAtMSA6IDA7XG4gIHJldHVybiAoaCAqIDYgPCAxID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IGggPCAuNSA/IG0yIDogaCAqIDMgPCAyID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiBfMjU1ICsgLjUgfCAwO1xufSxcbiAgICBzcGxpdENvbG9yID0gZnVuY3Rpb24gc3BsaXRDb2xvcih2LCB0b0hTTCwgZm9yY2VBbHBoYSkge1xuICB2YXIgYSA9ICF2ID8gX2NvbG9yTG9va3VwLmJsYWNrIDogX2lzTnVtYmVyKHYpID8gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXG4gICAgICByLFxuICAgICAgZyxcbiAgICAgIGIsXG4gICAgICBoLFxuICAgICAgcyxcbiAgICAgIGwsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBkLFxuICAgICAgd2FzSFNMO1xuXG4gIGlmICghYSkge1xuICAgIGlmICh2LnN1YnN0cigtMSkgPT09IFwiLFwiKSB7XG4gICAgICAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1hIGlzIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY2hvcCBpdCBvZmYgKHR5cGljYWxseSBmcm9tIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIGxpa2UgYSB0ZXh0U2hhZG93OlwiMnB4IDJweCAycHggYmx1ZSwgNXB4IDVweCA1cHggcmdiKDI1NSwwLDApXCIgLSBpbiB0aGlzIGV4YW1wbGUgXCJibHVlLFwiIGhhcyBhIHRyYWlsaW5nIGNvbW1hLiBXZSBjb3VsZCBzdHJpcCBpdCBvdXQgaW5zaWRlIHBhcnNlQ29tcGxleCgpIGJ1dCB3ZSdkIG5lZWQgdG8gZG8gaXQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBwbHVzIGl0IHdvdWxkbid0IHByb3ZpZGUgcHJvdGVjdGlvbiBmcm9tIG90aGVyIHBvdGVudGlhbCBzY2VuYXJpb3MgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBzaW1pbGFyIHZhbHVlLlxuICAgICAgdiA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKF9jb2xvckxvb2t1cFt2XSkge1xuICAgICAgYSA9IF9jb2xvckxvb2t1cFt2XTtcbiAgICB9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgaWYgKHYubGVuZ3RoIDwgNikge1xuICAgICAgICAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwIG9yICM5RjBGIChjb3VsZCBoYXZlIGFscGhhKVxuICAgICAgICByID0gdi5jaGFyQXQoMSk7XG4gICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcbiAgICAgICAgYiA9IHYuY2hhckF0KDMpO1xuICAgICAgICB2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGIgKyAodi5sZW5ndGggPT09IDUgPyB2LmNoYXJBdCg0KSArIHYuY2hhckF0KDQpIDogXCJcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAvLyBoZXggd2l0aCBhbHBoYSwgbGlrZSAjZmQ1ZTUzZmZcbiAgICAgICAgYSA9IHBhcnNlSW50KHYuc3Vic3RyKDEsIDYpLCAxNik7XG4gICAgICAgIHJldHVybiBbYSA+PiAxNiwgYSA+PiA4ICYgXzI1NSwgYSAmIF8yNTUsIHBhcnNlSW50KHYuc3Vic3RyKDcpLCAxNikgLyAyNTVdO1xuICAgICAgfVxuXG4gICAgICB2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcbiAgICAgIGEgPSBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdO1xuICAgIH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcbiAgICAgIGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApO1xuXG4gICAgICBpZiAoIXRvSFNMKSB7XG4gICAgICAgIGggPSArYVswXSAlIDM2MCAvIDM2MDtcbiAgICAgICAgcyA9ICthWzFdIC8gMTAwO1xuICAgICAgICBsID0gK2FbMl0gLyAxMDA7XG4gICAgICAgIGcgPSBsIDw9IC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICByID0gbCAqIDIgLSBnO1xuICAgICAgICBhLmxlbmd0aCA+IDMgJiYgKGFbM10gKj0gMSk7IC8vY2FzdCBhcyBudW1iZXJcblxuICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuICAgICAgICBhWzFdID0gX2h1ZShoLCByLCBnKTtcbiAgICAgICAgYVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcbiAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcbiAgICAgICAgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG4gICAgICAgIGEgPSB2Lm1hdGNoKF9udW1FeHApO1xuICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIGEgPSBhLm1hcChOdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRvSFNMICYmICF3YXNIU0wpIHtcbiAgICByID0gYVswXSAvIF8yNTU7XG4gICAgZyA9IGFbMV0gLyBfMjU1O1xuICAgIGIgPSBhWzJdIC8gXzI1NTtcbiAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICBoID0gbWF4ID09PSByID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT09IGcgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH1cblxuICAgIGFbMF0gPSB+fihoICsgLjUpO1xuICAgIGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuICAgIGFbMl0gPSB+fihsICogMTAwICsgLjUpO1xuICB9XG5cbiAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgcmV0dXJuIGE7XG59LFxuICAgIF9jb2xvck9yZGVyRGF0YSA9IGZ1bmN0aW9uIF9jb2xvck9yZGVyRGF0YSh2KSB7XG4gIC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxuICB2YXIgdmFsdWVzID0gW10sXG4gICAgICBjID0gW10sXG4gICAgICBpID0gLTE7XG4gIHYuc3BsaXQoX2NvbG9yRXhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGEgPSB2Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcbiAgICBjLnB1c2goaSArPSBhLmxlbmd0aCArIDEpO1xuICB9KTtcbiAgdmFsdWVzLmMgPSBjO1xuICByZXR1cm4gdmFsdWVzO1xufSxcbiAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICBjb2xvcnMgPSAocyArIHJlc3VsdCkubWF0Y2goX2NvbG9yRXhwKSxcbiAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcbiAgICAgIGkgPSAwLFxuICAgICAgYyxcbiAgICAgIHNoZWxsLFxuICAgICAgZCxcbiAgICAgIGw7XG5cbiAgaWYgKCFjb2xvcnMpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIChjb2xvciA9IHNwbGl0Q29sb3IoY29sb3IsIHRvSFNMLCAxKSkgJiYgdHlwZSArICh0b0hTTCA/IGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcbiAgfSk7XG5cbiAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XG4gICAgZCA9IF9jb2xvck9yZGVyRGF0YShzKTtcbiAgICBjID0gb3JkZXJNYXRjaERhdGEuYztcblxuICAgIGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuICAgICAgc2hlbGwgPSBzLnJlcGxhY2UoX2NvbG9yRXhwLCBcIjFcIikuc3BsaXQoX251bVdpdGhVbml0RXhwKTtcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNoZWxsKSB7XG4gICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XG4gICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcbn0sXG4gICAgX2NvbG9yRXhwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszLDR9KXsxLDJ9XFxcXGJcIixcbiAgICAgIC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy4sXG4gIHA7XG5cbiAgZm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuICAgIHMgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocyArIFwiKVwiLCBcImdpXCIpO1xufSgpLFxuICAgIF9oc2xFeHAgPSAvaHNsW2FdP1xcKC8sXG4gICAgX2NvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24gX2NvbG9yU3RyaW5nRmlsdGVyKGEpIHtcbiAgdmFyIGNvbWJpbmVkID0gYS5qb2luKFwiIFwiKSxcbiAgICAgIHRvSFNMO1xuICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICBpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG4gICAgdG9IU0wgPSBfaHNsRXhwLnRlc3QoY29tYmluZWQpO1xuICAgIGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcbiAgICBhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCwgX2NvbG9yT3JkZXJEYXRhKGFbMV0pKTsgLy8gbWFrZSBzdXJlIHRoZSBvcmRlciBvZiBudW1iZXJzL2NvbG9ycyBtYXRjaCB3aXRoIHRoZSBFTkQgdmFsdWUuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSUNLRVJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl90aWNrZXJBY3RpdmUsXG4gICAgX3RpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgICBfbGFnVGhyZXNob2xkID0gNTAwLFxuICAgICAgX2FkanVzdGVkTGFnID0gMzMsXG4gICAgICBfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcbiAgICAgIF9sYXN0VXBkYXRlID0gX3N0YXJ0VGltZSxcbiAgICAgIF9nYXAgPSAxMDAwIC8gMjQwLFxuICAgICAgX25leHRUaW1lID0gX2dhcCxcbiAgICAgIF9saXN0ZW5lcnMgPSBbXSxcbiAgICAgIF9pZCxcbiAgICAgIF9yZXEsXG4gICAgICBfcmFmLFxuICAgICAgX3NlbGYsXG4gICAgICBfZGVsdGEsXG4gICAgICBfaSxcbiAgICAgIF90aWNrID0gZnVuY3Rpb24gX3RpY2sodikge1xuICAgIHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuICAgICAgICBtYW51YWwgPSB2ID09PSB0cnVlLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgdGltZSxcbiAgICAgICAgZnJhbWU7XG5cbiAgICAoZWxhcHNlZCA+IF9sYWdUaHJlc2hvbGQgfHwgZWxhcHNlZCA8IDApICYmIChfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWcpO1xuICAgIF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG4gICAgdGltZSA9IF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZTtcbiAgICBvdmVybGFwID0gdGltZSAtIF9uZXh0VGltZTtcblxuICAgIGlmIChvdmVybGFwID4gMCB8fCBtYW51YWwpIHtcbiAgICAgIGZyYW1lID0gKytfc2VsZi5mcmFtZTtcbiAgICAgIF9kZWx0YSA9IHRpbWUgLSBfc2VsZi50aW1lICogMTAwMDtcbiAgICAgIF9zZWxmLnRpbWUgPSB0aW1lID0gdGltZSAvIDEwMDA7XG4gICAgICBfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyA0IDogX2dhcCAtIG92ZXJsYXApO1xuICAgICAgZGlzcGF0Y2ggPSAxO1xuICAgIH1cblxuICAgIG1hbnVhbCB8fCAoX2lkID0gX3JlcShfdGljaykpOyAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBmb3IgKF9pID0gMDsgX2kgPCBfbGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAvLyB1c2UgX2kgYW5kIGNoZWNrIF9saXN0ZW5lcnMubGVuZ3RoIGluc3RlYWQgb2YgYSB2YXJpYWJsZSBiZWNhdXNlIGEgbGlzdGVuZXIgY291bGQgZ2V0IHJlbW92ZWQgZHVyaW5nIHRoZSBsb29wLCBhbmQgaWYgdGhhdCBoYXBwZW5zIHRvIGFuIGVsZW1lbnQgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGluZGV4LCBpdCdkIHRocm93IHRoaW5ncyBvZmYgaW4gdGhlIGxvb3AuXG4gICAgICAgIF9saXN0ZW5lcnNbX2ldKHRpbWUsIF9kZWx0YSwgZnJhbWUsIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfc2VsZiA9IHtcbiAgICB0aW1lOiAwLFxuICAgIGZyYW1lOiAwLFxuICAgIHRpY2s6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICBfdGljayh0cnVlKTtcbiAgICB9LFxuICAgIGRlbHRhUmF0aW86IGZ1bmN0aW9uIGRlbHRhUmF0aW8oZnBzKSB7XG4gICAgICByZXR1cm4gX2RlbHRhIC8gKDEwMDAgLyAoZnBzIHx8IDYwKSk7XG4gICAgfSxcbiAgICB3YWtlOiBmdW5jdGlvbiB3YWtlKCkge1xuICAgICAgaWYgKF9jb3JlUmVhZHkpIHtcbiAgICAgICAgaWYgKCFfY29yZUluaXR0ZWQgJiYgX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgICAgICAgX3dpbiA9IF9jb3JlSW5pdHRlZCA9IHdpbmRvdztcbiAgICAgICAgICBfZG9jID0gX3dpbi5kb2N1bWVudCB8fCB7fTtcbiAgICAgICAgICBfZ2xvYmFscy5nc2FwID0gZ3NhcDtcbiAgICAgICAgICAoX3dpbi5nc2FwVmVyc2lvbnMgfHwgKF93aW4uZ3NhcFZlcnNpb25zID0gW10pKS5wdXNoKGdzYXAudmVyc2lvbik7XG5cbiAgICAgICAgICBfaW5zdGFsbChfaW5zdGFsbFNjb3BlIHx8IF93aW4uR3JlZW5Tb2NrR2xvYmFscyB8fCAhX3dpbi5nc2FwICYmIF93aW4gfHwge30pO1xuXG4gICAgICAgICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUuZm9yRWFjaChfY3JlYXRlUGx1Z2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yYWYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgX2lkICYmIF9zZWxmLnNsZWVwKCk7XG5cbiAgICAgICAgX3JlcSA9IF9yYWYgfHwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCBfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGlja2VyQWN0aXZlID0gMTtcblxuICAgICAgICBfdGljaygyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgIChfcmFmID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhclRpbWVvdXQpKF9pZCk7XG4gICAgICBfdGlja2VyQWN0aXZlID0gMDtcbiAgICAgIF9yZXEgPSBfZW1wdHlGdW5jO1xuICAgIH0sXG4gICAgbGFnU21vb3RoaW5nOiBmdW5jdGlvbiBsYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuICAgICAgX2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCBJbmZpbml0eTsgLy8gemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXG4gICAgICBfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZyB8fCAzMywgX2xhZ1RocmVzaG9sZCk7XG4gICAgfSxcbiAgICBmcHM6IGZ1bmN0aW9uIGZwcyhfZnBzKSB7XG4gICAgICBfZ2FwID0gMTAwMCAvIChfZnBzIHx8IDI0MCk7XG4gICAgICBfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChjYWxsYmFjaywgb25jZSwgcHJpb3JpdGl6ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBvbmNlID8gZnVuY3Rpb24gKHQsIGQsIGYsIHYpIHtcbiAgICAgICAgY2FsbGJhY2sodCwgZCwgZiwgdik7XG5cbiAgICAgICAgX3NlbGYucmVtb3ZlKGZ1bmMpO1xuICAgICAgfSA6IGNhbGxiYWNrO1xuXG4gICAgICBfc2VsZi5yZW1vdmUoY2FsbGJhY2spO1xuXG4gICAgICBfbGlzdGVuZXJzW3ByaW9yaXRpemUgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiXShmdW5jKTtcblxuICAgICAgX3dha2UoKTtcblxuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaywgaSkge1xuICAgICAgfihpID0gX2xpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSkgJiYgX2xpc3RlbmVycy5zcGxpY2UoaSwgMSkgJiYgX2kgPj0gaSAmJiBfaS0tO1xuICAgIH0sXG4gICAgX2xpc3RlbmVyczogX2xpc3RlbmVyc1xuICB9O1xuICByZXR1cm4gX3NlbGY7XG59KCksXG4gICAgX3dha2UgPSBmdW5jdGlvbiBfd2FrZSgpIHtcbiAgcmV0dXJuICFfdGlja2VyQWN0aXZlICYmIF90aWNrZXIud2FrZSgpO1xufSxcbiAgICAvL2Fsc28gZW5zdXJlcyB0aGUgY29yZSBjbGFzc2VzIGFyZSBpbml0aWFsaXplZC5cblxuLypcbiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBFQVNJTkdcbiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKi9cbl9lYXNlTWFwID0ge30sXG4gICAgX2N1c3RvbUVhc2VFeHAgPSAvXltcXGQuXFwtTV1bXFxkLlxcLSxcXHNdLyxcbiAgICBfcXVvdGVzRXhwID0gL1tcIiddL2csXG4gICAgX3BhcnNlT2JqZWN0SW5TdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VPYmplY3RJblN0cmluZyh2YWx1ZSkge1xuICAvL3Rha2VzIGEgc3RyaW5nIGxpa2UgXCJ7d2lnZ2xlczoxMCwgdHlwZTphbnRpY2lwYXRlfSlcIiBhbmQgdHVybnMgaXQgaW50byBhIHJlYWwgb2JqZWN0LiBOb3RpY2UgaXQgZW5kcyBpbiBcIilcIiBhbmQgaW5jbHVkZXMgdGhlIHt9IHdyYXBwZXJzLiBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3IgcGFyc2luZyBlYXNlIGNvbmZpZ3MgYW5kIHByaW9yaXRpemVkIG9wdGltaXphdGlvbiByYXRoZXIgdGhhbiByZXVzYWJpbGl0eS5cbiAgdmFyIG9iaiA9IHt9LFxuICAgICAgc3BsaXQgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMykuc3BsaXQoXCI6XCIpLFxuICAgICAga2V5ID0gc3BsaXRbMF0sXG4gICAgICBpID0gMSxcbiAgICAgIGwgPSBzcGxpdC5sZW5ndGgsXG4gICAgICBpbmRleCxcbiAgICAgIHZhbCxcbiAgICAgIHBhcnNlZFZhbDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIHZhbCA9IHNwbGl0W2ldO1xuICAgIGluZGV4ID0gaSAhPT0gbCAtIDEgPyB2YWwubGFzdEluZGV4T2YoXCIsXCIpIDogdmFsLmxlbmd0aDtcbiAgICBwYXJzZWRWYWwgPSB2YWwuc3Vic3RyKDAsIGluZGV4KTtcbiAgICBvYmpba2V5XSA9IGlzTmFOKHBhcnNlZFZhbCkgPyBwYXJzZWRWYWwucmVwbGFjZShfcXVvdGVzRXhwLCBcIlwiKS50cmltKCkgOiArcGFyc2VkVmFsO1xuICAgIGtleSA9IHZhbC5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfdmFsdWVJblBhcmVudGhlc2VzID0gZnVuY3Rpb24gX3ZhbHVlSW5QYXJlbnRoZXNlcyh2YWx1ZSkge1xuICB2YXIgb3BlbiA9IHZhbHVlLmluZGV4T2YoXCIoXCIpICsgMSxcbiAgICAgIGNsb3NlID0gdmFsdWUuaW5kZXhPZihcIilcIiksXG4gICAgICBuZXN0ZWQgPSB2YWx1ZS5pbmRleE9mKFwiKFwiLCBvcGVuKTtcbiAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhvcGVuLCB+bmVzdGVkICYmIG5lc3RlZCA8IGNsb3NlID8gdmFsdWUuaW5kZXhPZihcIilcIiwgY2xvc2UgKyAxKSA6IGNsb3NlKTtcbn0sXG4gICAgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKG5hbWUpIHtcbiAgLy9uYW1lIGNhbiBiZSBhIHN0cmluZyBsaWtlIFwiZWxhc3RpYy5vdXQoMSwwLjUpXCIsIGFuZCBwYXNzIGluIF9lYXNlTWFwIGFzIG9iaiBhbmQgaXQnbGwgcGFyc2UgaXQgb3V0IGFuZCBjYWxsIHRoZSBhY3R1YWwgZnVuY3Rpb24gbGlrZSBfZWFzZU1hcC5FbGFzdGljLmVhc2VPdXQuY29uZmlnKDEsMC41KS4gSXQgd2lsbCBhbHNvIHBhcnNlIGN1c3RvbSBlYXNlIHN0cmluZ3MgYXMgbG9uZyBhcyBDdXN0b21FYXNlIGlzIGxvYWRlZCBhbmQgcmVnaXN0ZXJlZCAoaW50ZXJuYWxseSBhcyBfZWFzZU1hcC5fQ0UpLlxuICB2YXIgc3BsaXQgPSAobmFtZSArIFwiXCIpLnNwbGl0KFwiKFwiKSxcbiAgICAgIGVhc2UgPSBfZWFzZU1hcFtzcGxpdFswXV07XG4gIHJldHVybiBlYXNlICYmIHNwbGl0Lmxlbmd0aCA+IDEgJiYgZWFzZS5jb25maWcgPyBlYXNlLmNvbmZpZy5hcHBseShudWxsLCB+bmFtZS5pbmRleE9mKFwie1wiKSA/IFtfcGFyc2VPYmplY3RJblN0cmluZyhzcGxpdFsxXSldIDogX3ZhbHVlSW5QYXJlbnRoZXNlcyhuYW1lKS5zcGxpdChcIixcIikubWFwKF9udW1lcmljSWZQb3NzaWJsZSkpIDogX2Vhc2VNYXAuX0NFICYmIF9jdXN0b21FYXNlRXhwLnRlc3QobmFtZSkgPyBfZWFzZU1hcC5fQ0UoXCJcIiwgbmFtZSkgOiBlYXNlO1xufSxcbiAgICBfaW52ZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnZlcnRFYXNlKGVhc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlKDEgLSBwKTtcbiAgfTtcbn0sXG4gICAgLy8gYWxsb3cgeW95b0Vhc2UgdG8gYmUgc2V0IGluIGNoaWxkcmVuIGFuZCBoYXZlIHRob3NlIGFmZmVjdGVkIHdoZW4gdGhlIHBhcmVudC9hbmNlc3RvciB0aW1lbGluZSB5b3lvcy5cbl9wcm9wYWdhdGVZb3lvRWFzZSA9IGZ1bmN0aW9uIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKSB7XG4gIHZhciBjaGlsZCA9IHRpbWVsaW5lLl9maXJzdCxcbiAgICAgIGVhc2U7XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcbiAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZCwgaXNZb3lvKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnZhcnMueW95b0Vhc2UgJiYgKCFjaGlsZC5feW95byB8fCAhY2hpbGQuX3JlcGVhdCkgJiYgY2hpbGQuX3lveW8gIT09IGlzWW95bykge1xuICAgICAgaWYgKGNoaWxkLnRpbWVsaW5lKSB7XG4gICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZC50aW1lbGluZSwgaXNZb3lvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhc2UgPSBjaGlsZC5fZWFzZTtcbiAgICAgICAgY2hpbGQuX2Vhc2UgPSBjaGlsZC5feUVhc2U7XG4gICAgICAgIGNoaWxkLl95RWFzZSA9IGVhc2U7XG4gICAgICAgIGNoaWxkLl95b3lvID0gaXNZb3lvO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gIH1cbn0sXG4gICAgX3BhcnNlRWFzZSA9IGZ1bmN0aW9uIF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgcmV0dXJuICFlYXNlID8gZGVmYXVsdEVhc2UgOiAoX2lzRnVuY3Rpb24oZWFzZSkgPyBlYXNlIDogX2Vhc2VNYXBbZWFzZV0gfHwgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKGVhc2UpKSB8fCBkZWZhdWx0RWFzZTtcbn0sXG4gICAgX2luc2VydEVhc2UgPSBmdW5jdGlvbiBfaW5zZXJ0RWFzZShuYW1lcywgZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXQpIHtcbiAgaWYgKGVhc2VPdXQgPT09IHZvaWQgMCkge1xuICAgIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICAgIHJldHVybiAxIC0gZWFzZUluKDEgLSBwKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGVhc2VJbk91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZUluT3V0ID0gZnVuY3Rpb24gZWFzZUluT3V0KHApIHtcbiAgICAgIHJldHVybiBwIDwgLjUgPyBlYXNlSW4ocCAqIDIpIC8gMiA6IDEgLSBlYXNlSW4oKDEgLSBwKSAqIDIpIC8gMjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGVhc2UgPSB7XG4gICAgZWFzZUluOiBlYXNlSW4sXG4gICAgZWFzZU91dDogZWFzZU91dCxcbiAgICBlYXNlSW5PdXQ6IGVhc2VJbk91dFxuICB9LFxuICAgICAgbG93ZXJjYXNlTmFtZTtcblxuICBfZm9yRWFjaE5hbWUobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfZ2xvYmFsc1tuYW1lXSA9IGVhc2U7XG4gICAgX2Vhc2VNYXBbbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKV0gPSBlYXNlT3V0O1xuXG4gICAgZm9yICh2YXIgcCBpbiBlYXNlKSB7XG4gICAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lICsgKHAgPT09IFwiZWFzZUluXCIgPyBcIi5pblwiIDogcCA9PT0gXCJlYXNlT3V0XCIgPyBcIi5vdXRcIiA6IFwiLmluT3V0XCIpXSA9IF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHBdID0gZWFzZVtwXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlYXNlO1xufSxcbiAgICBfZWFzZUluT3V0RnJvbU91dCA9IGZ1bmN0aW9uIF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/ICgxIC0gZWFzZU91dCgxIC0gcCAqIDIpKSAvIDIgOiAuNSArIGVhc2VPdXQoKHAgLSAuNSkgKiAyKSAvIDI7XG4gIH07XG59LFxuICAgIF9jb25maWdFbGFzdGljID0gZnVuY3Rpb24gX2NvbmZpZ0VsYXN0aWModHlwZSwgYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgdmFyIHAxID0gYW1wbGl0dWRlID49IDEgPyBhbXBsaXR1ZGUgOiAxLFxuICAgICAgLy9ub3RlOiBpZiBhbXBsaXR1ZGUgaXMgPCAxLCB3ZSBzaW1wbHkgYWRqdXN0IHRoZSBwZXJpb2QgZm9yIGEgbW9yZSBuYXR1cmFsIGZlZWwuIE90aGVyd2lzZSB0aGUgbWF0aCBkb2Vzbid0IHdvcmsgcmlnaHQgYW5kIHRoZSBjdXJ2ZSBzdGFydHMgYXQgMS5cbiAgcDIgPSAocGVyaW9kIHx8ICh0eXBlID8gLjMgOiAuNDUpKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSksXG4gICAgICBwMyA9IHAyIC8gXzJQSSAqIChNYXRoLmFzaW4oMSAvIHAxKSB8fCAwKSxcbiAgICAgIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICByZXR1cm4gcCA9PT0gMSA/IDEgOiBwMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogX3NpbigocCAtIHAzKSAqIHAyKSArIDE7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBwMiA9IF8yUEkgLyBwMjsgLy9wcmVjYWxjdWxhdGUgdG8gb3B0aW1pemVcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgIHJldHVybiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCk7XG4gIH07XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9jb25maWdCYWNrID0gZnVuY3Rpb24gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KSB7XG4gIGlmIChvdmVyc2hvb3QgPT09IHZvaWQgMCkge1xuICAgIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG4gIH1cblxuICB2YXIgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID8gLS1wICogcCAqICgob3ZlcnNob290ICsgMSkgKiBwICsgb3ZlcnNob290KSArIDEgOiAwO1xuICB9LFxuICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9IDogX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCk7XG5cbiAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAob3ZlcnNob290KSB7XG4gICAgcmV0dXJuIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCk7XG4gIH07XG5cbiAgcmV0dXJuIGVhc2U7XG59OyAvLyBhIGNoZWFwZXIgKGtiIGFuZCBjcHUpIGJ1dCBtb3JlIG1pbGQgd2F5IHRvIGdldCBhIHBhcmFtZXRlcml6ZWQgd2VpZ2h0ZWQgZWFzZSBieSBmZWVkaW5nIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlID0gcmF0aW8gPT4ge1xuLy8gXHRsZXQgeSA9IDAuNSArIHJhdGlvIC8gMjtcbi8vIFx0cmV0dXJuIHAgPT4gKDIgKiAoMSAtIHApICogcCAqIHkgKyBwICogcCk7XG4vLyB9LFxuLy8gYSBzdHJvbmdlciAoYnV0IG1vcmUgZXhwZW5zaXZlIGtiL2NwdSkgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIHRoYXQgbGV0cyB5b3UgZmVlZCBpbiBhIHZhbHVlIGJldHdlZW4gLTEgKGVhc2VJbikgYW5kIDEgKGVhc2VPdXQpIHdoZXJlIDAgaXMgbGluZWFyLlxuLy8gX3dlaWdodGVkRWFzZVN0cm9uZyA9IHJhdGlvID0+IHtcbi8vIFx0cmF0aW8gPSAuNSArIHJhdGlvIC8gMjtcbi8vIFx0bGV0IG8gPSAxIC8gMyAqIChyYXRpbyA8IC41ID8gcmF0aW8gOiAxIC0gcmF0aW8pLFxuLy8gXHRcdGIgPSByYXRpbyAtIG8sXG4vLyBcdFx0YyA9IHJhdGlvICsgbztcbi8vIFx0cmV0dXJuIHAgPT4gcCA9PT0gMSA/IHAgOiAzICogYiAqICgxIC0gcCkgKiAoMSAtIHApICogcCArIDMgKiBjICogKDEgLSBwKSAqIHAgKiBwICsgcCAqIHAgKiBwO1xuLy8gfTtcblxuXG5fZm9yRWFjaE5hbWUoXCJMaW5lYXIsUXVhZCxDdWJpYyxRdWFydCxRdWludCxTdHJvbmdcIiwgZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgdmFyIHBvd2VyID0gaSA8IDUgPyBpICsgMSA6IGk7XG5cbiAgX2luc2VydEVhc2UobmFtZSArIFwiLFBvd2VyXCIgKyAocG93ZXIgLSAxKSwgaSA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHAsIHBvd2VyKTtcbiAgfSA6IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHA7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gcCwgcG93ZXIpO1xuICB9LCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwIDwgLjUgPyBNYXRoLnBvdyhwICogMiwgcG93ZXIpIC8gMiA6IDEgLSBNYXRoLnBvdygoMSAtIHApICogMiwgcG93ZXIpIC8gMjtcbiAgfSk7XG59KTtcblxuX2Vhc2VNYXAuTGluZWFyLmVhc2VOb25lID0gX2Vhc2VNYXAubm9uZSA9IF9lYXNlTWFwLkxpbmVhci5lYXNlSW47XG5cbl9pbnNlcnRFYXNlKFwiRWxhc3RpY1wiLCBfY29uZmlnRWxhc3RpYyhcImluXCIpLCBfY29uZmlnRWxhc3RpYyhcIm91dFwiKSwgX2NvbmZpZ0VsYXN0aWMoKSk7XG5cbihmdW5jdGlvbiAobiwgYykge1xuICB2YXIgbjEgPSAxIC8gYyxcbiAgICAgIG4yID0gMiAqIG4xLFxuICAgICAgbjMgPSAyLjUgKiBuMSxcbiAgICAgIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICByZXR1cm4gcCA8IG4xID8gbiAqIHAgKiBwIDogcCA8IG4yID8gbiAqIE1hdGgucG93KHAgLSAxLjUgLyBjLCAyKSArIC43NSA6IHAgPCBuMyA/IG4gKiAocCAtPSAyLjI1IC8gYykgKiBwICsgLjkzNzUgOiBuICogTWF0aC5wb3cocCAtIDIuNjI1IC8gYywgMikgKyAuOTg0Mzc1O1xuICB9O1xuXG4gIF9pbnNlcnRFYXNlKFwiQm91bmNlXCIsIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSwgZWFzZU91dCk7XG59KSg3LjU2MjUsIDIuNzUpO1xuXG5faW5zZXJ0RWFzZShcIkV4cG9cIiwgZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAgPyBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIDogMDtcbn0pO1xuXG5faW5zZXJ0RWFzZShcIkNpcmNcIiwgZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIC0oX3NxcnQoMSAtIHAgKiBwKSAtIDEpO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiU2luZVwiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA9PT0gMSA/IDEgOiAtX2NvcyhwICogX0hBTEZfUEkpICsgMTtcbn0pO1xuXG5faW5zZXJ0RWFzZShcIkJhY2tcIiwgX2NvbmZpZ0JhY2soXCJpblwiKSwgX2NvbmZpZ0JhY2soXCJvdXRcIiksIF9jb25maWdCYWNrKCkpO1xuXG5fZWFzZU1hcC5TdGVwcGVkRWFzZSA9IF9lYXNlTWFwLnN0ZXBzID0gX2dsb2JhbHMuU3RlcHBlZEVhc2UgPSB7XG4gIGNvbmZpZzogZnVuY3Rpb24gY29uZmlnKHN0ZXBzLCBpbW1lZGlhdGVTdGFydCkge1xuICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGVwcyA9IDE7XG4gICAgfVxuXG4gICAgdmFyIHAxID0gMSAvIHN0ZXBzLFxuICAgICAgICBwMiA9IHN0ZXBzICsgKGltbWVkaWF0ZVN0YXJ0ID8gMCA6IDEpLFxuICAgICAgICBwMyA9IGltbWVkaWF0ZVN0YXJ0ID8gMSA6IDAsXG4gICAgICAgIG1heCA9IDEgLSBfdGlueU51bTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAoKHAyICogX2NsYW1wKDAsIG1heCwgcCkgfCAwKSArIHAzKSAqIHAxO1xuICAgIH07XG4gIH1cbn07XG5fZGVmYXVsdHMuZWFzZSA9IF9lYXNlTWFwW1wicXVhZC5vdXRcIl07XG5cbl9mb3JFYWNoTmFtZShcIm9uQ29tcGxldGUsb25VcGRhdGUsb25TdGFydCxvblJlcGVhdCxvblJldmVyc2VDb21wbGV0ZSxvbkludGVycnVwdFwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2NhbGxiYWNrTmFtZXMgKz0gbmFtZSArIFwiLFwiICsgbmFtZSArIFwiUGFyYW1zLFwiO1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENBQ0hFXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBHU0NhY2hlID0gZnVuY3Rpb24gR1NDYWNoZSh0YXJnZXQsIGhhcm5lc3MpIHtcbiAgdGhpcy5pZCA9IF9nc0lEKys7XG4gIHRhcmdldC5fZ3NhcCA9IHRoaXM7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLmhhcm5lc3MgPSBoYXJuZXNzO1xuICB0aGlzLmdldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldCA6IF9nZXRQcm9wZXJ0eTtcbiAgdGhpcy5zZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXRTZXR0ZXIgOiBfZ2V0U2V0dGVyO1xufTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQU5JTUFUSU9OXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmV4cG9ydCB2YXIgQW5pbWF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uKHZhcnMpIHtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIHRoaXMuX2RlbGF5ID0gK3ZhcnMuZGVsYXkgfHwgMDtcblxuICAgIGlmICh0aGlzLl9yZXBlYXQgPSB2YXJzLnJlcGVhdCA9PT0gSW5maW5pdHkgPyAtMiA6IHZhcnMucmVwZWF0IHx8IDApIHtcbiAgICAgIC8vIFRPRE86IHJlcGVhdDogSW5maW5pdHkgb24gYSB0aW1lbGluZSdzIGNoaWxkcmVuIG11c3QgZmxhZyB0aGF0IHRpbWVsaW5lIGludGVybmFsbHkgYW5kIGFmZmVjdCBpdHMgdG90YWxEdXJhdGlvbiwgb3RoZXJ3aXNlIGl0J2xsIHN0b3AgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbiB3aGVuIHJlYWNoaW5nIHRoZSBzdGFydC5cbiAgICAgIHRoaXMuX3JEZWxheSA9IHZhcnMucmVwZWF0RGVsYXkgfHwgMDtcbiAgICAgIHRoaXMuX3lveW8gPSAhIXZhcnMueW95byB8fCAhIXZhcnMueW95b0Vhc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fdHMgPSAxO1xuXG4gICAgX3NldER1cmF0aW9uKHRoaXMsICt2YXJzLmR1cmF0aW9uLCAxLCAxKTtcblxuICAgIHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcblxuICAgIGlmIChfY29udGV4dCkge1xuICAgICAgdGhpcy5fY3R4ID0gX2NvbnRleHQ7XG5cbiAgICAgIF9jb250ZXh0LmRhdGEucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICBfdGlja2VyQWN0aXZlIHx8IF90aWNrZXIud2FrZSgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0ICsgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICB0aGlzLl9kZWxheSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlbGF5O1xuICB9O1xuXG4gIF9wcm90by5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsRHVyYXRpb24odGhpcy5fcmVwZWF0ID4gMCA/IHZhbHVlICsgKHZhbHVlICsgdGhpcy5fckRlbGF5KSAqIHRoaXMuX3JlcGVhdCA6IHZhbHVlKSA6IHRoaXMudG90YWxEdXJhdGlvbigpICYmIHRoaXMuX2R1cjtcbiAgfTtcblxuICBfcHJvdG8udG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90RHVyO1xuICAgIH1cblxuICAgIHRoaXMuX2RpcnR5ID0gMDtcbiAgICByZXR1cm4gX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX3JlcGVhdCA8IDAgPyB2YWx1ZSA6ICh2YWx1ZSAtIHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JEZWxheSkgLyAodGhpcy5fcmVwZWF0ICsgMSkpO1xuICB9O1xuXG4gIF9wcm90by50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBfd2FrZSgpO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdFRpbWU7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX2RwO1xuXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5fdHMpIHtcbiAgICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIF90b3RhbFRpbWUpO1xuXG4gICAgICAhcGFyZW50Ll9kcCB8fCBwYXJlbnQucGFyZW50IHx8IF9wb3N0QWRkQ2hlY2tzKHBhcmVudCwgdGhpcyk7IC8vIGVkZ2UgY2FzZTogaWYgdGhpcyBpcyBhIGNoaWxkIG9mIGEgdGltZWxpbmUgdGhhdCBhbHJlYWR5IGNvbXBsZXRlZCwgZm9yIGV4YW1wbGUsIHdlIG11c3QgcmUtYWN0aXZhdGUgdGhlIHBhcmVudC5cbiAgICAgIC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9yIHRpbWVsaW5lcyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQsIHdlIHNob3VsZCByZXNldCB0aGVpciB0b3RhbFRpbWUoKSB3aGljaCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhleSdyZSBsaW5lZCB1cCBwcm9wZXJseSBhbmQgZW5hYmxlZC4gU2tpcCBmb3IgYW5pbWF0aW9ucyB0aGF0IGFyZSBvbiB0aGUgcm9vdCAod2FzdGVmdWwpLiBFeGFtcGxlOiBhIFRpbWVsaW5lTGl0ZS5leHBvcnRSb290KCkgaXMgcGVyZm9ybWVkIHdoZW4gdGhlcmUncyBhIHBhdXNlZCB0d2VlbiBvbiB0aGUgcm9vdCwgdGhlIGV4cG9ydCB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGF0IHR3ZWVuIGlzIHVucGF1c2VkLCBidXQgaW1hZ2luZSBhIGNoaWxkIGdldHMgcmVzdGFydGVkIGxhdGVyLCBhZnRlciBhbGwgW3VucGF1c2VkXSB0d2VlbnMgaGF2ZSBjb21wbGV0ZWQuIFRoZSBzdGFydCBvZiB0aGF0IGNoaWxkIHdvdWxkIGdldCBwdXNoZWQgb3V0LCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgbWF5IGhhdmUgY29tcGxldGVkLlxuXG4gICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5wYXJlbnQuX3RpbWUgIT09IHBhcmVudC5fc3RhcnQgKyAocGFyZW50Ll90cyA+PSAwID8gcGFyZW50Ll90VGltZSAvIHBhcmVudC5fdHMgOiAocGFyZW50LnRvdGFsRHVyYXRpb24oKSAtIHBhcmVudC5fdFRpbWUpIC8gLXBhcmVudC5fdHMpKSB7XG4gICAgICAgICAgcGFyZW50LnRvdGFsVGltZShwYXJlbnQuX3RUaW1lLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5wYXJlbnQgJiYgdGhpcy5fZHAuYXV0b1JlbW92ZUNoaWxkcmVuICYmICh0aGlzLl90cyA+IDAgJiYgX3RvdGFsVGltZSA8IHRoaXMuX3REdXIgfHwgdGhpcy5fdHMgPCAwICYmIF90b3RhbFRpbWUgPiAwIHx8ICF0aGlzLl90RHVyICYmICFfdG90YWxUaW1lKSkge1xuICAgICAgICAvL2lmIHRoZSBhbmltYXRpb24gZG9lc24ndCBoYXZlIGEgcGFyZW50LCBwdXQgaXQgYmFjayBpbnRvIGl0cyBsYXN0IHBhcmVudCAocmVjb3JkZWQgYXMgX2RwIGZvciBleGFjdGx5IGNhc2VzIGxpa2UgdGhpcykuIExpbWl0IHRvIHBhcmVudHMgd2l0aCBhdXRvUmVtb3ZlQ2hpbGRyZW4gKGxpa2UgZ2xvYmFsVGltZWxpbmUpIHNvIHRoYXQgaWYgdGhlIHVzZXIgbWFudWFsbHkgcmVtb3ZlcyBhbiBhbmltYXRpb24gZnJvbSBhIHRpbWVsaW5lIGFuZCB0aGVuIGFsdGVycyBpdHMgcGxheWhlYWQsIGl0IGRvZXNuJ3QgZ2V0IGFkZGVkIGJhY2sgaW4uXG4gICAgICAgIF9hZGRUb1RpbWVsaW5lKHRoaXMuX2RwLCB0aGlzLCB0aGlzLl9zdGFydCAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdFRpbWUgIT09IF90b3RhbFRpbWUgfHwgIXRoaXMuX2R1ciAmJiAhc3VwcHJlc3NFdmVudHMgfHwgdGhpcy5faW5pdHRlZCAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgPT09IF90aW55TnVtIHx8ICFfdG90YWxUaW1lICYmICF0aGlzLl9pbml0dGVkICYmICh0aGlzLmFkZCB8fCB0aGlzLl9wdExvb2t1cCkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBfcHRMb29rdXAgb24gYSBUd2VlbiBpbnN0YW5jZSB0byBlbnN1cmUgaXQgaGFzIGFjdHVhbGx5IGZpbmlzaGVkIGJlaW5nIGluc3RhbnRpYXRlZCwgb3RoZXJ3aXNlIGlmIHRoaXMucmV2ZXJzZSgpIGdldHMgY2FsbGVkIGluIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIGl0IGNvdWxkIHRyaWdnZXIgYSByZW5kZXIoKSBoZXJlIGV2ZW4gdGhvdWdoIHRoZSBfdGFyZ2V0cyB3ZXJlbid0IHBvcHVsYXRlZCwgdGh1cyB3aGVuIF9pbml0KCkgaXMgY2FsbGVkIHRoZXJlIHdvbid0IGJlIGFueSBQcm9wVHdlZW5zIChpdCdsbCBhY3QgbGlrZSB0aGUgdHdlZW4gaXMgbm9uLWZ1bmN0aW9uYWwpXG4gICAgICB0aGlzLl90cyB8fCAodGhpcy5fcFRpbWUgPSBfdG90YWxUaW1lKTsgLy8gb3RoZXJ3aXNlLCBpZiBhbiBhbmltYXRpb24gaXMgcGF1c2VkLCB0aGVuIHRoZSBwbGF5aGVhZCBpcyBtb3ZlZCBiYWNrIHRvIHplcm8sIHRoZW4gcmVzdW1lZCwgaXQnZCByZXZlcnQgYmFjayB0byB0aGUgb3JpZ2luYWwgdGltZSBhdCB0aGUgcGF1c2VcbiAgICAgIC8vaWYgKCF0aGlzLl9sb2NrKSB7IC8vIGF2b2lkIGVuZGxlc3MgcmVjdXJzaW9uIChub3Qgc3VyZSB3ZSBuZWVkIHRoaXMgeWV0IG9yIGlmIGl0J3Mgd29ydGggdGhlIHBlcmZvcm1hbmNlIGhpdClcbiAgICAgIC8vICAgdGhpcy5fbG9jayA9IDE7XG5cbiAgICAgIF9sYXp5U2FmZVJlbmRlcih0aGlzLCBfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cyk7IC8vICAgdGhpcy5fbG9jayA9IDA7XG4gICAgICAvL31cblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50aW1lID0gZnVuY3Rpb24gdGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKE1hdGgubWluKHRoaXMudG90YWxEdXJhdGlvbigpLCB2YWx1ZSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSkgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSB8fCAodmFsdWUgPyB0aGlzLl9kdXIgOiAwKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fdGltZTsgLy8gbm90ZTogaWYgdGhlIG1vZHVsdXMgcmVzdWx0cyBpbiAwLCB0aGUgcGxheWhlYWQgY291bGQgYmUgZXhhY3RseSBhdCB0aGUgZW5kIG9yIHRoZSBiZWdpbm5pbmcsIGFuZCB3ZSBhbHdheXMgZGVmZXIgdG8gdGhlIEVORCB3aXRoIGEgbm9uLXplcm8gdmFsdWUsIG90aGVyd2lzZSBpZiB5b3Ugc2V0IHRoZSB0aW1lKCkgdG8gdGhlIHZlcnkgZW5kIChkdXJhdGlvbigpKSwgaXQgd291bGQgcmVuZGVyIGF0IHRoZSBTVEFSVCFcbiAgfTtcblxuICBfcHJvdG8udG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uIHRvdGFsUHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RUaW1lIC8gdGhpcy5fdER1cikgOiB0aGlzLnJhd1RpbWUoKSA+IDAgPyAxIDogMDtcbiAgfTtcblxuICBfcHJvdG8ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSAqICh0aGlzLl95b3lvICYmICEodGhpcy5pdGVyYXRpb24oKSAmIDEpID8gMSAtIHZhbHVlIDogdmFsdWUpICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLmR1cmF0aW9uKCkgPyBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5fZHVyKSA6IHRoaXMucmF3VGltZSgpID4gMCA/IDEgOiAwO1xuICB9O1xuXG4gIF9wcm90by5pdGVyYXRpb24gPSBmdW5jdGlvbiBpdGVyYXRpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgdmFyIGN5Y2xlRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCkgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcbiAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIGFkZGl0aW9uOlxuICAvLyBpc1BsYXlpbmdCYWNrd2FyZHMoKSB7XG4gIC8vIFx0bGV0IGFuaW1hdGlvbiA9IHRoaXMsXG4gIC8vIFx0XHRvcmllbnRhdGlvbiA9IDE7IC8vIDEgPSBmb3J3YXJkLCAtMSA9IGJhY2t3YXJkXG4gIC8vIFx0d2hpbGUgKGFuaW1hdGlvbikge1xuICAvLyBcdFx0b3JpZW50YXRpb24gKj0gYW5pbWF0aW9uLnJldmVyc2VkKCkgfHwgKGFuaW1hdGlvbi5yZXBlYXQoKSAmJiAhKGFuaW1hdGlvbi5pdGVyYXRpb24oKSAmIDEpKSA/IC0xIDogMTtcbiAgLy8gXHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXJlbnQ7XG4gIC8vIFx0fVxuICAvLyBcdHJldHVybiBvcmllbnRhdGlvbiA8IDA7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90by50aW1lU2NhbGUgPSBmdW5jdGlvbiB0aW1lU2NhbGUodmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnRzID09PSAtX3RpbnlOdW0gPyAwIDogdGhpcy5fcnRzOyAvLyByZWNvcmRlZCB0aW1lU2NhbGUuIFNwZWNpYWwgY2FzZTogaWYgc29tZW9uZSBjYWxscyByZXZlcnNlKCkgb24gYW4gYW5pbWF0aW9uIHdpdGggdGltZVNjYWxlIG9mIDAsIHdlIGFzc2lnbiBpdCAtX3RpbnlOdW0gdG8gcmVtZW1iZXIgaXQncyByZXZlcnNlZC5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcnRzID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHRUaW1lID0gdGhpcy5wYXJlbnQgJiYgdGhpcy5fdHMgPyBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aGlzLnBhcmVudC5fdGltZSwgdGhpcykgOiB0aGlzLl90VGltZTsgLy8gbWFrZSBzdXJlIHRvIGRvIHRoZSBwYXJlbnRUb0NoaWxkVG90YWxUaW1lKCkgQkVGT1JFIHNldHRpbmcgdGhlIG5ldyBfdHMgYmVjYXVzZSB0aGUgb2xkIG9uZSBtdXN0IGJlIHVzZWQgaW4gdGhhdCBjYWxjdWxhdGlvbi5cbiAgICAvLyBmdXR1cmUgYWRkaXRpb24/IFVwIHNpZGU6IGZhc3QgYW5kIG1pbmltYWwgZmlsZSBzaXplLiBEb3duIHNpZGU6IG9ubHkgd29ya3Mgb24gdGhpcyBhbmltYXRpb247IGlmIGEgdGltZWxpbmUgaXMgcmV2ZXJzZWQsIGZvciBleGFtcGxlLCBpdHMgY2hpbGRyZW5zJyBvblJldmVyc2Ugd291bGRuJ3QgZ2V0IGNhbGxlZC5cbiAgICAvLygrdmFsdWUgPCAwICYmIHRoaXMuX3J0cyA+PSAwKSAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJldmVyc2VcIiwgdHJ1ZSk7XG4gICAgLy8gcHJpb3JpdGl6ZSByZW5kZXJpbmcgd2hlcmUgdGhlIHBhcmVudCdzIHBsYXloZWFkIGxpbmVzIHVwIGluc3RlYWQgb2YgdGhpcy5fdFRpbWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBhIHR3ZWVuIHRoYXQncyBhbmltYXRpbmcgYW5vdGhlciB0d2VlbidzIHRpbWVTY2FsZSBpbiB0aGUgc2FtZSByZW5kZXJpbmcgbG9vcCAoc2FtZSBwYXJlbnQpLCB0aHVzIGlmIHRoZSB0aW1lU2NhbGUgdHdlZW4gcmVuZGVycyBmaXJzdCwgaXQgd291bGQgYWx0ZXIgX3N0YXJ0IEJFRk9SRSBfdFRpbWUgd2FzIHNldCBvbiB0aGF0IHRpY2sgKGluIHRoZSByZW5kZXJpbmcgbG9vcCksIGVmZmVjdGl2ZWx5IGZyZWV6aW5nIGl0IHVudGlsIHRoZSB0aW1lU2NhbGUgdHdlZW4gZmluaXNoZXMuXG5cbiAgICB0aGlzLl9ydHMgPSArdmFsdWUgfHwgMDtcbiAgICB0aGlzLl90cyA9IHRoaXMuX3BzIHx8IHZhbHVlID09PSAtX3RpbnlOdW0gPyAwIDogdGhpcy5fcnRzOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlIHdoaWNoIHdvdWxkIGJlIDAgaWYgdGhlIGFuaW1hdGlvbiBpcyBwYXVzZWQuXG5cbiAgICB0aGlzLnRvdGFsVGltZShfY2xhbXAoLU1hdGguYWJzKHRoaXMuX2RlbGF5KSwgdGhpcy5fdER1ciwgdFRpbWUpLCBzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpO1xuXG4gICAgX3NldEVuZCh0aGlzKTsgLy8gaWYgcGFyZW50LnNtb290aENoaWxkVGltaW5nIHdhcyBmYWxzZSwgdGhlIGVuZCB0aW1lIGRpZG4ndCBnZXQgdXBkYXRlZCBpbiB0aGUgX2FsaWduUGxheWhlYWQoKSBtZXRob2QsIHNvIGRvIGl0IGhlcmUuXG5cblxuICAgIHJldHVybiBfcmVjYWNoZUFuY2VzdG9ycyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKHZhbHVlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BzICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fcHMgPSB2YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3BUaW1lID0gdGhpcy5fdFRpbWUgfHwgTWF0aC5tYXgoLXRoaXMuX2RlbGF5LCB0aGlzLnJhd1RpbWUoKSk7IC8vIGlmIHRoZSBwYXVzZSBvY2N1cnMgZHVyaW5nIHRoZSBkZWxheSBwaGFzZSwgbWFrZSBzdXJlIHRoYXQncyBmYWN0b3JlZCBpbiB3aGVuIHJlc3VtaW5nLlxuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fYWN0ID0gMDsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSwgc28gYSBwYXVzZWQgdHdlZW4gd291bGQgZWZmZWN0aXZlbHkgaGF2ZSBhIHRpbWVTY2FsZSBvZiAwLiBXZSByZWNvcmQgdGhlIFwicmVhbFwiIHRpbWVTY2FsZSBhcyBfcnRzIChyZWNvcmRlZCB0aW1lIHNjYWxlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3dha2UoKTtcblxuICAgICAgICB0aGlzLl90cyA9IHRoaXMuX3J0czsgLy9vbmx5IGRlZmVyIHRvIF9wVGltZSAocGF1c2VUaW1lKSBpZiB0VGltZSBpcyB6ZXJvLiBSZW1lbWJlciwgc29tZW9uZSBjb3VsZCBwYXVzZSgpIGFuIGFuaW1hdGlvbiwgdGhlbiBzY3J1YiB0aGUgcGxheWhlYWQgYW5kIHJlc3VtZSgpLiBJZiB0aGUgcGFyZW50IGRvZXNuJ3QgaGF2ZSBzbW9vdGhDaGlsZFRpbWluZywgd2UgcmVuZGVyIGF0IHRoZSByYXdUaW1lKCkgYmVjYXVzZSB0aGUgc3RhcnRUaW1lIHdvbid0IGdldCB1cGRhdGVkLlxuXG4gICAgICAgIHRoaXMudG90YWxUaW1lKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMucmF3VGltZSgpIDogdGhpcy5fdFRpbWUgfHwgdGhpcy5fcFRpbWUsIHRoaXMucHJvZ3Jlc3MoKSA9PT0gMSAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgIT09IF90aW55TnVtICYmICh0aGlzLl90VGltZSAtPSBfdGlueU51bSkpOyAvLyBlZGdlIGNhc2U6IGFuaW1hdGlvbi5wcm9ncmVzcygxKS5wYXVzZSgpLnBsYXkoKSB3b3VsZG4ndCByZW5kZXIgYWdhaW4gYmVjYXVzZSB0aGUgcGxheWhlYWQgaXMgYWxyZWFkeSBhdCB0aGUgZW5kLCBidXQgdGhlIGNhbGwgdG8gdG90YWxUaW1lKCkgYmVsb3cgd2lsbCBhZGQgaXQgYmFjayB0byBpdHMgcGFyZW50Li4uYW5kIG5vdCByZW1vdmUgaXQgYWdhaW4gKHNpbmNlIHJlbW92aW5nIG9ubHkgaGFwcGVucyB1cG9uIHJlbmRlcmluZyBhdCBhIG5ldyB0aW1lKS4gT2Zmc2V0dGluZyB0aGUgX3RUaW1lIHNsaWdodGx5IGlzIGRvbmUgc2ltcGx5IHRvIGNhdXNlIHRoZSBmaW5hbCByZW5kZXIgaW4gdG90YWxUaW1lKCkgdGhhdCdsbCBwb3AgaXQgb2ZmIGl0cyB0aW1lbGluZSAoaWYgYXV0b1JlbW92ZUNoaWxkcmVuIGlzIHRydWUsIG9mIGNvdXJzZSkuIENoZWNrIHRvIG1ha2Ugc3VyZSBfelRpbWUgaXNuJ3QgLV90aW55TnVtIHRvIGF2b2lkIGFuIGVkZ2UgY2FzZSB3aGVyZSB0aGUgcGxheWhlYWQgaXMgcHVzaGVkIHRvIHRoZSBlbmQgYnV0IElOU0lERSBhIHR3ZWVuL2NhbGxiYWNrLCB0aGUgdGltZWxpbmUgaXRzZWxmIGlzIHBhdXNlZCB0aHVzIGhhbHRpbmcgcmVuZGVyaW5nIGFuZCBsZWF2aW5nIGEgZmV3IHVucmVuZGVyZWQuIFdoZW4gcmVzdW1pbmcsIGl0IHdvdWxkbid0IHJlbmRlciB0aG9zZSBvdGhlcndpc2UuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0VGltZSA9IGZ1bmN0aW9uIHN0YXJ0VGltZSh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydCA9IHZhbHVlO1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwO1xuICAgICAgcGFyZW50ICYmIChwYXJlbnQuX3NvcnQgfHwgIXRoaXMucGFyZW50KSAmJiBfYWRkVG9UaW1lbGluZShwYXJlbnQsIHRoaXMsIHZhbHVlIC0gdGhpcy5fZGVsYXkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xuICB9O1xuXG4gIF9wcm90by5lbmRUaW1lID0gZnVuY3Rpb24gZW5kVGltZShpbmNsdWRlUmVwZWF0cykge1xuICAgIHJldHVybiB0aGlzLl9zdGFydCArIChfaXNOb3RGYWxzZShpbmNsdWRlUmVwZWF0cykgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuZHVyYXRpb24oKSkgLyBNYXRoLmFicyh0aGlzLl90cyB8fCAxKTtcbiAgfTtcblxuICBfcHJvdG8ucmF3VGltZSA9IGZ1bmN0aW9uIHJhd1RpbWUod3JhcFJlcGVhdHMpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7IC8vIF9kcCA9IGRldGFjaGVkIHBhcmVudFxuXG4gICAgcmV0dXJuICFwYXJlbnQgPyB0aGlzLl90VGltZSA6IHdyYXBSZXBlYXRzICYmICghdGhpcy5fdHMgfHwgdGhpcy5fcmVwZWF0ICYmIHRoaXMuX3RpbWUgJiYgdGhpcy50b3RhbFByb2dyZXNzKCkgPCAxKSA/IHRoaXMuX3RUaW1lICUgKHRoaXMuX2R1ciArIHRoaXMuX3JEZWxheSkgOiAhdGhpcy5fdHMgPyB0aGlzLl90VGltZSA6IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudC5yYXdUaW1lKHdyYXBSZXBlYXRzKSwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJldmVydCA9IGZ1bmN0aW9uIHJldmVydChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgIGNvbmZpZyA9IF9yZXZlcnRDb25maWc7XG4gICAgfVxuXG4gICAgdmFyIHByZXZJc1JldmVydGluZyA9IF9yZXZlcnRpbmc7XG4gICAgX3JldmVydGluZyA9IGNvbmZpZztcblxuICAgIGlmICh0aGlzLl9pbml0dGVkIHx8IHRoaXMuX3N0YXJ0QXQpIHtcbiAgICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5yZXZlcnQoY29uZmlnKTtcbiAgICAgIHRoaXMudG90YWxUaW1lKC0wLjAxLCBjb25maWcuc3VwcHJlc3NFdmVudHMpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YSAhPT0gXCJuZXN0ZWRcIiAmJiBjb25maWcua2lsbCAhPT0gZmFsc2UgJiYgdGhpcy5raWxsKCk7XG4gICAgX3JldmVydGluZyA9IHByZXZJc1JldmVydGluZztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2xvYmFsVGltZSA9IGZ1bmN0aW9uIGdsb2JhbFRpbWUocmF3VGltZSkge1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLFxuICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgd2hpbGUgKGFuaW1hdGlvbikge1xuICAgICAgdGltZSA9IGFuaW1hdGlvbi5fc3RhcnQgKyB0aW1lIC8gKE1hdGguYWJzKGFuaW1hdGlvbi5fdHMpIHx8IDEpO1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLl9kcDtcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXMucGFyZW50ICYmIHRoaXMuX3NhdCA/IHRoaXMuX3NhdC5nbG9iYWxUaW1lKHJhd1RpbWUpIDogdGltZTsgLy8gdGhlIF9zdGFydEF0IHR3ZWVucyBmb3IgLmZyb21UbygpIGFuZCAuZnJvbSgpIHRoYXQgaGF2ZSBpbW1lZGlhdGVSZW5kZXIgc2hvdWxkIGFsd2F5cyBiZSBGSVJTVCBpbiB0aGUgdGltZWxpbmUgKGltcG9ydGFudCBmb3IgY29udGV4dC5yZXZlcnQoKSkuIFwiX3NhdFwiIHN0YW5kcyBmb3IgX3N0YXJ0QXRUd2VlbiwgcmVmZXJyaW5nIHRvIHRoZSBwYXJlbnQgdHdlZW4gdGhhdCBjcmVhdGVkIHRoZSBfc3RhcnRBdC4gV2UgbXVzdCBkaXNjZXJuIGlmIHRoYXQgdHdlZW4gaGFkIGltbWVkaWF0ZVJlbmRlciBzbyB0aGF0IHdlIGNhbiBrbm93IHdoZXRoZXIgb3Igbm90IHRvIHByaW9yaXRpemUgaXQgaW4gcmV2ZXJ0KCkuXG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdCA9IGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yZXBlYXQgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAtMiA6IHZhbHVlO1xuICAgICAgcmV0dXJuIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcGVhdCA9PT0gLTIgPyBJbmZpbml0eSA6IHRoaXMuX3JlcGVhdDtcbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiByZXBlYXREZWxheSh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdGltZSA9IHRoaXMuX3RpbWU7XG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YWx1ZTtcblxuICAgICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcblxuICAgICAgcmV0dXJuIHRpbWUgPyB0aGlzLnRpbWUodGltZSkgOiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yRGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLnlveW8gPSBmdW5jdGlvbiB5b3lvKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3lveW8gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl95b3lvO1xuICB9O1xuXG4gIF9wcm90by5zZWVrID0gZnVuY3Rpb24gc2Vlayhwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5yZXN0YXJ0ID0gZnVuY3Rpb24gcmVzdGFydChpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGF0VGltZSAhPSBudWxsICYmIHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlZCA9IGZ1bmN0aW9uIHJldmVyc2VkKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICEhdmFsdWUgIT09IHRoaXMucmV2ZXJzZWQoKSAmJiB0aGlzLnRpbWVTY2FsZSgtdGhpcy5fcnRzIHx8ICh2YWx1ZSA/IC1fdGlueU51bSA6IDApKTsgLy8gaW4gY2FzZSB0aW1lU2NhbGUgaXMgemVybywgcmV2ZXJzaW5nIHdvdWxkIGhhdmUgbm8gZWZmZWN0IHNvIHdlIHVzZSBfdGlueU51bS5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3J0cyA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9hY3QgPSAwO1xuICAgIHRoaXMuX3pUaW1lID0gLV90aW55TnVtO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcCxcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9zdGFydCxcbiAgICAgICAgcmF3VGltZTtcbiAgICByZXR1cm4gISEoIXBhcmVudCB8fCB0aGlzLl90cyAmJiB0aGlzLl9pbml0dGVkICYmIHBhcmVudC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gcGFyZW50LnJhd1RpbWUodHJ1ZSkpID49IHN0YXJ0ICYmIHJhd1RpbWUgPCB0aGlzLmVuZFRpbWUodHJ1ZSkgLSBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiBldmVudENhbGxiYWNrKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICB2YXIgdmFycyA9IHRoaXMudmFycztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBkZWxldGUgdmFyc1t0eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcnNbdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgcGFyYW1zICYmICh2YXJzW3R5cGUgKyBcIlBhcmFtc1wiXSA9IHBhcmFtcyk7XG4gICAgICAgIHR5cGUgPT09IFwib25VcGRhdGVcIiAmJiAodGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJzW3R5cGVdO1xuICB9O1xuXG4gIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHZhciBmID0gX2lzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBfcGFzc1Rocm91Z2gsXG4gICAgICAgICAgX3Jlc29sdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZSgpIHtcbiAgICAgICAgdmFyIF90aGVuID0gc2VsZi50aGVuO1xuICAgICAgICBzZWxmLnRoZW4gPSBudWxsOyAvLyB0ZW1wb3JhcmlseSBudWxsIHRoZSB0aGVuKCkgbWV0aG9kIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzMyMilcblxuICAgICAgICBfaXNGdW5jdGlvbihmKSAmJiAoZiA9IGYoc2VsZikpICYmIChmLnRoZW4gfHwgZiA9PT0gc2VsZikgJiYgKHNlbGYudGhlbiA9IF90aGVuKTtcbiAgICAgICAgcmVzb2x2ZShmKTtcbiAgICAgICAgc2VsZi50aGVuID0gX3RoZW47XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZi5faW5pdHRlZCAmJiBzZWxmLnRvdGFsUHJvZ3Jlc3MoKSA9PT0gMSAmJiBzZWxmLl90cyA+PSAwIHx8ICFzZWxmLl90VGltZSAmJiBzZWxmLl90cyA8IDApIHtcbiAgICAgICAgX3Jlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3Byb20gPSBfcmVzb2x2ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgX2ludGVycnVwdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gQW5pbWF0aW9uO1xufSgpO1xuXG5fc2V0RGVmYXVsdHMoQW5pbWF0aW9uLnByb3RvdHlwZSwge1xuICBfdGltZTogMCxcbiAgX3N0YXJ0OiAwLFxuICBfZW5kOiAwLFxuICBfdFRpbWU6IDAsXG4gIF90RHVyOiAwLFxuICBfZGlydHk6IDAsXG4gIF9yZXBlYXQ6IDAsXG4gIF95b3lvOiBmYWxzZSxcbiAgcGFyZW50OiBudWxsLFxuICBfaW5pdHRlZDogZmFsc2UsXG4gIF9yRGVsYXk6IDAsXG4gIF90czogMSxcbiAgX2RwOiAwLFxuICByYXRpbzogMCxcbiAgX3pUaW1lOiAtX3RpbnlOdW0sXG4gIF9wcm9tOiAwLFxuICBfcHM6IGZhbHNlLFxuICBfcnRzOiAxXG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSU1FTElORVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBUaW1lbGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShUaW1lbGluZSwgX0FuaW1hdGlvbik7XG5cbiAgZnVuY3Rpb24gVGltZWxpbmUodmFycywgcG9zaXRpb24pIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQW5pbWF0aW9uLmNhbGwodGhpcywgdmFycykgfHwgdGhpcztcbiAgICBfdGhpcy5sYWJlbHMgPSB7fTtcbiAgICBfdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICEhdmFycy5zbW9vdGhDaGlsZFRpbWluZztcbiAgICBfdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAhIXZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuO1xuICAgIF90aGlzLl9zb3J0ID0gX2lzTm90RmFsc2UodmFycy5zb3J0Q2hpbGRyZW4pO1xuICAgIF9nbG9iYWxUaW1lbGluZSAmJiBfYWRkVG9UaW1lbGluZSh2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBwb3NpdGlvbik7XG4gICAgdmFycy5yZXZlcnNlZCAmJiBfdGhpcy5yZXZlcnNlKCk7XG4gICAgdmFycy5wYXVzZWQgJiYgX3RoaXMucGF1c2VkKHRydWUpO1xuICAgIHZhcnMuc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFycy5zY3JvbGxUcmlnZ2VyKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFRpbWVsaW5lLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICBfY3JlYXRlVHdlZW5UeXBlKDAsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgxLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcbiAgICBfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gISF2YXJzLmltbWVkaWF0ZVJlbmRlcjtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmNhbGwgPSBmdW5jdGlvbiBjYWxsKGNhbGxiYWNrLCBwYXJhbXMsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMpLCBwb3NpdGlvbik7XG4gIH0gLy9PTkxZIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5ISBNYXliZSBkZWxldGU/XG4gIDtcblxuICBfcHJvdG8yLnN0YWdnZXJUbyA9IGZ1bmN0aW9uIHN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdmFycy5zdGFnZ2VyID0gdmFycy5zdGFnZ2VyIHx8IHN0YWdnZXI7XG4gICAgdmFycy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZUFsbDtcbiAgICB2YXJzLm9uQ29tcGxldGVQYXJhbXMgPSBvbkNvbXBsZXRlQWxsUGFyYW1zO1xuICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tID0gZnVuY3Rpb24gc3RhZ2dlckZyb20odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5ydW5CYWNrd2FyZHMgPSAxO1xuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICB9O1xuXG4gIF9wcm90bzIuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tVG8odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcbiAgICBfaW5oZXJpdERlZmF1bHRzKHRvVmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodG9WYXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl9kaXJ0eSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5fdER1cixcbiAgICAgICAgZHVyID0gdGhpcy5fZHVyLFxuICAgICAgICB0VGltZSA9IHRvdGFsVGltZSA8PSAwID8gMCA6IF9yb3VuZFByZWNpc2UodG90YWxUaW1lKSxcbiAgICAgICAgLy8gaWYgYSBwYXVzZWQgdGltZWxpbmUgaXMgcmVzdW1lZCAob3IgaXRzIF9zdGFydCBpcyB1cGRhdGVkIGZvciBhbm90aGVyIHJlYXNvbi4uLndoaWNoIHJvdW5kcyBpdCksIHRoYXQgY291bGQgcmVzdWx0IGluIHRoZSBwbGF5aGVhZCBzaGlmdGluZyBhICoqdGlueSoqIGFtb3VudCBhbmQgYSB6ZXJvLWR1cmF0aW9uIGNoaWxkIGF0IHRoYXQgc3BvdCBtYXkgZ2V0IHJlbmRlcmVkIGF0IGEgZGlmZmVyZW50IHJhdGlvLCBsaWtlIGl0cyB0b3RhbFRpbWUgaW4gcmVuZGVyKCkgbWF5IGJlIDFlLTE3IGluc3RlYWQgb2YgMCwgZm9yIGV4YW1wbGUuXG4gICAgY3Jvc3NpbmdTdGFydCA9IHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCAmJiAodGhpcy5faW5pdHRlZCB8fCAhZHVyKSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldlBhdXNlZCxcbiAgICAgICAgcGF1c2VUd2VlbixcbiAgICAgICAgdGltZVNjYWxlLFxuICAgICAgICBwcmV2U3RhcnQsXG4gICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgIHlveW8sXG4gICAgICAgIGlzWW95bztcbiAgICB0aGlzICE9PSBfZ2xvYmFsVGltZWxpbmUgJiYgdFRpbWUgPiB0RHVyICYmIHRvdGFsVGltZSA+PSAwICYmICh0VGltZSA9IHREdXIpO1xuXG4gICAgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCBmb3JjZSB8fCBjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgJiYgZHVyKSB7XG4gICAgICAgIC8vaWYgdG90YWxEdXJhdGlvbigpIGZpbmRzIGEgY2hpbGQgd2l0aCBhIG5lZ2F0aXZlIHN0YXJ0VGltZSBhbmQgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgdGhpbmdzIGdldCBzaGlmdGVkIGFyb3VuZCBpbnRlcm5hbGx5IHNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB0aW1lIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgYSB0d2VlbiBzdGFydHMgYXQgLTMwIHdlIG11c3Qgc2hpZnQgRVZFUllUSElORyBmb3J3YXJkIDMwIHNlY29uZHMgYW5kIG1vdmUgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSBiYWNrd2FyZCBieSAzMCBzZWNvbmRzIHNvIHRoYXQgdGhpbmdzIGFsaWduIHdpdGggdGhlIHBsYXloZWFkIChubyBqdW1wKS5cbiAgICAgICAgdFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuICAgICAgICB0b3RhbFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aW1lID0gdFRpbWU7XG4gICAgICBwcmV2U3RhcnQgPSB0aGlzLl9zdGFydDtcbiAgICAgIHRpbWVTY2FsZSA9IHRoaXMuX3RzO1xuICAgICAgcHJldlBhdXNlZCA9ICF0aW1lU2NhbGU7XG5cbiAgICAgIGlmIChjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICAgIGR1ciB8fCAocHJldlRpbWUgPSB0aGlzLl96VGltZSk7IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUsIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cbiAgICAgICAgKHRvdGFsVGltZSB8fCAhc3VwcHJlc3NFdmVudHMpICYmICh0aGlzLl96VGltZSA9IHRvdGFsVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG4gICAgICAgIHlveW8gPSB0aGlzLl95b3lvO1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xuICAgICAgICAgIC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuICAgICAgICAhcHJldlRpbWUgJiYgdGhpcy5fdFRpbWUgJiYgcHJldkl0ZXJhdGlvbiAhPT0gaXRlcmF0aW9uICYmIHRoaXMuX3RUaW1lIC0gcHJldkl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24gLSB0aGlzLl9kdXIgPD0gMCAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzIzODIzLWNsb3NpbmctbmF2LWFuaW1hdGlvbi1ub3Qtd29ya2luZy1vbi1pZS1hbmQtaXBob25lLTYtbWF5YmUtb3RoZXItb2xkZXItYnJvd3Nlci8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTEzMDA1IGFsc28sIHRoaXMuX3RUaW1lIC0gcHJldkl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24gLSB0aGlzLl9kdXIgPD0gMCBqdXN0IGNoZWNrcyB0byBtYWtlIHN1cmUgaXQgd2Fzbid0IHByZXZpb3VzbHkgaW4gdGhlIFwicmVwZWF0RGVsYXlcIiBwb3J0aW9uXG5cbiAgICAgICAgaWYgKHlveW8gJiYgaXRlcmF0aW9uICYgMSkge1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICAgIGlzWW95byA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgbWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcbiAgICAgICAgYSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcbiAgICAgICAgd291bGQgZ2V0IHRyYW5zbGF0ZWQgdG8gMi44IHNlY29uZHMgaWYgdGhlIHRpbWVsaW5lIHlveW9zIG9yIDAuMiBzZWNvbmRzIGlmIGl0IGp1c3QgcmVwZWF0cyksIHRoZXJlXG4gICAgICAgIGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xuICAgICAgICB3ZSBuZWVkIHRvIHB1c2ggdGhlIHRpbWVsaW5lIHRvIHRoZSBlbmQgKGFuZC9vciBiZWdpbm5pbmcgZGVwZW5kaW5nIG9uIGl0cyB5b3lvIHZhbHVlKS4gQWxzbyB3ZSBtdXN0XG4gICAgICAgIGVuc3VyZSB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIFRpbWVsaW5lIHdvcmsuXG4gICAgICAgICovXG5cblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmICF0aGlzLl9sb2NrKSB7XG4gICAgICAgICAgdmFyIHJld2luZGluZyA9IHlveW8gJiYgcHJldkl0ZXJhdGlvbiAmIDEsXG4gICAgICAgICAgICAgIGRvZXNXcmFwID0gcmV3aW5kaW5nID09PSAoeW95byAmJiBpdGVyYXRpb24gJiAxKTtcbiAgICAgICAgICBpdGVyYXRpb24gPCBwcmV2SXRlcmF0aW9uICYmIChyZXdpbmRpbmcgPSAhcmV3aW5kaW5nKTtcbiAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IDAgOiB0VGltZSAlIGR1ciA/IGR1ciA6IHRUaW1lOyAvLyBpZiB0aGUgcGxheWhlYWQgaXMgbGFuZGluZyBleGFjdGx5IGF0IHRoZSBlbmQgb2YgYW4gaXRlcmF0aW9uLCB1c2UgdGhhdCB0b3RhbFRpbWUgcmF0aGVyIHRoYW4gb25seSB0aGUgZHVyYXRpb24sIG90aGVyd2lzZSBpdCdsbCBza2lwIHRoZSAybmQgcmVuZGVyIHNpbmNlIGl0J3MgZWZmZWN0aXZlbHkgYXQgdGhlIHNhbWUgdGltZS5cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAxO1xuICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lIHx8IChpc1lveW8gPyAwIDogX3JvdW5kUHJlY2lzZShpdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uKSksIHN1cHByZXNzRXZlbnRzLCAhZHVyKS5fbG9jayA9IDA7XG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTsgLy8gaWYgYSB1c2VyIGdldHMgdGhlIGl0ZXJhdGlvbigpIGluc2lkZSB0aGUgb25SZXBlYXQsIGZvciBleGFtcGxlLCBpdCBzaG91bGQgYmUgYWNjdXJhdGUuXG5cbiAgICAgICAgICAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG4gICAgICAgICAgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAodGhpcy5pbnZhbGlkYXRlKCkuX2xvY2sgPSAxKTtcblxuICAgICAgICAgIGlmIChwcmV2VGltZSAmJiBwcmV2VGltZSAhPT0gdGhpcy5fdGltZSB8fCBwcmV2UGF1c2VkICE9PSAhdGhpcy5fdHMgfHwgdGhpcy52YXJzLm9uUmVwZWF0ICYmICF0aGlzLnBhcmVudCAmJiAhdGhpcy5fYWN0KSB7XG4gICAgICAgICAgICAvLyBpZiBwcmV2VGltZSBpcyAwIGFuZCB3ZSByZW5kZXIgYXQgdGhlIHZlcnkgZW5kLCBfdGltZSB3aWxsIGJlIHRoZSBlbmQsIHRodXMgd29uJ3QgbWF0Y2guIFNvIGluIHRoaXMgZWRnZSBjYXNlLCBwcmV2VGltZSB3b24ndCBtYXRjaCBfdGltZSBidXQgdGhhdCdzIG9rYXkuIElmIGl0IGdldHMga2lsbGVkIGluIHRoZSBvblJlcGVhdCwgZWplY3QgYXMgd2VsbC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGR1ciA9IHRoaXMuX2R1cjsgLy8gaW4gY2FzZSB0aGUgZHVyYXRpb24gY2hhbmdlZCBpbiB0aGUgb25SZXBlYXRcblxuICAgICAgICAgIHREdXIgPSB0aGlzLl90RHVyO1xuXG4gICAgICAgICAgaWYgKGRvZXNXcmFwKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gMjtcbiAgICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gZHVyIDogLTAuMDAwMTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IC8vaW4gb3JkZXIgZm9yIHlveW9FYXNlIHRvIHdvcmsgcHJvcGVybHkgd2hlbiB0aGVyZSdzIGEgc3RhZ2dlciwgd2UgbXVzdCBzd2FwIG91dCB0aGUgZWFzZSBpbiBlYWNoIHN1Yi10d2Vlbi5cblxuXG4gICAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKHRoaXMsIGlzWW95byk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nICYmIHRoaXMuX2xvY2sgPCAyKSB7XG4gICAgICAgIHBhdXNlVHdlZW4gPSBfZmluZE5leHRQYXVzZVR3ZWVuKHRoaXMsIF9yb3VuZFByZWNpc2UocHJldlRpbWUpLCBfcm91bmRQcmVjaXNlKHRpbWUpKTtcblxuICAgICAgICBpZiAocGF1c2VUd2Vlbikge1xuICAgICAgICAgIHRUaW1lIC09IHRpbWUgLSAodGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgICB0aGlzLl9hY3QgPSAhdGltZVNjYWxlOyAvL2FzIGxvbmcgYXMgaXQncyBub3QgcGF1c2VkLCBmb3JjZSBpdCB0byBiZSBhY3RpdmUgc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGluZGVwZW5kZW50IG9mIHRoZSBwYXJlbnQgdGltZWxpbmUsIGl0J2xsIGJlIGZvcmNlZCB0byByZS1yZW5kZXIgb24gdGhlIG5leHQgdGljay5cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuICAgICAgICB0aGlzLl9pbml0dGVkID0gMTtcbiAgICAgICAgdGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgIHByZXZUaW1lID0gMDsgLy8gdXBvbiBpbml0LCB0aGUgcGxheWhlYWQgc2hvdWxkIGFsd2F5cyBnbyBmb3J3YXJkOyBzb21lb25lIGNvdWxkIGludmFsaWRhdGUoKSBhIGNvbXBsZXRlZCB0aW1lbGluZSBhbmQgdGhlbiBpZiB0aGV5IHJlc3RhcnQoKSwgdGhhdCB3b3VsZCBtYWtlIGNoaWxkIHR3ZWVucyByZW5kZXIgaW4gcmV2ZXJzZSBvcmRlciB3aGljaCBjb3VsZCBsb2NrIGluIHRoZSB3cm9uZyBzdGFydGluZyB2YWx1ZXMgaWYgdGhleSBidWlsZCBvbiBlYWNoIG90aGVyLCBsaWtlIHRsLnRvKG9iaiwge3g6IDEwMH0pLnRvKG9iaiwge3g6IDB9KS5cbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmV2VGltZSAmJiB0aW1lICYmICFzdXBwcmVzc0V2ZW50cyAmJiAhaXRlcmF0aW9uKSB7XG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uU3RhcnRcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkge1xuICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG9uU3RhcnQgdHJpZ2dlcmVkIGEgcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QsIGVqZWN0LiBMaWtlIGlmIHNvbWVvbmUgZGlkIGFuaW1hdGlvbi5wYXVzZSgwLjUpIG9yIHNvbWV0aGluZyBpbnNpZGUgdGhlIG9uU3RhcnQuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWUgPj0gcHJldlRpbWUgJiYgdG90YWxUaW1lID49IDApIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gLV90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGZsYWcgelRpbWUgYXMgbmVnYXRpdmUgc28gdGhhdCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgcmVuZGVyKCkgaXMgY2FsbGVkIGl0J2xsIGJlIGZvcmNlZCAodG8gcmVuZGVyIGFueSByZW1haW5pbmcgY2hpbGRyZW4pXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2xhc3Q7XG4gICAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZTsgLy93aGVuIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnQgb2YgdGhpcyB0aW1lbGluZSwgd2UgbXVzdCBwYXNzIHRoYXQgaW5mb3JtYXRpb24gZG93biB0byB0aGUgY2hpbGQgYW5pbWF0aW9ucyBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIGtub3cgd2hldGhlciB0byByZW5kZXIgdGhlaXIgc3RhcnRpbmcgb3IgZW5kaW5nIHZhbHVlcy5cblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBuZXh0ID0gY2hpbGQuX3ByZXY7XG5cbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgYWRqdXN0ZWRUaW1lIDw9IGNoaWxkLl9lbmQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSB8fCBfcmV2ZXJ0aW5nICYmIChjaGlsZC5faW5pdHRlZCB8fCBjaGlsZC5fc3RhcnRBdCkpOyAvLyBpZiByZXZlcnRpbmcsIHdlIHNob3VsZCBhbHdheXMgZm9yY2UgcmVuZGVycyBvZiBpbml0dGVkIHR3ZWVucyAoYnV0IHJlbWVtYmVyIHRoYXQgLmZyb21UbygpIG9yIC5mcm9tKCkgbWF5IGhhdmUgYSBfc3RhcnRBdCBidXQgbm90IF9pbml0dGVkIHlldCkuIElmLCBmb3IgZXhhbXBsZSwgYSAuZnJvbVRvKCkgdHdlZW4gd2l0aCBhIHN0YWdnZXIgKHdoaWNoIGNyZWF0ZXMgYW4gaW50ZXJuYWwgdGltZWxpbmUpIGdldHMgcmV2ZXJ0ZWQgQkVGT1JFIHNvbWUgb2YgaXRzIGNoaWxkIHR3ZWVucyByZW5kZXIgZm9yIHRoZSBmaXJzdCB0aW1lLCBpdCBtYXkgbm90IHByb3Blcmx5IHRyaWdnZXIgdGhlbSB0byByZXZlcnQuXG5cbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG4gICAgICAgICAgICAgIHBhdXNlVHdlZW4gPSAwO1xuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IGFkanVzdGVkVGltZSA/IC1fdGlueU51bSA6IF90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGFkanVzdCB6VGltZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdXNlVHdlZW4gJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgcGF1c2VUd2Vlbi5yZW5kZXIodGltZSA+PSBwcmV2VGltZSA/IDAgOiAtX3RpbnlOdW0pLl96VGltZSA9IHRpbWUgPj0gcHJldlRpbWUgPyAxIDogLTE7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RzKSB7XG4gICAgICAgICAgLy90aGUgY2FsbGJhY2sgcmVzdW1lZCBwbGF5YmFjayEgU28gc2luY2Ugd2UgbWF5IGhhdmUgaGVsZCBiYWNrIHRoZSBwbGF5aGVhZCBkdWUgdG8gd2hlcmUgdGhlIHBhdXNlIGlzIHBvc2l0aW9uZWQsIGdvIGFoZWFkIGFuZCBqdW1wIHRvIHdoZXJlIGl0J3MgU1VQUE9TRUQgdG8gYmUgKGlmIG5vIHBhdXNlIGhhcHBlbmVkKS5cbiAgICAgICAgICB0aGlzLl9zdGFydCA9IHByZXZTdGFydDsgLy9pZiB0aGUgcGF1c2Ugd2FzIGF0IGFuIGVhcmxpZXIgdGltZSBhbmQgdGhlIHVzZXIgcmVzdW1lZCBpbiB0aGUgY2FsbGJhY2ssIGl0IGNvdWxkIHJlcG9zaXRpb24gdGhlIHRpbWVsaW5lIChjaGFuZ2luZyBpdHMgc3RhcnRUaW1lKSwgdGhyb3dpbmcgdGhpbmdzIG9mZiBzbGlnaHRseSwgc28gd2UgbWFrZSBzdXJlIHRoZSBfc3RhcnQgZG9lc24ndCBzaGlmdC5cblxuICAgICAgICAgIF9zZXRFbmQodGhpcyk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiLCB0cnVlKTtcbiAgICAgIGlmICh0VGltZSA9PT0gdER1ciAmJiB0aGlzLl90VGltZSA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSB8fCAhdFRpbWUgJiYgcHJldlRpbWUpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0IHx8IE1hdGguYWJzKHRpbWVTY2FsZSkgIT09IE1hdGguYWJzKHRoaXMuX3RzKSkgaWYgKCF0aGlzLl9sb2NrKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyLCBhIGNoaWxkJ3MgY2FsbGJhY2sgbWF5IGFsdGVyIHRoaXMgdGltZWxpbmUncyBwbGF5aGVhZCBvciB0aW1lU2NhbGUgd2hpY2ggaXMgd2h5IHdlIG5lZWQgdG8gYWRkIHNvbWUgb2YgdGhlc2UgY2hlY2tzLlxuICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8ICF0RHVyKSkge1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICAgIHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkID0gZnVuY3Rpb24gYWRkKGNoaWxkLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgX2lzTnVtYmVyKHBvc2l0aW9uKSB8fCAocG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiwgY2hpbGQpKTtcblxuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuICAgICAgaWYgKF9pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZChvYmosIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYWJlbChjaGlsZCwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7IC8vZG9uJ3QgYWxsb3cgYSB0aW1lbGluZSB0byBiZSBhZGRlZCB0byBpdHNlbGYgYXMgYSBjaGlsZCFcbiAgfTtcblxuICBfcHJvdG8yLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChuZXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgbmVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHdlZW5zID09PSB2b2lkIDApIHtcbiAgICAgIHR3ZWVucyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVsaW5lcyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lbGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IFtdLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgICB0d2VlbnMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBuZXN0ZWQgJiYgYS5wdXNoLmFwcGx5KGEsIGNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBfcHJvdG8yLmdldEJ5SWQgPSBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmdldENoaWxkcmVuKDEsIDEsIDEpLFxuICAgICAgICBpID0gYW5pbWF0aW9ucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoY2hpbGQpIHtcbiAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtpbGxUd2VlbnNPZihjaGlsZCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIGNoaWxkKTtcblxuICAgIGlmIChjaGlsZCA9PT0gdGhpcy5fcmVjZW50KSB7XG4gICAgICB0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMTtcblxuICAgIGlmICghdGhpcy5fZHAgJiYgdGhpcy5fdHMpIHtcbiAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciB0aGUgZ2xvYmFsIHRpbWVsaW5lIChvciBhbnkgb3RoZXIgdGhhdCBoYXMgbm8gcGFyZW50IG9yIGRldGFjaGVkIHBhcmVudCkuXG4gICAgICB0aGlzLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoX3RpY2tlci50aW1lIC0gKHRoaXMuX3RzID4gMCA/IF90b3RhbFRpbWUyIC8gdGhpcy5fdHMgOiAodGhpcy50b3RhbER1cmF0aW9uKCkgLSBfdG90YWxUaW1lMikgLyAtdGhpcy5fdHMpKTtcbiAgICB9XG5cbiAgICBfQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuY2FsbCh0aGlzLCBfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpO1xuXG4gICAgdGhpcy5fZm9yY2luZyA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRMYWJlbCA9IGZ1bmN0aW9uIGFkZExhYmVsKGxhYmVsLCBwb3NpdGlvbikge1xuICAgIHRoaXMubGFiZWxzW2xhYmVsXSA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24gcmVtb3ZlTGFiZWwobGFiZWwpIHtcbiAgICBkZWxldGUgdGhpcy5sYWJlbHNbbGFiZWxdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkUGF1c2UgPSBmdW5jdGlvbiBhZGRQYXVzZShwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgIHZhciB0ID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2sgfHwgX2VtcHR5RnVuYywgcGFyYW1zKTtcbiAgICB0LmRhdGEgPSBcImlzUGF1c2VcIjtcbiAgICB0aGlzLl9oYXNQYXVzZSA9IDE7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIHQsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmVQYXVzZSA9IGZ1bmN0aW9uIHJlbW92ZVBhdXNlKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgcG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPT09IHBvc2l0aW9uICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICB2YXIgdHdlZW5zID0gdGhpcy5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSxcbiAgICAgICAgaSA9IHR3ZWVucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiAhPT0gdHdlZW5zW2ldICYmIHR3ZWVuc1tpXS5raWxsKHRhcmdldHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmdldFR3ZWVuc09mID0gZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHZhciBhID0gW10sXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBpc0dsb2JhbFRpbWUgPSBfaXNOdW1iZXIob25seUFjdGl2ZSksXG4gICAgICAgIC8vIGEgbnVtYmVyIGlzIGludGVycHJldGVkIGFzIGEgZ2xvYmFsIHRpbWUuIElmIHRoZSBhbmltYXRpb24gc3BhbnNcbiAgICBjaGlsZHJlbjtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgaWYgKF9hcnJheUNvbnRhaW5zQW55KGNoaWxkLl90YXJnZXRzLCBwYXJzZWRUYXJnZXRzKSAmJiAoaXNHbG9iYWxUaW1lID8gKCFfb3ZlcndyaXRpbmdUd2VlbiB8fCBjaGlsZC5faW5pdHRlZCAmJiBjaGlsZC5fdHMpICYmIGNoaWxkLmdsb2JhbFRpbWUoMCkgPD0gb25seUFjdGl2ZSAmJiBjaGlsZC5nbG9iYWxUaW1lKGNoaWxkLnRvdGFsRHVyYXRpb24oKSkgPiBvbmx5QWN0aXZlIDogIW9ubHlBY3RpdmUgfHwgY2hpbGQuaXNBY3RpdmUoKSkpIHtcbiAgICAgICAgICAvLyBub3RlOiBpZiB0aGlzIGlzIGZvciBvdmVyd3JpdGluZywgaXQgc2hvdWxkIG9ubHkgYmUgZm9yIHR3ZWVucyB0aGF0IGFyZW4ndCBwYXVzZWQgYW5kIGFyZSBpbml0dGVkLlxuICAgICAgICAgIGEucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGNoaWxkcmVuID0gY2hpbGQuZ2V0VHdlZW5zT2YocGFyc2VkVGFyZ2V0cywgb25seUFjdGl2ZSkpLmxlbmd0aCkge1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAtIHRhcmdldHMoKSBvbiB0aW1lbGluZXNcbiAgLy8gdGFyZ2V0cygpIHtcbiAgLy8gXHRsZXQgcmVzdWx0ID0gW107XG4gIC8vIFx0dGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaCh0ID0+IHJlc3VsdC5wdXNoKC4uLnQudGFyZ2V0cygpKSk7XG4gIC8vIFx0cmV0dXJuIHJlc3VsdC5maWx0ZXIoKHYsIGkpID0+IHJlc3VsdC5pbmRleE9mKHYpID09PSBpKTtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvMi50d2VlblRvID0gZnVuY3Rpb24gdHdlZW5Ubyhwb3NpdGlvbiwgdmFycykge1xuICAgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gICAgdmFyIHRsID0gdGhpcyxcbiAgICAgICAgZW5kVGltZSA9IF9wYXJzZVBvc2l0aW9uKHRsLCBwb3NpdGlvbiksXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgc3RhcnRBdCA9IF92YXJzLnN0YXJ0QXQsXG4gICAgICAgIF9vblN0YXJ0ID0gX3ZhcnMub25TdGFydCxcbiAgICAgICAgb25TdGFydFBhcmFtcyA9IF92YXJzLm9uU3RhcnRQYXJhbXMsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF92YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgdHdlZW4gPSBUd2Vlbi50byh0bCwgX3NldERlZmF1bHRzKHtcbiAgICAgIGVhc2U6IHZhcnMuZWFzZSB8fCBcIm5vbmVcIixcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIHRpbWU6IGVuZFRpbWUsXG4gICAgICBvdmVyd3JpdGU6IFwiYXV0b1wiLFxuICAgICAgZHVyYXRpb246IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0ID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKSB8fCBfdGlueU51bSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIHRsLnBhdXNlKCk7XG5cbiAgICAgICAgaWYgKCFpbml0dGVkKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpO1xuICAgICAgICAgIHR3ZWVuLl9kdXIgIT09IGR1cmF0aW9uICYmIF9zZXREdXJhdGlvbih0d2VlbiwgZHVyYXRpb24sIDAsIDEpLnJlbmRlcih0d2Vlbi5fdGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5pdHRlZCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBfb25TdGFydCAmJiBfb25TdGFydC5hcHBseSh0d2Vlbiwgb25TdGFydFBhcmFtcyB8fCBbXSk7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuICAgICAgfVxuICAgIH0sIHZhcnMpKTtcblxuICAgIHJldHVybiBpbW1lZGlhdGVSZW5kZXIgPyB0d2Vlbi5yZW5kZXIoMCkgOiB0d2VlbjtcbiAgfTtcblxuICBfcHJvdG8yLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24gdHdlZW5Gcm9tVG8oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgc3RhcnRBdDoge1xuICAgICAgICB0aW1lOiBfcGFyc2VQb3NpdGlvbih0aGlzLCBmcm9tUG9zaXRpb24pXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuICB9O1xuXG4gIF9wcm90bzIucmVjZW50ID0gZnVuY3Rpb24gcmVjZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNlbnQ7XG4gIH07XG5cbiAgX3Byb3RvMi5uZXh0TGFiZWwgPSBmdW5jdGlvbiBuZXh0TGFiZWwoYWZ0ZXJUaW1lKSB7XG4gICAgaWYgKGFmdGVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBhZnRlclRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBhZnRlclRpbWUpKTtcbiAgfTtcblxuICBfcHJvdG8yLnByZXZpb3VzTGFiZWwgPSBmdW5jdGlvbiBwcmV2aW91c0xhYmVsKGJlZm9yZVRpbWUpIHtcbiAgICBpZiAoYmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiZWZvcmVUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xuICB9O1xuXG4gIF9wcm90bzIuY3VycmVudExhYmVsID0gZnVuY3Rpb24gY3VycmVudExhYmVsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNlZWsodmFsdWUsIHRydWUpIDogdGhpcy5wcmV2aW91c0xhYmVsKHRoaXMuX3RpbWUgKyBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvMi5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24gc2hpZnRDaGlsZHJlbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAwO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBsYWJlbHMgPSB0aGlzLmxhYmVscyxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG4gICAgICAgIGNoaWxkLl9lbmQgKz0gYW1vdW50O1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChhZGp1c3RMYWJlbHMpIHtcbiAgICAgIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICAgICAgaWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgICAgbGFiZWxzW3BdICs9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKHNvZnQpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgY2hpbGQuaW52YWxpZGF0ZShzb2Z0KTtcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzLCBzb2Z0KTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xuICAgIGlmIChpbmNsdWRlTGFiZWxzID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG4gICAgaW5jbHVkZUxhYmVscyAmJiAodGhpcy5sYWJlbHMgPSB7fSk7XG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNoaWxkID0gc2VsZi5fbGFzdCxcbiAgICAgICAgcHJldlN0YXJ0ID0gX2JpZ051bSxcbiAgICAgICAgcHJldixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBhcmVudDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VsZi50aW1lU2NhbGUoKHNlbGYuX3JlcGVhdCA8IDAgPyBzZWxmLmR1cmF0aW9uKCkgOiBzZWxmLnRvdGFsRHVyYXRpb24oKSkgLyAoc2VsZi5yZXZlcnNlZCgpID8gLXZhbHVlIDogdmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgIHBhcmVudCA9IHNlbGYucGFyZW50O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cbiAgICAgICAgY2hpbGQuX2RpcnR5ICYmIGNoaWxkLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblxuICAgICAgICBzdGFydCA9IGNoaWxkLl9zdGFydDtcblxuICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcbiAgICAgICAgICAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gICAgICAgICAgc2VsZi5fbG9jayA9IDE7IC8vcHJldmVudCBlbmRsZXNzIHJlY3Vyc2l2ZSBjYWxscyAtIHRoZXJlIGFyZSBtZXRob2RzIHRoYXQgZ2V0IHRyaWdnZXJlZCB0aGF0IGNoZWNrIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gd2hlbiB3ZSBhZGQoKS5cblxuICAgICAgICAgIF9hZGRUb1RpbWVsaW5lKHNlbGYsIGNoaWxkLCBzdGFydCAtIGNoaWxkLl9kZWxheSwgMSkuX2xvY2sgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCAmJiBjaGlsZC5fdHMpIHtcbiAgICAgICAgICAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuICAgICAgICAgIG1heCAtPSBzdGFydDtcblxuICAgICAgICAgIGlmICghcGFyZW50ICYmICFzZWxmLl9kcCB8fCBwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSB7XG4gICAgICAgICAgICBzZWxmLl9zdGFydCArPSBzdGFydCAvIHNlbGYuX3RzO1xuICAgICAgICAgICAgc2VsZi5fdGltZSAtPSBzdGFydDtcbiAgICAgICAgICAgIHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuc2hpZnRDaGlsZHJlbigtc3RhcnQsIGZhbHNlLCAtMWU5OTkpO1xuICAgICAgICAgIHByZXZTdGFydCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5fZW5kID4gbWF4ICYmIGNoaWxkLl90cyAmJiAobWF4ID0gY2hpbGQuX2VuZCk7XG4gICAgICAgIGNoaWxkID0gcHJldjtcbiAgICAgIH1cblxuICAgICAgX3NldER1cmF0aW9uKHNlbGYsIHNlbGYgPT09IF9nbG9iYWxUaW1lbGluZSAmJiBzZWxmLl90aW1lID4gbWF4ID8gc2VsZi5fdGltZSA6IG1heCwgMSwgMSk7XG5cbiAgICAgIHNlbGYuX2RpcnR5ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5fdER1cjtcbiAgfTtcblxuICBUaW1lbGluZS51cGRhdGVSb290ID0gZnVuY3Rpb24gdXBkYXRlUm9vdCh0aW1lKSB7XG4gICAgaWYgKF9nbG9iYWxUaW1lbGluZS5fdHMpIHtcbiAgICAgIF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXG4gICAgICBfbGFzdFJlbmRlcmVkRnJhbWUgPSBfdGlja2VyLmZyYW1lO1xuICAgIH1cblxuICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuICAgICAgX25leHRHQ0ZyYW1lICs9IF9jb25maWcuYXV0b1NsZWVwIHx8IDEyMDtcbiAgICAgIHZhciBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuICAgICAgICB3aGlsZSAoY2hpbGQgJiYgIWNoaWxkLl90cykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCB8fCBfdGlja2VyLnNsZWVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaW1lbGluZTtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFRpbWVsaW5lLnByb3RvdHlwZSwge1xuICBfbG9jazogMCxcbiAgX2hhc1BhdXNlOiAwLFxuICBfZm9yY2luZzogMFxufSk7XG5cbnZhciBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAvL25vdGU6IHdlIGNhbGwgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0d2Vlbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YXJ0TnVtcyxcbiAgICAgIGNvbG9yLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBzdGFydE51bSxcbiAgICAgIGhhc1JhbmRvbSxcbiAgICAgIGE7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICB9XG5cbiAgaWYgKHN0cmluZ0ZpbHRlcikge1xuICAgIGEgPSBbc3RhcnQsIGVuZF07XG4gICAgc3RyaW5nRmlsdGVyKGEsIHRhcmdldCwgcHJvcCk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblxuICAgIHN0YXJ0ID0gYVswXTtcbiAgICBlbmQgPSBhWzFdO1xuICB9XG5cbiAgc3RhcnROdW1zID0gc3RhcnQubWF0Y2goX2NvbXBsZXhTdHJpbmdOdW1FeHApIHx8IFtdO1xuXG4gIHdoaWxlIChyZXN1bHQgPSBfY29tcGxleFN0cmluZ051bUV4cC5leGVjKGVuZCkpIHtcbiAgICBlbmROdW0gPSByZXN1bHRbMF07XG4gICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIikge1xuICAgICAgY29sb3IgPSAxO1xuICAgIH1cblxuICAgIGlmIChlbmROdW0gIT09IHN0YXJ0TnVtc1ttYXRjaEluZGV4KytdKSB7XG4gICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW21hdGNoSW5kZXggLSAxXSkgfHwgMDsgLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG4gICAgICBwdC5fcHQgPSB7XG4gICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgIGM6IGVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZE51bSkgLSBzdGFydE51bSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSwgb3B0aW9uYWwpIHtcbiAgX2lzRnVuY3Rpb24oZW5kKSAmJiAoZW5kID0gZW5kKGluZGV4IHx8IDAsIHRhcmdldCwgdGFyZ2V0cykpO1xuICB2YXIgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdLFxuICAgICAgcGFyc2VkU3RhcnQgPSBzdGFydCAhPT0gXCJnZXRcIiA/IHN0YXJ0IDogIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUgOiBmdW5jUGFyYW0gPyB0YXJnZXRbcHJvcC5pbmRleE9mKFwic2V0XCIpIHx8ICFfaXNGdW5jdGlvbih0YXJnZXRbXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXSkgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXShmdW5jUGFyYW0pIDogdGFyZ2V0W3Byb3BdKCksXG4gICAgICBzZXR0ZXIgPSAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IF9zZXR0ZXJQbGFpbiA6IGZ1bmNQYXJhbSA/IF9zZXR0ZXJGdW5jV2l0aFBhcmFtIDogX3NldHRlckZ1bmMsXG4gICAgICBwdDtcblxuICBpZiAoX2lzU3RyaW5nKGVuZCkpIHtcbiAgICBpZiAofmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgZW5kID0gX3JlcGxhY2VSYW5kb20oZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcbiAgICAgIHB0ID0gX3BhcnNlUmVsYXRpdmUocGFyc2VkU3RhcnQsIGVuZCkgKyAoZ2V0VW5pdChwYXJzZWRTdGFydCkgfHwgMCk7XG5cbiAgICAgIGlmIChwdCB8fCBwdCA9PT0gMCkge1xuICAgICAgICAvLyB0byBhdm9pZCBpc05hTiwgbGlrZSBpZiBzb21lb25lIHBhc3NlcyBpbiBhIHZhbHVlIGxpa2UgXCIhPSB3aGF0ZXZlclwiXG4gICAgICAgIGVuZCA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0aW9uYWwgfHwgcGFyc2VkU3RhcnQgIT09IGVuZCB8fCBfZm9yY2VBbGxQcm9wVHdlZW5zKSB7XG4gICAgaWYgKCFpc05hTihwYXJzZWRTdGFydCAqIGVuZCkgJiYgZW5kICE9PSBcIlwiKSB7XG4gICAgICAvLyBmdW4gZmFjdDogYW55IG51bWJlciBtdWx0aXBsaWVkIGJ5IFwiXCIgaXMgZXZhbHVhdGVkIGFzIHRoZSBudW1iZXIgMCFcbiAgICAgIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCArcGFyc2VkU3RhcnQgfHwgMCwgZW5kIC0gKHBhcnNlZFN0YXJ0IHx8IDApLCB0eXBlb2YgY3VycmVudFZhbHVlID09PSBcImJvb2xlYW5cIiA/IF9yZW5kZXJCb29sZWFuIDogX3JlbmRlclBsYWluLCAwLCBzZXR0ZXIpO1xuICAgICAgZnVuY1BhcmFtICYmIChwdC5mcCA9IGZ1bmNQYXJhbSk7XG4gICAgICBtb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdGhpcywgdGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzLl9wdCA9IHB0O1xuICAgIH1cblxuICAgICFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcbiAgICByZXR1cm4gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0aGlzLCB0YXJnZXQsIHByb3AsIHBhcnNlZFN0YXJ0LCBlbmQsIHNldHRlciwgc3RyaW5nRmlsdGVyIHx8IF9jb25maWcuc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pO1xuICB9XG59LFxuICAgIC8vY3JlYXRlcyBhIGNvcHkgb2YgdGhlIHZhcnMgb2JqZWN0IGFuZCBwcm9jZXNzZXMgYW55IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyAocHV0dGluZyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBjb3B5KSBhcyB3ZWxsIGFzIHN0cmluZ3Mgd2l0aCBcInJhbmRvbSgpXCIgaW4gdGhlbS4gSXQgZG9lcyBOT1QgcHJvY2VzcyByZWxhdGl2ZSB2YWx1ZXMuXG5fcHJvY2Vzc1ZhcnMgPSBmdW5jdGlvbiBfcHJvY2Vzc1ZhcnModmFycywgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pIHtcbiAgX2lzRnVuY3Rpb24odmFycykgJiYgKHZhcnMgPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICBpZiAoIV9pc09iamVjdCh2YXJzKSB8fCB2YXJzLnN0eWxlICYmIHZhcnMubm9kZVR5cGUgfHwgX2lzQXJyYXkodmFycykgfHwgX2lzVHlwZWRBcnJheSh2YXJzKSkge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFycykgPyBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFycztcbiAgfVxuXG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiB2YXJzKSB7XG4gICAgY29weVtwXSA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzW3BdLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2NoZWNrUGx1Z2luID0gZnVuY3Rpb24gX2NoZWNrUGx1Z2luKHByb3BlcnR5LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykge1xuICB2YXIgcGx1Z2luLCBwdCwgcHRMb29rdXAsIGk7XG5cbiAgaWYgKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3Byb3BlcnR5XSgpKS5pbml0KHRhcmdldCwgcGx1Z2luLnJhd1ZhcnMgPyB2YXJzW3Byb3BlcnR5XSA6IF9wcm9jZXNzVmFycyh2YXJzW3Byb3BlcnR5XSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgIGlmICh0d2VlbiAhPT0gX3F1aWNrVHdlZW4pIHtcbiAgICAgIHB0TG9va3VwID0gdHdlZW4uX3B0TG9va3VwW3R3ZWVuLl90YXJnZXRzLmluZGV4T2YodGFyZ2V0KV07IC8vbm90ZTogd2UgY2FuJ3QgdXNlIHR3ZWVuLl9wdExvb2t1cFtpbmRleF0gYmVjYXVzZSBmb3Igc3RhZ2dlcmVkIHR3ZWVucywgdGhlIGluZGV4IGZyb20gdGhlIGZ1bGxUYXJnZXRzIGFycmF5IHdvbid0IG1hdGNoIHdoYXQgaXQgaXMgaW4gZWFjaCBpbmRpdmlkdWFsIHR3ZWVuIHRoYXQgc3Bhd25zIGZyb20gdGhlIHN0YWdnZXIuXG5cbiAgICAgIGkgPSBwbHVnaW4uX3Byb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBwdExvb2t1cFtwbHVnaW4uX3Byb3BzW2ldXSA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59LFxuICAgIF9vdmVyd3JpdGluZ1R3ZWVuLFxuICAgIC8vc3RvcmUgYSByZWZlcmVuY2UgdGVtcG9yYXJpbHkgc28gd2UgY2FuIGF2b2lkIG92ZXJ3cml0aW5nIGl0c2VsZi5cbl9mb3JjZUFsbFByb3BUd2VlbnMsXG4gICAgX2luaXRUd2VlbiA9IGZ1bmN0aW9uIF9pbml0VHdlZW4odHdlZW4sIHRpbWUsIHRUaW1lKSB7XG4gIHZhciB2YXJzID0gdHdlZW4udmFycyxcbiAgICAgIGVhc2UgPSB2YXJzLmVhc2UsXG4gICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICBsYXp5ID0gdmFycy5sYXp5LFxuICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgcnVuQmFja3dhcmRzID0gdmFycy5ydW5CYWNrd2FyZHMsXG4gICAgICB5b3lvRWFzZSA9IHZhcnMueW95b0Vhc2UsXG4gICAgICBrZXlmcmFtZXMgPSB2YXJzLmtleWZyYW1lcyxcbiAgICAgIGF1dG9SZXZlcnQgPSB2YXJzLmF1dG9SZXZlcnQsXG4gICAgICBkdXIgPSB0d2Vlbi5fZHVyLFxuICAgICAgcHJldlN0YXJ0QXQgPSB0d2Vlbi5fc3RhcnRBdCxcbiAgICAgIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcbiAgICAgIHBhcmVudCA9IHR3ZWVuLnBhcmVudCxcbiAgICAgIGZ1bGxUYXJnZXRzID0gcGFyZW50ICYmIHBhcmVudC5kYXRhID09PSBcIm5lc3RlZFwiID8gcGFyZW50LnZhcnMudGFyZ2V0cyA6IHRhcmdldHMsXG4gICAgICBhdXRvT3ZlcndyaXRlID0gdHdlZW4uX292ZXJ3cml0ZSA9PT0gXCJhdXRvXCIgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgICB0bCA9IHR3ZWVuLnRpbWVsaW5lLFxuICAgICAgY2xlYW5WYXJzLFxuICAgICAgaSxcbiAgICAgIHAsXG4gICAgICBwdCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGhhc1ByaW9yaXR5LFxuICAgICAgZ3NEYXRhLFxuICAgICAgaGFybmVzcyxcbiAgICAgIHBsdWdpbixcbiAgICAgIHB0TG9va3VwLFxuICAgICAgaW5kZXgsXG4gICAgICBoYXJuZXNzVmFycyxcbiAgICAgIG92ZXJ3cml0dGVuO1xuICB0bCAmJiAoIWtleWZyYW1lcyB8fCAhZWFzZSkgJiYgKGVhc2UgPSBcIm5vbmVcIik7XG4gIHR3ZWVuLl9lYXNlID0gX3BhcnNlRWFzZShlYXNlLCBfZGVmYXVsdHMuZWFzZSk7XG4gIHR3ZWVuLl95RWFzZSA9IHlveW9FYXNlID8gX2ludmVydEVhc2UoX3BhcnNlRWFzZSh5b3lvRWFzZSA9PT0gdHJ1ZSA/IGVhc2UgOiB5b3lvRWFzZSwgX2RlZmF1bHRzLmVhc2UpKSA6IDA7XG5cbiAgaWYgKHlveW9FYXNlICYmIHR3ZWVuLl95b3lvICYmICF0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy90aGVyZSBtdXN0IGhhdmUgYmVlbiBhIHBhcmVudCB0aW1lbGluZSB3aXRoIHlveW86dHJ1ZSB0aGF0IGlzIGN1cnJlbnRseSBpbiBpdHMgeW95byBwaGFzZSwgc28gZmxpcCB0aGUgZWFzZXMuXG4gICAgeW95b0Vhc2UgPSB0d2Vlbi5feUVhc2U7XG4gICAgdHdlZW4uX3lFYXNlID0gdHdlZW4uX2Vhc2U7XG4gICAgdHdlZW4uX2Vhc2UgPSB5b3lvRWFzZTtcbiAgfVxuXG4gIHR3ZWVuLl9mcm9tID0gIXRsICYmICEhdmFycy5ydW5CYWNrd2FyZHM7IC8vbmVzdGVkIHRpbWVsaW5lcyBzaG91bGQgbmV2ZXIgcnVuIGJhY2t3YXJkcyAtIHRoZSBiYWNrd2FyZHMtbmVzcyBpcyBpbiB0aGUgY2hpbGQgdHdlZW5zLlxuXG4gIGlmICghdGwgfHwga2V5ZnJhbWVzICYmICF2YXJzLnN0YWdnZXIpIHtcbiAgICAvL2lmIHRoZXJlJ3MgYW4gaW50ZXJuYWwgdGltZWxpbmUsIHNraXAgYWxsIHRoZSBwYXJzaW5nIGJlY2F1c2Ugd2UgcGFzc2VkIHRoYXQgdGFzayBkb3duIHRoZSBjaGFpbi5cbiAgICBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMDtcbiAgICBoYXJuZXNzVmFycyA9IGhhcm5lc3MgJiYgdmFyc1toYXJuZXNzLnByb3BdOyAvL3NvbWVvbmUgbWF5IG5lZWQgdG8gc3BlY2lmeSBDU1Mtc3BlY2lmaWMgdmFsdWVzIEFORCBub24tQ1NTIHZhbHVlcywgbGlrZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gXCJ4XCIgcHJvcGVydHkgcGx1cyBpdCdzIGEgc3RhbmRhcmQgRE9NIGVsZW1lbnQuIFdlIGFsbG93IHBlb3BsZSB0byBkaXN0aW5ndWlzaCBieSB3cmFwcGluZyBwbHVnaW4tc3BlY2lmaWMgc3R1ZmYgaW4gYSBjc3M6e30gb2JqZWN0IGZvciBleGFtcGxlLlxuXG4gICAgY2xlYW5WYXJzID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3Jlc2VydmVkUHJvcHMpO1xuXG4gICAgaWYgKHByZXZTdGFydEF0KSB7XG4gICAgICBwcmV2U3RhcnRBdC5felRpbWUgPCAwICYmIHByZXZTdGFydEF0LnByb2dyZXNzKDEpOyAvLyBpbiBjYXNlIGl0J3MgYSBsYXp5IHN0YXJ0QXQgdGhhdCBoYXNuJ3QgcmVuZGVyZWQgeWV0LlxuXG4gICAgICB0aW1lIDwgMCAmJiBydW5CYWNrd2FyZHMgJiYgaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0ID8gcHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSA6IHByZXZTdGFydEF0LnJldmVydChydW5CYWNrd2FyZHMgJiYgZHVyID8gX3JldmVydENvbmZpZ05vS2lsbCA6IF9zdGFydEF0UmV2ZXJ0Q29uZmlnKTsgLy8gaWYgaXQncyBhIFwic3RhcnRBdFwiIChub3QgXCJmcm9tKClcIiBvciBydW5CYWNrd2FyZHM6IHRydWUpLCB3ZSBvbmx5IG5lZWQgdG8gZG8gYSBzaGFsbG93IHJldmVydCAoa2VlcCB0cmFuc2Zvcm1zIGNhY2hlZCBpbiBDU1NQbHVnaW4pXG4gICAgICAvLyBkb24ndCBqdXN0IF9yZW1vdmVGcm9tUGFyZW50KHByZXZTdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSkpIGJlY2F1c2UgdGhhdCdsbCBsZWF2ZSBpbmxpbmUgc3R5bGVzLiBXZSdyZSBjcmVhdGluZyBhIG5ldyBfc3RhcnRBdCBmb3IgXCJzdGFydEF0XCIgdHdlZW5zIHRoYXQgcmUtY2FwdHVyZSB0aGluZ3MgdG8gZW5zdXJlIHRoYXQgaWYgdGhlIHByZS10d2VlbiB2YWx1ZXMgY2hhbmdlZCBzaW5jZSB0aGUgdHdlZW4gd2FzIGNyZWF0ZWQsIHRoZXkncmUgcmVjb3JkZWQuXG5cbiAgICAgIHByZXZTdGFydEF0Ll9sYXp5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXG4gICAgICAgIGxhenk6ICFwcmV2U3RhcnRBdCAmJiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgc3RhcnRBdDogbnVsbCxcbiAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgIG9uVXBkYXRlOiBvblVwZGF0ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhZ2dlcjogMFxuICAgICAgfSwgc3RhcnRBdCkpKTsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIGZyb20sIHRvKS5mcm9tVG8oZSwgdG8sIGZyb20pO1xuXG5cbiAgICAgIHR3ZWVuLl9zdGFydEF0Ll9kcCA9IDA7IC8vIGRvbid0IGFsbG93IGl0IHRvIGdldCBwdXQgYmFjayBpbnRvIHJvb3QgdGltZWxpbmUhIExpa2Ugd2hlbiByZXZlcnQoKSBpcyBjYWxsZWQgYW5kIHRvdGFsVGltZSgpIGdldHMgc2V0LlxuXG4gICAgICB0d2Vlbi5fc3RhcnRBdC5fc2F0ID0gdHdlZW47IC8vIHVzZWQgaW4gZ2xvYmFsVGltZSgpLiBfc2F0IHN0YW5kcyBmb3IgX3N0YXJ0QXRUd2VlblxuXG4gICAgICB0aW1lIDwgMCAmJiAoX3JldmVydGluZyB8fCAhaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0KSAmJiB0d2Vlbi5fc3RhcnRBdC5yZXZlcnQoX3JldmVydENvbmZpZ05vS2lsbCk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgdHdlZW4uXG5cbiAgICAgIGlmIChpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgaWYgKGR1ciAmJiB0aW1lIDw9IDAgJiYgdFRpbWUgPD0gMCkge1xuICAgICAgICAgIC8vIGNoZWNrIHRUaW1lIGhlcmUgYmVjYXVzZSBpbiB0aGUgY2FzZSBvZiBhIHlveW8gdHdlZW4gd2hvc2UgcGxheWhlYWQgZ2V0cyBwdXNoZWQgdG8gdGhlIGVuZCBsaWtlIHR3ZWVuLnByb2dyZXNzKDEpLCB3ZSBzaG91bGQgYWxsb3cgaXQgdGhyb3VnaCBzbyB0aGF0IHRoZSBvbkNvbXBsZXRlIGdldHMgZmlyZWQgcHJvcGVybHkuXG4gICAgICAgICAgdGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG4gICAgICAgICAgcmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChydW5CYWNrd2FyZHMgJiYgZHVyKSB7XG4gICAgICAvL2Zyb20oKSB0d2VlbnMgbXVzdCBiZSBoYW5kbGVkIHVuaXF1ZWx5OiB0aGVpciBiZWdpbm5pbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQgYnV0IHdlIGRvbid0IHdhbnQgb3ZlcndyaXRpbmcgdG8gb2NjdXIgeWV0ICh3aGVuIHRpbWUgaXMgc3RpbGwgMCkuIFdhaXQgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucyBiZWZvcmUgZG9pbmcgYWxsIHRoZSByb3V0aW5lcyBsaWtlIG92ZXJ3cml0aW5nLiBBdCB0aGF0IHRpbWUsIHdlIHNob3VsZCByZW5kZXIgYXQgdGhlIEVORCBvZiB0aGUgdHdlZW4gdG8gZW5zdXJlIHRoYXQgdGhpbmdzIGluaXRpYWxpemUgY29ycmVjdGx5IChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBnbyBiYWNrd2FyZHMpXG4gICAgICBpZiAoIXByZXZTdGFydEF0KSB7XG4gICAgICAgIHRpbWUgJiYgKGltbWVkaWF0ZVJlbmRlciA9IGZhbHNlKTsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblxuICAgICAgICBwID0gX3NldERlZmF1bHRzKHtcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGRhdGE6IFwiaXNGcm9tU3RhcnRcIixcbiAgICAgICAgICAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cbiAgICAgICAgICBsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgIXByZXZTdGFydEF0ICYmIF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICAgIGltbWVkaWF0ZVJlbmRlcjogaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICAgIC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcbiAgICAgICAgICBzdGFnZ2VyOiAwLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50IC8vZW5zdXJlcyB0aGF0IG5lc3RlZCB0d2VlbnMgdGhhdCBoYWQgYSBzdGFnZ2VyIGFyZSBoYW5kbGVkIHByb3Blcmx5LCBsaWtlIGdzYXAuZnJvbShcIi5jbGFzc1wiLCB7eTogZ3NhcC51dGlscy53cmFwKFstMTAwLDEwMF0pLCBzdGFnZ2VyOiAwLjV9KVxuXG4gICAgICAgIH0sIGNsZWFuVmFycyk7XG4gICAgICAgIGhhcm5lc3NWYXJzICYmIChwW2hhcm5lc3MucHJvcF0gPSBoYXJuZXNzVmFycyk7IC8vIGluIGNhc2Ugc29tZW9uZSBkb2VzIHNvbWV0aGluZyBsaWtlIC5mcm9tKC4uLiwge2Nzczp7fX0pXG5cbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgcCkpO1xuXG4gICAgICAgIHR3ZWVuLl9zdGFydEF0Ll9kcCA9IDA7IC8vIGRvbid0IGFsbG93IGl0IHRvIGdldCBwdXQgYmFjayBpbnRvIHJvb3QgdGltZWxpbmUhXG5cbiAgICAgICAgdHdlZW4uX3N0YXJ0QXQuX3NhdCA9IHR3ZWVuOyAvLyB1c2VkIGluIGdsb2JhbFRpbWUoKVxuXG4gICAgICAgIHRpbWUgPCAwICYmIChfcmV2ZXJ0aW5nID8gdHdlZW4uX3N0YXJ0QXQucmV2ZXJ0KF9yZXZlcnRDb25maWdOb0tpbGwpIDogdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSk7XG4gICAgICAgIHR3ZWVuLl96VGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKCFpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgICBfaW5pdFR3ZWVuKHR3ZWVuLl9zdGFydEF0LCBfdGlueU51bSwgX3RpbnlOdW0pOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cbiAgICAgICAgfSBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHR3ZWVuLl9wdCA9IHR3ZWVuLl9wdENhY2hlID0gMDtcbiAgICBsYXp5ID0gZHVyICYmIF9pc05vdEZhbHNlKGxhenkpIHx8IGxhenkgJiYgIWR1cjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgZ3NEYXRhID0gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRhcmdldHMpW2ldLl9nc2FwO1xuICAgICAgdHdlZW4uX3B0TG9va3VwW2ldID0gcHRMb29rdXAgPSB7fTtcbiAgICAgIF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gJiYgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cbiAgICAgIGluZGV4ID0gZnVsbFRhcmdldHMgPT09IHRhcmdldHMgPyBpIDogZnVsbFRhcmdldHMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgICBpZiAoaGFybmVzcyAmJiAocGx1Z2luID0gbmV3IGhhcm5lc3MoKSkuaW5pdCh0YXJnZXQsIGhhcm5lc3NWYXJzIHx8IGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCBmdWxsVGFyZ2V0cykgIT09IGZhbHNlKSB7XG4gICAgICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcGx1Z2luLm5hbWUsIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgICAgICBwbHVnaW4uX3Byb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBwdExvb2t1cFtuYW1lXSA9IHB0O1xuICAgICAgICB9KTtcblxuICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFybmVzcyB8fCBoYXJuZXNzVmFycykge1xuICAgICAgICBmb3IgKHAgaW4gY2xlYW5WYXJzKSB7XG4gICAgICAgICAgaWYgKF9wbHVnaW5zW3BdICYmIChwbHVnaW4gPSBfY2hlY2tQbHVnaW4ocCwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgZnVsbFRhcmdldHMpKSkge1xuICAgICAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdExvb2t1cFtwXSA9IHB0ID0gX2FkZFByb3BUd2Vlbi5jYWxsKHR3ZWVuLCB0YXJnZXQsIHAsIFwiZ2V0XCIsIGNsZWFuVmFyc1twXSwgaW5kZXgsIGZ1bGxUYXJnZXRzLCAwLCB2YXJzLnN0cmluZ0ZpbHRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHR3ZWVuLl9vcCAmJiB0d2Vlbi5fb3BbaV0gJiYgdHdlZW4ua2lsbCh0YXJnZXQsIHR3ZWVuLl9vcFtpXSk7XG5cbiAgICAgIGlmIChhdXRvT3ZlcndyaXRlICYmIHR3ZWVuLl9wdCkge1xuICAgICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IHR3ZWVuO1xuXG4gICAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0LCBwdExvb2t1cCwgdHdlZW4uZ2xvYmFsVGltZSh0aW1lKSk7IC8vIG1ha2Ugc3VyZSB0aGUgb3ZlcndyaXRpbmcgZG9lc24ndCBvdmVyd3JpdGUgVEhJUyB0d2VlbiEhIVxuXG5cbiAgICAgICAgb3ZlcndyaXR0ZW4gPSAhdHdlZW4ucGFyZW50O1xuICAgICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHR3ZWVuLl9wdCAmJiBsYXp5ICYmIChfbGF6eUxvb2t1cFtnc0RhdGEuaWRdID0gMSk7XG4gICAgfVxuXG4gICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0d2Vlbik7XG4gICAgdHdlZW4uX29uSW5pdCAmJiB0d2Vlbi5fb25Jbml0KHR3ZWVuKTsgLy9wbHVnaW5zIGxpa2UgUm91bmRQcm9wcyBtdXN0IHdhaXQgdW50aWwgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIGFyZSBpbnN0YW50aWF0ZWQuIEluIHRoZSBwbHVnaW4ncyBpbml0KCkgZnVuY3Rpb24sIGl0IHNldHMgdGhlIF9vbkluaXQgb24gdGhlIHR3ZWVuIGluc3RhbmNlLiBNYXkgbm90IGJlIHByZXR0eS9pbnR1aXRpdmUsIGJ1dCBpdCdzIGZhc3QgYW5kIGtlZXBzIGZpbGUgc2l6ZSBkb3duLlxuICB9XG5cbiAgdHdlZW4uX29uVXBkYXRlID0gb25VcGRhdGU7XG4gIHR3ZWVuLl9pbml0dGVkID0gKCF0d2Vlbi5fb3AgfHwgdHdlZW4uX3B0KSAmJiAhb3ZlcndyaXR0ZW47IC8vIGlmIG92ZXJ3cml0dGVuUHJvcHMgcmVzdWx0ZWQgaW4gdGhlIGVudGlyZSB0d2VlbiBiZWluZyBraWxsZWQsIGRvIE5PVCBmbGFnIGl0IGFzIGluaXR0ZWQgb3IgZWxzZSBpdCBtYXkgcmVuZGVyIGZvciBvbmUgdGljay5cblxuICBrZXlmcmFtZXMgJiYgdGltZSA8PSAwICYmIHRsLnJlbmRlcihfYmlnTnVtLCB0cnVlLCB0cnVlKTsgLy8gaWYgdGhlcmUncyBhIDAlIGtleWZyYW1lLCBpdCdsbCByZW5kZXIgaW4gdGhlIFwiYmVmb3JlXCIgc3RhdGUgZm9yIGFueSBzdGFnZ2VyZWQvZGVsYXllZCBhbmltYXRpb25zIHRodXMgd2hlbiB0aGUgZm9sbG93aW5nIHR3ZWVuIGluaXRpYWxpemVzLCBpdCdsbCB1c2UgdGhlIFwiYmVmb3JlXCIgc3RhdGUgaW5zdGVhZCBvZiB0aGUgXCJhZnRlclwiIHN0YXRlIGFzIHRoZSBpbml0aWFsIHZhbHVlcy5cbn0sXG4gICAgX3VwZGF0ZVByb3BUd2VlbnMgPSBmdW5jdGlvbiBfdXBkYXRlUHJvcFR3ZWVucyh0d2VlbiwgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSwgc2tpcFJlY3Vyc2lvbikge1xuICB2YXIgcHRDYWNoZSA9ICh0d2Vlbi5fcHQgJiYgdHdlZW4uX3B0Q2FjaGUgfHwgKHR3ZWVuLl9wdENhY2hlID0ge30pKVtwcm9wZXJ0eV0sXG4gICAgICBwdCxcbiAgICAgIHJvb3RQVCxcbiAgICAgIGxvb2t1cCxcbiAgICAgIGk7XG5cbiAgaWYgKCFwdENhY2hlKSB7XG4gICAgcHRDYWNoZSA9IHR3ZWVuLl9wdENhY2hlW3Byb3BlcnR5XSA9IFtdO1xuICAgIGxvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cDtcbiAgICBpID0gdHdlZW4uX3RhcmdldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcHQgPSBsb29rdXBbaV1bcHJvcGVydHldO1xuXG4gICAgICBpZiAocHQgJiYgcHQuZCAmJiBwdC5kLl9wdCkge1xuICAgICAgICAvLyBpdCdzIGEgcGx1Z2luLCBzbyBmaW5kIHRoZSBuZXN0ZWQgUHJvcFR3ZWVuXG4gICAgICAgIHB0ID0gcHQuZC5fcHQ7XG5cbiAgICAgICAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3BlcnR5ICYmIHB0LmZwICE9PSBwcm9wZXJ0eSkge1xuICAgICAgICAgIC8vIFwiZnBcIiBpcyBmdW5jdGlvblBhcmFtIGZvciB0aGluZ3MgbGlrZSBzZXR0aW5nIENTUyB2YXJpYWJsZXMgd2hpY2ggcmVxdWlyZSAuc2V0UHJvcGVydHkoXCItLXZhci1uYW1lXCIsIHZhbHVlKVxuICAgICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwdCkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIHRoYXQgcHJvcGVydHksIHNvIHdlIG11c3QgRk9SQ0Ugb25lIHRvIGJlIGNyZWF0ZWQgYW5kIGRpdGNoIG91dCBvZiB0aGlzXG4gICAgICAgIC8vIGlmIHRoZSB0d2VlbiBoYXMgb3RoZXIgcHJvcGVydGllcyB0aGF0IGFscmVhZHkgcmVuZGVyZWQgYXQgbmV3IHBvc2l0aW9ucywgd2UnZCBub3JtYWxseSBoYXZlIHRvIHJld2luZCB0byBwdXQgdGhlbSBiYWNrIGxpa2UgdHdlZW4ucmVuZGVyKDAsIHRydWUpIGJlZm9yZSBmb3JjaW5nIGFuIF9pbml0VHdlZW4oKSwgYnV0IHRoYXQgY2FuIGNyZWF0ZSBhbm90aGVyIGVkZ2UgY2FzZSBsaWtlIHR3ZWVuaW5nIGEgdGltZWxpbmUncyBwcm9ncmVzcyB3b3VsZCB0cmlnZ2VyIG9uVXBkYXRlcyB0byBmaXJlIHdoaWNoIGNvdWxkIG1vdmUgb3RoZXIgdGhpbmdzIGFyb3VuZC4gSXQncyBiZXR0ZXIgdG8ganVzdCBpbmZvcm0gdXNlcnMgdGhhdCAucmVzZXRUbygpIHNob3VsZCBPTkxZIGJlIHVzZWQgZm9yIHR3ZWVucyB0aGF0IGFscmVhZHkgaGF2ZSB0aGF0IHByb3BlcnR5LiBGb3IgZXhhbXBsZSwgeW91IGNhbid0IGdzYXAudG8oLi4ueyB5OiAwIH0pIGFuZCB0aGVuIHR3ZWVuLnJlc3RUbyhcInhcIiwgMjAwKSBmb3IgZXhhbXBsZS5cbiAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDE7IC8vIG90aGVyd2lzZSwgd2hlbiB3ZSBfYWRkUHJvcFR3ZWVuKCkgYW5kIGl0IGZpbmRzIG5vIGNoYW5nZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcywgaXQgc2tpcHMgY3JlYXRpbmcgYSBQcm9wVHdlZW4gKGZvciBlZmZpY2llbmN5Li4ud2h5IHR3ZWVuIHdoZW4gdGhlcmUncyBubyBkaWZmZXJlbmNlPykgYnV0IGluIHRoaXMgY2FzZSB3ZSBORUVEIHRoYXQgUHJvcFR3ZWVuIGNyZWF0ZWQgc28gd2UgY2FuIGVkaXQgaXQuXG5cbiAgICAgICAgdHdlZW4udmFyc1twcm9wZXJ0eV0gPSBcIis9MFwiO1xuXG4gICAgICAgIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpO1xuXG4gICAgICAgIF9mb3JjZUFsbFByb3BUd2VlbnMgPSAwO1xuICAgICAgICByZXR1cm4gc2tpcFJlY3Vyc2lvbiA/IF93YXJuKHByb3BlcnR5ICsgXCIgbm90IGVsaWdpYmxlIGZvciByZXNldFwiKSA6IDE7IC8vIGlmIHNvbWVvbmUgdHJpZXMgdG8gZG8gYSBxdWlja1RvKCkgb24gYSBzcGVjaWFsIHByb3BlcnR5IGxpa2UgYm9yZGVyUmFkaXVzIHdoaWNoIG11c3QgZ2V0IHNwbGl0IGludG8gNCBkaWZmZXJlbnQgcHJvcGVydGllcywgdGhhdCdzIG5vdCBlbGlnaWJsZSBmb3IgLnJlc2V0VG8oKS5cbiAgICAgIH1cblxuICAgICAgcHRDYWNoZS5wdXNoKHB0KTtcbiAgICB9XG4gIH1cblxuICBpID0gcHRDYWNoZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHJvb3RQVCA9IHB0Q2FjaGVbaV07XG4gICAgcHQgPSByb290UFQuX3B0IHx8IHJvb3RQVDsgLy8gY29tcGxleCB2YWx1ZXMgbWF5IGhhdmUgbmVzdGVkIFByb3BUd2VlbnMuIFdlIG9ubHkgYWNjb21tb2RhdGUgdGhlIEZJUlNUIHZhbHVlLlxuXG4gICAgcHQucyA9IChzdGFydCB8fCBzdGFydCA9PT0gMCkgJiYgIXN0YXJ0SXNSZWxhdGl2ZSA/IHN0YXJ0IDogcHQucyArIChzdGFydCB8fCAwKSArIHJhdGlvICogcHQuYztcbiAgICBwdC5jID0gdmFsdWUgLSBwdC5zO1xuICAgIHJvb3RQVC5lICYmIChyb290UFQuZSA9IF9yb3VuZCh2YWx1ZSkgKyBnZXRVbml0KHJvb3RQVC5lKSk7IC8vIG1haW5seSBmb3IgQ1NTUGx1Z2luIChlbmQgdmFsdWUpXG5cbiAgICByb290UFQuYiAmJiAocm9vdFBULmIgPSBwdC5zICsgZ2V0VW5pdChyb290UFQuYikpOyAvLyAoYmVnaW5uaW5nIHZhbHVlKVxuICB9XG59LFxuICAgIF9hZGRBbGlhc2VzVG9WYXJzID0gZnVuY3Rpb24gX2FkZEFsaWFzZXNUb1ZhcnModGFyZ2V0cywgdmFycykge1xuICB2YXIgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDAsXG4gICAgICBwcm9wZXJ0eUFsaWFzZXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyxcbiAgICAgIGNvcHksXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIGFsaWFzZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICByZXR1cm4gdmFycztcbiAgfVxuXG4gIGNvcHkgPSBfbWVyZ2Uoe30sIHZhcnMpO1xuXG4gIGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICBpZiAocCBpbiBjb3B5KSB7XG4gICAgICBhbGlhc2VzID0gcHJvcGVydHlBbGlhc2VzW3BdLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBhbGlhc2VzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb3B5W2FsaWFzZXNbaV1dID0gY29weVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgLy8gcGFyc2VzIG11bHRpcGxlIGZvcm1hdHMsIGxpa2Uge1wiMCVcIjoge3g6IDEwMH0sIHtcIjUwJVwiOiB7eDogLTIwfX0gYW5kIHsgeDoge1wiMCVcIjogMTAwLCBcIjUwJVwiOiAtMjB9IH0sIGFuZCBhbiBcImVhc2VcIiBjYW4gYmUgc2V0IG9uIGFueSBvYmplY3QuIFdlIHBvcHVsYXRlIGFuIFwiYWxsUHJvcHNcIiBvYmplY3Qgd2l0aCBhbiBBcnJheSBmb3IgZWFjaCBwcm9wZXJ0eSwgbGlrZSB7eDogW3t9LCB7fV0sIHk6W3t9LCB7fV19IHdpdGggZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eSB0d2Vlbi4gVGhlIG9iamVjdHMgaGF2ZSBhIFwidFwiICh0aW1lKSwgXCJ2XCIsICh2YWx1ZSksIGFuZCBcImVcIiAoZWFzZSkgcHJvcGVydHkuIFRoaXMgYWxsb3dzIHVzIHRvIHBpZWNlIHRvZ2V0aGVyIGEgdGltZWxpbmUgbGF0ZXIuXG5fcGFyc2VLZXlmcmFtZSA9IGZ1bmN0aW9uIF9wYXJzZUtleWZyYW1lKHByb3AsIG9iaiwgYWxsUHJvcHMsIGVhc2VFYWNoKSB7XG4gIHZhciBlYXNlID0gb2JqLmVhc2UgfHwgZWFzZUVhY2ggfHwgXCJwb3dlcjEuaW5PdXRcIixcbiAgICAgIHAsXG4gICAgICBhO1xuXG4gIGlmIChfaXNBcnJheShvYmopKSB7XG4gICAgYSA9IGFsbFByb3BzW3Byb3BdIHx8IChhbGxQcm9wc1twcm9wXSA9IFtdKTsgLy8gdCA9IHRpbWUgKG91dCBvZiAxMDApLCB2ID0gdmFsdWUsIGUgPSBlYXNlXG5cbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgIHJldHVybiBhLnB1c2goe1xuICAgICAgICB0OiBpIC8gKG9iai5sZW5ndGggLSAxKSAqIDEwMCxcbiAgICAgICAgdjogdmFsdWUsXG4gICAgICAgIGU6IGVhc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZvciAocCBpbiBvYmopIHtcbiAgICAgIGEgPSBhbGxQcm9wc1twXSB8fCAoYWxsUHJvcHNbcF0gPSBbXSk7XG4gICAgICBwID09PSBcImVhc2VcIiB8fCBhLnB1c2goe1xuICAgICAgICB0OiBwYXJzZUZsb2F0KHByb3ApLFxuICAgICAgICB2OiBvYmpbcF0sXG4gICAgICAgIGU6IGVhc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfcGFyc2VGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VGdW5jT3JTdHJpbmcodmFsdWUsIHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgOiBfaXNTdHJpbmcodmFsdWUpICYmIH52YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSA/IF9yZXBsYWNlUmFuZG9tKHZhbHVlKSA6IHZhbHVlO1xufSxcbiAgICBfc3RhZ2dlclR3ZWVuUHJvcHMgPSBfY2FsbGJhY2tOYW1lcyArIFwicmVwZWF0LHJlcGVhdERlbGF5LHlveW8scmVwZWF0UmVmcmVzaCx5b3lvRWFzZSxhdXRvUmV2ZXJ0XCIsXG4gICAgX3N0YWdnZXJQcm9wc1RvU2tpcCA9IHt9O1xuXG5fZm9yRWFjaE5hbWUoX3N0YWdnZXJUd2VlblByb3BzICsgXCIsaWQsc3RhZ2dlcixkZWxheSxkdXJhdGlvbixwYXVzZWQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX3N0YWdnZXJQcm9wc1RvU2tpcFtuYW1lXSA9IDE7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uMikge1xuICBfaW5oZXJpdHNMb29zZShUd2VlbiwgX0FuaW1hdGlvbjIpO1xuXG4gIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uLCBza2lwSW5oZXJpdCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBpZiAodHlwZW9mIHZhcnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHBvc2l0aW9uLmR1cmF0aW9uID0gdmFycztcbiAgICAgIHZhcnMgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfQW5pbWF0aW9uMi5jYWxsKHRoaXMsIHNraXBJbmhlcml0ID8gdmFycyA6IF9pbmhlcml0RGVmYXVsdHModmFycykpIHx8IHRoaXM7XG4gICAgdmFyIF90aGlzMyR2YXJzID0gX3RoaXMzLnZhcnMsXG4gICAgICAgIGR1cmF0aW9uID0gX3RoaXMzJHZhcnMuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX3RoaXMzJHZhcnMuZGVsYXksXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF90aGlzMyR2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgc3RhZ2dlciA9IF90aGlzMyR2YXJzLnN0YWdnZXIsXG4gICAgICAgIG92ZXJ3cml0ZSA9IF90aGlzMyR2YXJzLm92ZXJ3cml0ZSxcbiAgICAgICAga2V5ZnJhbWVzID0gX3RoaXMzJHZhcnMua2V5ZnJhbWVzLFxuICAgICAgICBkZWZhdWx0cyA9IF90aGlzMyR2YXJzLmRlZmF1bHRzLFxuICAgICAgICBzY3JvbGxUcmlnZ2VyID0gX3RoaXMzJHZhcnMuc2Nyb2xsVHJpZ2dlcixcbiAgICAgICAgeW95b0Vhc2UgPSBfdGhpczMkdmFycy55b3lvRWFzZSxcbiAgICAgICAgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgICBwYXJzZWRUYXJnZXRzID0gKF9pc0FycmF5KHRhcmdldHMpIHx8IF9pc1R5cGVkQXJyYXkodGFyZ2V0cykgPyBfaXNOdW1iZXIodGFyZ2V0c1swXSkgOiBcImxlbmd0aFwiIGluIHZhcnMpID8gW3RhcmdldHNdIDogdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgdGwsXG4gICAgICAgIGksXG4gICAgICAgIGNvcHksXG4gICAgICAgIGwsXG4gICAgICAgIHAsXG4gICAgICAgIGN1clRhcmdldCxcbiAgICAgICAgc3RhZ2dlckZ1bmMsXG4gICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZTtcbiAgICBfdGhpczMuX3RhcmdldHMgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aCA/IF9oYXJuZXNzKHBhcnNlZFRhcmdldHMpIDogX3dhcm4oXCJHU0FQIHRhcmdldCBcIiArIHRhcmdldHMgKyBcIiBub3QgZm91bmQuIGh0dHBzOi8vZ3NhcC5jb21cIiwgIV9jb25maWcubnVsbFRhcmdldFdhcm4pIHx8IFtdO1xuICAgIF90aGlzMy5fcHRMb29rdXAgPSBbXTsgLy9Qcm9wVHdlZW4gbG9va3VwLiBBbiBhcnJheSBjb250YWluaW5nIGFuIG9iamVjdCBmb3IgZWFjaCB0YXJnZXQsIGhhdmluZyBrZXlzIGZvciBlYWNoIHR3ZWVuaW5nIHByb3BlcnR5XG5cbiAgICBfdGhpczMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcblxuICAgIGlmIChrZXlmcmFtZXMgfHwgc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgIHZhcnMgPSBfdGhpczMudmFycztcbiAgICAgIHRsID0gX3RoaXMzLnRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgICAgICAgZGF0YTogXCJuZXN0ZWRcIixcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzIHx8IHt9LFxuICAgICAgICB0YXJnZXRzOiBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQudmFycy50YXJnZXRzIDogcGFyc2VkVGFyZ2V0c1xuICAgICAgfSk7IC8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIHRhcmdldHMgYmVjYXVzZSBmb3Igc3RhZ2dlcnMgYW5kIGtleWZyYW1lcywgd2UgZW5kIHVwIGNyZWF0aW5nIGFuIGluZGl2aWR1YWwgdHdlZW4gZm9yIGVhY2ggYnV0IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBuZWVkIHRvIGtub3cgdGhlIGluZGV4IGFuZCB0aGUgd2hvbGUgQXJyYXkgb2YgdGFyZ2V0cy5cblxuICAgICAgdGwua2lsbCgpO1xuICAgICAgdGwucGFyZW50ID0gdGwuX2RwID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuICAgICAgdGwuX3N0YXJ0ID0gMDtcblxuICAgICAgaWYgKHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICAgIGwgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcbiAgICAgICAgc3RhZ2dlckZ1bmMgPSBzdGFnZ2VyICYmIGRpc3RyaWJ1dGUoc3RhZ2dlcik7XG5cbiAgICAgICAgaWYgKF9pc09iamVjdChzdGFnZ2VyKSkge1xuICAgICAgICAgIC8vdXNlcnMgY2FuIHBhc3MgaW4gY2FsbGJhY2tzIGxpa2Ugb25TdGFydC9vbkNvbXBsZXRlIGluIHRoZSBzdGFnZ2VyIG9iamVjdC4gVGhlc2Ugc2hvdWxkIGZpcmUgd2l0aCBlYWNoIGluZGl2aWR1YWwgdHdlZW4uXG4gICAgICAgICAgZm9yIChwIGluIHN0YWdnZXIpIHtcbiAgICAgICAgICAgIGlmICh+X3N0YWdnZXJUd2VlblByb3BzLmluZGV4T2YocCkpIHtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlIHx8IChzdGFnZ2VyVmFyc1RvTWVyZ2UgPSB7fSk7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZVtwXSA9IHN0YWdnZXJbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvcHkgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfc3RhZ2dlclByb3BzVG9Ta2lwKTtcbiAgICAgICAgICBjb3B5LnN0YWdnZXIgPSAwO1xuICAgICAgICAgIHlveW9FYXNlICYmIChjb3B5LnlveW9FYXNlID0geW95b0Vhc2UpO1xuICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSAmJiBfbWVyZ2UoY29weSwgc3RhZ2dlclZhcnNUb01lcmdlKTtcbiAgICAgICAgICBjdXJUYXJnZXQgPSBwYXJzZWRUYXJnZXRzW2ldOyAvL2Rvbid0IGp1c3QgY29weSBkdXJhdGlvbiBvciBkZWxheSBiZWNhdXNlIGlmIHRoZXkncmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24sIHdlJ2QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBfaXNGdW5jT3JTdHJpbmcoKSB3b3VsZCBldmFsdWF0ZSBhcyB0cnVlIGluIHRoZSBjaGlsZCB0d2VlbnMsIGVudGVyaW5nIHRoaXMgbG9vcCwgZXRjLiBTbyB3ZSBwYXJzZSB0aGUgdmFsdWUgc3RyYWlnaHQgZnJvbSB2YXJzIGFuZCBkZWZhdWx0IHRvIDAuXG5cbiAgICAgICAgICBjb3B5LmR1cmF0aW9uID0gK19wYXJzZUZ1bmNPclN0cmluZyhkdXJhdGlvbiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpO1xuICAgICAgICAgIGNvcHkuZGVsYXkgPSAoK19wYXJzZUZ1bmNPclN0cmluZyhkZWxheSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIHx8IDApIC0gX3RoaXMzLl9kZWxheTtcblxuICAgICAgICAgIGlmICghc3RhZ2dlciAmJiBsID09PSAxICYmIGNvcHkuZGVsYXkpIHtcbiAgICAgICAgICAgIC8vIGlmIHNvbWVvbmUgZG9lcyBkZWxheTpcInJhbmRvbSgxLCA1KVwiLCByZXBlYXQ6LTEsIGZvciBleGFtcGxlLCB0aGUgZGVsYXkgc2hvdWxkbid0IGJlIGluc2lkZSB0aGUgcmVwZWF0LlxuICAgICAgICAgICAgX3RoaXMzLl9kZWxheSA9IGRlbGF5ID0gY29weS5kZWxheTtcbiAgICAgICAgICAgIF90aGlzMy5fc3RhcnQgKz0gZGVsYXk7XG4gICAgICAgICAgICBjb3B5LmRlbGF5ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC50byhjdXJUYXJnZXQsIGNvcHksIHN0YWdnZXJGdW5jID8gc3RhZ2dlckZ1bmMoaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSA6IDApO1xuICAgICAgICAgIHRsLl9lYXNlID0gX2Vhc2VNYXAubm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRsLmR1cmF0aW9uKCkgPyBkdXJhdGlvbiA9IGRlbGF5ID0gMCA6IF90aGlzMy50aW1lbGluZSA9IDA7IC8vIGlmIHRoZSB0aW1lbGluZSdzIGR1cmF0aW9uIGlzIDAsIHdlIGRvbid0IG5lZWQgYSB0aW1lbGluZSBpbnRlcm5hbGx5IVxuICAgICAgfSBlbHNlIGlmIChrZXlmcmFtZXMpIHtcbiAgICAgICAgX2luaGVyaXREZWZhdWx0cyhfc2V0RGVmYXVsdHModGwudmFycy5kZWZhdWx0cywge1xuICAgICAgICAgIGVhc2U6IFwibm9uZVwiXG4gICAgICAgIH0pKTtcblxuICAgICAgICB0bC5fZWFzZSA9IF9wYXJzZUVhc2Uoa2V5ZnJhbWVzLmVhc2UgfHwgdmFycy5lYXNlIHx8IFwibm9uZVwiKTtcbiAgICAgICAgdmFyIHRpbWUgPSAwLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGtmLFxuICAgICAgICAgICAgdjtcblxuICAgICAgICBpZiAoX2lzQXJyYXkoa2V5ZnJhbWVzKSkge1xuICAgICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRsLnRvKHBhcnNlZFRhcmdldHMsIGZyYW1lLCBcIj5cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGwuZHVyYXRpb24oKTsgLy8gdG8gZW5zdXJlIHRsLl9kdXIgaXMgY2FjaGVkIGJlY2F1c2Ugd2UgdGFwIGludG8gaXQgZm9yIHBlcmZvcm1hbmNlIHB1cnBvc2VzIGluIHRoZSByZW5kZXIoKSBtZXRob2QuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weSA9IHt9O1xuXG4gICAgICAgICAgZm9yIChwIGluIGtleWZyYW1lcykge1xuICAgICAgICAgICAgcCA9PT0gXCJlYXNlXCIgfHwgcCA9PT0gXCJlYXNlRWFjaFwiIHx8IF9wYXJzZUtleWZyYW1lKHAsIGtleWZyYW1lc1twXSwgY29weSwga2V5ZnJhbWVzLmVhc2VFYWNoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHAgaW4gY29weSkge1xuICAgICAgICAgICAgYSA9IGNvcHlbcF0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYS50IC0gYi50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aW1lID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAga2YgPSBhW2ldO1xuICAgICAgICAgICAgICB2ID0ge1xuICAgICAgICAgICAgICAgIGVhc2U6IGtmLmUsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IChrZi50IC0gKGkgPyBhW2kgLSAxXS50IDogMCkpIC8gMTAwICogZHVyYXRpb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdltwXSA9IGtmLnY7XG4gICAgICAgICAgICAgIHRsLnRvKHBhcnNlZFRhcmdldHMsIHYsIHRpbWUpO1xuICAgICAgICAgICAgICB0aW1lICs9IHYuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGwuZHVyYXRpb24oKSA8IGR1cmF0aW9uICYmIHRsLnRvKHt9LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gLSB0bC5kdXJhdGlvbigpXG4gICAgICAgICAgfSk7IC8vIGluIGNhc2Uga2V5ZnJhbWVzIGRpZG4ndCBnbyB0byAxMDAlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZHVyYXRpb24gfHwgX3RoaXMzLmR1cmF0aW9uKGR1cmF0aW9uID0gdGwuZHVyYXRpb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzMy50aW1lbGluZSA9IDA7IC8vc3BlZWQgb3B0aW1pemF0aW9uLCBmYXN0ZXIgbG9va3VwcyAobm8gZ29pbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbilcbiAgICB9XG5cbiAgICBpZiAob3ZlcndyaXRlID09PSB0cnVlICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzKSB7XG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcblxuICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZihwYXJzZWRUYXJnZXRzKTtcblxuICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgIH1cblxuICAgIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBwb3NpdGlvbik7XG5cbiAgICB2YXJzLnJldmVyc2VkICYmIF90aGlzMy5yZXZlcnNlKCk7XG4gICAgdmFycy5wYXVzZWQgJiYgX3RoaXMzLnBhdXNlZCh0cnVlKTtcblxuICAgIGlmIChpbW1lZGlhdGVSZW5kZXIgfHwgIWR1cmF0aW9uICYmICFrZXlmcmFtZXMgJiYgX3RoaXMzLl9zdGFydCA9PT0gX3JvdW5kUHJlY2lzZShwYXJlbnQuX3RpbWUpICYmIF9pc05vdEZhbHNlKGltbWVkaWF0ZVJlbmRlcikgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSkgJiYgcGFyZW50LmRhdGEgIT09IFwibmVzdGVkXCIpIHtcbiAgICAgIF90aGlzMy5fdFRpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXG4gICAgICBfdGhpczMucmVuZGVyKE1hdGgubWF4KDAsIC1kZWxheSkgfHwgMCk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXG4gICAgfVxuXG4gICAgc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIGlzTmVnYXRpdmUgPSB0b3RhbFRpbWUgPCAwLFxuICAgICAgICB0VGltZSA9IHRvdGFsVGltZSA+IHREdXIgLSBfdGlueU51bSAmJiAhaXNOZWdhdGl2ZSA/IHREdXIgOiB0b3RhbFRpbWUgPCBfdGlueU51bSA/IDAgOiB0b3RhbFRpbWUsXG4gICAgICAgIHRpbWUsXG4gICAgICAgIHB0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgIGlzWW95byxcbiAgICAgICAgcmF0aW8sXG4gICAgICAgIHRpbWVsaW5lLFxuICAgICAgICB5b3lvRWFzZTtcblxuICAgIGlmICghZHVyKSB7XG4gICAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgIH0gZWxzZSBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8ICF0b3RhbFRpbWUgfHwgZm9yY2UgfHwgIXRoaXMuX2luaXR0ZWQgJiYgdGhpcy5fdFRpbWUgfHwgdGhpcy5fc3RhcnRBdCAmJiB0aGlzLl96VGltZSA8IDAgIT09IGlzTmVnYXRpdmUpIHtcbiAgICAgIC8vdGhpcyBzZW5zZXMgaWYgd2UncmUgY3Jvc3Npbmcgb3ZlciB0aGUgc3RhcnQgdGltZSwgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHJlY29yZCBfelRpbWUgYW5kIGZvcmNlIHRoZSByZW5kZXIsIGJ1dCB3ZSBkbyBpdCBpbiB0aGlzIGxlbmd0aHkgY29uZGl0aW9uYWwgd2F5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zICh1c3VhbGx5IHdlIGNhbiBza2lwIHRoZSBjYWxjdWxhdGlvbnMpOiB0aGlzLl9pbml0dGVkICYmICh0aGlzLl96VGltZSA8IDApICE9PSAodG90YWxUaW1lIDwgMClcbiAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgIHRpbWVsaW5lID0gdGhpcy50aW1lbGluZTtcblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0IDwgLTEgJiYgaXNOZWdhdGl2ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gX3JvdW5kUHJlY2lzZSh0VGltZSAvIGN5Y2xlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBpc1lveW8gPSB0aGlzLl95b3lvICYmIGl0ZXJhdGlvbiAmIDE7XG5cbiAgICAgICAgaWYgKGlzWW95bykge1xuICAgICAgICAgIHlveW9FYXNlID0gdGhpcy5feUVhc2U7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICBpZiAodGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlICYmIHRoaXMuX2luaXR0ZWQgJiYgaXRlcmF0aW9uID09PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgLy9jb3VsZCBiZSBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IHBhcnQuIE5vIG5lZWQgdG8gcmVuZGVyIGFuZCBmaXJlIGNhbGxiYWNrcy5cbiAgICAgICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgICAgIHRpbWVsaW5lICYmIHRoaXMuX3lFYXNlICYmIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKTsgLy9yZXBlYXRSZWZyZXNoIGZ1bmN0aW9uYWxpdHlcblxuICAgICAgICAgIGlmICh0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICF0aGlzLl9sb2NrICYmIHRoaXMuX3RpbWUgIT09IGN5Y2xlRHVyYXRpb24gJiYgdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgICAgLy8gdGhpcy5fdGltZSB3aWxsID09PSBjeWNsZUR1cmF0aW9uIHdoZW4gd2UgcmVuZGVyIGF0IEVYQUNUTFkgdGhlIGVuZCBvZiBhbiBpdGVyYXRpb24uIFdpdGhvdXQgdGhpcyBjb25kaXRpb24sIGl0J2Qgb2Z0ZW4gZG8gdGhlIHJlcGVhdFJlZnJlc2ggcmVuZGVyIFRXSUNFIChhZ2FpbiBvbiB0aGUgdmVyeSBuZXh0IHRpY2spLlxuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kUHJlY2lzZShjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCBpc05lZ2F0aXZlID8gdG90YWxUaW1lIDogdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzLCB0VGltZSkpIHtcbiAgICAgICAgICB0aGlzLl90VGltZSA9IDA7IC8vIGluIGNvbnN0cnVjdG9yIGlmIGltbWVkaWF0ZVJlbmRlciBpcyB0cnVlLCB3ZSBzZXQgX3RUaW1lIHRvIC1fdGlueU51bSB0byBoYXZlIHRoZSBwbGF5aGVhZCBjcm9zcyB0aGUgc3RhcnRpbmcgcG9pbnQgYnV0IHdlIGNhbid0IGxlYXZlIF90VGltZSBhcyBhIG5lZ2F0aXZlIG51bWJlci5cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmICEoZm9yY2UgJiYgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSkge1xuICAgICAgICAgIC8vIHJhcmUgZWRnZSBjYXNlIC0gZHVyaW5nIGluaXRpYWxpemF0aW9uLCBhbiBvblVwZGF0ZSBpbiB0aGUgX3N0YXJ0QXQgKC5mcm9tVG8oKSkgbWlnaHQgZm9yY2UgdGhpcyB0d2VlbiB0byByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkaXRjaCB0aGlzIHJlbmRlcigpIGNhbGwgc28gdGhhdCBpdCBkb2Vzbid0IHJldmVydCB0aGUgdmFsdWVzLiBCdXQgd2UgYWxzbyBkb24ndCB3YW50IHRvIGR1bXAgaWYgd2UncmUgZG9pbmcgYSByZXBlYXRSZWZyZXNoIHJlbmRlciFcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXIgIT09IHRoaXMuX2R1cikge1xuICAgICAgICAgIC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgaWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcbiAgICAgICAgdGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgICAgdGhpcy5fbGF6eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZSAmJiAhcHJldlRpbWUgJiYgIXN1cHByZXNzRXZlbnRzICYmICFpdGVyYXRpb24pIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwdCA9IHRoaXMuX3B0O1xuXG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnJlbmRlcih0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZWxpbmUuX2R1ciAqIHRpbWVsaW5lLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHx8IHRoaXMuX3N0YXJ0QXQgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcblxuICAgICAgaWYgKHRoaXMuX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICBpc05lZ2F0aXZlICYmIF9yZXdpbmRTdGFydEF0KHRoaXMsIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblxuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwZWF0ICYmIGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbiAmJiB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgICBpZiAoKHRUaW1lID09PSB0aGlzLl90RHVyIHx8ICF0VGltZSkgJiYgdGhpcy5fdFRpbWUgPT09IHRUaW1lKSB7XG4gICAgICAgIGlzTmVnYXRpdmUgJiYgIXRoaXMuX29uVXBkYXRlICYmIF9yZXdpbmRTdGFydEF0KHRoaXMsIHRvdGFsVGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0aGlzLl90RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHdlJ3JlIHJlbmRlcmluZyBhdCBleGFjdGx5IGEgdGltZSBvZiAwLCBhcyB0aGVyZSBjb3VsZCBiZSBhdXRvUmV2ZXJ0IHZhbHVlcyB0aGF0IHNob3VsZCBnZXQgc2V0IG9uIHRoZSBuZXh0IHRpY2sgKGlmIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnRUaW1lLCBuZWdhdGl2ZSB0b3RhbFRpbWUpLiBEb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cblxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEoaXNOZWdhdGl2ZSAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSB8fCBpc1lveW8pKSB7XG4gICAgICAgICAgLy8gaWYgcHJldlRpbWUgYW5kIHRUaW1lIGFyZSB6ZXJvLCB3ZSBzaG91bGRuJ3QgZmlyZSB0aGUgb25SZXZlcnNlQ29tcGxldGUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHlvdSBnc2FwLnRvKC4uLiB7cGF1c2VkOnRydWV9KS5wbGF5KCk7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMy50YXJnZXRzID0gZnVuY3Rpb24gdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cztcbiAgfTtcblxuICBfcHJvdG8zLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKHNvZnQpIHtcbiAgICAvLyBcInNvZnRcIiBnaXZlcyB1cyBhIHdheSB0byBjbGVhciBvdXQgZXZlcnl0aGluZyBFWENFUFQgdGhlIHJlY29yZGVkIHByZS1cImZyb21cIiBwb3J0aW9uIG9mIGZyb20oKSB0d2VlbnMuIE90aGVyd2lzZSwgZm9yIGV4YW1wbGUsIGlmIHlvdSB0d2Vlbi5wcm9ncmVzcygxKS5yZW5kZXIoMCwgdHJ1ZSB0cnVlKS5pbnZhbGlkYXRlKCksIHRoZSBcImZyb21cIiB2YWx1ZXMgd291bGQgcGVyc2lzdCBhbmQgdGhlbiBvbiB0aGUgbmV4dCByZW5kZXIsIHRoZSBmcm9tKCkgdHdlZW5zIHdvdWxkIGluaXRpYWxpemUgYW5kIHRoZSBjdXJyZW50IHZhbHVlIHdvdWxkIG1hdGNoIHRoZSBcImZyb21cIiB2YWx1ZXMsIHRodXMgYW5pbWF0ZSBmcm9tIHRoZSBzYW1lIHZhbHVlIHRvIHRoZSBzYW1lIHZhbHVlIChubyBhbmltYXRpb24pLiBXZSB0YXAgaW50byB0aGlzIGluIFNjcm9sbFRyaWdnZXIncyByZWZyZXNoKCkgd2hlcmUgd2UgbXVzdCBwdXNoIGEgdHdlZW4gdG8gY29tcGxldGlvbiBhbmQgdGhlbiBiYWNrIGFnYWluIGJ1dCBob25vciBpdHMgaW5pdCBzdGF0ZSBpbiBjYXNlIHRoZSB0d2VlbiBpcyBkZXBlbmRlbnQgb24gYW5vdGhlciB0d2VlbiBmdXJ0aGVyIHVwIG9uIHRoZSBwYWdlLlxuICAgICghc29mdCB8fCAhdGhpcy52YXJzLnJ1bkJhY2t3YXJkcykgJiYgKHRoaXMuX3N0YXJ0QXQgPSAwKTtcbiAgICB0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9sYXp5ID0gdGhpcy5yYXRpbyA9IDA7XG4gICAgdGhpcy5fcHRMb29rdXAgPSBbXTtcbiAgICB0aGlzLnRpbWVsaW5lICYmIHRoaXMudGltZWxpbmUuaW52YWxpZGF0ZShzb2Z0KTtcbiAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzLCBzb2Z0KTtcbiAgfTtcblxuICBfcHJvdG8zLnJlc2V0VG8gPSBmdW5jdGlvbiByZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSwgc2tpcFJlY3Vyc2lvbikge1xuICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gICAgdGhpcy5fdHMgfHwgdGhpcy5wbGF5KCk7XG4gICAgdmFyIHRpbWUgPSBNYXRoLm1pbih0aGlzLl9kdXIsICh0aGlzLl9kcC5fdGltZSAtIHRoaXMuX3N0YXJ0KSAqIHRoaXMuX3RzKSxcbiAgICAgICAgcmF0aW87XG4gICAgdGhpcy5faW5pdHRlZCB8fCBfaW5pdFR3ZWVuKHRoaXMsIHRpbWUpO1xuICAgIHJhdGlvID0gdGhpcy5fZWFzZSh0aW1lIC8gdGhpcy5fZHVyKTsgLy8gZG9uJ3QganVzdCBnZXQgdHdlZW4ucmF0aW8gYmVjYXVzZSBpdCBtYXkgbm90IGhhdmUgcmVuZGVyZWQgeWV0LlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBhZGRpdGlvbiB0byBhbGxvdyBhbiBvYmplY3Qgd2l0aCBtdWx0aXBsZSB2YWx1ZXMgdG8gdXBkYXRlLCBsaWtlIHR3ZWVuLnJlc2V0VG8oe3g6IDEwMCwgeTogMjAwfSk7IEF0IHRoaXMgcG9pbnQsIGl0IGRvZXNuJ3Qgc2VlbSB3b3J0aCB0aGUgYWRkZWQga2IgZ2l2ZW4gdGhlIGZhY3QgdGhhdCBtb3N0IHVzZXJzIHdpbGwgbGlrZWx5IG9wdCBmb3IgdGhlIGNvbnZlbmllbnQgZ3NhcC5xdWlja1RvKCkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggdGhpcyBtZXRob2QuXG4gICAgLy8gaWYgKF9pc09iamVjdChwcm9wZXJ0eSkpIHsgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gICAgLy8gXHRmb3IgKHAgaW4gcHJvcGVydHkpIHtcbiAgICAvLyBcdFx0aWYgKF91cGRhdGVQcm9wVHdlZW5zKHRoaXMsIHAsIHByb3BlcnR5W3BdLCB2YWx1ZSA/IHZhbHVlW3BdIDogbnVsbCwgc3RhcnQsIHJhdGlvLCB0aW1lKSkge1xuICAgIC8vIFx0XHRcdHJldHVybiB0aGlzLnJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKTsgLy8gaWYgYSBQcm9wVHdlZW4gd2Fzbid0IGZvdW5kIGZvciB0aGUgcHJvcGVydHksIGl0J2xsIGdldCBmb3JjZWQgd2l0aCBhIHJlLWluaXRpYWxpemF0aW9uIHNvIHdlIG5lZWQgdG8ganVtcCBvdXQgYW5kIHN0YXJ0IG92ZXIgYWdhaW4uXG4gICAgLy8gXHRcdH1cbiAgICAvLyBcdH1cbiAgICAvLyB9IGVsc2Uge1xuXG4gICAgaWYgKF91cGRhdGVQcm9wVHdlZW5zKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSwgcmF0aW8sIHRpbWUsIHNraXBSZWN1cnNpb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSwgMSk7IC8vIGlmIGEgUHJvcFR3ZWVuIHdhc24ndCBmb3VuZCBmb3IgdGhlIHByb3BlcnR5LCBpdCdsbCBnZXQgZm9yY2VkIHdpdGggYSByZS1pbml0aWFsaXphdGlvbiBzbyB3ZSBuZWVkIHRvIGp1bXAgb3V0IGFuZCBzdGFydCBvdmVyIGFnYWluLlxuICAgIH0gLy99XG5cblxuICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIDApO1xuXG4gICAgdGhpcy5wYXJlbnQgfHwgX2FkZExpbmtlZExpc3RJdGVtKHRoaXMuX2RwLCB0aGlzLCBcIl9maXJzdFwiLCBcIl9sYXN0XCIsIHRoaXMuX2RwLl9zb3J0ID8gXCJfc3RhcnRcIiA6IDApO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcigwKTtcbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKHRhcmdldHMsIHZhcnMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0gXCJhbGxcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldHMgJiYgKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpKSB7XG4gICAgICB0aGlzLl9sYXp5ID0gdGhpcy5fcHQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gX2ludGVycnVwdCh0aGlzKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgIHZhciB0RHVyID0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCk7XG4gICAgICB0aGlzLnRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCB2YXJzLCBfb3ZlcndyaXRpbmdUd2VlbiAmJiBfb3ZlcndyaXRpbmdUd2Vlbi52YXJzLm92ZXJ3cml0ZSAhPT0gdHJ1ZSkuX2ZpcnN0IHx8IF9pbnRlcnJ1cHQodGhpcyk7IC8vIGlmIG5vdGhpbmcgaXMgbGVmdCB0d2VlbmluZywgaW50ZXJydXB0LlxuXG4gICAgICB0aGlzLnBhcmVudCAmJiB0RHVyICE9PSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKSAmJiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fZHVyICogdGhpcy50aW1lbGluZS5fdER1ciAvIHREdXIsIDAsIDEpOyAvLyBpZiBhIG5lc3RlZCB0d2VlbiBpcyBraWxsZWQgdGhhdCBjaGFuZ2VzIHRoZSBkdXJhdGlvbiwgaXQgc2hvdWxkIGFmZmVjdCB0aGlzIHR3ZWVuJ3MgZHVyYXRpb24uIFdlIG11c3QgdXNlIHRoZSByYXRpbywgdGhvdWdoLCBiZWNhdXNlIHNvbWV0aW1lcyB0aGUgaW50ZXJuYWwgdGltZWxpbmUgaXMgc3RyZXRjaGVkIGxpa2UgZm9yIGtleWZyYW1lcyB3aGVyZSB0aGV5IGRvbid0IGFsbCBhZGQgdXAgdG8gd2hhdGV2ZXIgdGhlIHBhcmVudCB0d2VlbidzIGR1cmF0aW9uIHdhcyBzZXQgdG8uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAga2lsbGluZ1RhcmdldHMgPSB0YXJnZXRzID8gdG9BcnJheSh0YXJnZXRzKSA6IHBhcnNlZFRhcmdldHMsXG4gICAgICAgIHByb3BUd2Vlbkxvb2t1cCA9IHRoaXMuX3B0TG9va3VwLFxuICAgICAgICBmaXJzdFBUID0gdGhpcy5fcHQsXG4gICAgICAgIG92ZXJ3cml0dGVuUHJvcHMsXG4gICAgICAgIGN1ckxvb2t1cCxcbiAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBwLFxuICAgICAgICBwdCxcbiAgICAgICAgaTtcblxuICAgIGlmICgoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikgJiYgX2FycmF5c01hdGNoKHBhcnNlZFRhcmdldHMsIGtpbGxpbmdUYXJnZXRzKSkge1xuICAgICAgdmFycyA9PT0gXCJhbGxcIiAmJiAodGhpcy5fcHQgPSAwKTtcbiAgICAgIHJldHVybiBfaW50ZXJydXB0KHRoaXMpO1xuICAgIH1cblxuICAgIG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vcCA9IHRoaXMuX29wIHx8IFtdO1xuXG4gICAgaWYgKHZhcnMgIT09IFwiYWxsXCIpIHtcbiAgICAgIC8vc28gcGVvcGxlIGNhbiBwYXNzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgcCA9IHt9O1xuXG4gICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBwW25hbWVdID0gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFycyA9IHA7XG4gICAgICB9XG5cbiAgICAgIHZhcnMgPSBfYWRkQWxpYXNlc1RvVmFycyhwYXJzZWRUYXJnZXRzLCB2YXJzKTtcbiAgICB9XG5cbiAgICBpID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAofmtpbGxpbmdUYXJnZXRzLmluZGV4T2YocGFyc2VkVGFyZ2V0c1tpXSkpIHtcbiAgICAgICAgY3VyTG9va3VwID0gcHJvcFR3ZWVuTG9va3VwW2ldO1xuXG4gICAgICAgIGlmICh2YXJzID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnM7XG4gICAgICAgICAgcHJvcHMgPSBjdXJMb29rdXA7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gPSBvdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9O1xuICAgICAgICAgIHByb3BzID0gdmFycztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgICAgIHB0ID0gY3VyTG9va3VwICYmIGN1ckxvb2t1cFtwXTtcblxuICAgICAgICAgIGlmIChwdCkge1xuICAgICAgICAgICAgaWYgKCEoXCJraWxsXCIgaW4gcHQuZCkgfHwgcHQuZC5raWxsKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjdXJMb29rdXBbcF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1ck92ZXJ3cml0ZVByb3BzICE9PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wc1twXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdHRlZCAmJiAhdGhpcy5fcHQgJiYgZmlyc3RQVCAmJiBfaW50ZXJydXB0KHRoaXMpOyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFR3ZWVuLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgYXJndW1lbnRzWzJdKTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBUd2Vlbi5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uIGRlbGF5ZWRDYWxsKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuICAgIHJldHVybiBuZXcgVHdlZW4oY2FsbGJhY2ssIDAsIHtcbiAgICAgIGltbWVkaWF0ZVJlbmRlcjogZmFsc2UsXG4gICAgICBsYXp5OiBmYWxzZSxcbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICBkZWxheTogZGVsYXksXG4gICAgICBvbkNvbXBsZXRlOiBjYWxsYmFjayxcbiAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlOiBjYWxsYmFjayxcbiAgICAgIG9uQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOiBwYXJhbXMsXG4gICAgICBjYWxsYmFja1Njb3BlOiBzY29wZVxuICAgIH0pOyAvLyB3ZSBtdXN0IHVzZSBvblJldmVyc2VDb21wbGV0ZSB0b28gZm9yIHRoaW5ncyBsaWtlIHRpbWVsaW5lLmFkZCgoKSA9PiB7Li4ufSkgd2hpY2ggc2hvdWxkIGJlIHRyaWdnZXJlZCBpbiBCT1RIIGRpcmVjdGlvbnMgKGZvcndhcmQgYW5kIHJldmVyc2UpXG4gIH07XG5cbiAgVHdlZW4uZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFR3ZWVuLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgdmFycy5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMpO1xuICB9O1xuXG4gIFR3ZWVuLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKTtcbiAgfTtcblxuICByZXR1cm4gVHdlZW47XG59KEFuaW1hdGlvbik7XG5cbl9zZXREZWZhdWx0cyhUd2Vlbi5wcm90b3R5cGUsIHtcbiAgX3RhcmdldHM6IFtdLFxuICBfbGF6eTogMCxcbiAgX3N0YXJ0QXQ6IDAsXG4gIF9vcDogMCxcbiAgX29uSW5pdDogMFxufSk7IC8vYWRkIHRoZSBwZXJ0aW5lbnQgdGltZWxpbmUgbWV0aG9kcyB0byBUd2VlbiBpbnN0YW5jZXMgc28gdGhhdCB1c2VycyBjYW4gY2hhaW4gY29udmVuaWVudGx5IGFuZCBjcmVhdGUgYSB0aW1lbGluZSBhdXRvbWF0aWNhbGx5LiAocmVtb3ZlZCBkdWUgdG8gY29uY2VybnMgdGhhdCBpdCdkIHVsdGltYXRlbHkgYWRkIHRvIG1vcmUgY29uZnVzaW9uIGVzcGVjaWFsbHkgZm9yIGJlZ2lubmVycylcbi8vIF9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLHNldCxjYWxsLGFkZCxhZGRMYWJlbCxhZGRQYXVzZVwiLCBuYW1lID0+IHtcbi8vIFx0VHdlZW4ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4vLyBcdFx0bGV0IHRsID0gbmV3IFRpbWVsaW5lKCk7XG4vLyBcdFx0cmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRsLCB0aGlzKVtuYW1lXS5hcHBseSh0bCwgdG9BcnJheShhcmd1bWVudHMpKTtcbi8vIFx0fVxuLy8gfSk7XG4vL2ZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBMZXZlcmFnZSB0aGUgdGltZWxpbmUgY2FsbHMuXG5cblxuX2ZvckVhY2hOYW1lKFwic3RhZ2dlclRvLHN0YWdnZXJGcm9tLHN0YWdnZXJGcm9tVG9cIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgVHdlZW5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKCksXG4gICAgICAgIHBhcmFtcyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICBwYXJhbXMuc3BsaWNlKG5hbWUgPT09IFwic3RhZ2dlckZyb21Ub1wiID8gNSA6IDQsIDAsIDApO1xuICAgIHJldHVybiB0bFtuYW1lXS5hcHBseSh0bCwgcGFyYW1zKTtcbiAgfTtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQUk9QVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG52YXIgX3NldHRlclBsYWluID0gZnVuY3Rpb24gX3NldHRlclBsYWluKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJGdW5jID0gZnVuY3Rpb24gX3NldHRlckZ1bmModGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0odmFsdWUpO1xufSxcbiAgICBfc2V0dGVyRnVuY1dpdGhQYXJhbSA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jV2l0aFBhcmFtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKGRhdGEuZnAsIHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9zZXR0ZXJBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHZhbHVlKTtcbn0sXG4gICAgX2dldFNldHRlciA9IGZ1bmN0aW9uIF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odGFyZ2V0W3Byb3BlcnR5XSkgPyBfc2V0dGVyRnVuYyA6IF9pc1VuZGVmaW5lZCh0YXJnZXRbcHJvcGVydHldKSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlID8gX3NldHRlckF0dHJpYnV0ZSA6IF9zZXR0ZXJQbGFpbjtcbn0sXG4gICAgX3JlbmRlclBsYWluID0gZnVuY3Rpb24gX3JlbmRlclBsYWluKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDAwMCkgLyAxMDAwMDAwLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckJvb2xlYW4gPSBmdW5jdGlvbiBfcmVuZGVyQm9vbGVhbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsICEhKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDb21wbGV4U3RyaW5nID0gZnVuY3Rpb24gX3JlbmRlckNvbXBsZXhTdHJpbmcocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICBzID0gXCJcIjtcblxuICBpZiAoIXJhdGlvICYmIGRhdGEuYikge1xuICAgIC8vYiA9IGJlZ2lubmluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5iO1xuICB9IGVsc2UgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuZSkge1xuICAgIC8vZSA9IGVuZGluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5lO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChwdCkge1xuICAgICAgcyA9IHB0LnAgKyAocHQubSA/IHB0Lm0ocHQucyArIHB0LmMgKiByYXRpbykgOiBNYXRoLnJvdW5kKChwdC5zICsgcHQuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIHM7IC8vd2UgdXNlIHRoZSBcInBcIiBwcm9wZXJ0eSBmb3IgdGhlIHRleHQgaW5iZXR3ZWVuIChsaWtlIGEgc3VmZml4KS4gQW5kIGluIHRoZSBjb250ZXh0IG9mIGEgY29tcGxleCBzdHJpbmcsIHRoZSBtb2RpZmllciAobSkgaXMgdHlwaWNhbGx5IGp1c3QgTWF0aC5yb3VuZCgpLCBsaWtlIGZvciBSR0IgY29sb3JzLlxuXG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHMgKz0gZGF0YS5jOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgY2h1bmsgb2Ygbm9uLW51bWVyaWMgdGV4dC5cbiAgfVxuXG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBzLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFR3ZWVucyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG59LFxuICAgIF9hZGRQbHVnaW5Nb2RpZmllciA9IGZ1bmN0aW9uIF9hZGRQbHVnaW5Nb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdC5wID09PSBwcm9wZXJ0eSAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCk7XG4gICAgcHQgPSBuZXh0O1xuICB9XG59LFxuICAgIF9raWxsUHJvcFR3ZWVuc09mID0gZnVuY3Rpb24gX2tpbGxQcm9wVHdlZW5zT2YocHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcblxuICAgIGlmIChwdC5wID09PSBwcm9wZXJ0eSAmJiAhcHQub3AgfHwgcHQub3AgPT09IHByb3BlcnR5KSB7XG4gICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuICAgIH0gZWxzZSBpZiAoIXB0LmRlcCkge1xuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nID0gMTtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gIWhhc05vbkRlcGVuZGVudFJlbWFpbmluZztcbn0sXG4gICAgX3NldHRlcldpdGhNb2RpZmllciA9IGZ1bmN0aW9uIF9zZXR0ZXJXaXRoTW9kaWZpZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgZGF0YS5tU2V0KHRhcmdldCwgcHJvcGVydHksIGRhdGEubS5jYWxsKGRhdGEudHdlZW4sIHZhbHVlLCBkYXRhLm10KSwgZGF0YSk7XG59LFxuICAgIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkgPSBmdW5jdGlvbiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHBhcmVudCkge1xuICB2YXIgcHQgPSBwYXJlbnQuX3B0LFxuICAgICAgbmV4dCxcbiAgICAgIHB0MixcbiAgICAgIGZpcnN0LFxuICAgICAgbGFzdDsgLy9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gZG8gdGhlaXIgd29yayBhZnRlciBBTEwgb2YgdGhlIFByb3BUd2VlbnMgd2VyZSBjcmVhdGVkIChsaWtlIFJvdW5kUHJvcHNQbHVnaW4gYW5kIE1vZGlmaWVyc1BsdWdpbilcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQyID0gZmlyc3Q7XG5cbiAgICB3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG4gICAgICBwdDIgPSBwdDIuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkge1xuICAgICAgcHQuX3ByZXYuX25leHQgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3QgPSBwdDtcbiAgICB9XG5cbiAgICBpZiAocHQuX25leHQgPSBwdDIpIHtcbiAgICAgIHB0Mi5fcHJldiA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gcHQ7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcGFyZW50Ll9wdCA9IGZpcnN0O1xufTsgLy9Qcm9wVHdlZW4ga2V5OiB0ID0gdGFyZ2V0LCBwID0gcHJvcCwgciA9IHJlbmRlcmVyLCBkID0gZGF0YSwgcyA9IHN0YXJ0LCBjID0gY2hhbmdlLCBvcCA9IG92ZXJ3cml0ZVByb3BlcnR5IChPTkxZIHBvcHVsYXRlZCB3aGVuIGl0J3MgZGlmZmVyZW50IHRoYW4gcCksIHByID0gcHJpb3JpdHksIF9uZXh0L19wcmV2IGZvciB0aGUgbGlua2VkIGxpc3Qgc2libGluZ3MsIHNldCA9IHNldHRlciwgbSA9IG1vZGlmaWVyLCBtU2V0ID0gbW9kaWZpZXJTZXR0ZXIgKHRoZSBvcmlnaW5hbCBzZXR0ZXIsIGJlZm9yZSBhIG1vZGlmaWVyIHdhcyBhZGRlZClcblxuXG5leHBvcnQgdmFyIFByb3BUd2VlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BUd2VlbihuZXh0LCB0YXJnZXQsIHByb3AsIHN0YXJ0LCBjaGFuZ2UsIHJlbmRlcmVyLCBkYXRhLCBzZXR0ZXIsIHByaW9yaXR5KSB7XG4gICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgIHRoaXMucyA9IHN0YXJ0O1xuICAgIHRoaXMuYyA9IGNoYW5nZTtcbiAgICB0aGlzLnAgPSBwcm9wO1xuICAgIHRoaXMuciA9IHJlbmRlcmVyIHx8IF9yZW5kZXJQbGFpbjtcbiAgICB0aGlzLmQgPSBkYXRhIHx8IHRoaXM7XG4gICAgdGhpcy5zZXQgPSBzZXR0ZXIgfHwgX3NldHRlclBsYWluO1xuICAgIHRoaXMucHIgPSBwcmlvcml0eSB8fCAwO1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIG5leHQuX3ByZXYgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gUHJvcFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG80Lm1vZGlmaWVyID0gZnVuY3Rpb24gbW9kaWZpZXIoZnVuYywgdHdlZW4sIHRhcmdldCkge1xuICAgIHRoaXMubVNldCA9IHRoaXMubVNldCB8fCB0aGlzLnNldDsgLy9pbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHNldCAoYSBQcm9wVHdlZW4gY2FuIG9ubHkgaGF2ZSBvbmUgbW9kaWZpZXIpXG5cbiAgICB0aGlzLnNldCA9IF9zZXR0ZXJXaXRoTW9kaWZpZXI7XG4gICAgdGhpcy5tID0gZnVuYztcbiAgICB0aGlzLm10ID0gdGFyZ2V0OyAvL21vZGlmaWVyIHRhcmdldFxuXG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuICB9O1xuXG4gIHJldHVybiBQcm9wVHdlZW47XG59KCk7IC8vSW5pdGlhbGl6YXRpb24gdGFza3NcblxuX2ZvckVhY2hOYW1lKF9jYWxsYmFja05hbWVzICsgXCJwYXJlbnQsZHVyYXRpb24sZWFzZSxkZWxheSxvdmVyd3JpdGUscnVuQmFja3dhcmRzLHN0YXJ0QXQseW95byxpbW1lZGlhdGVSZW5kZXIscmVwZWF0LHJlcGVhdERlbGF5LGRhdGEscGF1c2VkLHJldmVyc2VkLGxhenksY2FsbGJhY2tTY29wZSxzdHJpbmdGaWx0ZXIsaWQseW95b0Vhc2Usc3RhZ2dlcixpbmhlcml0LHJlcGVhdFJlZnJlc2gsa2V5ZnJhbWVzLGF1dG9SZXZlcnQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xufSk7XG5cbl9nbG9iYWxzLlR3ZWVuTWF4ID0gX2dsb2JhbHMuVHdlZW5MaXRlID0gVHdlZW47XG5fZ2xvYmFscy5UaW1lbGluZUxpdGUgPSBfZ2xvYmFscy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xuX2dsb2JhbFRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgc29ydENoaWxkcmVuOiBmYWxzZSxcbiAgZGVmYXVsdHM6IF9kZWZhdWx0cyxcbiAgYXV0b1JlbW92ZUNoaWxkcmVuOiB0cnVlLFxuICBpZDogXCJyb290XCIsXG4gIHNtb290aENoaWxkVGltaW5nOiB0cnVlXG59KTtcbl9jb25maWcuc3RyaW5nRmlsdGVyID0gX2NvbG9yU3RyaW5nRmlsdGVyO1xuXG52YXIgX21lZGlhID0gW10sXG4gICAgX2xpc3RlbmVycyA9IHt9LFxuICAgIF9lbXB0eUFycmF5ID0gW10sXG4gICAgX2xhc3RNZWRpYVRpbWUgPSAwLFxuICAgIF9jb250ZXh0SUQgPSAwLFxuICAgIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIF9kaXNwYXRjaCh0eXBlKSB7XG4gIHJldHVybiAoX2xpc3RlbmVyc1t0eXBlXSB8fCBfZW1wdHlBcnJheSkubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYoKTtcbiAgfSk7XG59LFxuICAgIF9vbk1lZGlhQ2hhbmdlID0gZnVuY3Rpb24gX29uTWVkaWFDaGFuZ2UoKSB7XG4gIHZhciB0aW1lID0gRGF0ZS5ub3coKSxcbiAgICAgIG1hdGNoZXMgPSBbXTtcblxuICBpZiAodGltZSAtIF9sYXN0TWVkaWFUaW1lID4gMikge1xuICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFJbml0XCIpO1xuXG4gICAgX21lZGlhLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHZhciBxdWVyaWVzID0gYy5xdWVyaWVzLFxuICAgICAgICAgIGNvbmRpdGlvbnMgPSBjLmNvbmRpdGlvbnMsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBhbnlNYXRjaCxcbiAgICAgICAgICB0b2dnbGVkO1xuXG4gICAgICBmb3IgKHAgaW4gcXVlcmllcykge1xuICAgICAgICBtYXRjaCA9IF93aW4ubWF0Y2hNZWRpYShxdWVyaWVzW3BdKS5tYXRjaGVzOyAvLyBGaXJlZm94IGRvZXNuJ3QgdXBkYXRlIHRoZSBcIm1hdGNoZXNcIiBwcm9wZXJ0eSBvZiB0aGUgTWVkaWFRdWVyeUxpc3Qgb2JqZWN0IGNvcnJlY3RseSAtIGl0IG9ubHkgZG9lcyBzbyBhcyBpdCBjYWxscyBpdHMgY2hhbmdlIGhhbmRsZXIgLSBzbyB3ZSBtdXN0IHJlLWNyZWF0ZSBhIG1lZGlhIHF1ZXJ5IGhlcmUgdG8gZW5zdXJlIGl0J3MgYWNjdXJhdGUuXG5cbiAgICAgICAgbWF0Y2ggJiYgKGFueU1hdGNoID0gMSk7XG5cbiAgICAgICAgaWYgKG1hdGNoICE9PSBjb25kaXRpb25zW3BdKSB7XG4gICAgICAgICAgY29uZGl0aW9uc1twXSA9IG1hdGNoO1xuICAgICAgICAgIHRvZ2dsZWQgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2dnbGVkKSB7XG4gICAgICAgIGMucmV2ZXJ0KCk7XG4gICAgICAgIGFueU1hdGNoICYmIG1hdGNoZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFSZXZlcnRcIik7XG5cbiAgICBtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLm9uTWF0Y2goYywgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGMuYWRkKG51bGwsIGZ1bmMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX2xhc3RNZWRpYVRpbWUgPSB0aW1lO1xuXG4gICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYVwiKTtcbiAgfVxufTtcblxudmFyIENvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZXh0KGZ1bmMsIHNjb3BlKSB7XG4gICAgdGhpcy5zZWxlY3RvciA9IHNjb3BlICYmIHNlbGVjdG9yKHNjb3BlKTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLl9yID0gW107IC8vIHJldHVybmVkL2NsZWFudXAgZnVuY3Rpb25zXG5cbiAgICB0aGlzLmlzUmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlkID0gX2NvbnRleHRJRCsrOyAvLyB0byB3b3JrIGFyb3VuZCBpc3N1ZXMgdGhhdCBmcmFtZXdvcmtzIGxpa2UgVnVlIGNhdXNlIGJ5IG1ha2luZyB0aGluZ3MgaW50byBQcm94aWVzIHdoaWNoIG1ha2UgaXQgaW1wb3NzaWJsZSB0byBkbyBzb21ldGhpbmcgbGlrZSBfbWVkaWEuaW5kZXhPZih0aGlzKSBiZWNhdXNlIFwidGhpc1wiIHdvdWxkIG5vIGxvbmdlciByZWZlciB0byB0aGUgQ29udGV4dCBpbnN0YW5jZSBpdHNlbGYgLSBpdCdkIHJlZmVyIHRvIGEgUHJveHkhIFdlIG5lZWRlZCBhIHdheSB0byBpZGVudGlmeSB0aGUgY29udGV4dCB1bmlxdWVseVxuXG4gICAgZnVuYyAmJiB0aGlzLmFkZChmdW5jKTtcbiAgfVxuXG4gIHZhciBfcHJvdG81ID0gQ29udGV4dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNS5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgZnVuYywgc2NvcGUpIHtcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgYWRkaXRpb24gaWYgd2UgbmVlZCB0aGUgYWJpbGl0eSB0byBhZGQoKSBhbiBhbmltYXRpb24gdG8gYSBjb250ZXh0IGFuZCBmb3Igd2hhdGV2ZXIgcmVhc29uIGNhbm5vdCBjcmVhdGUgdGhhdCBhbmltYXRpb24gaW5zaWRlIG9mIGEgY29udGV4dC5hZGQoKCkgPT4gey4uLn0pIGZ1bmN0aW9uLlxuICAgIC8vIGlmIChuYW1lICYmIF9pc0Z1bmN0aW9uKG5hbWUucmV2ZXJ0KSkge1xuICAgIC8vIFx0dGhpcy5kYXRhLnB1c2gobmFtZSk7XG4gICAgLy8gXHRyZXR1cm4gKG5hbWUuX2N0eCA9IHRoaXMpO1xuICAgIC8vIH1cbiAgICBpZiAoX2lzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgIHNjb3BlID0gZnVuYztcbiAgICAgIGZ1bmMgPSBuYW1lO1xuICAgICAgbmFtZSA9IF9pc0Z1bmN0aW9uO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZiA9IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB2YXIgcHJldiA9IF9jb250ZXh0LFxuICAgICAgICAgIHByZXZTZWxlY3RvciA9IHNlbGYuc2VsZWN0b3IsXG4gICAgICAgICAgcmVzdWx0O1xuICAgICAgcHJldiAmJiBwcmV2ICE9PSBzZWxmICYmIHByZXYuZGF0YS5wdXNoKHNlbGYpO1xuICAgICAgc2NvcGUgJiYgKHNlbGYuc2VsZWN0b3IgPSBzZWxlY3RvcihzY29wZSkpO1xuICAgICAgX2NvbnRleHQgPSBzZWxmO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgX2lzRnVuY3Rpb24ocmVzdWx0KSAmJiBzZWxmLl9yLnB1c2gocmVzdWx0KTtcbiAgICAgIF9jb250ZXh0ID0gcHJldjtcbiAgICAgIHNlbGYuc2VsZWN0b3IgPSBwcmV2U2VsZWN0b3I7XG4gICAgICBzZWxmLmlzUmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHNlbGYubGFzdCA9IGY7XG4gICAgcmV0dXJuIG5hbWUgPT09IF9pc0Z1bmN0aW9uID8gZihzZWxmLCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgcmV0dXJuIHNlbGYuYWRkKG51bGwsIGZ1bmMpO1xuICAgIH0pIDogbmFtZSA/IHNlbGZbbmFtZV0gPSBmIDogZjtcbiAgfTtcblxuICBfcHJvdG81Lmlnbm9yZSA9IGZ1bmN0aW9uIGlnbm9yZShmdW5jKSB7XG4gICAgdmFyIHByZXYgPSBfY29udGV4dDtcbiAgICBfY29udGV4dCA9IG51bGw7XG4gICAgZnVuYyh0aGlzKTtcbiAgICBfY29udGV4dCA9IHByZXY7XG4gIH07XG5cbiAgX3Byb3RvNS5nZXRUd2VlbnMgPSBmdW5jdGlvbiBnZXRUd2VlbnMoKSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb250ZXh0ID8gYS5wdXNoLmFwcGx5KGEsIGUuZ2V0VHdlZW5zKCkpIDogZSBpbnN0YW5jZW9mIFR3ZWVuICYmICEoZS5wYXJlbnQgJiYgZS5wYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIikgJiYgYS5wdXNoKGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIF9wcm90bzUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLl9yLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwO1xuICB9O1xuXG4gIF9wcm90bzUua2lsbCA9IGZ1bmN0aW9uIGtpbGwocmV2ZXJ0LCBtYXRjaE1lZGlhKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJ0KSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHdlZW5zID0gX3RoaXM0LmdldFR3ZWVucygpLFxuICAgICAgICAgICAgaSA9IF90aGlzNC5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHQ7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIC8vIEZsaXAgcGx1Z2luIHR3ZWVucyBhcmUgdmVyeSBkaWZmZXJlbnQgaW4gdGhhdCB0aGV5IHNob3VsZCBhY3R1YWxseSBiZSBwdXNoZWQgdG8gdGhlaXIgZW5kLiBUaGUgcGx1Z2luIHJlcGxhY2VzIHRoZSB0aW1lbGluZSdzIC5yZXZlcnQoKSBtZXRob2QgdG8gZG8gZXhhY3RseSB0aGF0LiBCdXQgd2UgYWxzbyBuZWVkIHRvIHJlbW92ZSBhbnkgb2YgdGhvc2UgbmVzdGVkIHR3ZWVucyBpbnNpZGUgdGhlIGZsaXAgdGltZWxpbmUgc28gdGhhdCB0aGV5IGRvbid0IGdldCBpbmRpdmlkdWFsbHkgcmV2ZXJ0ZWQuXG4gICAgICAgICAgdCA9IF90aGlzNC5kYXRhW2ldO1xuXG4gICAgICAgICAgaWYgKHQuZGF0YSA9PT0gXCJpc0ZsaXBcIikge1xuICAgICAgICAgICAgdC5yZXZlcnQoKTtcbiAgICAgICAgICAgIHQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpLmZvckVhY2goZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0d2VlbnMuc3BsaWNlKHR3ZWVucy5pbmRleE9mKHR3ZWVuKSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gc2F2ZSBhcyBhbiBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gY2FjaGUgdGhlIGdsb2JhbFRpbWUgZm9yIGVhY2ggdHdlZW4gdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UgZHVyaW5nIHRoZSBzb3J0XG5cblxuICAgICAgICB0d2VlbnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGc6IHQuX2R1ciB8fCB0Ll9kZWxheSB8fCB0Ll9zYXQgJiYgIXQuX3NhdC52YXJzLmltbWVkaWF0ZVJlbmRlciA/IHQuZ2xvYmFsVGltZSgwKSA6IC1JbmZpbml0eSxcbiAgICAgICAgICAgIHQ6IHRcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuZyAtIGEuZyB8fCAtSW5maW5pdHk7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gby50LnJldmVydChyZXZlcnQpO1xuICAgICAgICB9KTsgLy8gbm90ZTogYWxsIG9mIHRoZSBfc3RhcnRBdCB0d2VlbnMgc2hvdWxkIGJlIHJldmVydGVkIGluIHJldmVyc2Ugb3JkZXIgdGhhdCB0aGV5IHdlcmUgY3JlYXRlZCwgYW5kIHRoZXknbGwgYWxsIGhhdmUgdGhlIHNhbWUgZ2xvYmFsVGltZSAoLTEpIHNvIHRoZSBcIiB8fCAtMVwiIGluIHRoZSBzb3J0IGtlZXBzIHRoZSBvcmRlciBwcm9wZXJseS5cblxuICAgICAgICBpID0gX3RoaXM0LmRhdGEubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgbG9vcCBiYWNrd2FyZHMgc28gdGhhdCwgZm9yIGV4YW1wbGUsIFNwbGl0VGV4dHMgdGhhdCB3ZXJlIGNyZWF0ZWQgbGF0ZXIgb24gdGhlIHNhbWUgZWxlbWVudCBnZXQgcmV2ZXJ0ZWQgZmlyc3RcbiAgICAgICAgICB0ID0gX3RoaXM0LmRhdGFbaV07XG5cbiAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XG4gICAgICAgICAgICBpZiAodC5kYXRhICE9PSBcIm5lc3RlZFwiKSB7XG4gICAgICAgICAgICAgIHQuc2Nyb2xsVHJpZ2dlciAmJiB0LnNjcm9sbFRyaWdnZXIucmV2ZXJ0KCk7XG4gICAgICAgICAgICAgIHQua2lsbCgpOyAvLyBkb24ndCByZXZlcnQoKSB0aGUgdGltZWxpbmUgYmVjYXVzZSB0aGF0J3MgZHVwbGljYXRpbmcgZWZmb3J0cyBzaW5jZSB3ZSBhbHJlYWR5IHJldmVydGVkIGFsbCB0aGUgdHdlZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICEodCBpbnN0YW5jZW9mIFR3ZWVuKSAmJiB0LnJldmVydCAmJiB0LnJldmVydChyZXZlcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNC5fci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIGYocmV2ZXJ0LCBfdGhpczQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpczQuaXNSZXZlcnRlZCA9IHRydWU7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5raWxsICYmIGUua2lsbCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgaWYgKG1hdGNoTWVkaWEpIHtcbiAgICAgIHZhciBpID0gX21lZGlhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAvLyBwcmV2aW91c2x5LCB3ZSBjaGVja2VkIF9tZWRpYS5pbmRleE9mKHRoaXMpLCBidXQgc29tZSBmcmFtZXdvcmtzIGxpa2UgVnVlIGVuZm9yY2UgUHJveHkgb2JqZWN0cyB0aGF0IG1ha2UgaXQgaW1wb3NzaWJsZSB0byBnZXQgdGhlIHByb3BlciByZXN1bHQgdGhhdCB3YXksIHNvIHdlIG11c3QgdXNlIGEgdW5pcXVlIElEIG51bWJlciBpbnN0ZWFkLlxuICAgICAgICBfbWVkaWFbaV0uaWQgPT09IHRoaXMuaWQgJiYgX21lZGlhLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNS5yZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoY29uZmlnKSB7XG4gICAgdGhpcy5raWxsKGNvbmZpZyB8fCB7fSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRleHQ7XG59KCk7XG5cbnZhciBNYXRjaE1lZGlhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWF0Y2hNZWRpYShzY29wZSkge1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgX2NvbnRleHQgJiYgX2NvbnRleHQuZGF0YS5wdXNoKHRoaXMpO1xuICB9XG5cbiAgdmFyIF9wcm90bzYgPSBNYXRjaE1lZGlhLnByb3RvdHlwZTtcblxuICBfcHJvdG82LmFkZCA9IGZ1bmN0aW9uIGFkZChjb25kaXRpb25zLCBmdW5jLCBzY29wZSkge1xuICAgIF9pc09iamVjdChjb25kaXRpb25zKSB8fCAoY29uZGl0aW9ucyA9IHtcbiAgICAgIG1hdGNoZXM6IGNvbmRpdGlvbnNcbiAgICB9KTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KDAsIHNjb3BlIHx8IHRoaXMuc2NvcGUpLFxuICAgICAgICBjb25kID0gY29udGV4dC5jb25kaXRpb25zID0ge30sXG4gICAgICAgIG1xLFxuICAgICAgICBwLFxuICAgICAgICBhY3RpdmU7XG4gICAgX2NvbnRleHQgJiYgIWNvbnRleHQuc2VsZWN0b3IgJiYgKGNvbnRleHQuc2VsZWN0b3IgPSBfY29udGV4dC5zZWxlY3Rvcik7IC8vIGluIGNhc2UgYSBjb250ZXh0IGlzIGNyZWF0ZWQgaW5zaWRlIGEgY29udGV4dC4gTGlrZSBhIGdzYXAubWF0Y2hNZWRpYSgpIHRoYXQncyBpbnNpZGUgYSBzY29wZWQgZ3NhcC5jb250ZXh0KClcblxuICAgIHRoaXMuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICBmdW5jID0gY29udGV4dC5hZGQoXCJvbk1hdGNoXCIsIGZ1bmMpO1xuICAgIGNvbnRleHQucXVlcmllcyA9IGNvbmRpdGlvbnM7XG5cbiAgICBmb3IgKHAgaW4gY29uZGl0aW9ucykge1xuICAgICAgaWYgKHAgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgYWN0aXZlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1xID0gX3dpbi5tYXRjaE1lZGlhKGNvbmRpdGlvbnNbcF0pO1xuXG4gICAgICAgIGlmIChtcSkge1xuICAgICAgICAgIF9tZWRpYS5pbmRleE9mKGNvbnRleHQpIDwgMCAmJiBfbWVkaWEucHVzaChjb250ZXh0KTtcbiAgICAgICAgICAoY29uZFtwXSA9IG1xLm1hdGNoZXMpICYmIChhY3RpdmUgPSAxKTtcbiAgICAgICAgICBtcS5hZGRMaXN0ZW5lciA/IG1xLmFkZExpc3RlbmVyKF9vbk1lZGlhQ2hhbmdlKSA6IG1xLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgX29uTWVkaWFDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWN0aXZlICYmIGZ1bmMoY29udGV4dCwgZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmFkZChudWxsLCBmKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyByZWZyZXNoKCkge1xuICAvLyBcdGxldCB0aW1lID0gX2xhc3RNZWRpYVRpbWUsXG4gIC8vIFx0XHRtZWRpYSA9IF9tZWRpYTtcbiAgLy8gXHRfbGFzdE1lZGlhVGltZSA9IC0xO1xuICAvLyBcdF9tZWRpYSA9IHRoaXMuY29udGV4dHM7XG4gIC8vIFx0X29uTWVkaWFDaGFuZ2UoKTtcbiAgLy8gXHRfbGFzdE1lZGlhVGltZSA9IHRpbWU7XG4gIC8vIFx0X21lZGlhID0gbWVkaWE7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90bzYucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGNvbmZpZykge1xuICAgIHRoaXMua2lsbChjb25maWcgfHwge30pO1xuICB9O1xuXG4gIF9wcm90bzYua2lsbCA9IGZ1bmN0aW9uIGtpbGwocmV2ZXJ0KSB7XG4gICAgdGhpcy5jb250ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy5raWxsKHJldmVydCwgdHJ1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1hdGNoTWVkaWE7XG59KCk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEdTQVBcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG52YXIgX2dzYXAgPSB7XG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgcmV0dXJuIF9jcmVhdGVQbHVnaW4oY29uZmlnKTtcbiAgICB9KTtcbiAgfSxcbiAgdGltZWxpbmU6IGZ1bmN0aW9uIHRpbWVsaW5lKHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVsaW5lKHZhcnMpO1xuICB9LFxuICBnZXRUd2VlbnNPZjogZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSk7XG4gIH0sXG4gIGdldFByb3BlcnR5OiBmdW5jdGlvbiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgX2lzU3RyaW5nKHRhcmdldCkgJiYgKHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KVswXSk7IC8vaW4gY2FzZSBzZWxlY3RvciB0ZXh0IG9yIGFuIGFycmF5IGlzIHBhc3NlZCBpblxuXG4gICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgZm9ybWF0ID0gdW5pdCA/IF9wYXNzVGhyb3VnaCA6IF9udW1lcmljSWZQb3NzaWJsZTtcblxuICAgIHVuaXQgPT09IFwibmF0aXZlXCIgJiYgKHVuaXQgPSBcIlwiKTtcbiAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gICAgfSA6IGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gIH0sXG4gIHF1aWNrU2V0dGVyOiBmdW5jdGlvbiBxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XG4gICAgdGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpO1xuXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgc2V0dGVycyA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGdzYXAucXVpY2tTZXR0ZXIodCwgcHJvcGVydHksIHVuaXQpO1xuICAgICAgfSksXG4gICAgICAgICAgbCA9IHNldHRlcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHNldHRlcnNbaV0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgIHZhciBQbHVnaW4gPSBfcGx1Z2luc1twcm9wZXJ0eV0sXG4gICAgICAgIGNhY2hlID0gX2dldENhY2hlKHRhcmdldCksXG4gICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcbiAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGFuIGFsaWFzLCBsaWtlIFwicm90YXRlXCIgZm9yIFwicm90YXRpb25cIi5cbiAgICBzZXR0ZXIgPSBQbHVnaW4gPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBwID0gbmV3IFBsdWdpbigpO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ID0gMDtcbiAgICAgIHAuaW5pdCh0YXJnZXQsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgX3F1aWNrVHdlZW4sIDAsIFt0YXJnZXRdKTtcbiAgICAgIHAucmVuZGVyKDEsIHApO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ICYmIF9yZW5kZXJQcm9wVHdlZW5zKDEsIF9xdWlja1R3ZWVuKTtcbiAgICB9IDogY2FjaGUuc2V0KHRhcmdldCwgcCk7XG5cbiAgICByZXR1cm4gUGx1Z2luID8gc2V0dGVyIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0dGVyKHRhcmdldCwgcCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBjYWNoZSwgMSk7XG4gICAgfTtcbiAgfSxcbiAgcXVpY2tUbzogZnVuY3Rpb24gcXVpY2tUbyh0YXJnZXQsIHByb3BlcnR5LCB2YXJzKSB7XG4gICAgdmFyIF9tZXJnZTI7XG5cbiAgICB2YXIgdHdlZW4gPSBnc2FwLnRvKHRhcmdldCwgX21lcmdlKChfbWVyZ2UyID0ge30sIF9tZXJnZTJbcHJvcGVydHldID0gXCIrPTAuMVwiLCBfbWVyZ2UyLnBhdXNlZCA9IHRydWUsIF9tZXJnZTIpLCB2YXJzIHx8IHt9KSksXG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKSB7XG4gICAgICByZXR1cm4gdHdlZW4ucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpO1xuICAgIH07XG5cbiAgICBmdW5jLnR3ZWVuID0gdHdlZW47XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0sXG4gIGlzVHdlZW5pbmc6IGZ1bmN0aW9uIGlzVHdlZW5pbmcodGFyZ2V0cykge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHZhbHVlKSB7XG4gICAgdmFsdWUgJiYgdmFsdWUuZWFzZSAmJiAodmFsdWUuZWFzZSA9IF9wYXJzZUVhc2UodmFsdWUuZWFzZSwgX2RlZmF1bHRzLmVhc2UpKTtcbiAgICByZXR1cm4gX21lcmdlRGVlcChfZGVmYXVsdHMsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcodmFsdWUpIHtcbiAgICByZXR1cm4gX21lcmdlRGVlcChfY29uZmlnLCB2YWx1ZSB8fCB7fSk7XG4gIH0sXG4gIHJlZ2lzdGVyRWZmZWN0OiBmdW5jdGlvbiByZWdpc3RlckVmZmVjdChfcmVmMykge1xuICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0LFxuICAgICAgICBwbHVnaW5zID0gX3JlZjMucGx1Z2lucyxcbiAgICAgICAgZGVmYXVsdHMgPSBfcmVmMy5kZWZhdWx0cyxcbiAgICAgICAgZXh0ZW5kVGltZWxpbmUgPSBfcmVmMy5leHRlbmRUaW1lbGluZTtcbiAgICAocGx1Z2lucyB8fCBcIlwiKS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuICAgICAgcmV0dXJuIHBsdWdpbk5hbWUgJiYgIV9wbHVnaW5zW3BsdWdpbk5hbWVdICYmICFfZ2xvYmFsc1twbHVnaW5OYW1lXSAmJiBfd2FybihuYW1lICsgXCIgZWZmZWN0IHJlcXVpcmVzIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbi5cIik7XG4gICAgfSk7XG5cbiAgICBfZWZmZWN0c1tuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCB0bCkge1xuICAgICAgcmV0dXJuIGVmZmVjdCh0b0FycmF5KHRhcmdldHMpLCBfc2V0RGVmYXVsdHModmFycyB8fCB7fSwgZGVmYXVsdHMpLCB0bCk7XG4gICAgfTtcblxuICAgIGlmIChleHRlbmRUaW1lbGluZSkge1xuICAgICAgVGltZWxpbmUucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChfZWZmZWN0c1tuYW1lXSh0YXJnZXRzLCBfaXNPYmplY3QodmFycykgPyB2YXJzIDogKHBvc2l0aW9uID0gdmFycykgJiYge30sIHRoaXMpLCBwb3NpdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgcmVnaXN0ZXJFYXNlOiBmdW5jdGlvbiByZWdpc3RlckVhc2UobmFtZSwgZWFzZSkge1xuICAgIF9lYXNlTWFwW25hbWVdID0gX3BhcnNlRWFzZShlYXNlKTtcbiAgfSxcbiAgcGFyc2VFYXNlOiBmdW5jdGlvbiBwYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIDogX2Vhc2VNYXA7XG4gIH0sXG4gIGdldEJ5SWQ6IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldEJ5SWQoaWQpO1xuICB9LFxuICBleHBvcnRSb290OiBmdW5jdGlvbiBleHBvcnRSb290KHZhcnMsIGluY2x1ZGVEZWxheWVkQ2FsbHMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0ge307XG4gICAgfVxuXG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKHZhcnMpLFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dDtcbiAgICB0bC5zbW9vdGhDaGlsZFRpbWluZyA9IF9pc05vdEZhbHNlKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcpO1xuXG4gICAgX2dsb2JhbFRpbWVsaW5lLnJlbW92ZSh0bCk7XG5cbiAgICB0bC5fZHAgPSAwOyAvL290aGVyd2lzZSBpdCdsbCBnZXQgcmUtYWN0aXZhdGVkIHdoZW4gYWRkaW5nIGNoaWxkcmVuIGFuZCBiZSByZS1pbnRyb2R1Y2VkIGludG8gX2dsb2JhbFRpbWVsaW5lJ3MgbGlua2VkIGxpc3QgKHRoZW4gYWRkZWQgdG8gaXRzZWxmKS5cblxuICAgIHRsLl90aW1lID0gdGwuX3RUaW1lID0gX2dsb2JhbFRpbWVsaW5lLl90aW1lO1xuICAgIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gICAgICBpZiAoaW5jbHVkZURlbGF5ZWRDYWxscyB8fCAhKCFjaGlsZC5fZHVyICYmIGNoaWxkIGluc3RhbmNlb2YgVHdlZW4gJiYgY2hpbGQudmFycy5vbkNvbXBsZXRlID09PSBjaGlsZC5fdGFyZ2V0c1swXSkpIHtcbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGwsIGNoaWxkLCBjaGlsZC5fc3RhcnQgLSBjaGlsZC5fZGVsYXkpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUoX2dsb2JhbFRpbWVsaW5lLCB0bCwgMCk7XG5cbiAgICByZXR1cm4gdGw7XG4gIH0sXG4gIGNvbnRleHQ6IGZ1bmN0aW9uIGNvbnRleHQoZnVuYywgc2NvcGUpIHtcbiAgICByZXR1cm4gZnVuYyA/IG5ldyBDb250ZXh0KGZ1bmMsIHNjb3BlKSA6IF9jb250ZXh0O1xuICB9LFxuICBtYXRjaE1lZGlhOiBmdW5jdGlvbiBtYXRjaE1lZGlhKHNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRjaE1lZGlhKHNjb3BlKTtcbiAgfSxcbiAgbWF0Y2hNZWRpYVJlZnJlc2g6IGZ1bmN0aW9uIG1hdGNoTWVkaWFSZWZyZXNoKCkge1xuICAgIHJldHVybiBfbWVkaWEuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIGNvbmQgPSBjLmNvbmRpdGlvbnMsXG4gICAgICAgICAgZm91bmQsXG4gICAgICAgICAgcDtcblxuICAgICAgZm9yIChwIGluIGNvbmQpIHtcbiAgICAgICAgaWYgKGNvbmRbcF0pIHtcbiAgICAgICAgICBjb25kW3BdID0gZmFsc2U7XG4gICAgICAgICAgZm91bmQgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvdW5kICYmIGMucmV2ZXJ0KCk7XG4gICAgfSkgfHwgX29uTWVkaWFDaGFuZ2UoKTtcbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSB8fCAoX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcbiAgICB+YS5pbmRleE9mKGNhbGxiYWNrKSB8fCBhLnB1c2goY2FsbGJhY2spO1xuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgICBpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xuICAgIGkgPj0gMCAmJiBhLnNwbGljZShpLCAxKTtcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB3cmFwOiB3cmFwLFxuICAgIHdyYXBZb3lvOiB3cmFwWW95byxcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZ2V0VW5pdDogZ2V0VW5pdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgcGlwZTogcGlwZSxcbiAgICB1bml0aXplOiB1bml0aXplLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICBzaHVmZmxlOiBzaHVmZmxlXG4gIH0sXG4gIGluc3RhbGw6IF9pbnN0YWxsLFxuICBlZmZlY3RzOiBfZWZmZWN0cyxcbiAgdGlja2VyOiBfdGlja2VyLFxuICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICBwbHVnaW5zOiBfcGx1Z2lucyxcbiAgZ2xvYmFsVGltZWxpbmU6IF9nbG9iYWxUaW1lbGluZSxcbiAgY29yZToge1xuICAgIFByb3BUd2VlbjogUHJvcFR3ZWVuLFxuICAgIGdsb2JhbHM6IF9hZGRHbG9iYWwsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFRpbWVsaW5lOiBUaW1lbGluZSxcbiAgICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbTogX3JlbW92ZUxpbmtlZExpc3RJdGVtLFxuICAgIHJldmVydGluZzogZnVuY3Rpb24gcmV2ZXJ0aW5nKCkge1xuICAgICAgcmV0dXJuIF9yZXZlcnRpbmc7XG4gICAgfSxcbiAgICBjb250ZXh0OiBmdW5jdGlvbiBjb250ZXh0KHRvQWRkKSB7XG4gICAgICBpZiAodG9BZGQgJiYgX2NvbnRleHQpIHtcbiAgICAgICAgX2NvbnRleHQuZGF0YS5wdXNoKHRvQWRkKTtcblxuICAgICAgICB0b0FkZC5fY3R4ID0gX2NvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfY29udGV4dDtcbiAgICB9LFxuICAgIHN1cHByZXNzT3ZlcndyaXRlczogZnVuY3Rpb24gc3VwcHJlc3NPdmVyd3JpdGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sZGVsYXllZENhbGwsc2V0LGtpbGxUd2VlbnNPZlwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcbn0pO1xuXG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcblxuX3F1aWNrVHdlZW4gPSBfZ3NhcC50byh7fSwge1xuICBkdXJhdGlvbjogMFxufSk7IC8vIC0tLS0gRVhUUkEgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XG4gIHZhciBwdCA9IHBsdWdpbi5fcHQ7XG5cbiAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYWRkTW9kaWZpZXJzID0gZnVuY3Rpb24gX2FkZE1vZGlmaWVycyh0d2VlbiwgbW9kaWZpZXJzKSB7XG4gIHZhciB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIHB0O1xuXG4gIGZvciAocCBpbiBtb2RpZmllcnMpIHtcbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblxuICAgICAgaWYgKHB0ICYmIChwdCA9IHB0LmQpKSB7XG4gICAgICAgIGlmIChwdC5fcHQpIHtcbiAgICAgICAgICAvLyBpcyBhIHBsdWdpblxuICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdCAmJiBwdC5tb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllcnNbcF0sIHR3ZWVuLCB0YXJnZXRzW2ldLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2J1aWxkTW9kaWZpZXJQbHVnaW4gPSBmdW5jdGlvbiBfYnVpbGRNb2RpZmllclBsdWdpbihuYW1lLCBtb2RpZmllcikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3VmFyczogMSxcbiAgICAvL2Rvbid0IHByZS1wcm9jZXNzIGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBvciBcInJhbmRvbSgpXCIgc3RyaW5ncy5cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcbiAgICAgIHR3ZWVuLl9vbkluaXQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdmFyIHRlbXAsIHA7XG5cbiAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBbbmFtZV0gPSAxO1xuICAgICAgICAgIH0pOyAvL2lmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHRvIHJvdW5kUHJvcHMsIGxpa2UgXCJ4LHlcIiwgd2Ugcm91bmQgdG8gd2hvbGUgbnVtYmVycy5cblxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgdGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vcmVnaXN0ZXIgY29yZSBwbHVnaW5zXG5cblxuZXhwb3J0IHZhciBnc2FwID0gX2dzYXAucmVnaXN0ZXJQbHVnaW4oe1xuICBuYW1lOiBcImF0dHJcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwLCBwdCwgdjtcbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XG5cbiAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgdiA9IHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgfHwgXCJcIjtcbiAgICAgIHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCAodiB8fCAwKSArIFwiXCIsIHZhcnNbcF0sIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgIHB0Lm9wID0gcDtcbiAgICAgIHB0LmIgPSB2OyAvLyByZWNvcmQgdGhlIGJlZ2lubmluZyB2YWx1ZSBzbyB3ZSBjYW4gcmV2ZXJ0KClcblxuICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIF9yZXZlcnRpbmcgPyBwdC5zZXQocHQudCwgcHQucCwgcHQuYiwgcHQpIDogcHQucihyYXRpbywgcHQuZCk7IC8vIGlmIHJldmVydGluZywgZ28gYmFjayB0byB0aGUgb3JpZ2luYWwgKHB0LmIpXG5cbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6IFwiZW5kQXJyYXlcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLmFkZCh0YXJnZXQsIGksIHRhcmdldFtpXSB8fCAwLCB2YWx1ZVtpXSwgMCwgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuICB9XG59LCBfYnVpbGRNb2RpZmllclBsdWdpbihcInJvdW5kUHJvcHNcIiwgX3JvdW5kTW9kaWZpZXIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcIm1vZGlmaWVyc1wiKSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJzbmFwXCIsIHNuYXApKSB8fCBfZ3NhcDsgLy90byBwcmV2ZW50IHRoZSBjb3JlIHBsdWdpbnMgZnJvbSBiZWluZyBkcm9wcGVkIHZpYSBhZ2dyZXNzaXZlIHRyZWUgc2hha2luZywgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIHRoaXMgd2F5LlxuXG5Ud2Vlbi52ZXJzaW9uID0gVGltZWxpbmUudmVyc2lvbiA9IGdzYXAudmVyc2lvbiA9IFwiMy4xMi41XCI7XG5fY29yZVJlYWR5ID0gMTtcbl93aW5kb3dFeGlzdHMoKSAmJiBfd2FrZSgpO1xudmFyIFBvd2VyMCA9IF9lYXNlTWFwLlBvd2VyMCxcbiAgICBQb3dlcjEgPSBfZWFzZU1hcC5Qb3dlcjEsXG4gICAgUG93ZXIyID0gX2Vhc2VNYXAuUG93ZXIyLFxuICAgIFBvd2VyMyA9IF9lYXNlTWFwLlBvd2VyMyxcbiAgICBQb3dlcjQgPSBfZWFzZU1hcC5Qb3dlcjQsXG4gICAgTGluZWFyID0gX2Vhc2VNYXAuTGluZWFyLFxuICAgIFF1YWQgPSBfZWFzZU1hcC5RdWFkLFxuICAgIEN1YmljID0gX2Vhc2VNYXAuQ3ViaWMsXG4gICAgUXVhcnQgPSBfZWFzZU1hcC5RdWFydCxcbiAgICBRdWludCA9IF9lYXNlTWFwLlF1aW50LFxuICAgIFN0cm9uZyA9IF9lYXNlTWFwLlN0cm9uZyxcbiAgICBFbGFzdGljID0gX2Vhc2VNYXAuRWxhc3RpYyxcbiAgICBCYWNrID0gX2Vhc2VNYXAuQmFjayxcbiAgICBTdGVwcGVkRWFzZSA9IF9lYXNlTWFwLlN0ZXBwZWRFYXNlLFxuICAgIEJvdW5jZSA9IF9lYXNlTWFwLkJvdW5jZSxcbiAgICBTaW5lID0gX2Vhc2VNYXAuU2luZSxcbiAgICBFeHBvID0gX2Vhc2VNYXAuRXhwbyxcbiAgICBDaXJjID0gX2Vhc2VNYXAuQ2lyYztcbmV4cG9ydCB7IFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9O1xuZXhwb3J0IHsgVHdlZW4gYXMgVHdlZW5NYXgsIFR3ZWVuIGFzIFR3ZWVuTGl0ZSwgVGltZWxpbmUgYXMgVGltZWxpbmVNYXgsIFRpbWVsaW5lIGFzIFRpbWVsaW5lTGl0ZSwgZ3NhcCBhcyBkZWZhdWx0LCB3cmFwLCB3cmFwWW95bywgZGlzdHJpYnV0ZSwgcmFuZG9tLCBzbmFwLCBub3JtYWxpemUsIGdldFVuaXQsIGNsYW1wLCBzcGxpdENvbG9yLCB0b0FycmF5LCBzZWxlY3RvciwgbWFwUmFuZ2UsIHBpcGUsIHVuaXRpemUsIGludGVycG9sYXRlLCBzaHVmZmxlIH07IC8vZXhwb3J0IHNvbWUgaW50ZXJuYWwgbWV0aG9kcy9vcm9qZWN0cyBmb3IgdXNlIGluIENTU1BsdWdpbiBzbyB0aGF0IHdlIGNhbiBleHRlcm5hbGl6ZSB0aGF0IGZpbGUgYW5kIGFsbG93IGN1c3RvbSBidWlsZHMgdGhhdCBleGNsdWRlIGl0LlxuXG5leHBvcnQgeyBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9yZXBsYWNlUmFuZG9tLCBfY2hlY2tQbHVnaW4sIF9wbHVnaW5zLCBfdGlja2VyLCBfY29uZmlnLCBfcm91bmRNb2RpZmllciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfY29sb3JFeHAsIF9wYXJzZVJlbGF0aXZlIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/gsap-core.js\n");

/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),\n/* harmony export */   Bounce: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),\n/* harmony export */   CSSPlugin: () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),\n/* harmony export */   Circ: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),\n/* harmony export */   Cubic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),\n/* harmony export */   Elastic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),\n/* harmony export */   Expo: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),\n/* harmony export */   Linear: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),\n/* harmony export */   Power0: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),\n/* harmony export */   Power1: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),\n/* harmony export */   Power2: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),\n/* harmony export */   Power3: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),\n/* harmony export */   Power4: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),\n/* harmony export */   Quad: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),\n/* harmony export */   Quart: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),\n/* harmony export */   Quint: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),\n/* harmony export */   Sine: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),\n/* harmony export */   SteppedEase: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),\n/* harmony export */   Strong: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),\n/* harmony export */   TimelineLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),\n/* harmony export */   TimelineMax: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),\n/* harmony export */   TweenLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),\n/* harmony export */   TweenMax: () => (/* binding */ TweenMaxWithCSS),\n/* harmony export */   \"default\": () => (/* binding */ gsapWithCSS),\n/* harmony export */   gsap: () => (/* binding */ gsapWithCSS)\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"./node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"./node_modules/gsap/CSSPlugin.js\");\n\n\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,\n    // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcU47QUFDMUs7QUFDM0Msa0JBQWtCLCtDQUFJLGdCQUFnQixvREFBUyxLQUFLLCtDQUFJO0FBQ3hEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcz9jZmZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdzYXAsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYywgVHdlZW5MaXRlLCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4IH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5pbXBvcnQgeyBDU1NQbHVnaW4gfSBmcm9tIFwiLi9DU1NQbHVnaW4uanNcIjtcbnZhciBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLFxuICAgIC8vIHRvIHByb3RlY3QgZnJvbSB0cmVlIHNoYWtpbmdcblR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5leHBvcnQgeyBnc2FwV2l0aENTUyBhcyBnc2FwLCBnc2FwV2l0aENTUyBhcyBkZWZhdWx0LCBDU1NQbHVnaW4sIFR3ZWVuTWF4V2l0aENTUyBhcyBUd2Vlbk1heCwgVHdlZW5MaXRlLCBUaW1lbGluZU1heCwgVGltZWxpbmVMaXRlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/index.js\n");

/***/ }),

/***/ "./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js":
/*!******************************************************************************!*\
  !*** ./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/*\n * Leaflet.markercluster 1.5.3+master.e5124b2,\n * Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.\n * https://github.com/Leaflet/Leaflet.markercluster\n * (c) 2012-2017, Dave Leaver, smartrak\n */\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, function (exports) { 'use strict';\n\n\t/*\n\t * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within\n\t */\n\n\tvar MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({\n\n\t\toptions: {\n\t\t\tmaxClusterRadius: 80, //A cluster will cover at most this many pixels from its center\n\t\t\ticonCreateFunction: null,\n\t\t\tclusterPane: L.Marker.prototype.options.pane,\n\n\t\t\tspiderfyOnEveryZoom: false,\n\t\t\tspiderfyOnMaxZoom: true,\n\t\t\tshowCoverageOnHover: true,\n\t\t\tzoomToBoundsOnClick: true,\n\t\t\tsingleMarkerMode: false,\n\n\t\t\tdisableClusteringAtZoom: null,\n\n\t\t\t// Setting this to false prevents the removal of any clusters outside of the viewpoint, which\n\t\t\t// is the default behaviour for performance reasons.\n\t\t\tremoveOutsideVisibleBounds: true,\n\n\t\t\t// Set to false to disable all animations (zoom and spiderfy).\n\t\t\t// If false, option animateAddingMarkers below has no effect.\n\t\t\t// If L.DomUtil.TRANSITION is falsy, this option has no effect.\n\t\t\tanimate: true,\n\n\t\t\t//Whether to animate adding markers after adding the MarkerClusterGroup to the map\n\t\t\t// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.\n\t\t\tanimateAddingMarkers: false,\n\n\t\t\t// Make it possible to provide custom function to calculate spiderfy shape positions\n\t\t\tspiderfyShapePositions: null,\n\n\t\t\t//Increase to increase the distance away that spiderfied markers appear from the center\n\t\t\tspiderfyDistanceMultiplier: 1,\n\n\t\t\t// Make it possible to specify a polyline options on a spider leg\n\t\t\tspiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },\n\n\t\t\t// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts\n\t\t\tchunkedLoading: false,\n\t\t\tchunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)\n\t\t\tchunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser\n\t\t\tchunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)\n\n\t\t\t//Options to pass to the L.Polygon constructor\n\t\t\tpolygonOptions: {}\n\t\t},\n\n\t\tinitialize: function (options) {\n\t\t\tL.Util.setOptions(this, options);\n\t\t\tif (!this.options.iconCreateFunction) {\n\t\t\t\tthis.options.iconCreateFunction = this._defaultIconCreateFunction;\n\t\t\t}\n\n\t\t\tthis._featureGroup = L.featureGroup();\n\t\t\tthis._featureGroup.addEventParent(this);\n\n\t\t\tthis._nonPointGroup = L.featureGroup();\n\t\t\tthis._nonPointGroup.addEventParent(this);\n\n\t\t\tthis._inZoomAnimation = 0;\n\t\t\tthis._needsClustering = [];\n\t\t\tthis._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of\n\t\t\t//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\n\t\t\tthis._currentShownBounds = null;\n\n\t\t\tthis._queue = [];\n\n\t\t\tthis._childMarkerEventHandlers = {\n\t\t\t\t'dragstart': this._childMarkerDragStart,\n\t\t\t\t'move': this._childMarkerMoved,\n\t\t\t\t'dragend': this._childMarkerDragEnd,\n\t\t\t};\n\n\t\t\t// Hook the appropriate animation methods.\n\t\t\tvar animate = L.DomUtil.TRANSITION && this.options.animate;\n\t\t\tL.extend(this, animate ? this._withAnimation : this._noAnimation);\n\t\t\t// Remember which MarkerCluster class to instantiate (animated or not).\n\t\t\tthis._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;\n\t\t},\n\n\t\taddLayer: function (layer) {\n\n\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\treturn this.addLayers([layer]);\n\t\t\t}\n\n\t\t\t//Don't cluster non point data\n\t\t\tif (!layer.getLatLng) {\n\t\t\t\tthis._nonPointGroup.addLayer(layer);\n\t\t\t\tthis.fire('layeradd', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!this._map) {\n\t\t\t\tthis._needsClustering.push(layer);\n\t\t\t\tthis.fire('layeradd', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this.hasLayer(layer)) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\n\t\t\t//If we have already clustered we'll need to add this one to a cluster\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\t\t\t}\n\n\t\t\tthis._addLayer(layer, this._maxZoom);\n\t\t\tthis.fire('layeradd', { layer: layer });\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t//Work out what is visible\n\t\t\tvar visibleLayer = layer,\n\t\t\t    currentZoom = this._zoom;\n\t\t\tif (layer.__parent) {\n\t\t\t\twhile (visibleLayer.__parent._zoom >= currentZoom) {\n\t\t\t\t\tvisibleLayer = visibleLayer.__parent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\n\t\t\t\tif (this.options.animateAddingMarkers) {\n\t\t\t\t\tthis._animationAddLayer(layer, visibleLayer);\n\t\t\t\t} else {\n\t\t\t\t\tthis._animationAddLayerNonAnimated(layer, visibleLayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveLayer: function (layer) {\n\n\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\treturn this.removeLayers([layer]);\n\t\t\t}\n\n\t\t\t//Non point layers\n\t\t\tif (!layer.getLatLng) {\n\t\t\t\tthis._nonPointGroup.removeLayer(layer);\n\t\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!this._map) {\n\t\t\t\tif (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {\n\t\t\t\t\tthis._needsRemoving.push({ layer: layer, latlng: layer._latlng });\n\t\t\t\t}\n\t\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!layer.__parent) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\t\t\t\tthis._unspiderfyLayer(layer);\n\t\t\t}\n\n\t\t\t//Remove the marker from clusters\n\t\t\tthis._removeLayer(layer, true);\n\t\t\tthis.fire('layerremove', { layer: layer });\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\tlayer.off(this._childMarkerEventHandlers, this);\n\n\t\t\tif (this._featureGroup.hasLayer(layer)) {\n\t\t\t\tthis._featureGroup.removeLayer(layer);\n\t\t\t\tif (layer.clusterShow) {\n\t\t\t\t\tlayer.clusterShow();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Takes an array of markers and adds them in bulk\n\t\taddLayers: function (layersArray, skipLayerAddEvent) {\n\t\t\tif (!L.Util.isArray(layersArray)) {\n\t\t\t\treturn this.addLayer(layersArray);\n\t\t\t}\n\n\t\t\tvar fg = this._featureGroup,\n\t\t\t    npg = this._nonPointGroup,\n\t\t\t    chunked = this.options.chunkedLoading,\n\t\t\t    chunkInterval = this.options.chunkInterval,\n\t\t\t    chunkProgress = this.options.chunkProgress,\n\t\t\t    l = layersArray.length,\n\t\t\t    offset = 0,\n\t\t\t    originalArray = true,\n\t\t\t    m;\n\n\t\t\tif (this._map) {\n\t\t\t\tvar started = (new Date()).getTime();\n\t\t\t\tvar process = L.bind(function () {\n\t\t\t\t\tvar start = (new Date()).getTime();\n\n\t\t\t\t\t// Make sure to unspiderfy before starting to add some layers\n\t\t\t\t\tif (this._map && this._unspiderfy) {\n\t\t\t\t\t\tthis._unspiderfy();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (; offset < l; offset++) {\n\t\t\t\t\t\tif (chunked && offset % 200 === 0) {\n\t\t\t\t\t\t\t// every couple hundred markers, instrument the time elapsed since processing started:\n\t\t\t\t\t\t\tvar elapsed = (new Date()).getTime() - start;\n\t\t\t\t\t\t\tif (elapsed > chunkInterval) {\n\t\t\t\t\t\t\t\tbreak; // been working too hard, time to take a break :-)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm = layersArray[offset];\n\n\t\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\t\t// Side effects:\n\t\t\t\t\t\t// - Total increases, so chunkProgress ratio jumps backward.\n\t\t\t\t\t\t// - Groups are not included in this group, only their non-group child layers (hasLayer).\n\t\t\t\t\t\t// Changing array length while looping does not affect performance in current browsers:\n\t\t\t\t\t\t// http://jsperf.com/for-loop-changing-length/6\n\t\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Not point data, can't be clustered\n\t\t\t\t\t\tif (!m.getLatLng) {\n\t\t\t\t\t\t\tnpg.addLayer(m);\n\t\t\t\t\t\t\tif (!skipLayerAddEvent) {\n\t\t\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._addLayer(m, this._maxZoom);\n\t\t\t\t\t\tif (!skipLayerAddEvent) {\n\t\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n\t\t\t\t\t\tif (m.__parent) {\n\t\t\t\t\t\t\tif (m.__parent.getChildCount() === 2) {\n\t\t\t\t\t\t\t\tvar markers = m.__parent.getAllChildMarkers(),\n\t\t\t\t\t\t\t\t    otherMarker = markers[0] === m ? markers[1] : markers[0];\n\t\t\t\t\t\t\t\tfg.removeLayer(otherMarker);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunkProgress) {\n\t\t\t\t\t\t// report progress and time elapsed:\n\t\t\t\t\t\tchunkProgress(offset, l, (new Date()).getTime() - started);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Completed processing all markers.\n\t\t\t\t\tif (offset === l) {\n\n\t\t\t\t\t\t// Refresh bounds and weighted positions.\n\t\t\t\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\t\t\t\tthis._refreshClustersIcons();\n\n\t\t\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetTimeout(process, this.options.chunkDelay);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\n\t\t\t\tprocess();\n\t\t\t} else {\n\t\t\t\tvar needsClustering = this._needsClustering;\n\n\t\t\t\tfor (; offset < l; offset++) {\n\t\t\t\t\tm = layersArray[offset];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Not point data, can't be clustered\n\t\t\t\t\tif (!m.getLatLng) {\n\t\t\t\t\t\tnpg.addLayer(m);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsClustering.push(m);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t//Takes an array of markers and removes them in bulk\n\t\tremoveLayers: function (layersArray) {\n\t\t\tvar i, m,\n\t\t\t    l = layersArray.length,\n\t\t\t    fg = this._featureGroup,\n\t\t\t    npg = this._nonPointGroup,\n\t\t\t    originalArray = true;\n\n\t\t\tif (!this._map) {\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tm = layersArray[i];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._arraySplice(this._needsClustering, m);\n\t\t\t\t\tnpg.removeLayer(m);\n\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\tthis._needsRemoving.push({ layer: m, latlng: m._latlng });\n\t\t\t\t\t}\n\t\t\t\t\tthis.fire('layerremove', { layer: m });\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\n\t\t\t\t// Work on a copy of the array, so that next loop is not affected.\n\t\t\t\tvar layersArray2 = layersArray.slice(),\n\t\t\t\t    l2 = l;\n\t\t\t\tfor (i = 0; i < l2; i++) {\n\t\t\t\t\tm = layersArray2[i];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray2);\n\t\t\t\t\t\tl2 = layersArray2.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._unspiderfyLayer(m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tm = layersArray[i];\n\n\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!m.__parent) {\n\t\t\t\t\tnpg.removeLayer(m);\n\t\t\t\t\tthis.fire('layerremove', { layer: m });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._removeLayer(m, true, true);\n\t\t\t\tthis.fire('layerremove', { layer: m });\n\n\t\t\t\tif (fg.hasLayer(m)) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t//Fix up the clusters and markers on the map\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Removes all layers from the MarkerClusterGroup\n\t\tclearLayers: function () {\n\t\t\t//Need our own special implementation as the LayerGroup one doesn't work for us\n\n\t\t\t//If we aren't on the map (yet), blow away the markers we know of\n\t\t\tif (!this._map) {\n\t\t\t\tthis._needsClustering = [];\n\t\t\t\tthis._needsRemoving = [];\n\t\t\t\tdelete this._gridClusters;\n\t\t\t\tdelete this._gridUnclustered;\n\t\t\t}\n\n\t\t\tif (this._noanimationUnspiderfy) {\n\t\t\t\tthis._noanimationUnspiderfy();\n\t\t\t}\n\n\t\t\t//Remove all the visible layers\n\t\t\tthis._featureGroup.clearLayers();\n\t\t\tthis._nonPointGroup.clearLayers();\n\n\t\t\tthis.eachLayer(function (marker) {\n\t\t\t\tmarker.off(this._childMarkerEventHandlers, this);\n\t\t\t\tdelete marker.__parent;\n\t\t\t}, this);\n\n\t\t\tif (this._map) {\n\t\t\t\t//Reset _topClusterLevel and the DistanceGrids\n\t\t\t\tthis._generateInitialClusters();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Override FeatureGroup.getBounds as it doesn't work\n\t\tgetBounds: function () {\n\t\t\tvar bounds = new L.LatLngBounds();\n\n\t\t\tif (this._topClusterLevel) {\n\t\t\t\tbounds.extend(this._topClusterLevel._bounds);\n\t\t\t}\n\n\t\t\tfor (var i = this._needsClustering.length - 1; i >= 0; i--) {\n\t\t\t\tbounds.extend(this._needsClustering[i].getLatLng());\n\t\t\t}\n\n\t\t\tbounds.extend(this._nonPointGroup.getBounds());\n\n\t\t\treturn bounds;\n\t\t},\n\n\t\t//Overrides LayerGroup.eachLayer\n\t\teachLayer: function (method, context) {\n\t\t\tvar markers = this._needsClustering.slice(),\n\t\t\t\tneedsRemoving = this._needsRemoving,\n\t\t\t\tthisNeedsRemoving, i, j;\n\n\t\t\tif (this._topClusterLevel) {\n\t\t\t\tthis._topClusterLevel.getAllChildMarkers(markers);\n\t\t\t}\n\n\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\tthisNeedsRemoving = true;\n\n\t\t\t\tfor (j = needsRemoving.length - 1; j >= 0; j--) {\n\t\t\t\t\tif (needsRemoving[j].layer === markers[i]) {\n\t\t\t\t\t\tthisNeedsRemoving = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (thisNeedsRemoving) {\n\t\t\t\t\tmethod.call(context, markers[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._nonPointGroup.eachLayer(method, context);\n\t\t},\n\n\t\t//Overrides LayerGroup.getLayers\n\t\tgetLayers: function () {\n\t\t\tvar layers = [];\n\t\t\tthis.eachLayer(function (l) {\n\t\t\t\tlayers.push(l);\n\t\t\t});\n\t\t\treturn layers;\n\t\t},\n\n\t\t//Overrides LayerGroup.getLayer, WARNING: Really bad performance\n\t\tgetLayer: function (id) {\n\t\t\tvar result = null;\n\n\t\t\tid = parseInt(id, 10);\n\n\t\t\tthis.eachLayer(function (l) {\n\t\t\t\tif (L.stamp(l) === id) {\n\t\t\t\t\tresult = l;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn result;\n\t\t},\n\n\t\t//Returns true if the given layer is in this MarkerClusterGroup\n\t\thasLayer: function (layer) {\n\t\t\tif (!layer) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, anArray = this._needsClustering;\n\n\t\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i] === layer) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanArray = this._needsRemoving;\n\t\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i].layer === layer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);\n\t\t},\n\n\t\t//Zoom down to show the given layer (spiderfying if necessary) then calls the callback\n\t\tzoomToShowLayer: function (layer, callback) {\n\n\t\t\tvar map = this._map;\n\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tcallback = function () {};\n\t\t\t}\n\n\t\t\tvar showMarker = function () {\n\t\t\t\t// Assumes that map.hasLayer checks for direct appearance on map, not recursively calling\n\t\t\t\t// hasLayer on Layer Groups that are on map (typically not calling this MarkerClusterGroup.hasLayer, which would always return true)\n\t\t\t\tif ((map.hasLayer(layer) || map.hasLayer(layer.__parent)) && !this._inZoomAnimation) {\n\t\t\t\t\tthis._map.off('moveend', showMarker, this);\n\t\t\t\t\tthis.off('animationend', showMarker, this);\n\n\t\t\t\t\tif (map.hasLayer(layer)) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if (layer.__parent._icon) {\n\t\t\t\t\t\tthis.once('spiderfied', callback, this);\n\t\t\t\t\t\tlayer.__parent.spiderfy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {\n\t\t\t\t//Layer is visible ond on screen, immediate return\n\t\t\t\tcallback();\n\t\t\t} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {\n\t\t\t\t//Layer should be visible at this zoom level. It must not be on screen so just pan over to it\n\t\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\t\tthis._map.panTo(layer.getLatLng());\n\t\t\t} else {\n\t\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\t\tthis.on('animationend', showMarker, this);\n\t\t\t\tlayer.__parent.zoomToBounds();\n\t\t\t}\n\t\t},\n\n\t\t//Overrides FeatureGroup.onAdd\n\t\tonAdd: function (map) {\n\t\t\tthis._map = map;\n\t\t\tvar i, l, layer;\n\n\t\t\tif (!isFinite(this._map.getMaxZoom())) {\n\t\t\t\tthrow \"Map has no maxZoom specified\";\n\t\t\t}\n\n\t\t\tthis._featureGroup.addTo(map);\n\t\t\tthis._nonPointGroup.addTo(map);\n\n\t\t\tif (!this._gridClusters) {\n\t\t\t\tthis._generateInitialClusters();\n\t\t\t}\n\n\t\t\tthis._maxLat = map.options.crs.projection.MAX_LATITUDE;\n\n\t\t\t//Restore all the positions as they are in the MCG before removing them\n\t\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\n\t\t\t\tlayer = this._needsRemoving[i];\n\t\t\t\tlayer.newlatlng = layer.layer._latlng;\n\t\t\t\tlayer.layer._latlng = layer.latlng;\n\t\t\t}\n\t\t\t//Remove them, then restore their new positions\n\t\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\n\t\t\t\tlayer = this._needsRemoving[i];\n\t\t\t\tthis._removeLayer(layer.layer, true);\n\t\t\t\tlayer.layer._latlng = layer.newlatlng;\n\t\t\t}\n\t\t\tthis._needsRemoving = [];\n\n\t\t\t//Remember the current zoom level and bounds\n\t\t\tthis._zoom = Math.round(this._map._zoom);\n\t\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\n\t\t\tthis._map.on('zoomend', this._zoomEnd, this);\n\t\t\tthis._map.on('moveend', this._moveEnd, this);\n\n\t\t\tif (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\t\tthis._spiderfierOnAdd();\n\t\t\t}\n\n\t\t\tthis._bindEvents();\n\n\t\t\t//Actually add our markers to the map:\n\t\t\tl = this._needsClustering;\n\t\t\tthis._needsClustering = [];\n\t\t\tthis.addLayers(l, true);\n\t\t},\n\n\t\t//Overrides FeatureGroup.onRemove\n\t\tonRemove: function (map) {\n\t\t\tmap.off('zoomend', this._zoomEnd, this);\n\t\t\tmap.off('moveend', this._moveEnd, this);\n\n\t\t\tthis._unbindEvents();\n\n\t\t\t//In case we are in a cluster animation\n\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\n\t\t\tif (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\t\tthis._spiderfierOnRemove();\n\t\t\t}\n\n\t\t\tdelete this._maxLat;\n\n\t\t\t//Clean up all the layers we added to the map\n\t\t\tthis._hideCoverage();\n\t\t\tthis._featureGroup.remove();\n\t\t\tthis._nonPointGroup.remove();\n\n\t\t\tthis._featureGroup.clearLayers();\n\n\t\t\tthis._map = null;\n\t\t},\n\n\t\tgetVisibleParent: function (marker) {\n\t\t\tvar vMarker = marker;\n\t\t\twhile (vMarker && !vMarker._icon) {\n\t\t\t\tvMarker = vMarker.__parent;\n\t\t\t}\n\t\t\treturn vMarker || null;\n\t\t},\n\n\t\t//Remove the given object from the given array\n\t\t_arraySplice: function (anArray, obj) {\n\t\t\tfor (var i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i] === obj) {\n\t\t\t\t\tanArray.splice(i, 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.\n\t\t * @param marker to be removed from _gridUnclustered.\n\t\t * @param z integer bottom start zoom level (included)\n\t\t * @private\n\t\t */\n\t\t_removeFromGridUnclustered: function (marker, z) {\n\t\t\tvar map = this._map,\n\t\t\t    gridUnclustered = this._gridUnclustered,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\tfor (; z >= minZoom; z--) {\n\t\t\t\tif (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_childMarkerDragStart: function (e) {\n\t\t\te.target.__dragStart = e.target._latlng;\n\t\t},\n\n\t\t_childMarkerMoved: function (e) {\n\t\t\tif (!this._ignoreMove && !e.target.__dragStart) {\n\t\t\t\tvar isPopupOpen = e.target._popup && e.target._popup.isOpen();\n\n\t\t\t\tthis._moveChild(e.target, e.oldLatLng, e.latlng);\n\n\t\t\t\tif (isPopupOpen) {\n\t\t\t\t\te.target.openPopup();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_moveChild: function (layer, from, to) {\n\t\t\tlayer._latlng = from;\n\t\t\tthis.removeLayer(layer);\n\n\t\t\tlayer._latlng = to;\n\t\t\tthis.addLayer(layer);\n\t\t},\n\n\t\t_childMarkerDragEnd: function (e) {\n\t\t\tvar dragStart = e.target.__dragStart;\n\t\t\tdelete e.target.__dragStart;\n\t\t\tif (dragStart) {\n\t\t\t\tthis._moveChild(e.target, dragStart, e.target._latlng);\n\t\t\t}\t\t\n\t\t},\n\n\n\t\t//Internal function for removing a marker from everything.\n\t\t//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)\n\t\t_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {\n\t\t\tvar gridClusters = this._gridClusters,\n\t\t\t\tgridUnclustered = this._gridUnclustered,\n\t\t\t\tfg = this._featureGroup,\n\t\t\t\tmap = this._map,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\t//Remove the marker from distance clusters it might be in\n\t\t\tif (removeFromDistanceGrid) {\n\t\t\t\tthis._removeFromGridUnclustered(marker, this._maxZoom);\n\t\t\t}\n\n\t\t\t//Work our way up the clusters removing them as we go if required\n\t\t\tvar cluster = marker.__parent,\n\t\t\t\tmarkers = cluster._markers,\n\t\t\t\totherMarker;\n\n\t\t\t//Remove the marker from the immediate parents marker list\n\t\t\tthis._arraySplice(markers, marker);\n\n\t\t\twhile (cluster) {\n\t\t\t\tcluster._childCount--;\n\t\t\t\tcluster._boundsNeedUpdate = true;\n\n\t\t\t\tif (cluster._zoom < minZoom) {\n\t\t\t\t\t//Top level, do nothing\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required\n\t\t\t\t\t//We need to push the other marker up to the parent\n\t\t\t\t\totherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];\n\n\t\t\t\t\t//Update distance grid\n\t\t\t\t\tgridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));\n\t\t\t\t\tgridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));\n\n\t\t\t\t\t//Move otherMarker up to parent\n\t\t\t\t\tthis._arraySplice(cluster.__parent._childClusters, cluster);\n\t\t\t\t\tcluster.__parent._markers.push(otherMarker);\n\t\t\t\t\totherMarker.__parent = cluster.__parent;\n\n\t\t\t\t\tif (cluster._icon) {\n\t\t\t\t\t\t//Cluster is currently on the map, need to put the marker on the map instead\n\t\t\t\t\t\tfg.removeLayer(cluster);\n\t\t\t\t\t\tif (!dontUpdateMap) {\n\t\t\t\t\t\t\tfg.addLayer(otherMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcluster._iconNeedsUpdate = true;\n\t\t\t\t}\n\n\t\t\t\tcluster = cluster.__parent;\n\t\t\t}\n\n\t\t\tdelete marker.__parent;\n\t\t},\n\n\t\t_isOrIsParent: function (el, oel) {\n\t\t\twhile (oel) {\n\t\t\t\tif (el === oel) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\toel = oel.parentNode;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t//Override L.Evented.fire\n\t\tfire: function (type, data, propagate) {\n\t\t\tif (data && data.layer instanceof L.MarkerCluster) {\n\t\t\t\t//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)\n\t\t\t\tif (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttype = 'cluster' + type;\n\t\t\t}\n\n\t\t\tL.FeatureGroup.prototype.fire.call(this, type, data, propagate);\n\t\t},\n\n\t\t//Override L.Evented.listens\n\t\tlistens: function (type, propagate) {\n\t\t\treturn L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);\n\t\t},\n\n\t\t//Default functionality\n\t\t_defaultIconCreateFunction: function (cluster) {\n\t\t\tvar childCount = cluster.getChildCount();\n\n\t\t\tvar c = ' marker-cluster-';\n\t\t\tif (childCount < 10) {\n\t\t\t\tc += 'small';\n\t\t\t} else if (childCount < 100) {\n\t\t\t\tc += 'medium';\n\t\t\t} else {\n\t\t\t\tc += 'large';\n\t\t\t}\n\n\t\t\treturn new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });\n\t\t},\n\n\t\t_bindEvents: function () {\n\t\t\tvar map = this._map,\n\t\t\t    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\t    showCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\t    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\t    spiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom;\n\n\t\t\t//Zoom on cluster click or spiderfy if we are at the lowest level\n\t\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n\t\t\t\tthis.on('clusterclick clusterkeypress', this._zoomOrSpiderfy, this);\n\t\t\t}\n\n\t\t\t//Show convex hull (boundary) polygon on mouse over\n\t\t\tif (showCoverageOnHover) {\n\t\t\t\tthis.on('clustermouseover', this._showCoverage, this);\n\t\t\t\tthis.on('clustermouseout', this._hideCoverage, this);\n\t\t\t\tmap.on('zoomend', this._hideCoverage, this);\n\t\t\t}\n\t\t},\n\n\t\t_zoomOrSpiderfy: function (e) {\n\t\t\tvar cluster = e.layer,\n\t\t\t    bottomCluster = cluster;\n\n\t\t\tif (e.type === 'clusterkeypress' && e.originalEvent && e.originalEvent.keyCode !== 13) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twhile (bottomCluster._childClusters.length === 1) {\n\t\t\t\tbottomCluster = bottomCluster._childClusters[0];\n\t\t\t}\n\n\t\t\tif (bottomCluster._zoom === this._maxZoom &&\n\t\t\t\tbottomCluster._childCount === cluster._childCount &&\n\t\t\t\tthis.options.spiderfyOnMaxZoom) {\n\n\t\t\t\t// All child markers are contained in a single cluster from this._maxZoom to this cluster.\n\t\t\t\tcluster.spiderfy();\n\t\t\t} else if (this.options.zoomToBoundsOnClick) {\n\t\t\t\tcluster.zoomToBounds();\n\t\t\t}\n\n\t\t\tif (this.options.spiderfyOnEveryZoom) {\n\t\t\t\tcluster.spiderfy();\n\t\t\t}\n\n\t\t\t// Focus the map again for keyboard users.\n\t\t\tif (e.originalEvent && e.originalEvent.keyCode === 13) {\n\t\t\t\tthis._map._container.focus();\n\t\t\t}\n\t\t},\n\n\t\t_showCoverage: function (e) {\n\t\t\tvar map = this._map;\n\t\t\tif (this._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._shownPolygon) {\n\t\t\t\tmap.removeLayer(this._shownPolygon);\n\t\t\t}\n\t\t\tif (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {\n\t\t\t\tthis._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);\n\t\t\t\tmap.addLayer(this._shownPolygon);\n\t\t\t}\n\t\t},\n\n\t\t_hideCoverage: function () {\n\t\t\tif (this._shownPolygon) {\n\t\t\t\tthis._map.removeLayer(this._shownPolygon);\n\t\t\t\tthis._shownPolygon = null;\n\t\t\t}\n\t\t},\n\n\t\t_unbindEvents: function () {\n\t\t\tvar spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\t\tshowCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\t\tzoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\t\tspiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom,\n\t\t\t\tmap = this._map;\n\n\t\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n\t\t\t\tthis.off('clusterclick clusterkeypress', this._zoomOrSpiderfy, this);\n\t\t\t}\n\t\t\tif (showCoverageOnHover) {\n\t\t\t\tthis.off('clustermouseover', this._showCoverage, this);\n\t\t\t\tthis.off('clustermouseout', this._hideCoverage, this);\n\t\t\t\tmap.off('zoomend', this._hideCoverage, this);\n\t\t\t}\n\t\t},\n\n\t\t_zoomEnd: function () {\n\t\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._mergeSplitClusters();\n\n\t\t\tthis._zoom = Math.round(this._map._zoom);\n\t\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\t\t},\n\n\t\t_moveEnd: function () {\n\t\t\tif (this._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar newBounds = this._getExpandedVisibleBounds();\n\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);\n\n\t\t\tthis._currentShownBounds = newBounds;\n\t\t\treturn;\n\t\t},\n\n\t\t_generateInitialClusters: function () {\n\t\t\tvar maxZoom = Math.ceil(this._map.getMaxZoom()),\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t\tradius = this.options.maxClusterRadius,\n\t\t\t\tradiusFn = radius;\n\n\t\t\t//If we just set maxClusterRadius to a single number, we need to create\n\t\t\t//a simple function to return that number. Otherwise, we just have to\n\t\t\t//use the function we've passed in.\n\t\t\tif (typeof radius !== \"function\") {\n\t\t\t\tradiusFn = function () { return radius; };\n\t\t\t}\n\n\t\t\tif (this.options.disableClusteringAtZoom !== null) {\n\t\t\t\tmaxZoom = this.options.disableClusteringAtZoom - 1;\n\t\t\t}\n\t\t\tthis._maxZoom = maxZoom;\n\t\t\tthis._gridClusters = {};\n\t\t\tthis._gridUnclustered = {};\n\n\t\t\t//Set up DistanceGrids for each zoom\n\t\t\tfor (var zoom = maxZoom; zoom >= minZoom; zoom--) {\n\t\t\t\tthis._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));\n\t\t\t\tthis._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));\n\t\t\t}\n\n\t\t\t// Instantiate the appropriate L.MarkerCluster class (animated or not).\n\t\t\tthis._topClusterLevel = new this._markerCluster(this, minZoom - 1);\n\t\t},\n\n\t\t//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)\n\t\t_addLayer: function (layer, zoom) {\n\t\t\tvar gridClusters = this._gridClusters,\n\t\t\t    gridUnclustered = this._gridUnclustered,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t    markerPoint, z;\n\n\t\t\tif (this.options.singleMarkerMode) {\n\t\t\t\tthis._overrideMarkerIcon(layer);\n\t\t\t}\n\n\t\t\tlayer.on(this._childMarkerEventHandlers, this);\n\n\t\t\t//Find the lowest zoom level to slot this one in\n\t\t\tfor (; zoom >= minZoom; zoom--) {\n\t\t\t\tmarkerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position\n\n\t\t\t\t//Try find a cluster close by\n\t\t\t\tvar closest = gridClusters[zoom].getNearObject(markerPoint);\n\t\t\t\tif (closest) {\n\t\t\t\t\tclosest._addChild(layer);\n\t\t\t\t\tlayer.__parent = closest;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Try find a marker close by to form a new cluster with\n\t\t\t\tclosest = gridUnclustered[zoom].getNearObject(markerPoint);\n\t\t\t\tif (closest) {\n\t\t\t\t\tvar parent = closest.__parent;\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tthis._removeLayer(closest, false);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Create new cluster with these 2 in it\n\n\t\t\t\t\tvar newCluster = new this._markerCluster(this, zoom, closest, layer);\n\t\t\t\t\tgridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));\n\t\t\t\t\tclosest.__parent = newCluster;\n\t\t\t\t\tlayer.__parent = newCluster;\n\n\t\t\t\t\t//First create any new intermediate parent clusters that don't exist\n\t\t\t\t\tvar lastParent = newCluster;\n\t\t\t\t\tfor (z = zoom - 1; z > parent._zoom; z--) {\n\t\t\t\t\t\tlastParent = new this._markerCluster(this, z, lastParent);\n\t\t\t\t\t\tgridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));\n\t\t\t\t\t}\n\t\t\t\t\tparent._addChild(lastParent);\n\n\t\t\t\t\t//Remove closest from this zoom level and any above that it is in, replace with newCluster\n\t\t\t\t\tthis._removeFromGridUnclustered(closest, zoom);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards\n\t\t\t\tgridUnclustered[zoom].addObject(layer, markerPoint);\n\t\t\t}\n\n\t\t\t//Didn't get in anything, add us to the top\n\t\t\tthis._topClusterLevel._addChild(layer);\n\t\t\tlayer.__parent = this._topClusterLevel;\n\t\t\treturn;\n\t\t},\n\n\t\t/**\n\t\t * Refreshes the icon of all \"dirty\" visible clusters.\n\t\t * Non-visible \"dirty\" clusters will be updated when they are added to the map.\n\t\t * @private\n\t\t */\n\t\t_refreshClustersIcons: function () {\n\t\t\tthis._featureGroup.eachLayer(function (c) {\n\t\t\t\tif (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\n\t\t\t\t\tc._updateIcon();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t//Enqueue code to fire after the marker expand/contract has happened\n\t\t_enqueue: function (fn) {\n\t\t\tthis._queue.push(fn);\n\t\t\tif (!this._queueTimeout) {\n\t\t\t\tthis._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);\n\t\t\t}\n\t\t},\n\t\t_processQueue: function () {\n\t\t\tfor (var i = 0; i < this._queue.length; i++) {\n\t\t\t\tthis._queue[i].call(this);\n\t\t\t}\n\t\t\tthis._queue.length = 0;\n\t\t\tclearTimeout(this._queueTimeout);\n\t\t\tthis._queueTimeout = null;\n\t\t},\n\n\t\t//Merge and split any existing clusters that are too big or small\n\t\t_mergeSplitClusters: function () {\n\t\t\tvar mapZoom = Math.round(this._map._zoom);\n\n\t\t\t//In case we are starting to split before the animation finished\n\t\t\tthis._processQueue();\n\n\t\t\tif (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split\n\t\t\t\tthis._animationStart();\n\t\t\t\t//Remove clusters now off screen\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());\n\n\t\t\t\tthis._animationZoomIn(this._zoom, mapZoom);\n\n\t\t\t} else if (this._zoom > mapZoom) { //Zoom out, merge\n\t\t\t\tthis._animationStart();\n\n\t\t\t\tthis._animationZoomOut(this._zoom, mapZoom);\n\t\t\t} else {\n\t\t\t\tthis._moveEnd();\n\t\t\t}\n\t\t},\n\n\t\t//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)\n\t\t_getExpandedVisibleBounds: function () {\n\t\t\tif (!this.options.removeOutsideVisibleBounds) {\n\t\t\t\treturn this._mapBoundsInfinite;\n\t\t\t} else if (L.Browser.mobile) {\n\t\t\t\treturn this._checkBoundsMaxLat(this._map.getBounds());\n\t\t\t}\n\n\t\t\treturn this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.\n\t\t},\n\n\t\t/**\n\t\t * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude\n\t\t * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).\n\t\t * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without\n\t\t * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,\n\t\t * making the user think that MCG \"eats\" them and never displays them again.\n\t\t * @param bounds L.LatLngBounds\n\t\t * @returns {L.LatLngBounds}\n\t\t * @private\n\t\t */\n\t\t_checkBoundsMaxLat: function (bounds) {\n\t\t\tvar maxLat = this._maxLat;\n\n\t\t\tif (maxLat !== undefined) {\n\t\t\t\tif (bounds.getNorth() >= maxLat) {\n\t\t\t\t\tbounds._northEast.lat = Infinity;\n\t\t\t\t}\n\t\t\t\tif (bounds.getSouth() <= -maxLat) {\n\t\t\t\t\tbounds._southWest.lat = -Infinity;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bounds;\n\t\t},\n\n\t\t//Shared animation code\n\t\t_animationAddLayerNonAnimated: function (layer, newCluster) {\n\t\t\tif (newCluster === layer) {\n\t\t\t\tthis._featureGroup.addLayer(layer);\n\t\t\t} else if (newCluster._childCount === 2) {\n\t\t\t\tnewCluster._addToMap();\n\n\t\t\t\tvar markers = newCluster.getAllChildMarkers();\n\t\t\t\tthis._featureGroup.removeLayer(markers[0]);\n\t\t\t\tthis._featureGroup.removeLayer(markers[1]);\n\t\t\t} else {\n\t\t\t\tnewCluster._updateIcon();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Extracts individual (i.e. non-group) layers from a Layer Group.\n\t\t * @param group to extract layers from.\n\t\t * @param output {Array} in which to store the extracted layers.\n\t\t * @returns {*|Array}\n\t\t * @private\n\t\t */\n\t\t_extractNonGroupLayers: function (group, output) {\n\t\t\tvar layers = group.getLayers(),\n\t\t\t    i = 0,\n\t\t\t    layer;\n\n\t\t\toutput = output || [];\n\n\t\t\tfor (; i < layers.length; i++) {\n\t\t\t\tlayer = layers[i];\n\n\t\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\t\tthis._extractNonGroupLayers(layer, output);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\toutput.push(layer);\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\t\t/**\n\t\t * Implements the singleMarkerMode option.\n\t\t * @param layer Marker to re-style using the Clusters iconCreateFunction.\n\t\t * @returns {L.Icon} The newly created icon.\n\t\t * @private\n\t\t */\n\t\t_overrideMarkerIcon: function (layer) {\n\t\t\tvar icon = layer.options.icon = this.options.iconCreateFunction({\n\t\t\t\tgetChildCount: function () {\n\t\t\t\t\treturn 1;\n\t\t\t\t},\n\t\t\t\tgetAllChildMarkers: function () {\n\t\t\t\t\treturn [layer];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn icon;\n\t\t}\n\t});\n\n\t// Constant bounds used in case option \"removeOutsideVisibleBounds\" is set to false.\n\tL.MarkerClusterGroup.include({\n\t\t_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))\n\t});\n\n\tL.MarkerClusterGroup.include({\n\t\t_noAnimation: {\n\t\t\t//Non Animated versions of everything\n\t\t\t_animationStart: function () {\n\t\t\t\t//Do nothing...\n\t\t\t},\n\t\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\n\t\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n\t\t\t\tthis.fire('animationend');\n\t\t\t},\n\t\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\n\t\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n\t\t\t\tthis.fire('animationend');\n\t\t\t},\n\t\t\t_animationAddLayer: function (layer, newCluster) {\n\t\t\t\tthis._animationAddLayerNonAnimated(layer, newCluster);\n\t\t\t}\n\t\t},\n\n\t\t_withAnimation: {\n\t\t\t//Animated versions here\n\t\t\t_animationStart: function () {\n\t\t\t\tthis._map._mapPane.className += ' leaflet-cluster-anim';\n\t\t\t\tthis._inZoomAnimation++;\n\t\t\t},\n\n\t\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tvar bounds = this._getExpandedVisibleBounds(),\n\t\t\t\t    fg = this._featureGroup,\n\t\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t\t    i;\n\n\t\t\t\tthis._ignoreMove = true;\n\n\t\t\t\t//Add all children of current clusters to map and remove those clusters from map\n\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\n\t\t\t\t\tvar startPos = c._latlng,\n\t\t\t\t\t    markers  = c._markers,\n\t\t\t\t\t    m;\n\n\t\t\t\t\tif (!bounds.contains(startPos)) {\n\t\t\t\t\t\tstartPos = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us\n\t\t\t\t\t\tfg.removeLayer(c);\n\t\t\t\t\t\tc._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Fade out old cluster\n\t\t\t\t\t\tc.clusterHide();\n\t\t\t\t\t\tc._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Remove all markers that aren't visible any more\n\t\t\t\t\t//TODO: Do we actually need to do this on the higher levels too?\n\t\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = markers[i];\n\t\t\t\t\t\tif (!bounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\tthis._forceLayout();\n\n\t\t\t\t//Update opacities\n\t\t\t\tthis._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\n\t\t\t\t//TODO Maybe? Update markers in _recursivelyBecomeVisible\n\t\t\t\tfg.eachLayer(function (n) {\n\t\t\t\t\tif (!(n instanceof L.MarkerCluster) && n._icon) {\n\t\t\t\t\t\tn.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t//update the positions of the just added clusters/markers\n\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {\n\t\t\t\t\tc._recursivelyRestoreChildPositions(newZoomLevel);\n\t\t\t\t});\n\n\t\t\t\tthis._ignoreMove = false;\n\n\t\t\t\t//Remove the old clusters and close the zoom animation\n\t\t\t\tthis._enqueue(function () {\n\t\t\t\t\t//update the positions of the just added clusters/markers\n\t\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\n\t\t\t\t\t\tfg.removeLayer(c);\n\t\t\t\t\t\tc.clusterShow();\n\t\t\t\t\t});\n\n\t\t\t\t\tthis._animationEnd();\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\n\n\t\t\t\t//Need to add markers for those that weren't on the map before but are now\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t\t\t\t//Remove markers that were on the map before but won't be now\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());\n\t\t\t},\n\n\t\t\t_animationAddLayer: function (layer, newCluster) {\n\t\t\t\tvar me = this,\n\t\t\t\t    fg = this._featureGroup;\n\n\t\t\t\tfg.addLayer(layer);\n\t\t\t\tif (newCluster !== layer) {\n\t\t\t\t\tif (newCluster._childCount > 2) { //Was already a cluster\n\n\t\t\t\t\t\tnewCluster._updateIcon();\n\t\t\t\t\t\tthis._forceLayout();\n\t\t\t\t\t\tthis._animationStart();\n\n\t\t\t\t\t\tlayer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\n\t\t\t\t\t\tlayer.clusterHide();\n\n\t\t\t\t\t\tthis._enqueue(function () {\n\t\t\t\t\t\t\tfg.removeLayer(layer);\n\t\t\t\t\t\t\tlayer.clusterShow();\n\n\t\t\t\t\t\t\tme._animationEnd();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t} else { //Just became a cluster\n\t\t\t\t\t\tthis._forceLayout();\n\n\t\t\t\t\t\tme._animationStart();\n\t\t\t\t\t\tme._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Private methods for animated versions.\n\t\t_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {\n\t\t\tvar bounds = this._getExpandedVisibleBounds(),\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\t//Animate all of the markers in the clusters to move to their cluster center point\n\t\t\tcluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);\n\n\t\t\tvar me = this;\n\n\t\t\t//Update the opacity (If we immediately set it they won't animate)\n\t\t\tthis._forceLayout();\n\t\t\tcluster._recursivelyBecomeVisible(bounds, newZoomLevel);\n\n\t\t\t//TODO: Maybe use the transition timing stuff to make this more reliable\n\t\t\t//When the animations are done, tidy up\n\t\t\tthis._enqueue(function () {\n\n\t\t\t\t//This cluster stopped being a cluster before the timeout fired\n\t\t\t\tif (cluster._childCount === 1) {\n\t\t\t\t\tvar m = cluster._markers[0];\n\t\t\t\t\t//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it\n\t\t\t\t\tthis._ignoreMove = true;\n\t\t\t\t\tm.setLatLng(m.getLatLng());\n\t\t\t\t\tthis._ignoreMove = false;\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcluster._recursively(bounds, newZoomLevel, minZoom, function (c) {\n\t\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tme._animationEnd();\n\t\t\t});\n\t\t},\n\n\t\t_animationEnd: function () {\n\t\t\tif (this._map) {\n\t\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\t\t\t}\n\t\t\tthis._inZoomAnimation--;\n\t\t\tthis.fire('animationend');\n\t\t},\n\n\t\t//Force a browser layout of stuff in the map\n\t\t// Should apply the current opacity and location to all elements so we can update them again for an animation\n\t\t_forceLayout: function () {\n\t\t\t//In my testing this works, infact offsetWidth of any element seems to work.\n\t\t\t//Could loop all this._layers and do this for each _icon if it stops working\n\n\t\t\tL.Util.falseFn(document.body.offsetWidth);\n\t\t}\n\t});\n\n\tL.markerClusterGroup = function (options) {\n\t\treturn new L.MarkerClusterGroup(options);\n\t};\n\n\tvar MarkerCluster = L.MarkerCluster = L.Marker.extend({\n\t\toptions: L.Icon.prototype.options,\n\n\t\tinitialize: function (group, zoom, a, b) {\n\n\t\t\tL.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0),\n\t            { icon: this, pane: group.options.clusterPane });\n\n\t\t\tthis._group = group;\n\t\t\tthis._zoom = zoom;\n\n\t\t\tthis._markers = [];\n\t\t\tthis._childClusters = [];\n\t\t\tthis._childCount = 0;\n\t\t\tthis._iconNeedsUpdate = true;\n\t\t\tthis._boundsNeedUpdate = true;\n\n\t\t\tthis._bounds = new L.LatLngBounds();\n\n\t\t\tif (a) {\n\t\t\t\tthis._addChild(a);\n\t\t\t}\n\t\t\tif (b) {\n\t\t\t\tthis._addChild(b);\n\t\t\t}\n\t\t},\n\n\t\t//Recursively retrieve all child markers of this cluster\n\t\tgetAllChildMarkers: function (storageArray, ignoreDraggedMarker) {\n\t\t\tstorageArray = storageArray || [];\n\n\t\t\tfor (var i = this._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\tthis._childClusters[i].getAllChildMarkers(storageArray, ignoreDraggedMarker);\n\t\t\t}\n\n\t\t\tfor (var j = this._markers.length - 1; j >= 0; j--) {\n\t\t\t\tif (ignoreDraggedMarker && this._markers[j].__dragStart) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstorageArray.push(this._markers[j]);\n\t\t\t}\n\n\t\t\treturn storageArray;\n\t\t},\n\n\t\t//Returns the count of how many child markers we have\n\t\tgetChildCount: function () {\n\t\t\treturn this._childCount;\n\t\t},\n\n\t\t//Zoom to the minimum of showing all of the child markers, or the extents of this cluster\n\t\tzoomToBounds: function (fitBoundsOptions) {\n\t\t\tvar childClusters = this._childClusters.slice(),\n\t\t\t\tmap = this._group._map,\n\t\t\t\tboundsZoom = map.getBoundsZoom(this._bounds),\n\t\t\t\tzoom = this._zoom + 1,\n\t\t\t\tmapZoom = map.getZoom(),\n\t\t\t\ti;\n\n\t\t\t//calculate how far we need to zoom down to see all of the markers\n\t\t\twhile (childClusters.length > 0 && boundsZoom > zoom) {\n\t\t\t\tzoom++;\n\t\t\t\tvar newClusters = [];\n\t\t\t\tfor (i = 0; i < childClusters.length; i++) {\n\t\t\t\t\tnewClusters = newClusters.concat(childClusters[i]._childClusters);\n\t\t\t\t}\n\t\t\t\tchildClusters = newClusters;\n\t\t\t}\n\n\t\t\tif (boundsZoom > zoom) {\n\t\t\t\tthis._group._map.setView(this._latlng, zoom);\n\t\t\t} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead\n\t\t\t\tthis._group._map.setView(this._latlng, mapZoom + 1);\n\t\t\t} else {\n\t\t\t\tthis._group._map.fitBounds(this._bounds, fitBoundsOptions);\n\t\t\t}\n\t\t},\n\n\t\tgetBounds: function () {\n\t\t\tvar bounds = new L.LatLngBounds();\n\t\t\tbounds.extend(this._bounds);\n\t\t\treturn bounds;\n\t\t},\n\n\t\t_updateIcon: function () {\n\t\t\tthis._iconNeedsUpdate = true;\n\t\t\tif (this._icon) {\n\t\t\t\tthis.setIcon(this);\n\t\t\t}\n\t\t},\n\n\t\t//Cludge for Icon, we pretend to be an icon for performance\n\t\tcreateIcon: function () {\n\t\t\tif (this._iconNeedsUpdate) {\n\t\t\t\tthis._iconObj = this._group.options.iconCreateFunction(this);\n\t\t\t\tthis._iconNeedsUpdate = false;\n\t\t\t}\n\t\t\treturn this._iconObj.createIcon();\n\t\t},\n\t\tcreateShadow: function () {\n\t\t\treturn this._iconObj.createShadow();\n\t\t},\n\n\n\t\t_addChild: function (new1, isNotificationFromChild) {\n\n\t\t\tthis._iconNeedsUpdate = true;\n\n\t\t\tthis._boundsNeedUpdate = true;\n\t\t\tthis._setClusterCenter(new1);\n\n\t\t\tif (new1 instanceof L.MarkerCluster) {\n\t\t\t\tif (!isNotificationFromChild) {\n\t\t\t\t\tthis._childClusters.push(new1);\n\t\t\t\t\tnew1.__parent = this;\n\t\t\t\t}\n\t\t\t\tthis._childCount += new1._childCount;\n\t\t\t} else {\n\t\t\t\tif (!isNotificationFromChild) {\n\t\t\t\t\tthis._markers.push(new1);\n\t\t\t\t}\n\t\t\t\tthis._childCount++;\n\t\t\t}\n\n\t\t\tif (this.__parent) {\n\t\t\t\tthis.__parent._addChild(new1, true);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.\n\t\t * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.\n\t\t * @private\n\t\t */\n\t\t_setClusterCenter: function (child) {\n\t\t\tif (!this._cLatLng) {\n\t\t\t\t// when clustering, take position of the first point as the cluster center\n\t\t\t\tthis._cLatLng = child._cLatLng || child._latlng;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Assigns impossible bounding values so that the next extend entirely determines the new bounds.\n\t\t * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.\n\t\t * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.\n\t\t * @private\n\t\t */\n\t\t_resetBounds: function () {\n\t\t\tvar bounds = this._bounds;\n\n\t\t\tif (bounds._southWest) {\n\t\t\t\tbounds._southWest.lat = Infinity;\n\t\t\t\tbounds._southWest.lng = Infinity;\n\t\t\t}\n\t\t\tif (bounds._northEast) {\n\t\t\t\tbounds._northEast.lat = -Infinity;\n\t\t\t\tbounds._northEast.lng = -Infinity;\n\t\t\t}\n\t\t},\n\n\t\t_recalculateBounds: function () {\n\t\t\tvar markers = this._markers,\n\t\t\t    childClusters = this._childClusters,\n\t\t\t    latSum = 0,\n\t\t\t    lngSum = 0,\n\t\t\t    totalCount = this._childCount,\n\t\t\t    i, child, childLatLng, childCount;\n\n\t\t\t// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.\n\t\t\tif (totalCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Reset rather than creating a new object, for performance.\n\t\t\tthis._resetBounds();\n\n\t\t\t// Child markers.\n\t\t\tfor (i = 0; i < markers.length; i++) {\n\t\t\t\tchildLatLng = markers[i]._latlng;\n\n\t\t\t\tthis._bounds.extend(childLatLng);\n\n\t\t\t\tlatSum += childLatLng.lat;\n\t\t\t\tlngSum += childLatLng.lng;\n\t\t\t}\n\n\t\t\t// Child clusters.\n\t\t\tfor (i = 0; i < childClusters.length; i++) {\n\t\t\t\tchild = childClusters[i];\n\n\t\t\t\t// Re-compute child bounds and weighted position first if necessary.\n\t\t\t\tif (child._boundsNeedUpdate) {\n\t\t\t\t\tchild._recalculateBounds();\n\t\t\t\t}\n\n\t\t\t\tthis._bounds.extend(child._bounds);\n\n\t\t\t\tchildLatLng = child._wLatLng;\n\t\t\t\tchildCount = child._childCount;\n\n\t\t\t\tlatSum += childLatLng.lat * childCount;\n\t\t\t\tlngSum += childLatLng.lng * childCount;\n\t\t\t}\n\n\t\t\tthis._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);\n\n\t\t\t// Reset dirty flag.\n\t\t\tthis._boundsNeedUpdate = false;\n\t\t},\n\n\t\t//Set our markers position as given and add it to the map\n\t\t_addToMap: function (startPos) {\n\t\t\tif (startPos) {\n\t\t\t\tthis._backupLatlng = this._latlng;\n\t\t\t\tthis.setLatLng(startPos);\n\t\t\t}\n\t\t\tthis._group._featureGroup.addLayer(this);\n\t\t},\n\n\t\t_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tvar markers = c._markers,\n\t\t\t\t\t\ti, m;\n\t\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = markers[i];\n\n\t\t\t\t\t\t//Only do it if the icon is still on the map\n\t\t\t\t\t\tif (m._icon) {\n\t\t\t\t\t\t\tm._setPos(center);\n\t\t\t\t\t\t\tm.clusterHide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\tvar childClusters = c._childClusters,\n\t\t\t\t\t\tj, cm;\n\t\t\t\t\tfor (j = childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tcm = childClusters[j];\n\t\t\t\t\t\tif (cm._icon) {\n\t\t\t\t\t\t\tcm._setPos(center);\n\t\t\t\t\t\t\tcm.clusterHide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {\n\t\t\tthis._recursively(bounds, newZoomLevel, mapMinZoom,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tc._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);\n\n\t\t\t\t\t//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.\n\t\t\t\t\t//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate\n\t\t\t\t\tif (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {\n\t\t\t\t\t\tc.clusterShow();\n\t\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc.clusterHide();\n\t\t\t\t\t}\n\n\t\t\t\t\tc._addToMap();\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyBecomeVisible: function (bounds, zoomLevel) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {\n\t\t\t\tc.clusterShow();\n\t\t\t});\n\t\t},\n\n\t\t_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tif (zoomLevel === c._zoom) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Add our child markers at startPos (so they can be animated out)\n\t\t\t\t\tfor (var i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar nm = c._markers[i];\n\n\t\t\t\t\t\tif (!bounds.contains(nm._latlng)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (startPos) {\n\t\t\t\t\t\t\tnm._backupLatlng = nm.getLatLng();\n\n\t\t\t\t\t\t\tnm.setLatLng(startPos);\n\t\t\t\t\t\t\tif (nm.clusterHide) {\n\t\t\t\t\t\t\t\tnm.clusterHide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tc._group._featureGroup.addLayer(nm);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\tc._addToMap(startPos);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyRestoreChildPositions: function (zoomLevel) {\n\t\t\t//Fix positions of child markers\n\t\t\tfor (var i = this._markers.length - 1; i >= 0; i--) {\n\t\t\t\tvar nm = this._markers[i];\n\t\t\t\tif (nm._backupLatlng) {\n\t\t\t\t\tnm.setLatLng(nm._backupLatlng);\n\t\t\t\t\tdelete nm._backupLatlng;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (zoomLevel - 1 === this._zoom) {\n\t\t\t\t//Reposition child clusters\n\t\t\t\tfor (var j = this._childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\tthis._childClusters[j]._restorePosition();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var k = this._childClusters.length - 1; k >= 0; k--) {\n\t\t\t\t\tthis._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_restorePosition: function () {\n\t\t\tif (this._backupLatlng) {\n\t\t\t\tthis.setLatLng(this._backupLatlng);\n\t\t\t\tdelete this._backupLatlng;\n\t\t\t}\n\t\t},\n\n\t\t//exceptBounds: If set, don't remove any markers/clusters in it\n\t\t_recursivelyRemoveChildrenFromMap: function (previousBounds, mapMinZoom, zoomLevel, exceptBounds) {\n\t\t\tvar m, i;\n\t\t\tthis._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1,\n\t\t\t\tfunction (c) {\n\t\t\t\t\t//Remove markers at every level\n\t\t\t\t\tfor (i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = c._markers[i];\n\t\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\t//Remove child clusters at just the bottom level\n\t\t\t\t\tfor (i = c._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = c._childClusters[i];\n\t\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t//Run the given functions recursively to this and child clusters\n\t\t// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\n\t\t// zoomLevelToStart: zoom level to start running functions (inclusive)\n\t\t// zoomLevelToStop: zoom level to stop running functions (inclusive)\n\t\t// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\n\t\t// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\n\t\t_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\n\t\t\tvar childClusters = this._childClusters,\n\t\t\t    zoom = this._zoom,\n\t\t\t    i, c;\n\n\t\t\tif (zoomLevelToStart <= zoom) {\n\t\t\t\tif (runAtEveryLevel) {\n\t\t\t\t\trunAtEveryLevel(this);\n\t\t\t\t}\n\t\t\t\tif (runAtBottomLevel && zoom === zoomLevelToStop) {\n\t\t\t\t\trunAtBottomLevel(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {\n\t\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\tc = childClusters[i];\n\t\t\t\t\tif (c._boundsNeedUpdate) {\n\t\t\t\t\t\tc._recalculateBounds();\n\t\t\t\t\t}\n\t\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\n\t\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t//Returns true if we are the parent of only one cluster and that cluster is the same as us\n\t\t_isSingleParent: function () {\n\t\t\t//Don't need to check this._markers as the rest won't work if there are any\n\t\t\treturn this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n\t\t}\n\t});\n\n\t/*\n\t* Extends L.Marker to include two extra methods: clusterHide and clusterShow.\n\t* \n\t* They work as setOpacity(0) and setOpacity(1) respectively, but\n\t* don't overwrite the options.opacity\n\t* \n\t*/\n\n\tL.Marker.include({\n\t\tclusterHide: function () {\n\t\t\tvar backup = this.options.opacity;\n\t\t\tthis.setOpacity(0);\n\t\t\tthis.options.opacity = backup;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\tclusterShow: function () {\n\t\t\treturn this.setOpacity(this.options.opacity);\n\t\t}\n\t});\n\n\tL.DistanceGrid = function (cellSize) {\n\t\tthis._cellSize = cellSize;\n\t\tthis._sqCellSize = cellSize * cellSize;\n\t\tthis._grid = {};\n\t\tthis._objectPoint = { };\n\t};\n\n\tL.DistanceGrid.prototype = {\n\n\t\taddObject: function (obj, point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    grid = this._grid,\n\t\t\t    row = grid[y] = grid[y] || {},\n\t\t\t    cell = row[x] = row[x] || [],\n\t\t\t    stamp = L.Util.stamp(obj);\n\n\t\t\tthis._objectPoint[stamp] = point;\n\n\t\t\tcell.push(obj);\n\t\t},\n\n\t\tupdateObject: function (obj, point) {\n\t\t\tthis.removeObject(obj);\n\t\t\tthis.addObject(obj, point);\n\t\t},\n\n\t\t//Returns true if the object was found\n\t\tremoveObject: function (obj, point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    grid = this._grid,\n\t\t\t    row = grid[y] = grid[y] || {},\n\t\t\t    cell = row[x] = row[x] || [],\n\t\t\t    i, len;\n\n\t\t\tdelete this._objectPoint[L.Util.stamp(obj)];\n\n\t\t\tfor (i = 0, len = cell.length; i < len; i++) {\n\t\t\t\tif (cell[i] === obj) {\n\n\t\t\t\t\tcell.splice(i, 1);\n\n\t\t\t\t\tif (len === 1) {\n\t\t\t\t\t\tdelete row[x];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t},\n\n\t\teachObject: function (fn, context) {\n\t\t\tvar i, j, k, len, row, cell, removed,\n\t\t\t    grid = this._grid;\n\n\t\t\tfor (i in grid) {\n\t\t\t\trow = grid[i];\n\n\t\t\t\tfor (j in row) {\n\t\t\t\t\tcell = row[j];\n\n\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\tremoved = fn.call(context, cell[k]);\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tk--;\n\t\t\t\t\t\t\tlen--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetNearObject: function (point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    i, j, k, row, cell, len, obj, dist,\n\t\t\t    objectPoint = this._objectPoint,\n\t\t\t    closestDistSq = this._sqCellSize,\n\t\t\t    closest = null;\n\n\t\t\tfor (i = y - 1; i <= y + 1; i++) {\n\t\t\t\trow = this._grid[i];\n\t\t\t\tif (row) {\n\n\t\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\n\t\t\t\t\t\tcell = row[j];\n\t\t\t\t\t\tif (cell) {\n\n\t\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\t\t\tobj = cell[k];\n\t\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);\n\t\t\t\t\t\t\t\tif (dist < closestDistSq ||\n\t\t\t\t\t\t\t\t\tdist <= closestDistSq && closest === null) {\n\t\t\t\t\t\t\t\t\tclosestDistSq = dist;\n\t\t\t\t\t\t\t\t\tclosest = obj;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn closest;\n\t\t},\n\n\t\t_getCoord: function (x) {\n\t\t\tvar coord = Math.floor(x / this._cellSize);\n\t\t\treturn isFinite(coord) ? coord : x;\n\t\t},\n\n\t\t_sqDist: function (p, p2) {\n\t\t\tvar dx = p2.x - p.x,\n\t\t\t    dy = p2.y - p.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\t}\n\t};\n\n\t/* Copyright (c) 2012 the authors listed at the following URL, and/or\n\tthe authors of referenced articles or incorporated external code:\n\thttp://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256\n\n\tPermission is hereby granted, free of charge, to any person obtaining\n\ta copy of this software and associated documentation files (the\n\t\"Software\"), to deal in the Software without restriction, including\n\twithout limitation the rights to use, copy, modify, merge, publish,\n\tdistribute, sublicense, and/or sell copies of the Software, and to\n\tpermit persons to whom the Software is furnished to do so, subject to\n\tthe following conditions:\n\n\tThe above copyright notice and this permission notice shall be\n\tincluded in all copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\tMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\tIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n\tCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n\tTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\tSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\tRetrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434\n\t*/\n\n\t(function () {\n\t\tL.QuickHull = {\n\n\t\t\t/*\n\t\t\t * @param {Object} cpt a point to be measured from the baseline\n\t\t\t * @param {Array} bl the baseline, as represented by a two-element\n\t\t\t *   array of latlng objects.\n\t\t\t * @returns {Number} an approximate distance measure\n\t\t\t */\n\t\t\tgetDistant: function (cpt, bl) {\n\t\t\t\tvar vY = bl[1].lat - bl[0].lat,\n\t\t\t\t\tvX = bl[0].lng - bl[1].lng;\n\t\t\t\treturn (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));\n\t\t\t},\n\n\t\t\t/*\n\t\t\t * @param {Array} baseLine a two-element array of latlng objects\n\t\t\t *   representing the baseline to project from\n\t\t\t * @param {Array} latLngs an array of latlng objects\n\t\t\t * @returns {Object} the maximum point and all new points to stay\n\t\t\t *   in consideration for the hull.\n\t\t\t */\n\t\t\tfindMostDistantPointFromBaseLine: function (baseLine, latLngs) {\n\t\t\t\tvar maxD = 0,\n\t\t\t\t\tmaxPt = null,\n\t\t\t\t\tnewPoints = [],\n\t\t\t\t\ti, pt, d;\n\n\t\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\t\tpt = latLngs[i];\n\t\t\t\t\td = this.getDistant(pt, baseLine);\n\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\tnewPoints.push(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (d > maxD) {\n\t\t\t\t\t\tmaxD = d;\n\t\t\t\t\t\tmaxPt = pt;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { maxPoint: maxPt, newPoints: newPoints };\n\t\t\t},\n\n\n\t\t\t/*\n\t\t\t * Given a baseline, compute the convex hull of latLngs as an array\n\t\t\t * of latLngs.\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tbuildConvexHull: function (baseLine, latLngs) {\n\t\t\t\tvar convexHullBaseLines = [],\n\t\t\t\t\tt = this.findMostDistantPointFromBaseLine(baseLine, latLngs);\n\n\t\t\t\tif (t.maxPoint) { // if there is still a point \"outside\" the base line\n\t\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\t\tthis.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)\n\t\t\t\t\t\t);\n\t\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\t\tthis.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)\n\t\t\t\t\t\t);\n\t\t\t\t\treturn convexHullBaseLines;\n\t\t\t\t} else {  // if there is no more point \"outside\" the base line, the current base line is part of the convex hull\n\t\t\t\t\treturn [baseLine[0]];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/*\n\t\t\t * Given an array of latlngs, compute a convex hull as an array\n\t\t\t * of latlngs\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tgetConvexHull: function (latLngs) {\n\t\t\t\t// find first baseline\n\t\t\t\tvar maxLat = false, minLat = false,\n\t\t\t\t\tmaxLng = false, minLng = false,\n\t\t\t\t\tmaxLatPt = null, minLatPt = null,\n\t\t\t\t\tmaxLngPt = null, minLngPt = null,\n\t\t\t\t\tmaxPt = null, minPt = null,\n\t\t\t\t\ti;\n\n\t\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar pt = latLngs[i];\n\t\t\t\t\tif (maxLat === false || pt.lat > maxLat) {\n\t\t\t\t\t\tmaxLatPt = pt;\n\t\t\t\t\t\tmaxLat = pt.lat;\n\t\t\t\t\t}\n\t\t\t\t\tif (minLat === false || pt.lat < minLat) {\n\t\t\t\t\t\tminLatPt = pt;\n\t\t\t\t\t\tminLat = pt.lat;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxLng === false || pt.lng > maxLng) {\n\t\t\t\t\t\tmaxLngPt = pt;\n\t\t\t\t\t\tmaxLng = pt.lng;\n\t\t\t\t\t}\n\t\t\t\t\tif (minLng === false || pt.lng < minLng) {\n\t\t\t\t\t\tminLngPt = pt;\n\t\t\t\t\t\tminLng = pt.lng;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (minLat !== maxLat) {\n\t\t\t\t\tminPt = minLatPt;\n\t\t\t\t\tmaxPt = maxLatPt;\n\t\t\t\t} else {\n\t\t\t\t\tminPt = minLngPt;\n\t\t\t\t\tmaxPt = maxLngPt;\n\t\t\t\t}\n\n\t\t\t\tvar ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),\n\t\t\t\t\t\t\t\t\tthis.buildConvexHull([maxPt, minPt], latLngs));\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t};\n\t}());\n\n\tL.MarkerCluster.include({\n\t\tgetConvexHull: function () {\n\t\t\tvar childMarkers = this.getAllChildMarkers(),\n\t\t\t\tpoints = [],\n\t\t\t\tp, i;\n\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tp = childMarkers[i].getLatLng();\n\t\t\t\tpoints.push(p);\n\t\t\t}\n\n\t\t\treturn L.QuickHull.getConvexHull(points);\n\t\t}\n\t});\n\n\t//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet\n\t//Huge thanks to jawj for implementing it first to make my job easy :-)\n\n\tL.MarkerCluster.include({\n\n\t\t_2PI: Math.PI * 2,\n\t\t_circleFootSeparation: 25, //related to circumference of circle\n\t\t_circleStartAngle: 0,\n\n\t\t_spiralFootSeparation:  28, //related to size of spiral (experiment!)\n\t\t_spiralLengthStart: 11,\n\t\t_spiralLengthFactor: 5,\n\n\t\t_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.\n\t\t\t\t\t\t\t\t\t// 0 -> always spiral; Infinity -> always circle\n\n\t\tspiderfy: function () {\n\t\t\tif (this._group._spiderfied === this || this._group._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar childMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tcenter = map.latLngToLayerPoint(this._latlng),\n\t\t\t\tpositions;\n\n\t\t\tthis._group._unspiderfy();\n\t\t\tthis._group._spiderfied = this;\n\n\t\t\t//TODO Maybe: childMarkers order by distance to center\n\n\t\t\tif (this._group.options.spiderfyShapePositions) {\n\t\t\t\tpositions = this._group.options.spiderfyShapePositions(childMarkers.length, center);\n\t\t\t} else if (childMarkers.length >= this._circleSpiralSwitchover) {\n\t\t\t\tpositions = this._generatePointsSpiral(childMarkers.length, center);\n\t\t\t} else {\n\t\t\t\tcenter.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.\n\t\t\t\tpositions = this._generatePointsCircle(childMarkers.length, center);\n\t\t\t}\n\n\t\t\tthis._animationSpiderfy(childMarkers, positions);\n\t\t},\n\n\t\tunspiderfy: function (zoomDetails) {\n\t\t\t/// <param Name=\"zoomDetails\">Argument from zoomanim if being called in a zoom animation or null otherwise</param>\n\t\t\tif (this._group._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._animationUnspiderfy(zoomDetails);\n\n\t\t\tthis._group._spiderfied = null;\n\t\t},\n\n\t\t_generatePointsCircle: function (count, centerPt) {\n\t\t\tvar circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),\n\t\t\t\tlegLength = circumference / this._2PI,  //radius from circumference\n\t\t\t\tangleStep = this._2PI / count,\n\t\t\t\tres = [],\n\t\t\t\ti, angle;\n\n\t\t\tlegLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.\n\n\t\t\tres.length = count;\n\n\t\t\tfor (i = 0; i < count; i++) { // Clockwise, like spiral.\n\t\t\t\tangle = this._circleStartAngle + i * angleStep;\n\t\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\n\t\t_generatePointsSpiral: function (count, centerPt) {\n\t\t\tvar spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,\n\t\t\t\tlegLength = spiderfyDistanceMultiplier * this._spiralLengthStart,\n\t\t\t\tseparation = spiderfyDistanceMultiplier * this._spiralFootSeparation,\n\t\t\t\tlengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,\n\t\t\t\tangle = 0,\n\t\t\t\tres = [],\n\t\t\t\ti;\n\n\t\t\tres.length = count;\n\n\t\t\t// Higher index, closer position to cluster center.\n\t\t\tfor (i = count; i >= 0; i--) {\n\t\t\t\t// Skip the first position, so that we are already farther from center and we avoid\n\t\t\t\t// being under the default cluster icon (especially important for Circle Markers).\n\t\t\t\tif (i < count) {\n\t\t\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\t\t}\n\t\t\t\tangle += separation / legLength + i * 0.0005;\n\t\t\t\tlegLength += lengthFactor / angle;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\n\t\t_noanimationUnspiderfy: function () {\n\t\t\tvar group = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tm, i;\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\tthis.setOpacity(1);\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tfg.removeLayer(m);\n\n\t\t\t\tif (m._preSpiderfyLatlng) {\n\t\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\t\t\tdelete m._preSpiderfyLatlng;\n\t\t\t\t}\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(0);\n\t\t\t\t}\n\n\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\t\tdelete m._spiderLeg;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup.fire('unspiderfied', {\n\t\t\t\tcluster: this,\n\t\t\t\tmarkers: childMarkers\n\t\t\t});\n\t\t\tgroup._ignoreMove = false;\n\t\t\tgroup._spiderfied = null;\n\t\t}\n\t});\n\n\t//Non Animated versions of everything\n\tL.MarkerClusterNonAnimated = L.MarkerCluster.extend({\n\t\t_animationSpiderfy: function (childMarkers, positions) {\n\t\t\tvar group = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tlegOptions = this._group.options.spiderLegPolylineOptions,\n\t\t\t\ti, m, leg, newPos;\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n\t\t\t// The reverse order trick no longer improves performance on modern browsers.\n\t\t\tfor (i = 0; i < childMarkers.length; i++) {\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n\t\t\t\tleg = new L.Polyline([this._latlng, newPos], legOptions);\n\t\t\t\tmap.addLayer(leg);\n\t\t\t\tm._spiderLeg = leg;\n\n\t\t\t\t// Now add the marker.\n\t\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\t\tm.setLatLng(newPos);\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n\t\t\t\t}\n\n\t\t\t\tfg.addLayer(m);\n\t\t\t}\n\t\t\tthis.setOpacity(0.3);\n\n\t\t\tgroup._ignoreMove = false;\n\t\t\tgroup.fire('spiderfied', {\n\t\t\t\tcluster: this,\n\t\t\t\tmarkers: childMarkers\n\t\t\t});\n\t\t},\n\n\t\t_animationUnspiderfy: function () {\n\t\t\tthis._noanimationUnspiderfy();\n\t\t}\n\t});\n\n\t//Animated versions here\n\tL.MarkerCluster.include({\n\n\t\t_animationSpiderfy: function (childMarkers, positions) {\n\t\t\tvar me = this,\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tthisLayerLatLng = this._latlng,\n\t\t\t\tthisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),\n\t\t\t\tsvg = L.Path.SVG,\n\t\t\t\tlegOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.\n\t\t\t\tfinalLegOpacity = legOptions.opacity,\n\t\t\t\ti, m, leg, legPath, legLength, newPos;\n\n\t\t\tif (finalLegOpacity === undefined) {\n\t\t\t\tfinalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;\n\t\t\t}\n\n\t\t\tif (svg) {\n\t\t\t\t// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.\n\t\t\t\tlegOptions.opacity = 0;\n\n\t\t\t\t// Add the class for CSS transitions.\n\t\t\t\tlegOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';\n\t\t\t} else {\n\t\t\t\t// Make sure we have a defined opacity.\n\t\t\t\tlegOptions.opacity = finalLegOpacity;\n\t\t\t}\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\t// Add markers and spider legs to map, hidden at our center point.\n\t\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n\t\t\t// The reverse order trick no longer improves performance on modern browsers.\n\t\t\tfor (i = 0; i < childMarkers.length; i++) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\n\t\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n\t\t\t\tleg = new L.Polyline([thisLayerLatLng, newPos], legOptions);\n\t\t\t\tmap.addLayer(leg);\n\t\t\t\tm._spiderLeg = leg;\n\n\t\t\t\t// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/\n\t\t\t\t// In our case the transition property is declared in the CSS file.\n\t\t\t\tif (svg) {\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.\n\t\t\t\t\tlegPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.\n\t\t\t\t\tlegPath.style.strokeDashoffset = legLength;\n\t\t\t\t}\n\n\t\t\t\t// If it is a marker, add it now and we'll animate it out\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING\n\t\t\t\t}\n\t\t\t\tif (m.clusterHide) {\n\t\t\t\t\tm.clusterHide();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Vectors just get immediately added\n\t\t\t\tfg.addLayer(m);\n\n\t\t\t\tif (m._setPos) {\n\t\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup._forceLayout();\n\t\t\tgroup._animationStart();\n\n\t\t\t// Reveal markers and spider legs.\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t//Move marker to new position\n\t\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\t\tm.setLatLng(newPos);\n\t\t\t\t\n\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\tm.clusterShow();\n\t\t\t\t}\n\n\t\t\t\t// Animate leg (animation is actually delegated to CSS transition).\n\t\t\t\tif (svg) {\n\t\t\t\t\tleg = m._spiderLeg;\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegPath.style.strokeDashoffset = 0;\n\t\t\t\t\t//legPath.style.strokeOpacity = finalLegOpacity;\n\t\t\t\t\tleg.setStyle({opacity: finalLegOpacity});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.setOpacity(0.3);\n\n\t\t\tgroup._ignoreMove = false;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tgroup._animationEnd();\n\t\t\t\tgroup.fire('spiderfied', {\n\t\t\t\t\tcluster: me,\n\t\t\t\t\tmarkers: childMarkers\n\t\t\t\t});\n\t\t\t}, 200);\n\t\t},\n\n\t\t_animationUnspiderfy: function (zoomDetails) {\n\t\t\tvar me = this,\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tthisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),\n\t\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tsvg = L.Path.SVG,\n\t\t\t\tm, i, leg, legPath, legLength, nonAnimatable;\n\n\t\t\tgroup._ignoreMove = true;\n\t\t\tgroup._animationStart();\n\n\t\t\t//Make us visible and bring the child markers back in\n\t\t\tthis.setOpacity(1);\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t//Marker was added to us after we were spiderfied\n\t\t\t\tif (!m._preSpiderfyLatlng) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll\n\t\t\t\tm.closePopup();\n\n\t\t\t\t//Fix up the location to the real one\n\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\t\tdelete m._preSpiderfyLatlng;\n\n\t\t\t\t//Hack override the location to be our center\n\t\t\t\tnonAnimatable = true;\n\t\t\t\tif (m._setPos) {\n\t\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t\t\tnonAnimatable = false;\n\t\t\t\t}\n\t\t\t\tif (m.clusterHide) {\n\t\t\t\t\tm.clusterHide();\n\t\t\t\t\tnonAnimatable = false;\n\t\t\t\t}\n\t\t\t\tif (nonAnimatable) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t}\n\n\t\t\t\t// Animate the spider leg back in (animation is actually delegated to CSS transition).\n\t\t\t\tif (svg) {\n\t\t\t\t\tleg = m._spiderLeg;\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegLength = legPath.getTotalLength() + 0.1;\n\t\t\t\t\tlegPath.style.strokeDashoffset = legLength;\n\t\t\t\t\tleg.setStyle({opacity: 0});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup._ignoreMove = false;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\t//If we have only <= one child left then that marker will be shown on the map so don't remove it!\n\t\t\t\tvar stillThereChildCount = 0;\n\t\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = childMarkers[i];\n\t\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\t\tstillThereChildCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t\tif (!m._spiderLeg) { //Has already been unspiderfied\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\t\tm.setZIndexOffset(0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stillThereChildCount > 1) {\n\t\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\t}\n\n\t\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\t\tdelete m._spiderLeg;\n\t\t\t\t}\n\t\t\t\tgroup._animationEnd();\n\t\t\t\tgroup.fire('unspiderfied', {\n\t\t\t\t\tcluster: me,\n\t\t\t\t\tmarkers: childMarkers\n\t\t\t\t});\n\t\t\t}, 200);\n\t\t}\n\t});\n\n\n\tL.MarkerClusterGroup.include({\n\t\t//The MarkerCluster currently spiderfied (if any)\n\t\t_spiderfied: null,\n\n\t\tunspiderfy: function () {\n\t\t\tthis._unspiderfy.apply(this, arguments);\n\t\t},\n\n\t\t_spiderfierOnAdd: function () {\n\t\t\tthis._map.on('click', this._unspiderfyWrapper, this);\n\n\t\t\tif (this._map.options.zoomAnimation) {\n\t\t\t\tthis._map.on('zoomstart', this._unspiderfyZoomStart, this);\n\t\t\t}\n\t\t\t//Browsers without zoomAnimation or a big zoom don't fire zoomstart\n\t\t\tthis._map.on('zoomend', this._noanimationUnspiderfy, this);\n\n\t\t\tif (!L.Browser.touch) {\n\t\t\t\tthis._map.getRenderer(this);\n\t\t\t\t//Needs to happen in the pageload, not after, or animations don't work in webkit\n\t\t\t\t//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements\n\t\t\t\t//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable\n\t\t\t}\n\t\t},\n\n\t\t_spiderfierOnRemove: function () {\n\t\t\tthis._map.off('click', this._unspiderfyWrapper, this);\n\t\t\tthis._map.off('zoomstart', this._unspiderfyZoomStart, this);\n\t\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t\tthis._map.off('zoomend', this._noanimationUnspiderfy, this);\n\n\t\t\t//Ensure that markers are back where they should be\n\t\t\t// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane\n\t\t\tthis._noanimationUnspiderfy();\n\t\t},\n\n\t\t//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)\n\t\t//This means we can define the animation they do rather than Markers doing an animation to their actual location\n\t\t_unspiderfyZoomStart: function () {\n\t\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._map.on('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t},\n\n\t\t_unspiderfyZoomAnim: function (zoomDetails) {\n\t\t\t//Wait until the first zoomanim after the user has finished touch-zooming before running the animation\n\t\t\tif (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t\tthis._unspiderfy(zoomDetails);\n\t\t},\n\n\t\t_unspiderfyWrapper: function () {\n\t\t\t/// <summary>_unspiderfy but passes no arguments</summary>\n\t\t\tthis._unspiderfy();\n\t\t},\n\n\t\t_unspiderfy: function (zoomDetails) {\n\t\t\tif (this._spiderfied) {\n\t\t\t\tthis._spiderfied.unspiderfy(zoomDetails);\n\t\t\t}\n\t\t},\n\n\t\t_noanimationUnspiderfy: function () {\n\t\t\tif (this._spiderfied) {\n\t\t\t\tthis._spiderfied._noanimationUnspiderfy();\n\t\t\t}\n\t\t},\n\n\t\t//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc\n\t\t_unspiderfyLayer: function (layer) {\n\t\t\tif (layer._spiderLeg) {\n\t\t\t\tthis._featureGroup.removeLayer(layer);\n\n\t\t\t\tif (layer.clusterShow) {\n\t\t\t\t\tlayer.clusterShow();\n\t\t\t\t}\n\t\t\t\t\t//Position will be fixed up immediately in _animationUnspiderfy\n\t\t\t\tif (layer.setZIndexOffset) {\n\t\t\t\t\tlayer.setZIndexOffset(0);\n\t\t\t\t}\n\n\t\t\t\tthis._map.removeLayer(layer._spiderLeg);\n\t\t\t\tdelete layer._spiderLeg;\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing\n\t * markers' icon options and refreshing their icon and their parent clusters\n\t * accordingly (case where their iconCreateFunction uses data of childMarkers\n\t * to make up the cluster icon).\n\t */\n\n\n\tL.MarkerClusterGroup.include({\n\t\t/**\n\t\t * Updates the icon of all clusters which are parents of the given marker(s).\n\t\t * In singleMarkerMode, also updates the given marker(s) icon.\n\t\t * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|\n\t\t * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent\n\t\t * clusters need to be updated. If not provided, retrieves all child markers of this.\n\t\t * @returns {L.MarkerClusterGroup}\n\t\t */\n\t\trefreshClusters: function (layers) {\n\t\t\tif (!layers) {\n\t\t\t\tlayers = this._topClusterLevel.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.MarkerClusterGroup) {\n\t\t\t\tlayers = layers._topClusterLevel.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.LayerGroup) {\n\t\t\t\tlayers = layers._layers;\n\t\t\t} else if (layers instanceof L.MarkerCluster) {\n\t\t\t\tlayers = layers.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.Marker) {\n\t\t\t\tlayers = [layers];\n\t\t\t} // else: must be an Array(L.Marker)|Map(L.Marker)\n\t\t\tthis._flagParentsIconsNeedUpdate(layers);\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t// In case of singleMarkerMode, also re-draw the markers.\n\t\t\tif (this.options.singleMarkerMode) {\n\t\t\t\tthis._refreshSingleMarkerModeMarkers(layers);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Simply flags all parent clusters of the given markers as having a \"dirty\" icon.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */\n\t\t_flagParentsIconsNeedUpdate: function (layers) {\n\t\t\tvar id, parent;\n\n\t\t\t// Assumes layers is an Array or an Object whose prototype is non-enumerable.\n\t\t\tfor (id in layers) {\n\t\t\t\t// Flag parent clusters' icon as \"dirty\", all the way up.\n\t\t\t\t// Dumb process that flags multiple times upper parents, but still\n\t\t\t\t// much more efficient than trying to be smart and make short lists,\n\t\t\t\t// at least in the case of a hierarchy following a power law:\n\t\t\t\t// http://jsperf.com/flag-nodes-in-power-hierarchy/2\n\t\t\t\tparent = layers[id].__parent;\n\t\t\t\twhile (parent) {\n\t\t\t\t\tparent._iconNeedsUpdate = true;\n\t\t\t\t\tparent = parent.__parent;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Re-draws the icon of the supplied markers.\n\t\t * To be used in singleMarkerMode only.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */\n\t\t_refreshSingleMarkerModeMarkers: function (layers) {\n\t\t\tvar id, layer;\n\n\t\t\tfor (id in layers) {\n\t\t\t\tlayer = layers[id];\n\n\t\t\t\t// Make sure we do not override markers that do not belong to THIS group.\n\t\t\t\tif (this.hasLayer(layer)) {\n\t\t\t\t\t// Need to re-create the icon first, then re-draw the marker.\n\t\t\t\t\tlayer.setIcon(this._overrideMarkerIcon(layer));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tL.Marker.include({\n\t\t/**\n\t\t * Updates the given options in the marker's icon and refreshes the marker.\n\t\t * @param options map object of icon options.\n\t\t * @param directlyRefreshClusters boolean (optional) true to trigger\n\t\t * MCG.refreshClustersOf() right away with this single marker.\n\t\t * @returns {L.Marker}\n\t\t */\n\t\trefreshIconOptions: function (options, directlyRefreshClusters) {\n\t\t\tvar icon = this.options.icon;\n\n\t\t\tL.setOptions(icon, options);\n\n\t\t\tthis.setIcon(icon);\n\n\t\t\t// Shortcut to refresh the associated MCG clusters right away.\n\t\t\t// To be used when refreshing a single marker.\n\t\t\t// Otherwise, better use MCG.refreshClusters() once at the end with\n\t\t\t// the list of modified markers.\n\t\t\tif (directlyRefreshClusters && this.__parent) {\n\t\t\t\tthis.__parent._group.refreshClusters(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\n\texports.MarkerClusterGroup = MarkerClusterGroup;\n\texports.MarkerCluster = MarkerCluster;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=leaflet.markercluster-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsS0FBNEQ7QUFDN0QsQ0FBQyxDQUM4RztBQUMvRyxDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsMENBQTBDOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGNBQWM7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FB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QTtBQUNBOztBQUVBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtEQUErRDtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMEJBQTBCLG9IQUFvSDtBQUM5SSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBLGVBQWUsNkNBQTZDOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLGtDQUFrQztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0RBQWdELGFBQWE7O0FBRTdELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvZGlzdC9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXItc3JjLmpzPzI1NzMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIExlYWZsZXQubWFya2VyY2x1c3RlciAxLjUuMyttYXN0ZXIuZTUxMjRiMixcbiAqIFByb3ZpZGVzIEJlYXV0aWZ1bCBBbmltYXRlZCBNYXJrZXIgQ2x1c3RlcmluZyBmdW5jdGlvbmFsaXR5IGZvciBMZWFmbGV0LCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0Lm1hcmtlcmNsdXN0ZXJcbiAqIChjKSAyMDEyLTIwMTcsIERhdmUgTGVhdmVyLCBzbWFydHJha1xuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeSgoZ2xvYmFsLkxlYWZsZXQgPSBnbG9iYWwuTGVhZmxldCB8fCB7fSwgZ2xvYmFsLkxlYWZsZXQubWFya2VyY2x1c3RlciA9IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblx0Lypcblx0ICogTC5NYXJrZXJDbHVzdGVyR3JvdXAgZXh0ZW5kcyBMLkZlYXR1cmVHcm91cCBieSBjbHVzdGVyaW5nIHRoZSBtYXJrZXJzIGNvbnRhaW5lZCB3aXRoaW5cblx0ICovXG5cblx0dmFyIE1hcmtlckNsdXN0ZXJHcm91cCA9IEwuTWFya2VyQ2x1c3Rlckdyb3VwID0gTC5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcblxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdG1heENsdXN0ZXJSYWRpdXM6IDgwLCAvL0EgY2x1c3RlciB3aWxsIGNvdmVyIGF0IG1vc3QgdGhpcyBtYW55IHBpeGVscyBmcm9tIGl0cyBjZW50ZXJcblx0XHRcdGljb25DcmVhdGVGdW5jdGlvbjogbnVsbCxcblx0XHRcdGNsdXN0ZXJQYW5lOiBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5wYW5lLFxuXG5cdFx0XHRzcGlkZXJmeU9uRXZlcnlab29tOiBmYWxzZSxcblx0XHRcdHNwaWRlcmZ5T25NYXhab29tOiB0cnVlLFxuXHRcdFx0c2hvd0NvdmVyYWdlT25Ib3ZlcjogdHJ1ZSxcblx0XHRcdHpvb21Ub0JvdW5kc09uQ2xpY2s6IHRydWUsXG5cdFx0XHRzaW5nbGVNYXJrZXJNb2RlOiBmYWxzZSxcblxuXHRcdFx0ZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb206IG51bGwsXG5cblx0XHRcdC8vIFNldHRpbmcgdGhpcyB0byBmYWxzZSBwcmV2ZW50cyB0aGUgcmVtb3ZhbCBvZiBhbnkgY2x1c3RlcnMgb3V0c2lkZSBvZiB0aGUgdmlld3BvaW50LCB3aGljaFxuXHRcdFx0Ly8gaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuXHRcdFx0cmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHM6IHRydWUsXG5cblx0XHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGFsbCBhbmltYXRpb25zICh6b29tIGFuZCBzcGlkZXJmeSkuXG5cdFx0XHQvLyBJZiBmYWxzZSwgb3B0aW9uIGFuaW1hdGVBZGRpbmdNYXJrZXJzIGJlbG93IGhhcyBubyBlZmZlY3QuXG5cdFx0XHQvLyBJZiBMLkRvbVV0aWwuVFJBTlNJVElPTiBpcyBmYWxzeSwgdGhpcyBvcHRpb24gaGFzIG5vIGVmZmVjdC5cblx0XHRcdGFuaW1hdGU6IHRydWUsXG5cblx0XHRcdC8vV2hldGhlciB0byBhbmltYXRlIGFkZGluZyBtYXJrZXJzIGFmdGVyIGFkZGluZyB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwIHRvIHRoZSBtYXBcblx0XHRcdC8vIElmIHlvdSBhcmUgYWRkaW5nIGluZGl2aWR1YWwgbWFya2VycyBzZXQgdG8gdHJ1ZSwgaWYgYWRkaW5nIGJ1bGsgbWFya2VycyBsZWF2ZSBmYWxzZSBmb3IgbWFzc2l2ZSBwZXJmb3JtYW5jZSBnYWlucy5cblx0XHRcdGFuaW1hdGVBZGRpbmdNYXJrZXJzOiBmYWxzZSxcblxuXHRcdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBwcm92aWRlIGN1c3RvbSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgc3BpZGVyZnkgc2hhcGUgcG9zaXRpb25zXG5cdFx0XHRzcGlkZXJmeVNoYXBlUG9zaXRpb25zOiBudWxsLFxuXG5cdFx0XHQvL0luY3JlYXNlIHRvIGluY3JlYXNlIHRoZSBkaXN0YW5jZSBhd2F5IHRoYXQgc3BpZGVyZmllZCBtYXJrZXJzIGFwcGVhciBmcm9tIHRoZSBjZW50ZXJcblx0XHRcdHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyOiAxLFxuXG5cdFx0XHQvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIHNwZWNpZnkgYSBwb2x5bGluZSBvcHRpb25zIG9uIGEgc3BpZGVyIGxlZ1xuXHRcdFx0c3BpZGVyTGVnUG9seWxpbmVPcHRpb25zOiB7IHdlaWdodDogMS41LCBjb2xvcjogJyMyMjInLCBvcGFjaXR5OiAwLjUgfSxcblxuXHRcdFx0Ly8gV2hlbiBidWxrIGFkZGluZyBsYXllcnMsIGFkZHMgbWFya2VycyBpbiBjaHVua3MuIE1lYW5zIGFkZExheWVycyBtYXkgbm90IGFkZCBhbGwgdGhlIGxheWVycyBpbiB0aGUgY2FsbCwgb3RoZXJzIHdpbGwgYmUgbG9hZGVkIGR1cmluZyBzZXRUaW1lb3V0c1xuXHRcdFx0Y2h1bmtlZExvYWRpbmc6IGZhbHNlLFxuXHRcdFx0Y2h1bmtJbnRlcnZhbDogMjAwLCAvLyBwcm9jZXNzIG1hcmtlcnMgZm9yIGEgbWF4aW11bSBvZiB+IG4gbWlsbGlzZWNvbmRzICh0aGVuIHRyaWdnZXIgdGhlIGNodW5rUHJvZ3Jlc3MgY2FsbGJhY2spXG5cdFx0XHRjaHVua0RlbGF5OiA1MCwgLy8gYXQgdGhlIGVuZCBvZiBlYWNoIGludGVydmFsLCBnaXZlIG4gbWlsbGlzZWNvbmRzIGJhY2sgdG8gc3lzdGVtL2Jyb3dzZXJcblx0XHRcdGNodW5rUHJvZ3Jlc3M6IG51bGwsIC8vIHByb2dyZXNzIGNhbGxiYWNrOiBmdW5jdGlvbihwcm9jZXNzZWQsIHRvdGFsLCBlbGFwc2VkKSAoZS5nLiBmb3IgYSBwcm9ncmVzcyBpbmRpY2F0b3IpXG5cblx0XHRcdC8vT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBMLlBvbHlnb24gY29uc3RydWN0b3Jcblx0XHRcdHBvbHlnb25PcHRpb25zOiB7fVxuXHRcdH0sXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0TC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24pIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmljb25DcmVhdGVGdW5jdGlvbiA9IHRoaXMuX2RlZmF1bHRJY29uQ3JlYXRlRnVuY3Rpb247XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XG5cblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAgPSBMLmZlYXR1cmVHcm91cCgpO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRFdmVudFBhcmVudCh0aGlzKTtcblxuXHRcdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uID0gMDtcblx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xuXHRcdFx0dGhpcy5fbmVlZHNSZW1vdmluZyA9IFtdOyAvL01hcmtlcnMgcmVtb3ZlZCB3aGlsZSB3ZSBhcmVuJ3Qgb24gdGhlIG1hcCBuZWVkIHRvIGJlIGtlcHQgdHJhY2sgb2Zcblx0XHRcdC8vVGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudGx5IHNob3duIGFyZWEgKGZyb20gX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcykgVXBkYXRlZCBvbiB6b29tL21vdmVcblx0XHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IG51bGw7XG5cblx0XHRcdHRoaXMuX3F1ZXVlID0gW107XG5cblx0XHRcdHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycyA9IHtcblx0XHRcdFx0J2RyYWdzdGFydCc6IHRoaXMuX2NoaWxkTWFya2VyRHJhZ1N0YXJ0LFxuXHRcdFx0XHQnbW92ZSc6IHRoaXMuX2NoaWxkTWFya2VyTW92ZWQsXG5cdFx0XHRcdCdkcmFnZW5kJzogdGhpcy5fY2hpbGRNYXJrZXJEcmFnRW5kLFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSG9vayB0aGUgYXBwcm9wcmlhdGUgYW5pbWF0aW9uIG1ldGhvZHMuXG5cdFx0XHR2YXIgYW5pbWF0ZSA9IEwuRG9tVXRpbC5UUkFOU0lUSU9OICYmIHRoaXMub3B0aW9ucy5hbmltYXRlO1xuXHRcdFx0TC5leHRlbmQodGhpcywgYW5pbWF0ZSA/IHRoaXMuX3dpdGhBbmltYXRpb24gOiB0aGlzLl9ub0FuaW1hdGlvbik7XG5cdFx0XHQvLyBSZW1lbWJlciB3aGljaCBNYXJrZXJDbHVzdGVyIGNsYXNzIHRvIGluc3RhbnRpYXRlIChhbmltYXRlZCBvciBub3QpLlxuXHRcdFx0dGhpcy5fbWFya2VyQ2x1c3RlciA9IGFuaW1hdGUgPyBMLk1hcmtlckNsdXN0ZXIgOiBMLk1hcmtlckNsdXN0ZXJOb25BbmltYXRlZDtcblx0XHR9LFxuXG5cdFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXJzKFtsYXllcl0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvL0Rvbid0IGNsdXN0ZXIgbm9uIHBvaW50IGRhdGFcblx0XHRcdGlmICghbGF5ZXIuZ2V0TGF0TG5nKSB7XG5cdFx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcucHVzaChsYXllcik7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXG5cdFx0XHQvL0lmIHdlIGhhdmUgYWxyZWFkeSBjbHVzdGVyZWQgd2UnbGwgbmVlZCB0byBhZGQgdGhpcyBvbmUgdG8gYSBjbHVzdGVyXG5cblx0XHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XG5cdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIHRoaXMuX21heFpvb20pO1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXG5cdFx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXG5cdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xuXG5cdFx0XHQvL1dvcmsgb3V0IHdoYXQgaXMgdmlzaWJsZVxuXHRcdFx0dmFyIHZpc2libGVMYXllciA9IGxheWVyLFxuXHRcdFx0ICAgIGN1cnJlbnRab29tID0gdGhpcy5fem9vbTtcblx0XHRcdGlmIChsYXllci5fX3BhcmVudCkge1xuXHRcdFx0XHR3aGlsZSAodmlzaWJsZUxheWVyLl9fcGFyZW50Ll96b29tID49IGN1cnJlbnRab29tKSB7XG5cdFx0XHRcdFx0dmlzaWJsZUxheWVyID0gdmlzaWJsZUxheWVyLl9fcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMuY29udGFpbnModmlzaWJsZUxheWVyLmdldExhdExuZygpKSkge1xuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmFuaW1hdGVBZGRpbmdNYXJrZXJzKSB7XG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXIobGF5ZXIsIHZpc2libGVMYXllcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgdmlzaWJsZUxheWVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUxheWVycyhbbGF5ZXJdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Ob24gcG9pbnQgbGF5ZXJzXG5cdFx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xuXHRcdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9hcnJheVNwbGljZSh0aGlzLl9uZWVkc0NsdXN0ZXJpbmcsIGxheWVyKSAmJiB0aGlzLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcucHVzaCh7IGxheWVyOiBsYXllciwgbGF0bG5nOiBsYXllci5fbGF0bG5nIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbGF5ZXIuX19wYXJlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XG5cdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblx0XHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKGxheWVyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIGNsdXN0ZXJzXG5cdFx0XHR0aGlzLl9yZW1vdmVMYXllcihsYXllciwgdHJ1ZSk7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cblx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XG5cblx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdGxheWVyLm9mZih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xuXG5cdFx0XHRpZiAodGhpcy5fZmVhdHVyZUdyb3VwLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHRpZiAobGF5ZXIuY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIGFkZHMgdGhlbSBpbiBidWxrXG5cdFx0YWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzQXJyYXksIHNraXBMYXllckFkZEV2ZW50KSB7XG5cdFx0XHRpZiAoIUwuVXRpbC5pc0FycmF5KGxheWVyc0FycmF5KSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcnNBcnJheSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcblx0XHRcdCAgICBucGcgPSB0aGlzLl9ub25Qb2ludEdyb3VwLFxuXHRcdFx0ICAgIGNodW5rZWQgPSB0aGlzLm9wdGlvbnMuY2h1bmtlZExvYWRpbmcsXG5cdFx0XHQgICAgY2h1bmtJbnRlcnZhbCA9IHRoaXMub3B0aW9ucy5jaHVua0ludGVydmFsLFxuXHRcdFx0ICAgIGNodW5rUHJvZ3Jlc3MgPSB0aGlzLm9wdGlvbnMuY2h1bmtQcm9ncmVzcyxcblx0XHRcdCAgICBsID0gbGF5ZXJzQXJyYXkubGVuZ3RoLFxuXHRcdFx0ICAgIG9mZnNldCA9IDAsXG5cdFx0XHQgICAgb3JpZ2luYWxBcnJheSA9IHRydWUsXG5cdFx0XHQgICAgbTtcblxuXHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHR2YXIgc3RhcnRlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0XHRcdHZhciBwcm9jZXNzID0gTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRvIHVuc3BpZGVyZnkgYmVmb3JlIHN0YXJ0aW5nIHRvIGFkZCBzb21lIGxheWVyc1xuXHRcdFx0XHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoOyBvZmZzZXQgPCBsOyBvZmZzZXQrKykge1xuXHRcdFx0XHRcdFx0aWYgKGNodW5rZWQgJiYgb2Zmc2V0ICUgMjAwID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGV2ZXJ5IGNvdXBsZSBodW5kcmVkIG1hcmtlcnMsIGluc3RydW1lbnQgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSBwcm9jZXNzaW5nIHN0YXJ0ZWQ6XG5cdFx0XHRcdFx0XHRcdHZhciBlbGFwc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRpZiAoZWxhcHNlZCA+IGNodW5rSW50ZXJ2YWwpIHtcblx0XHRcdFx0XHRcdFx0XHRicmVhazsgLy8gYmVlbiB3b3JraW5nIHRvbyBoYXJkLCB0aW1lIHRvIHRha2UgYSBicmVhayA6LSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbb2Zmc2V0XTtcblxuXHRcdFx0XHRcdFx0Ly8gR3JvdXAgb2YgbGF5ZXJzLCBhcHBlbmQgY2hpbGRyZW4gdG8gbGF5ZXJzQXJyYXkgYW5kIHNraXAuXG5cdFx0XHRcdFx0XHQvLyBTaWRlIGVmZmVjdHM6XG5cdFx0XHRcdFx0XHQvLyAtIFRvdGFsIGluY3JlYXNlcywgc28gY2h1bmtQcm9ncmVzcyByYXRpbyBqdW1wcyBiYWNrd2FyZC5cblx0XHRcdFx0XHRcdC8vIC0gR3JvdXBzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpcyBncm91cCwgb25seSB0aGVpciBub24tZ3JvdXAgY2hpbGQgbGF5ZXJzIChoYXNMYXllcikuXG5cdFx0XHRcdFx0XHQvLyBDaGFuZ2luZyBhcnJheSBsZW5ndGggd2hpbGUgbG9vcGluZyBkb2VzIG5vdCBhZmZlY3QgcGVyZm9ybWFuY2UgaW4gY3VycmVudCBicm93c2Vyczpcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Zvci1sb29wLWNoYW5naW5nLWxlbmd0aC82XG5cdFx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRcdGxheWVyc0FycmF5ID0gbGF5ZXJzQXJyYXkuc2xpY2UoKTtcblx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5KTtcblx0XHRcdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vTm90IHBvaW50IGRhdGEsIGNhbid0IGJlIGNsdXN0ZXJlZFxuXHRcdFx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xuXHRcdFx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbSB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRoaXMuX2FkZExheWVyKG0sIHRoaXMuX21heFpvb20pO1xuXHRcdFx0XHRcdFx0aWYgKCFza2lwTGF5ZXJBZGRFdmVudCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbSB9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly9JZiB3ZSBqdXN0IG1hZGUgYSBjbHVzdGVyIG9mIHNpemUgMiB0aGVuIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBvdGhlciBtYXJrZXIgZnJvbSB0aGUgbWFwIChpZiBpdCBpcykgb3Igd2UgbmV2ZXIgd2lsbFxuXHRcdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hcmtlcnMgPSBtLl9fcGFyZW50LmdldEFsbENoaWxkTWFya2VycygpLFxuXHRcdFx0XHRcdFx0XHRcdCAgICBvdGhlck1hcmtlciA9IG1hcmtlcnNbMF0gPT09IG0gPyBtYXJrZXJzWzFdIDogbWFya2Vyc1swXTtcblx0XHRcdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihvdGhlck1hcmtlcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoY2h1bmtQcm9ncmVzcykge1xuXHRcdFx0XHRcdFx0Ly8gcmVwb3J0IHByb2dyZXNzIGFuZCB0aW1lIGVsYXBzZWQ6XG5cdFx0XHRcdFx0XHRjaHVua1Byb2dyZXNzKG9mZnNldCwgbCwgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0ZWQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIENvbXBsZXRlZCBwcm9jZXNzaW5nIGFsbCBtYXJrZXJzLlxuXHRcdFx0XHRcdGlmIChvZmZzZXQgPT09IGwpIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cblx0XHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgdGhpcy5fem9vbSwgdGhpcy5fY3VycmVudFNob3duQm91bmRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChwcm9jZXNzLCB0aGlzLm9wdGlvbnMuY2h1bmtEZWxheSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbmVlZHNDbHVzdGVyaW5nID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xuXG5cdFx0XHRcdGZvciAoOyBvZmZzZXQgPCBsOyBvZmZzZXQrKykge1xuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheVtvZmZzZXRdO1xuXG5cdFx0XHRcdFx0Ly8gR3JvdXAgb2YgbGF5ZXJzLCBhcHBlbmQgY2hpbGRyZW4gdG8gbGF5ZXJzQXJyYXkgYW5kIHNraXAuXG5cdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0XHRcdGlmIChvcmlnaW5hbEFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdGxheWVyc0FycmF5ID0gbGF5ZXJzQXJyYXkuc2xpY2UoKTtcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5KTtcblx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcblx0XHRcdFx0XHRpZiAoIW0uZ2V0TGF0TG5nKSB7XG5cdFx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodGhpcy5oYXNMYXllcihtKSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bmVlZHNDbHVzdGVyaW5nLnB1c2gobSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIHJlbW92ZXMgdGhlbSBpbiBidWxrXG5cdFx0cmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzQXJyYXkpIHtcblx0XHRcdHZhciBpLCBtLFxuXHRcdFx0ICAgIGwgPSBsYXllcnNBcnJheS5sZW5ndGgsXG5cdFx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcblx0XHRcdCAgICBvcmlnaW5hbEFycmF5ID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheVtpXTtcblxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxuXHRcdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XG5cdFx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBtKTtcblx0XHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcucHVzaCh7IGxheWVyOiBtLCBsYXRsbmc6IG0uX2xhdGxuZyB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XG5cdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblxuXHRcdFx0XHQvLyBXb3JrIG9uIGEgY29weSBvZiB0aGUgYXJyYXksIHNvIHRoYXQgbmV4dCBsb29wIGlzIG5vdCBhZmZlY3RlZC5cblx0XHRcdFx0dmFyIGxheWVyc0FycmF5MiA9IGxheWVyc0FycmF5LnNsaWNlKCksXG5cdFx0XHRcdCAgICBsMiA9IGw7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsMjsgaSsrKSB7XG5cdFx0XHRcdFx0bSA9IGxheWVyc0FycmF5MltpXTtcblxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxuXHRcdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkyKTtcblx0XHRcdFx0XHRcdGwyID0gbGF5ZXJzQXJyYXkyLmxlbmd0aDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnlMYXllcihtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdG0gPSBsYXllcnNBcnJheVtpXTtcblxuXHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xuXHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xuXHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIW0uX19wYXJlbnQpIHtcblx0XHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9yZW1vdmVMYXllcihtLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XG5cblx0XHRcdFx0aWYgKGZnLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcblxuXHRcdFx0Ly9GaXggdXAgdGhlIGNsdXN0ZXJzIGFuZCBtYXJrZXJzIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvL1JlbW92ZXMgYWxsIGxheWVycyBmcm9tIHRoZSBNYXJrZXJDbHVzdGVyR3JvdXBcblx0XHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly9OZWVkIG91ciBvd24gc3BlY2lhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGUgTGF5ZXJHcm91cCBvbmUgZG9lc24ndCB3b3JrIGZvciB1c1xuXG5cdFx0XHQvL0lmIHdlIGFyZW4ndCBvbiB0aGUgbWFwICh5ZXQpLCBibG93IGF3YXkgdGhlIG1hcmtlcnMgd2Uga25vdyBvZlxuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XG5cdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2dyaWRDbHVzdGVycztcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2dyaWRVbmNsdXN0ZXJlZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9SZW1vdmUgYWxsIHRoZSB2aXNpYmxlIGxheWVyc1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cblx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHRcdFx0bWFya2VyLm9mZih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xuXHRcdFx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0Ly9SZXNldCBfdG9wQ2x1c3RlckxldmVsIGFuZCB0aGUgRGlzdGFuY2VHcmlkc1xuXHRcdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZSBGZWF0dXJlR3JvdXAuZ2V0Qm91bmRzIGFzIGl0IGRvZXNuJ3Qgd29ya1xuXHRcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xuXG5cdFx0XHRpZiAodGhpcy5fdG9wQ2x1c3RlckxldmVsKSB7XG5cdFx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fdG9wQ2x1c3RlckxldmVsLl9ib3VuZHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fbmVlZHNDbHVzdGVyaW5nW2ldLmdldExhdExuZygpKTtcblx0XHRcdH1cblxuXHRcdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9ub25Qb2ludEdyb3VwLmdldEJvdW5kcygpKTtcblxuXHRcdFx0cmV0dXJuIGJvdW5kcztcblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5lYWNoTGF5ZXJcblx0XHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRcdHZhciBtYXJrZXJzID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nLnNsaWNlKCksXG5cdFx0XHRcdG5lZWRzUmVtb3ZpbmcgPSB0aGlzLl9uZWVkc1JlbW92aW5nLFxuXHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZywgaSwgajtcblxuXHRcdFx0aWYgKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCkge1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKG1hcmtlcnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHRoaXNOZWVkc1JlbW92aW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRmb3IgKGogPSBuZWVkc1JlbW92aW5nLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0aWYgKG5lZWRzUmVtb3Zpbmdbal0ubGF5ZXIgPT09IG1hcmtlcnNbaV0pIHtcblx0XHRcdFx0XHRcdHRoaXNOZWVkc1JlbW92aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpc05lZWRzUmVtb3ZpbmcpIHtcblx0XHRcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCBtYXJrZXJzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmVhY2hMYXllcihtZXRob2QsIGNvbnRleHQpO1xuXHRcdH0sXG5cblx0XHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyc1xuXHRcdGdldExheWVyczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxheWVycyA9IFtdO1xuXHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcblx0XHRcdFx0bGF5ZXJzLnB1c2gobCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBsYXllcnM7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZ2V0TGF5ZXIsIFdBUk5JTkc6IFJlYWxseSBiYWQgcGVyZm9ybWFuY2Vcblx0XHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcblxuXHRcdFx0aWQgPSBwYXJzZUludChpZCwgMTApO1xuXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobCkge1xuXHRcdFx0XHRpZiAoTC5zdGFtcChsKSA9PT0gaWQpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBsO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXG5cdFx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGluIHRoaXMgTWFya2VyQ2x1c3Rlckdyb3VwXG5cdFx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdFx0aWYgKCFsYXllcikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpLCBhbkFycmF5ID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xuXG5cdFx0XHRmb3IgKGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChhbkFycmF5W2ldID09PSBsYXllcikge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGFuQXJyYXkgPSB0aGlzLl9uZWVkc1JlbW92aW5nO1xuXHRcdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoYW5BcnJheVtpXS5sYXllciA9PT0gbGF5ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICEhKGxheWVyLl9fcGFyZW50ICYmIGxheWVyLl9fcGFyZW50Ll9ncm91cCA9PT0gdGhpcykgfHwgdGhpcy5fbm9uUG9pbnRHcm91cC5oYXNMYXllcihsYXllcik7XG5cdFx0fSxcblxuXHRcdC8vWm9vbSBkb3duIHRvIHNob3cgdGhlIGdpdmVuIGxheWVyIChzcGlkZXJmeWluZyBpZiBuZWNlc3NhcnkpIHRoZW4gY2FsbHMgdGhlIGNhbGxiYWNrXG5cdFx0em9vbVRvU2hvd0xheWVyOiBmdW5jdGlvbiAobGF5ZXIsIGNhbGxiYWNrKSB7XG5cblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHNob3dNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIEFzc3VtZXMgdGhhdCBtYXAuaGFzTGF5ZXIgY2hlY2tzIGZvciBkaXJlY3QgYXBwZWFyYW5jZSBvbiBtYXAsIG5vdCByZWN1cnNpdmVseSBjYWxsaW5nXG5cdFx0XHRcdC8vIGhhc0xheWVyIG9uIExheWVyIEdyb3VwcyB0aGF0IGFyZSBvbiBtYXAgKHR5cGljYWxseSBub3QgY2FsbGluZyB0aGlzIE1hcmtlckNsdXN0ZXJHcm91cC5oYXNMYXllciwgd2hpY2ggd291bGQgYWx3YXlzIHJldHVybiB0cnVlKVxuXHRcdFx0XHRpZiAoKG1hcC5oYXNMYXllcihsYXllcikgfHwgbWFwLmhhc0xheWVyKGxheWVyLl9fcGFyZW50KSkgJiYgIXRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdFx0XHR0aGlzLm9mZignYW5pbWF0aW9uZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XG5cblx0XHRcdFx0XHRpZiAobWFwLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll9pY29uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm9uY2UoJ3NwaWRlcmZpZWQnLCBjYWxsYmFjaywgdGhpcyk7XG5cdFx0XHRcdFx0XHRsYXllci5fX3BhcmVudC5zcGlkZXJmeSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKGxheWVyLl9pY29uICYmIHRoaXMuX21hcC5nZXRCb3VuZHMoKS5jb250YWlucyhsYXllci5nZXRMYXRMbmcoKSkpIHtcblx0XHRcdFx0Ly9MYXllciBpcyB2aXNpYmxlIG9uZCBvbiBzY3JlZW4sIGltbWVkaWF0ZSByZXR1cm5cblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIuX19wYXJlbnQuX3pvb20gPCBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSkpIHtcblx0XHRcdFx0Ly9MYXllciBzaG91bGQgYmUgdmlzaWJsZSBhdCB0aGlzIHpvb20gbGV2ZWwuIEl0IG11c3Qgbm90IGJlIG9uIHNjcmVlbiBzbyBqdXN0IHBhbiBvdmVyIHRvIGl0XG5cdFx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9tYXAucGFuVG8obGF5ZXIuZ2V0TGF0TG5nKCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XG5cdFx0XHRcdHRoaXMub24oJ2FuaW1hdGlvbmVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXHRcdFx0XHRsYXllci5fX3BhcmVudC56b29tVG9Cb3VuZHMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZXMgRmVhdHVyZUdyb3VwLm9uQWRkXG5cdFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHRcdHZhciBpLCBsLCBsYXllcjtcblxuXHRcdFx0aWYgKCFpc0Zpbml0ZSh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSkge1xuXHRcdFx0XHR0aHJvdyBcIk1hcCBoYXMgbm8gbWF4Wm9vbSBzcGVjaWZpZWRcIjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmFkZFRvKG1hcCk7XG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZFRvKG1hcCk7XG5cblx0XHRcdGlmICghdGhpcy5fZ3JpZENsdXN0ZXJzKSB7XG5cdFx0XHRcdHRoaXMuX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21heExhdCA9IG1hcC5vcHRpb25zLmNycy5wcm9qZWN0aW9uLk1BWF9MQVRJVFVERTtcblxuXHRcdFx0Ly9SZXN0b3JlIGFsbCB0aGUgcG9zaXRpb25zIGFzIHRoZXkgYXJlIGluIHRoZSBNQ0cgYmVmb3JlIHJlbW92aW5nIHRoZW1cblx0XHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc1JlbW92aW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XG5cdFx0XHRcdGxheWVyLm5ld2xhdGxuZyA9IGxheWVyLmxheWVyLl9sYXRsbmc7XG5cdFx0XHRcdGxheWVyLmxheWVyLl9sYXRsbmcgPSBsYXllci5sYXRsbmc7XG5cdFx0XHR9XG5cdFx0XHQvL1JlbW92ZSB0aGVtLCB0aGVuIHJlc3RvcmUgdGhlaXIgbmV3IHBvc2l0aW9uc1xuXHRcdFx0Zm9yIChpID0gMCwgbCA9IHRoaXMuX25lZWRzUmVtb3ZpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbmVlZHNSZW1vdmluZ1tpXTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobGF5ZXIubGF5ZXIsIHRydWUpO1xuXHRcdFx0XHRsYXllci5sYXllci5fbGF0bG5nID0gbGF5ZXIubmV3bGF0bG5nO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbmVlZHNSZW1vdmluZyA9IFtdO1xuXG5cdFx0XHQvL1JlbWVtYmVyIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYW5kIGJvdW5kc1xuXHRcdFx0dGhpcy5fem9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcblx0XHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xuXG5cdFx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl96b29tRW5kLCB0aGlzKTtcblx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xuXG5cdFx0XHRpZiAodGhpcy5fc3BpZGVyZmllck9uQWRkKSB7IC8vVE9ETyBGSVhNRTogTm90IHN1cmUgaG93IHRvIGhhdmUgc3BpZGVyZmllciBhZGQgc29tZXRoaW5nIG9uIGhlcmUgbmljZWx5XG5cdFx0XHRcdHRoaXMuX3NwaWRlcmZpZXJPbkFkZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9iaW5kRXZlbnRzKCk7XG5cblx0XHRcdC8vQWN0dWFsbHkgYWRkIG91ciBtYXJrZXJzIHRvIHRoZSBtYXA6XG5cdFx0XHRsID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xuXHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XG5cdFx0XHR0aGlzLmFkZExheWVycyhsLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZXMgRmVhdHVyZUdyb3VwLm9uUmVtb3ZlXG5cdFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl96b29tRW5kLCB0aGlzKTtcblx0XHRcdG1hcC5vZmYoJ21vdmVlbmQnLCB0aGlzLl9tb3ZlRW5kLCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fdW5iaW5kRXZlbnRzKCk7XG5cblx0XHRcdC8vSW4gY2FzZSB3ZSBhcmUgaW4gYSBjbHVzdGVyIGFuaW1hdGlvblxuXHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSA9IHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY2x1c3Rlci1hbmltJywgJycpO1xuXG5cdFx0XHRpZiAodGhpcy5fc3BpZGVyZmllck9uUmVtb3ZlKSB7IC8vVE9ETyBGSVhNRTogTm90IHN1cmUgaG93IHRvIGhhdmUgc3BpZGVyZmllciBhZGQgc29tZXRoaW5nIG9uIGhlcmUgbmljZWx5XG5cdFx0XHRcdHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgdGhpcy5fbWF4TGF0O1xuXG5cdFx0XHQvL0NsZWFuIHVwIGFsbCB0aGUgbGF5ZXJzIHdlIGFkZGVkIHRvIHRoZSBtYXBcblx0XHRcdHRoaXMuX2hpZGVDb3ZlcmFnZSgpO1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5yZW1vdmUoKTtcblxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cblx0XHRcdHRoaXMuX21hcCA9IG51bGw7XG5cdFx0fSxcblxuXHRcdGdldFZpc2libGVQYXJlbnQ6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHRcdHZhciB2TWFya2VyID0gbWFya2VyO1xuXHRcdFx0d2hpbGUgKHZNYXJrZXIgJiYgIXZNYXJrZXIuX2ljb24pIHtcblx0XHRcdFx0dk1hcmtlciA9IHZNYXJrZXIuX19wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdk1hcmtlciB8fCBudWxsO1xuXHRcdH0sXG5cblx0XHQvL1JlbW92ZSB0aGUgZ2l2ZW4gb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5XG5cdFx0X2FycmF5U3BsaWNlOiBmdW5jdGlvbiAoYW5BcnJheSwgb2JqKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gb2JqKSB7XG5cdFx0XHRcdFx0YW5BcnJheS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhIG1hcmtlciBmcm9tIGFsbCBfZ3JpZFVuY2x1c3RlcmVkIHpvb20gbGV2ZWxzLCBzdGFydGluZyBhdCB0aGUgc3VwcGxpZWQgem9vbS5cblx0XHQgKiBAcGFyYW0gbWFya2VyIHRvIGJlIHJlbW92ZWQgZnJvbSBfZ3JpZFVuY2x1c3RlcmVkLlxuXHRcdCAqIEBwYXJhbSB6IGludGVnZXIgYm90dG9tIHN0YXJ0IHpvb20gbGV2ZWwgKGluY2x1ZGVkKVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQ6IGZ1bmN0aW9uIChtYXJrZXIsIHopIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHQgICAgZ3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcblxuXHRcdFx0Zm9yICg7IHogPj0gbWluWm9vbTsgei0tKSB7XG5cdFx0XHRcdGlmICghZ3JpZFVuY2x1c3RlcmVkW3pdLnJlbW92ZU9iamVjdChtYXJrZXIsIG1hcC5wcm9qZWN0KG1hcmtlci5nZXRMYXRMbmcoKSwgeikpKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2NoaWxkTWFya2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0ZS50YXJnZXQuX19kcmFnU3RhcnQgPSBlLnRhcmdldC5fbGF0bG5nO1xuXHRcdH0sXG5cblx0XHRfY2hpbGRNYXJrZXJNb3ZlZDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmICghdGhpcy5faWdub3JlTW92ZSAmJiAhZS50YXJnZXQuX19kcmFnU3RhcnQpIHtcblx0XHRcdFx0dmFyIGlzUG9wdXBPcGVuID0gZS50YXJnZXQuX3BvcHVwICYmIGUudGFyZ2V0Ll9wb3B1cC5pc09wZW4oKTtcblxuXHRcdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGUub2xkTGF0TG5nLCBlLmxhdGxuZyk7XG5cblx0XHRcdFx0aWYgKGlzUG9wdXBPcGVuKSB7XG5cdFx0XHRcdFx0ZS50YXJnZXQub3BlblBvcHVwKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X21vdmVDaGlsZDogZnVuY3Rpb24gKGxheWVyLCBmcm9tLCB0bykge1xuXHRcdFx0bGF5ZXIuX2xhdGxuZyA9IGZyb207XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKGxheWVyKTtcblxuXHRcdFx0bGF5ZXIuX2xhdGxuZyA9IHRvO1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcik7XG5cdFx0fSxcblxuXHRcdF9jaGlsZE1hcmtlckRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgZHJhZ1N0YXJ0ID0gZS50YXJnZXQuX19kcmFnU3RhcnQ7XG5cdFx0XHRkZWxldGUgZS50YXJnZXQuX19kcmFnU3RhcnQ7XG5cdFx0XHRpZiAoZHJhZ1N0YXJ0KSB7XG5cdFx0XHRcdHRoaXMuX21vdmVDaGlsZChlLnRhcmdldCwgZHJhZ1N0YXJ0LCBlLnRhcmdldC5fbGF0bG5nKTtcblx0XHRcdH1cdFx0XG5cdFx0fSxcblxuXG5cdFx0Ly9JbnRlcm5hbCBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYSBtYXJrZXIgZnJvbSBldmVyeXRoaW5nLlxuXHRcdC8vZG9udFVwZGF0ZU1hcDogc2V0IHRvIHRydWUgaWYgeW91IHdpbGwgaGFuZGxlIHVwZGF0aW5nIHRoZSBtYXAgbWFudWFsbHkgKGZvciBidWxrIGZ1bmN0aW9ucylcblx0XHRfcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChtYXJrZXIsIHJlbW92ZUZyb21EaXN0YW5jZUdyaWQsIGRvbnRVcGRhdGVNYXApIHtcblx0XHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXG5cdFx0XHRcdGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcblx0XHRcdFx0ZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHRcdG1hcCA9IHRoaXMuX21hcCxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XG5cblx0XHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSBkaXN0YW5jZSBjbHVzdGVycyBpdCBtaWdodCBiZSBpblxuXHRcdFx0aWYgKHJlbW92ZUZyb21EaXN0YW5jZUdyaWQpIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlRnJvbUdyaWRVbmNsdXN0ZXJlZChtYXJrZXIsIHRoaXMuX21heFpvb20pO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1dvcmsgb3VyIHdheSB1cCB0aGUgY2x1c3RlcnMgcmVtb3ZpbmcgdGhlbSBhcyB3ZSBnbyBpZiByZXF1aXJlZFxuXHRcdFx0dmFyIGNsdXN0ZXIgPSBtYXJrZXIuX19wYXJlbnQsXG5cdFx0XHRcdG1hcmtlcnMgPSBjbHVzdGVyLl9tYXJrZXJzLFxuXHRcdFx0XHRvdGhlck1hcmtlcjtcblxuXHRcdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBpbW1lZGlhdGUgcGFyZW50cyBtYXJrZXIgbGlzdFxuXHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UobWFya2VycywgbWFya2VyKTtcblxuXHRcdFx0d2hpbGUgKGNsdXN0ZXIpIHtcblx0XHRcdFx0Y2x1c3Rlci5fY2hpbGRDb3VudC0tO1xuXHRcdFx0XHRjbHVzdGVyLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoY2x1c3Rlci5fem9vbSA8IG1pblpvb20pIHtcblx0XHRcdFx0XHQvL1RvcCBsZXZlbCwgZG8gbm90aGluZ1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlbW92ZUZyb21EaXN0YW5jZUdyaWQgJiYgY2x1c3Rlci5fY2hpbGRDb3VudCA8PSAxKSB7IC8vQ2x1c3RlciBubyBsb25nZXIgcmVxdWlyZWRcblx0XHRcdFx0XHQvL1dlIG5lZWQgdG8gcHVzaCB0aGUgb3RoZXIgbWFya2VyIHVwIHRvIHRoZSBwYXJlbnRcblx0XHRcdFx0XHRvdGhlck1hcmtlciA9IGNsdXN0ZXIuX21hcmtlcnNbMF0gPT09IG1hcmtlciA/IGNsdXN0ZXIuX21hcmtlcnNbMV0gOiBjbHVzdGVyLl9tYXJrZXJzWzBdO1xuXG5cdFx0XHRcdFx0Ly9VcGRhdGUgZGlzdGFuY2UgZ3JpZFxuXHRcdFx0XHRcdGdyaWRDbHVzdGVyc1tjbHVzdGVyLl96b29tXS5yZW1vdmVPYmplY3QoY2x1c3RlciwgbWFwLnByb2plY3QoY2x1c3Rlci5fY0xhdExuZywgY2x1c3Rlci5fem9vbSkpO1xuXHRcdFx0XHRcdGdyaWRVbmNsdXN0ZXJlZFtjbHVzdGVyLl96b29tXS5hZGRPYmplY3Qob3RoZXJNYXJrZXIsIG1hcC5wcm9qZWN0KG90aGVyTWFya2VyLmdldExhdExuZygpLCBjbHVzdGVyLl96b29tKSk7XG5cblx0XHRcdFx0XHQvL01vdmUgb3RoZXJNYXJrZXIgdXAgdG8gcGFyZW50XG5cdFx0XHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UoY2x1c3Rlci5fX3BhcmVudC5fY2hpbGRDbHVzdGVycywgY2x1c3Rlcik7XG5cdFx0XHRcdFx0Y2x1c3Rlci5fX3BhcmVudC5fbWFya2Vycy5wdXNoKG90aGVyTWFya2VyKTtcblx0XHRcdFx0XHRvdGhlck1hcmtlci5fX3BhcmVudCA9IGNsdXN0ZXIuX19wYXJlbnQ7XG5cblx0XHRcdFx0XHRpZiAoY2x1c3Rlci5faWNvbikge1xuXHRcdFx0XHRcdFx0Ly9DbHVzdGVyIGlzIGN1cnJlbnRseSBvbiB0aGUgbWFwLCBuZWVkIHRvIHB1dCB0aGUgbWFya2VyIG9uIHRoZSBtYXAgaW5zdGVhZFxuXHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoY2x1c3Rlcik7XG5cdFx0XHRcdFx0XHRpZiAoIWRvbnRVcGRhdGVNYXApIHtcblx0XHRcdFx0XHRcdFx0ZmcuYWRkTGF5ZXIob3RoZXJNYXJrZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbHVzdGVyLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2x1c3RlciA9IGNsdXN0ZXIuX19wYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBtYXJrZXIuX19wYXJlbnQ7XG5cdFx0fSxcblxuXHRcdF9pc09ySXNQYXJlbnQ6IGZ1bmN0aW9uIChlbCwgb2VsKSB7XG5cdFx0XHR3aGlsZSAob2VsKSB7XG5cdFx0XHRcdGlmIChlbCA9PT0gb2VsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2VsID0gb2VsLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmZpcmVcblx0XHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XG5cdFx0XHRpZiAoZGF0YSAmJiBkYXRhLmxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSB7XG5cdFx0XHRcdC8vUHJldmVudCBtdWx0aXBsZSBjbHVzdGVybW91c2VvdmVyL29mZiBldmVudHMgaWYgdGhlIGljb24gaXMgbWFkZSB1cCBvZiBzdGFja2VkIGRpdnMgKERvZXNuJ3Qgd29yayBpbiBpZSA8PSA4LCBubyByZWxhdGVkVGFyZ2V0KVxuXHRcdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50ICYmIHRoaXMuX2lzT3JJc1BhcmVudChkYXRhLmxheWVyLl9pY29uLCBkYXRhLm9yaWdpbmFsRXZlbnQucmVsYXRlZFRhcmdldCkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dHlwZSA9ICdjbHVzdGVyJyArIHR5cGU7XG5cdFx0XHR9XG5cblx0XHRcdEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5maXJlLmNhbGwodGhpcywgdHlwZSwgZGF0YSwgcHJvcGFnYXRlKTtcblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZSBMLkV2ZW50ZWQubGlzdGVuc1xuXHRcdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcblx0XHRcdHJldHVybiBMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUubGlzdGVucy5jYWxsKHRoaXMsIHR5cGUsIHByb3BhZ2F0ZSkgfHwgTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCAnY2x1c3RlcicgKyB0eXBlLCBwcm9wYWdhdGUpO1xuXHRcdH0sXG5cblx0XHQvL0RlZmF1bHQgZnVuY3Rpb25hbGl0eVxuXHRcdF9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uOiBmdW5jdGlvbiAoY2x1c3Rlcikge1xuXHRcdFx0dmFyIGNoaWxkQ291bnQgPSBjbHVzdGVyLmdldENoaWxkQ291bnQoKTtcblxuXHRcdFx0dmFyIGMgPSAnIG1hcmtlci1jbHVzdGVyLSc7XG5cdFx0XHRpZiAoY2hpbGRDb3VudCA8IDEwKSB7XG5cdFx0XHRcdGMgKz0gJ3NtYWxsJztcblx0XHRcdH0gZWxzZSBpZiAoY2hpbGRDb3VudCA8IDEwMCkge1xuXHRcdFx0XHRjICs9ICdtZWRpdW0nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YyArPSAnbGFyZ2UnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEwuRGl2SWNvbih7IGh0bWw6ICc8ZGl2PjxzcGFuPicgKyBjaGlsZENvdW50ICsgJzwvc3Bhbj48L2Rpdj4nLCBjbGFzc05hbWU6ICdtYXJrZXItY2x1c3RlcicgKyBjLCBpY29uU2l6ZTogbmV3IEwuUG9pbnQoNDAsIDQwKSB9KTtcblx0XHR9LFxuXG5cdFx0X2JpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHQgICAgc3BpZGVyZnlPbk1heFpvb20gPSB0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20sXG5cdFx0XHQgICAgc2hvd0NvdmVyYWdlT25Ib3ZlciA9IHRoaXMub3B0aW9ucy5zaG93Q292ZXJhZ2VPbkhvdmVyLFxuXHRcdFx0ICAgIHpvb21Ub0JvdW5kc09uQ2xpY2sgPSB0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljayxcblx0XHRcdCAgICBzcGlkZXJmeU9uRXZlcnlab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25FdmVyeVpvb207XG5cblx0XHRcdC8vWm9vbSBvbiBjbHVzdGVyIGNsaWNrIG9yIHNwaWRlcmZ5IGlmIHdlIGFyZSBhdCB0aGUgbG93ZXN0IGxldmVsXG5cdFx0XHRpZiAoc3BpZGVyZnlPbk1heFpvb20gfHwgem9vbVRvQm91bmRzT25DbGljayB8fCBzcGlkZXJmeU9uRXZlcnlab29tKSB7XG5cdFx0XHRcdHRoaXMub24oJ2NsdXN0ZXJjbGljayBjbHVzdGVya2V5cHJlc3MnLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vU2hvdyBjb252ZXggaHVsbCAoYm91bmRhcnkpIHBvbHlnb24gb24gbW91c2Ugb3ZlclxuXHRcdFx0aWYgKHNob3dDb3ZlcmFnZU9uSG92ZXIpIHtcblx0XHRcdFx0dGhpcy5vbignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF96b29tT3JTcGlkZXJmeTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBjbHVzdGVyID0gZS5sYXllcixcblx0XHRcdCAgICBib3R0b21DbHVzdGVyID0gY2x1c3RlcjtcblxuXHRcdFx0aWYgKGUudHlwZSA9PT0gJ2NsdXN0ZXJrZXlwcmVzcycgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5rZXlDb2RlICE9PSAxMykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlIChib3R0b21DbHVzdGVyLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRib3R0b21DbHVzdGVyID0gYm90dG9tQ2x1c3Rlci5fY2hpbGRDbHVzdGVyc1swXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvdHRvbUNsdXN0ZXIuX3pvb20gPT09IHRoaXMuX21heFpvb20gJiZcblx0XHRcdFx0Ym90dG9tQ2x1c3Rlci5fY2hpbGRDb3VudCA9PT0gY2x1c3Rlci5fY2hpbGRDb3VudCAmJlxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20pIHtcblxuXHRcdFx0XHQvLyBBbGwgY2hpbGQgbWFya2VycyBhcmUgY29udGFpbmVkIGluIGEgc2luZ2xlIGNsdXN0ZXIgZnJvbSB0aGlzLl9tYXhab29tIHRvIHRoaXMgY2x1c3Rlci5cblx0XHRcdFx0Y2x1c3Rlci5zcGlkZXJmeSgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljaykge1xuXHRcdFx0XHRjbHVzdGVyLnpvb21Ub0JvdW5kcygpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnNwaWRlcmZ5T25FdmVyeVpvb20pIHtcblx0XHRcdFx0Y2x1c3Rlci5zcGlkZXJmeSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb2N1cyB0aGUgbWFwIGFnYWluIGZvciBrZXlib2FyZCB1c2Vycy5cblx0XHRcdGlmIChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zaG93Q292ZXJhZ2U6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdFx0aWYgKHRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fc2hvd25Qb2x5Z29uKSB7XG5cdFx0XHRcdG1hcC5yZW1vdmVMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGUubGF5ZXIuZ2V0Q2hpbGRDb3VudCgpID4gMiAmJiBlLmxheWVyICE9PSB0aGlzLl9zcGlkZXJmaWVkKSB7XG5cdFx0XHRcdHRoaXMuX3Nob3duUG9seWdvbiA9IG5ldyBMLlBvbHlnb24oZS5sYXllci5nZXRDb252ZXhIdWxsKCksIHRoaXMub3B0aW9ucy5wb2x5Z29uT3B0aW9ucyk7XG5cdFx0XHRcdG1hcC5hZGRMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGlkZUNvdmVyYWdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5fc2hvd25Qb2x5Z29uKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xuXHRcdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfdW5iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3BpZGVyZnlPbk1heFpvb20gPSB0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20sXG5cdFx0XHRcdHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3Zlcixcblx0XHRcdFx0em9vbVRvQm91bmRzT25DbGljayA9IHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrLFxuXHRcdFx0XHRzcGlkZXJmeU9uRXZlcnlab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25FdmVyeVpvb20sXG5cdFx0XHRcdG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2sgfHwgc3BpZGVyZnlPbkV2ZXJ5Wm9vbSkge1xuXHRcdFx0XHR0aGlzLm9mZignY2x1c3RlcmNsaWNrIGNsdXN0ZXJrZXlwcmVzcycsIHRoaXMuX3pvb21PclNwaWRlcmZ5LCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCdjbHVzdGVybW91c2VvdmVyJywgdGhpcy5fc2hvd0NvdmVyYWdlLCB0aGlzKTtcblx0XHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfem9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX21lcmdlU3BsaXRDbHVzdGVycygpO1xuXG5cdFx0XHR0aGlzLl96b29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xuXHRcdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XG5cdFx0fSxcblxuXHRcdF9tb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5ld0JvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgdGhpcy5fem9vbSwgbmV3Qm91bmRzKTtcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKSwgbmV3Qm91bmRzKTtcblxuXHRcdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gbmV3Qm91bmRzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0sXG5cblx0XHRfZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtYXhab29tID0gTWF0aC5jZWlsKHRoaXMuX21hcC5nZXRNYXhab29tKCkpLFxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcblx0XHRcdFx0cmFkaXVzID0gdGhpcy5vcHRpb25zLm1heENsdXN0ZXJSYWRpdXMsXG5cdFx0XHRcdHJhZGl1c0ZuID0gcmFkaXVzO1xuXG5cdFx0XHQvL0lmIHdlIGp1c3Qgc2V0IG1heENsdXN0ZXJSYWRpdXMgdG8gYSBzaW5nbGUgbnVtYmVyLCB3ZSBuZWVkIHRvIGNyZWF0ZVxuXHRcdFx0Ly9hIHNpbXBsZSBmdW5jdGlvbiB0byByZXR1cm4gdGhhdCBudW1iZXIuIE90aGVyd2lzZSwgd2UganVzdCBoYXZlIHRvXG5cdFx0XHQvL3VzZSB0aGUgZnVuY3Rpb24gd2UndmUgcGFzc2VkIGluLlxuXHRcdFx0aWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRyYWRpdXNGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhZGl1czsgfTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSAhPT0gbnVsbCkge1xuXHRcdFx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLmRpc2FibGVDbHVzdGVyaW5nQXRab29tIC0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX21heFpvb20gPSBtYXhab29tO1xuXHRcdFx0dGhpcy5fZ3JpZENsdXN0ZXJzID0ge307XG5cdFx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWQgPSB7fTtcblxuXHRcdFx0Ly9TZXQgdXAgRGlzdGFuY2VHcmlkcyBmb3IgZWFjaCB6b29tXG5cdFx0XHRmb3IgKHZhciB6b29tID0gbWF4Wm9vbTsgem9vbSA+PSBtaW5ab29tOyB6b29tLS0pIHtcblx0XHRcdFx0dGhpcy5fZ3JpZENsdXN0ZXJzW3pvb21dID0gbmV3IEwuRGlzdGFuY2VHcmlkKHJhZGl1c0ZuKHpvb20pKTtcblx0XHRcdFx0dGhpcy5fZ3JpZFVuY2x1c3RlcmVkW3pvb21dID0gbmV3IEwuRGlzdGFuY2VHcmlkKHJhZGl1c0ZuKHpvb20pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5zdGFudGlhdGUgdGhlIGFwcHJvcHJpYXRlIEwuTWFya2VyQ2x1c3RlciBjbGFzcyAoYW5pbWF0ZWQgb3Igbm90KS5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIG1pblpvb20gLSAxKTtcblx0XHR9LFxuXG5cdFx0Ly9ab29tOiBab29tIHRvIHN0YXJ0IGFkZGluZyBhdCAoUGFzcyB0aGlzLl9tYXhab29tIHRvIHN0YXJ0IGF0IHRoZSBib3R0b20pXG5cdFx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIHpvb20pIHtcblx0XHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXG5cdFx0XHQgICAgZ3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcblx0XHRcdCAgICBtYXJrZXJQb2ludCwgejtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XG5cdFx0XHRcdHRoaXMuX292ZXJyaWRlTWFya2VySWNvbihsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdGxheWVyLm9uKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XG5cblx0XHRcdC8vRmluZCB0aGUgbG93ZXN0IHpvb20gbGV2ZWwgdG8gc2xvdCB0aGlzIG9uZSBpblxuXHRcdFx0Zm9yICg7IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XG5cdFx0XHRcdG1hcmtlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QobGF5ZXIuZ2V0TGF0TG5nKCksIHpvb20pOyAvLyBjYWxjdWxhdGUgcGl4ZWwgcG9zaXRpb25cblxuXHRcdFx0XHQvL1RyeSBmaW5kIGEgY2x1c3RlciBjbG9zZSBieVxuXHRcdFx0XHR2YXIgY2xvc2VzdCA9IGdyaWRDbHVzdGVyc1t6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcblx0XHRcdFx0aWYgKGNsb3Nlc3QpIHtcblx0XHRcdFx0XHRjbG9zZXN0Ll9hZGRDaGlsZChsYXllcik7XG5cdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBjbG9zZXN0O1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vVHJ5IGZpbmQgYSBtYXJrZXIgY2xvc2UgYnkgdG8gZm9ybSBhIG5ldyBjbHVzdGVyIHdpdGhcblx0XHRcdFx0Y2xvc2VzdCA9IGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcblx0XHRcdFx0aWYgKGNsb3Nlc3QpIHtcblx0XHRcdFx0XHR2YXIgcGFyZW50ID0gY2xvc2VzdC5fX3BhcmVudDtcblx0XHRcdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9yZW1vdmVMYXllcihjbG9zZXN0LCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9DcmVhdGUgbmV3IGNsdXN0ZXIgd2l0aCB0aGVzZSAyIGluIGl0XG5cblx0XHRcdFx0XHR2YXIgbmV3Q2x1c3RlciA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIHpvb20sIGNsb3Nlc3QsIGxheWVyKTtcblx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbem9vbV0uYWRkT2JqZWN0KG5ld0NsdXN0ZXIsIHRoaXMuX21hcC5wcm9qZWN0KG5ld0NsdXN0ZXIuX2NMYXRMbmcsIHpvb20pKTtcblx0XHRcdFx0XHRjbG9zZXN0Ll9fcGFyZW50ID0gbmV3Q2x1c3Rlcjtcblx0XHRcdFx0XHRsYXllci5fX3BhcmVudCA9IG5ld0NsdXN0ZXI7XG5cblx0XHRcdFx0XHQvL0ZpcnN0IGNyZWF0ZSBhbnkgbmV3IGludGVybWVkaWF0ZSBwYXJlbnQgY2x1c3RlcnMgdGhhdCBkb24ndCBleGlzdFxuXHRcdFx0XHRcdHZhciBsYXN0UGFyZW50ID0gbmV3Q2x1c3Rlcjtcblx0XHRcdFx0XHRmb3IgKHogPSB6b29tIC0gMTsgeiA+IHBhcmVudC5fem9vbTsgei0tKSB7XG5cdFx0XHRcdFx0XHRsYXN0UGFyZW50ID0gbmV3IHRoaXMuX21hcmtlckNsdXN0ZXIodGhpcywgeiwgbGFzdFBhcmVudCk7XG5cdFx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbel0uYWRkT2JqZWN0KGxhc3RQYXJlbnQsIHRoaXMuX21hcC5wcm9qZWN0KGNsb3Nlc3QuZ2V0TGF0TG5nKCksIHopKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50Ll9hZGRDaGlsZChsYXN0UGFyZW50KTtcblxuXHRcdFx0XHRcdC8vUmVtb3ZlIGNsb3Nlc3QgZnJvbSB0aGlzIHpvb20gbGV2ZWwgYW5kIGFueSBhYm92ZSB0aGF0IGl0IGlzIGluLCByZXBsYWNlIHdpdGggbmV3Q2x1c3RlclxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQoY2xvc2VzdCwgem9vbSk7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL0RpZG4ndCBtYW5hZ2UgdG8gY2x1c3RlciBpbiBhdCB0aGlzIHpvb20sIHJlY29yZCB1cyBhcyBhIG1hcmtlciBoZXJlIGFuZCBjb250aW51ZSB1cHdhcmRzXG5cdFx0XHRcdGdyaWRVbmNsdXN0ZXJlZFt6b29tXS5hZGRPYmplY3QobGF5ZXIsIG1hcmtlclBvaW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly9EaWRuJ3QgZ2V0IGluIGFueXRoaW5nLCBhZGQgdXMgdG8gdGhlIHRvcFxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9hZGRDaGlsZChsYXllcik7XG5cdFx0XHRsYXllci5fX3BhcmVudCA9IHRoaXMuX3RvcENsdXN0ZXJMZXZlbDtcblx0XHRcdHJldHVybjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVmcmVzaGVzIHRoZSBpY29uIG9mIGFsbCBcImRpcnR5XCIgdmlzaWJsZSBjbHVzdGVycy5cblx0XHQgKiBOb24tdmlzaWJsZSBcImRpcnR5XCIgY2x1c3RlcnMgd2lsbCBiZSB1cGRhdGVkIHdoZW4gdGhleSBhcmUgYWRkZWQgdG8gdGhlIG1hcC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZWZyZXNoQ2x1c3RlcnNJY29uczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRpZiAoYyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3RlciAmJiBjLl9pY29uTmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0XHRjLl91cGRhdGVJY29uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvL0VucXVldWUgY29kZSB0byBmaXJlIGFmdGVyIHRoZSBtYXJrZXIgZXhwYW5kL2NvbnRyYWN0IGhhcyBoYXBwZW5lZFxuXHRcdF9lbnF1ZXVlOiBmdW5jdGlvbiAoZm4pIHtcblx0XHRcdHRoaXMuX3F1ZXVlLnB1c2goZm4pO1xuXHRcdFx0aWYgKCF0aGlzLl9xdWV1ZVRpbWVvdXQpIHtcblx0XHRcdFx0dGhpcy5fcXVldWVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5fcHJvY2Vzc1F1ZXVlLCB0aGlzKSwgMzAwKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9wcm9jZXNzUXVldWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcXVldWVbaV0uY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcXVldWVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IG51bGw7XG5cdFx0fSxcblxuXHRcdC8vTWVyZ2UgYW5kIHNwbGl0IGFueSBleGlzdGluZyBjbHVzdGVycyB0aGF0IGFyZSB0b28gYmlnIG9yIHNtYWxsXG5cdFx0X21lcmdlU3BsaXRDbHVzdGVyczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG1hcFpvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XG5cblx0XHRcdC8vSW4gY2FzZSB3ZSBhcmUgc3RhcnRpbmcgdG8gc3BsaXQgYmVmb3JlIHRoZSBhbmltYXRpb24gZmluaXNoZWRcblx0XHRcdHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuXG5cdFx0XHRpZiAodGhpcy5fem9vbSA8IG1hcFpvb20gJiYgdGhpcy5fY3VycmVudFNob3duQm91bmRzLmludGVyc2VjdHModGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpKSB7IC8vWm9vbSBpbiwgc3BsaXRcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcblx0XHRcdFx0Ly9SZW1vdmUgY2x1c3RlcnMgbm93IG9mZiBzY3JlZW5cblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcblxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25ab29tSW4odGhpcy5fem9vbSwgbWFwWm9vbSk7XG5cblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fem9vbSA+IG1hcFpvb20pIHsgLy9ab29tIG91dCwgbWVyZ2Vcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0KHRoaXMuX3pvb20sIG1hcFpvb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbW92ZUVuZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL0dldHMgdGhlIG1hcHMgdmlzaWJsZSBib3VuZHMgZXhwYW5kZWQgaW4gZWFjaCBkaXJlY3Rpb24gYnkgdGhlIHNpemUgb2YgdGhlIHNjcmVlbiAoc28gdGhlIHVzZXIgY2Fubm90IHNlZSBhbiBhcmVhIHdlIGRvIG5vdCBjb3ZlciBpbiBvbmUgcGFuKVxuXHRcdF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLnJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXBCb3VuZHNJbmZpbml0ZTtcblx0XHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLm1vYmlsZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2hlY2tCb3VuZHNNYXhMYXQodGhpcy5fbWFwLmdldEJvdW5kcygpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuX2NoZWNrQm91bmRzTWF4TGF0KHRoaXMuX21hcC5nZXRCb3VuZHMoKS5wYWQoMSkpOyAvLyBQYWRkaW5nIGV4cGFuZHMgdGhlIGJvdW5kcyBieSBpdHMgb3duIGRpbWVuc2lvbnMgYnV0IHNjYWxlZCB3aXRoIHRoZSBnaXZlbiBmYWN0b3IuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEV4cGFuZHMgdGhlIGxhdGl0dWRlIHRvIEluZmluaXR5IChvciAtSW5maW5pdHkpIGlmIHRoZSBpbnB1dCBib3VuZHMgcmVhY2ggdGhlIG1hcCBwcm9qZWN0aW9uIG1heGltdW0gZGVmaW5lZCBsYXRpdHVkZVxuXHRcdCAqIChpbiB0aGUgY2FzZSBvZiBXZWIvU3BoZXJpY2FsIE1lcmNhdG9yLCBpdCBpcyA4NS4wNTExMjg3Nzk4IC8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NZXJjYXRvciNGb3JtdWxhcykuXG5cdFx0ICogT3RoZXJ3aXNlLCB0aGUgcmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMgb3B0aW9uIHdpbGwgcmVtb3ZlIG1hcmtlcnMgYmV5b25kIHRoYXQgbGltaXQsIHdoZXJlYXMgdGhlIHNhbWUgbWFya2VycyB3aXRob3V0XG5cdFx0ICogdGhpcyBvcHRpb24gKG9yIG91dHNpZGUgTUNHKSB3aWxsIGhhdmUgdGhlaXIgcG9zaXRpb24gZmxvb3JlZCAoY2VpbGVkKSBieSB0aGUgcHJvamVjdGlvbiBhbmQgcmVuZGVyZWQgYXQgdGhhdCBsaW1pdCxcblx0XHQgKiBtYWtpbmcgdGhlIHVzZXIgdGhpbmsgdGhhdCBNQ0cgXCJlYXRzXCIgdGhlbSBhbmQgbmV2ZXIgZGlzcGxheXMgdGhlbSBhZ2Fpbi5cblx0XHQgKiBAcGFyYW0gYm91bmRzIEwuTGF0TG5nQm91bmRzXG5cdFx0ICogQHJldHVybnMge0wuTGF0TG5nQm91bmRzfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X2NoZWNrQm91bmRzTWF4TGF0OiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgbWF4TGF0ID0gdGhpcy5fbWF4TGF0O1xuXG5cdFx0XHRpZiAobWF4TGF0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKGJvdW5kcy5nZXROb3J0aCgpID49IG1heExhdCkge1xuXHRcdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IEluZmluaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChib3VuZHMuZ2V0U291dGgoKSA8PSAtbWF4TGF0KSB7XG5cdFx0XHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gLUluZmluaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fSxcblxuXHRcdC8vU2hhcmVkIGFuaW1hdGlvbiBjb2RlXG5cdFx0X2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQ6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xuXHRcdFx0aWYgKG5ld0NsdXN0ZXIgPT09IGxheWVyKSB7XG5cdFx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihsYXllcik7XG5cdFx0XHR9IGVsc2UgaWYgKG5ld0NsdXN0ZXIuX2NoaWxkQ291bnQgPT09IDIpIHtcblx0XHRcdFx0bmV3Q2x1c3Rlci5fYWRkVG9NYXAoKTtcblxuXHRcdFx0XHR2YXIgbWFya2VycyA9IG5ld0NsdXN0ZXIuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XG5cdFx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtYXJrZXJzWzBdKTtcblx0XHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcnNbMV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3Q2x1c3Rlci5fdXBkYXRlSWNvbigpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHRyYWN0cyBpbmRpdmlkdWFsIChpLmUuIG5vbi1ncm91cCkgbGF5ZXJzIGZyb20gYSBMYXllciBHcm91cC5cblx0XHQgKiBAcGFyYW0gZ3JvdXAgdG8gZXh0cmFjdCBsYXllcnMgZnJvbS5cblx0XHQgKiBAcGFyYW0gb3V0cHV0IHtBcnJheX0gaW4gd2hpY2ggdG8gc3RvcmUgdGhlIGV4dHJhY3RlZCBsYXllcnMuXG5cdFx0ICogQHJldHVybnMgeyp8QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfZXh0cmFjdE5vbkdyb3VwTGF5ZXJzOiBmdW5jdGlvbiAoZ3JvdXAsIG91dHB1dCkge1xuXHRcdFx0dmFyIGxheWVycyA9IGdyb3VwLmdldExheWVycygpLFxuXHRcdFx0ICAgIGkgPSAwLFxuXHRcdFx0ICAgIGxheWVyO1xuXG5cdFx0XHRvdXRwdXQgPSBvdXRwdXQgfHwgW107XG5cblx0XHRcdGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxheWVyID0gbGF5ZXJzW2ldO1xuXG5cdFx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhsYXllciwgb3V0cHV0KTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKGxheWVyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW1wbGVtZW50cyB0aGUgc2luZ2xlTWFya2VyTW9kZSBvcHRpb24uXG5cdFx0ICogQHBhcmFtIGxheWVyIE1hcmtlciB0byByZS1zdHlsZSB1c2luZyB0aGUgQ2x1c3RlcnMgaWNvbkNyZWF0ZUZ1bmN0aW9uLlxuXHRcdCAqIEByZXR1cm5zIHtMLkljb259IFRoZSBuZXdseSBjcmVhdGVkIGljb24uXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfb3ZlcnJpZGVNYXJrZXJJY29uOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdHZhciBpY29uID0gbGF5ZXIub3B0aW9ucy5pY29uID0gdGhpcy5vcHRpb25zLmljb25DcmVhdGVGdW5jdGlvbih7XG5cdFx0XHRcdGdldENoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0QWxsQ2hpbGRNYXJrZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFtsYXllcl07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gaWNvbjtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIENvbnN0YW50IGJvdW5kcyB1c2VkIGluIGNhc2Ugb3B0aW9uIFwicmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHNcIiBpcyBzZXQgdG8gZmFsc2UuXG5cdEwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xuXHRcdF9tYXBCb3VuZHNJbmZpbml0ZTogbmV3IEwuTGF0TG5nQm91bmRzKG5ldyBMLkxhdExuZygtSW5maW5pdHksIC1JbmZpbml0eSksIG5ldyBMLkxhdExuZyhJbmZpbml0eSwgSW5maW5pdHkpKVxuXHR9KTtcblxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHRfbm9BbmltYXRpb246IHtcblx0XHRcdC8vTm9uIEFuaW1hdGVkIHZlcnNpb25zIG9mIGV2ZXJ5dGhpbmdcblx0XHRcdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvL0RvIG5vdGhpbmcuLi5cblx0XHRcdH0sXG5cdFx0XHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgcHJldmlvdXNab29tTGV2ZWwpO1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcblxuXHRcdFx0XHQvL1dlIGRpZG4ndCBhY3R1YWxseSBhbmltYXRlLCBidXQgd2UgdXNlIHRoaXMgZXZlbnQgdG8gbWVhbiBcImNsdXN0ZXJpbmcgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkXCJcblx0XHRcdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcblx0XHRcdH0sXG5cdFx0XHRfYW5pbWF0aW9uWm9vbU91dDogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cblx0XHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXG5cdFx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XG5cdFx0XHR9LFxuXHRcdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgbmV3Q2x1c3Rlcik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF93aXRoQW5pbWF0aW9uOiB7XG5cdFx0XHQvL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcblx0XHRcdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lICs9ICcgbGVhZmxldC1jbHVzdGVyLWFuaW0nO1xuXHRcdFx0XHR0aGlzLl9pblpvb21BbmltYXRpb24rKztcblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRpb25ab29tSW46IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSxcblx0XHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxuXHRcdFx0XHQgICAgaTtcblxuXHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcblxuXHRcdFx0XHQvL0FkZCBhbGwgY2hpbGRyZW4gb2YgY3VycmVudCBjbHVzdGVycyB0byBtYXAgYW5kIHJlbW92ZSB0aG9zZSBjbHVzdGVycyBmcm9tIG1hcFxuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0UG9zID0gYy5fbGF0bG5nLFxuXHRcdFx0XHRcdCAgICBtYXJrZXJzICA9IGMuX21hcmtlcnMsXG5cdFx0XHRcdFx0ICAgIG07XG5cblx0XHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhzdGFydFBvcykpIHtcblx0XHRcdFx0XHRcdHN0YXJ0UG9zID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYy5faXNTaW5nbGVQYXJlbnQoKSAmJiBwcmV2aW91c1pvb21MZXZlbCArIDEgPT09IG5ld1pvb21MZXZlbCkgeyAvL0ltbWVkaWF0ZWx5IGFkZCB0aGUgbmV3IGNoaWxkIGFuZCByZW1vdmUgdXNcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xuXHRcdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgYm91bmRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly9GYWRlIG91dCBvbGQgY2x1c3RlclxuXHRcdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKHN0YXJ0UG9zLCBuZXdab29tTGV2ZWwsIGJvdW5kcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9SZW1vdmUgYWxsIG1hcmtlcnMgdGhhdCBhcmVuJ3QgdmlzaWJsZSBhbnkgbW9yZVxuXHRcdFx0XHRcdC8vVE9ETzogRG8gd2UgYWN0dWFsbHkgbmVlZCB0byBkbyB0aGlzIG9uIHRoZSBoaWdoZXIgbGV2ZWxzIHRvbz9cblx0XHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcblx0XHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cblx0XHRcdFx0Ly9VcGRhdGUgb3BhY2l0aWVzXG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcblx0XHRcdFx0Ly9UT0RPIE1heWJlPyBVcGRhdGUgbWFya2VycyBpbiBfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlXG5cdFx0XHRcdGZnLmVhY2hMYXllcihmdW5jdGlvbiAobikge1xuXHRcdFx0XHRcdGlmICghKG4gaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpICYmIG4uX2ljb24pIHtcblx0XHRcdFx0XHRcdG4uY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGp1c3QgYWRkZWQgY2x1c3RlcnMvbWFya2Vyc1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyhuZXdab29tTGV2ZWwpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly9SZW1vdmUgdGhlIG9sZCBjbHVzdGVycyBhbmQgY2xvc2UgdGhlIHpvb20gYW5pbWF0aW9uXG5cdFx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGp1c3QgYWRkZWQgY2x1c3RlcnMvbWFya2Vyc1xuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHkoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xuXHRcdFx0XHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUodGhpcy5fdG9wQ2x1c3RlckxldmVsLCBwcmV2aW91c1pvb21MZXZlbCAtIDEsIG5ld1pvb21MZXZlbCk7XG5cblx0XHRcdFx0Ly9OZWVkIHRvIGFkZCBtYXJrZXJzIGZvciB0aG9zZSB0aGF0IHdlcmVuJ3Qgb24gdGhlIG1hcCBiZWZvcmUgYnV0IGFyZSBub3dcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cdFx0XHRcdC8vUmVtb3ZlIG1hcmtlcnMgdGhhdCB3ZXJlIG9uIHRoZSBtYXAgYmVmb3JlIGJ1dCB3b24ndCBiZSBub3dcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYW5pbWF0aW9uQWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xuXHRcdFx0XHR2YXIgbWUgPSB0aGlzLFxuXHRcdFx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXA7XG5cblx0XHRcdFx0ZmcuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHRpZiAobmV3Q2x1c3RlciAhPT0gbGF5ZXIpIHtcblx0XHRcdFx0XHRpZiAobmV3Q2x1c3Rlci5fY2hpbGRDb3VudCA+IDIpIHsgLy9XYXMgYWxyZWFkeSBhIGNsdXN0ZXJcblxuXHRcdFx0XHRcdFx0bmV3Q2x1c3Rlci5fdXBkYXRlSWNvbigpO1xuXHRcdFx0XHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XG5cblx0XHRcdFx0XHRcdGxheWVyLl9zZXRQb3ModGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChuZXdDbHVzdGVyLmdldExhdExuZygpKSk7XG5cdFx0XHRcdFx0XHRsYXllci5jbHVzdGVySGlkZSgpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXHRcdFx0XHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xuXG5cdFx0XHRcdFx0XHRcdG1lLl9hbmltYXRpb25FbmQoKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9KdXN0IGJlY2FtZSBhIGNsdXN0ZXJcblx0XHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cblx0XHRcdFx0XHRcdG1lLl9hbmltYXRpb25TdGFydCgpO1xuXHRcdFx0XHRcdFx0bWUuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUobmV3Q2x1c3RlciwgdGhpcy5fbWFwLmdldE1heFpvb20oKSwgdGhpcy5fem9vbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIFByaXZhdGUgbWV0aG9kcyBmb3IgYW5pbWF0ZWQgdmVyc2lvbnMuXG5cdFx0X2FuaW1hdGlvblpvb21PdXRTaW5nbGU6IGZ1bmN0aW9uIChjbHVzdGVyLCBwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCksXG5cdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xuXG5cdFx0XHQvL0FuaW1hdGUgYWxsIG9mIHRoZSBtYXJrZXJzIGluIHRoZSBjbHVzdGVycyB0byBtb3ZlIHRvIHRoZWlyIGNsdXN0ZXIgY2VudGVyIHBvaW50XG5cdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0XHQvL1VwZGF0ZSB0aGUgb3BhY2l0eSAoSWYgd2UgaW1tZWRpYXRlbHkgc2V0IGl0IHRoZXkgd29uJ3QgYW5pbWF0ZSlcblx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUJlY29tZVZpc2libGUoYm91bmRzLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0XHQvL1RPRE86IE1heWJlIHVzZSB0aGUgdHJhbnNpdGlvbiB0aW1pbmcgc3R1ZmYgdG8gbWFrZSB0aGlzIG1vcmUgcmVsaWFibGVcblx0XHRcdC8vV2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgZG9uZSwgdGlkeSB1cFxuXHRcdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Ly9UaGlzIGNsdXN0ZXIgc3RvcHBlZCBiZWluZyBhIGNsdXN0ZXIgYmVmb3JlIHRoZSB0aW1lb3V0IGZpcmVkXG5cdFx0XHRcdGlmIChjbHVzdGVyLl9jaGlsZENvdW50ID09PSAxKSB7XG5cdFx0XHRcdFx0dmFyIG0gPSBjbHVzdGVyLl9tYXJrZXJzWzBdO1xuXHRcdFx0XHRcdC8vSWYgd2Ugd2VyZSBpbiBhIGNsdXN0ZXIgYW5pbWF0aW9uIGF0IHRoZSB0aW1lIHRoZW4gdGhlIG9wYWNpdHkgYW5kIHBvc2l0aW9uIG9mIG91ciBjaGlsZCBjb3VsZCBiZSB3cm9uZyBub3csIHNvIGZpeCBpdFxuXHRcdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXHRcdFx0XHRcdG0uc2V0TGF0TG5nKG0uZ2V0TGF0TG5nKCkpO1xuXHRcdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xuXHRcdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseShib3VuZHMsIG5ld1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X2FuaW1hdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lID0gdGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jbHVzdGVyLWFuaW0nLCAnJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pblpvb21BbmltYXRpb24tLTtcblx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XG5cdFx0fSxcblxuXHRcdC8vRm9yY2UgYSBicm93c2VyIGxheW91dCBvZiBzdHVmZiBpbiB0aGUgbWFwXG5cdFx0Ly8gU2hvdWxkIGFwcGx5IHRoZSBjdXJyZW50IG9wYWNpdHkgYW5kIGxvY2F0aW9uIHRvIGFsbCBlbGVtZW50cyBzbyB3ZSBjYW4gdXBkYXRlIHRoZW0gYWdhaW4gZm9yIGFuIGFuaW1hdGlvblxuXHRcdF9mb3JjZUxheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly9JbiBteSB0ZXN0aW5nIHRoaXMgd29ya3MsIGluZmFjdCBvZmZzZXRXaWR0aCBvZiBhbnkgZWxlbWVudCBzZWVtcyB0byB3b3JrLlxuXHRcdFx0Ly9Db3VsZCBsb29wIGFsbCB0aGlzLl9sYXllcnMgYW5kIGRvIHRoaXMgZm9yIGVhY2ggX2ljb24gaWYgaXQgc3RvcHMgd29ya2luZ1xuXG5cdFx0XHRMLlV0aWwuZmFsc2VGbihkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKTtcblx0XHR9XG5cdH0pO1xuXG5cdEwubWFya2VyQ2x1c3Rlckdyb3VwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IEwuTWFya2VyQ2x1c3Rlckdyb3VwKG9wdGlvbnMpO1xuXHR9O1xuXG5cdHZhciBNYXJrZXJDbHVzdGVyID0gTC5NYXJrZXJDbHVzdGVyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblx0XHRvcHRpb25zOiBMLkljb24ucHJvdG90eXBlLm9wdGlvbnMsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ3JvdXAsIHpvb20sIGEsIGIpIHtcblxuXHRcdFx0TC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhID8gKGEuX2NMYXRMbmcgfHwgYS5nZXRMYXRMbmcoKSkgOiBuZXcgTC5MYXRMbmcoMCwgMCksXG5cdCAgICAgICAgICAgIHsgaWNvbjogdGhpcywgcGFuZTogZ3JvdXAub3B0aW9ucy5jbHVzdGVyUGFuZSB9KTtcblxuXHRcdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9tYXJrZXJzID0gW107XG5cdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzID0gW107XG5cdFx0XHR0aGlzLl9jaGlsZENvdW50ID0gMDtcblx0XHRcdHRoaXMuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cblx0XHRcdGlmIChhKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENoaWxkKGEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0dGhpcy5fYWRkQ2hpbGQoYik7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vUmVjdXJzaXZlbHkgcmV0cmlldmUgYWxsIGNoaWxkIG1hcmtlcnMgb2YgdGhpcyBjbHVzdGVyXG5cdFx0Z2V0QWxsQ2hpbGRNYXJrZXJzOiBmdW5jdGlvbiAoc3RvcmFnZUFycmF5LCBpZ25vcmVEcmFnZ2VkTWFya2VyKSB7XG5cdFx0XHRzdG9yYWdlQXJyYXkgPSBzdG9yYWdlQXJyYXkgfHwgW107XG5cblx0XHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbaV0uZ2V0QWxsQ2hpbGRNYXJrZXJzKHN0b3JhZ2VBcnJheSwgaWdub3JlRHJhZ2dlZE1hcmtlcik7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGogPSB0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdGlmIChpZ25vcmVEcmFnZ2VkTWFya2VyICYmIHRoaXMuX21hcmtlcnNbal0uX19kcmFnU3RhcnQpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9yYWdlQXJyYXkucHVzaCh0aGlzLl9tYXJrZXJzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0b3JhZ2VBcnJheTtcblx0XHR9LFxuXG5cdFx0Ly9SZXR1cm5zIHRoZSBjb3VudCBvZiBob3cgbWFueSBjaGlsZCBtYXJrZXJzIHdlIGhhdmVcblx0XHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDb3VudDtcblx0XHR9LFxuXG5cdFx0Ly9ab29tIHRvIHRoZSBtaW5pbXVtIG9mIHNob3dpbmcgYWxsIG9mIHRoZSBjaGlsZCBtYXJrZXJzLCBvciB0aGUgZXh0ZW50cyBvZiB0aGlzIGNsdXN0ZXJcblx0XHR6b29tVG9Cb3VuZHM6IGZ1bmN0aW9uIChmaXRCb3VuZHNPcHRpb25zKSB7XG5cdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMuc2xpY2UoKSxcblx0XHRcdFx0bWFwID0gdGhpcy5fZ3JvdXAuX21hcCxcblx0XHRcdFx0Ym91bmRzWm9vbSA9IG1hcC5nZXRCb3VuZHNab29tKHRoaXMuX2JvdW5kcyksXG5cdFx0XHRcdHpvb20gPSB0aGlzLl96b29tICsgMSxcblx0XHRcdFx0bWFwWm9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0XHRcdGk7XG5cblx0XHRcdC8vY2FsY3VsYXRlIGhvdyBmYXIgd2UgbmVlZCB0byB6b29tIGRvd24gdG8gc2VlIGFsbCBvZiB0aGUgbWFya2Vyc1xuXHRcdFx0d2hpbGUgKGNoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiBib3VuZHNab29tID4gem9vbSkge1xuXHRcdFx0XHR6b29tKys7XG5cdFx0XHRcdHZhciBuZXdDbHVzdGVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG5ld0NsdXN0ZXJzID0gbmV3Q2x1c3RlcnMuY29uY2F0KGNoaWxkQ2x1c3RlcnNbaV0uX2NoaWxkQ2x1c3RlcnMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkQ2x1c3RlcnMgPSBuZXdDbHVzdGVycztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJvdW5kc1pvb20gPiB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIHpvb20pO1xuXHRcdFx0fSBlbHNlIGlmIChib3VuZHNab29tIDw9IG1hcFpvb20pIHsgLy9JZiBmaXRCb3VuZHMgd291bGRuJ3Qgem9vbSB1cyBkb3duLCB6b29tIHVzIGRvd24gaW5zdGVhZFxuXHRcdFx0XHR0aGlzLl9ncm91cC5fbWFwLnNldFZpZXcodGhpcy5fbGF0bG5nLCBtYXBab29tICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ncm91cC5fbWFwLmZpdEJvdW5kcyh0aGlzLl9ib3VuZHMsIGZpdEJvdW5kc09wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fYm91bmRzKTtcblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fSxcblxuXHRcdF91cGRhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcblx0XHRcdFx0dGhpcy5zZXRJY29uKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL0NsdWRnZSBmb3IgSWNvbiwgd2UgcHJldGVuZCB0byBiZSBhbiBpY29uIGZvciBwZXJmb3JtYW5jZVxuXHRcdGNyZWF0ZUljb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pY29uTmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0dGhpcy5faWNvbk9iaiA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZUljb24oKTtcblx0XHR9LFxuXHRcdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlU2hhZG93KCk7XG5cdFx0fSxcblxuXG5cdFx0X2FkZENoaWxkOiBmdW5jdGlvbiAobmV3MSwgaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcblxuXHRcdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9zZXRDbHVzdGVyQ2VudGVyKG5ldzEpO1xuXG5cdFx0XHRpZiAobmV3MSBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVycy5wdXNoKG5ldzEpO1xuXHRcdFx0XHRcdG5ldzEuX19wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoaWxkQ291bnQgKz0gbmV3MS5fY2hpbGRDb3VudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLl9tYXJrZXJzLnB1c2gobmV3MSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2hpbGRDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fX3BhcmVudCkge1xuXHRcdFx0XHR0aGlzLl9fcGFyZW50Ll9hZGRDaGlsZChuZXcxLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWFrZXMgc3VyZSB0aGUgY2x1c3RlciBjZW50ZXIgaXMgc2V0LiBJZiBub3QsIHVzZXMgdGhlIGNoaWxkIGNlbnRlciBpZiBpdCBpcyBhIGNsdXN0ZXIsIG9yIHRoZSBtYXJrZXIgcG9zaXRpb24uXG5cdFx0ICogQHBhcmFtIGNoaWxkIEwuTWFya2VyQ2x1c3RlcnxMLk1hcmtlciB0aGF0IHdpbGwgYmUgdXNlZCBhcyBjbHVzdGVyIGNlbnRlciBpZiBub3QgZGVmaW5lZCB5ZXQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfc2V0Q2x1c3RlckNlbnRlcjogZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2NMYXRMbmcpIHtcblx0XHRcdFx0Ly8gd2hlbiBjbHVzdGVyaW5nLCB0YWtlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBhcyB0aGUgY2x1c3RlciBjZW50ZXJcblx0XHRcdFx0dGhpcy5fY0xhdExuZyA9IGNoaWxkLl9jTGF0TG5nIHx8IGNoaWxkLl9sYXRsbmc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFzc2lnbnMgaW1wb3NzaWJsZSBib3VuZGluZyB2YWx1ZXMgc28gdGhhdCB0aGUgbmV4dCBleHRlbmQgZW50aXJlbHkgZGV0ZXJtaW5lcyB0aGUgbmV3IGJvdW5kcy5cblx0XHQgKiBUaGlzIG1ldGhvZCBhdm9pZHMgaGF2aW5nIHRvIHRyYXNoIHRoZSBwcmV2aW91cyBMLkxhdExuZ0JvdW5kcyBvYmplY3QgYW5kIHRvIGNyZWF0ZSBhIG5ldyBvbmUsIHdoaWNoIGlzIG11Y2ggc2xvd2VyIGZvciB0aGlzIGNsYXNzLlxuXHRcdCAqIEFzIGxvbmcgYXMgdGhlIGJvdW5kcyBhcmUgbm90IGV4dGVuZGVkLCBtb3N0IG90aGVyIG1ldGhvZHMgd291bGQgcHJvYmFibHkgZmFpbCwgYXMgdGhleSB3b3VsZCB3aXRoIGJvdW5kcyBpbml0aWFsaXplZCBidXQgbm90IGV4dGVuZGVkLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3Jlc2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuXG5cdFx0XHRpZiAoYm91bmRzLl9zb3V0aFdlc3QpIHtcblx0XHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gSW5maW5pdHk7XG5cdFx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxuZyA9IEluZmluaXR5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGJvdW5kcy5fbm9ydGhFYXN0KSB7XG5cdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IC1JbmZpbml0eTtcblx0XHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubG5nID0gLUluZmluaXR5O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfcmVjYWxjdWxhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtYXJrZXJzID0gdGhpcy5fbWFya2Vycyxcblx0XHRcdCAgICBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycyxcblx0XHRcdCAgICBsYXRTdW0gPSAwLFxuXHRcdFx0ICAgIGxuZ1N1bSA9IDAsXG5cdFx0XHQgICAgdG90YWxDb3VudCA9IHRoaXMuX2NoaWxkQ291bnQsXG5cdFx0XHQgICAgaSwgY2hpbGQsIGNoaWxkTGF0TG5nLCBjaGlsZENvdW50O1xuXG5cdFx0XHQvLyBDYXNlIHdoZXJlIGFsbCBtYXJrZXJzIGFyZSByZW1vdmVkIGZyb20gdGhlIG1hcCBhbmQgd2UgYXJlIGxlZnQgd2l0aCBqdXN0IGFuIGVtcHR5IF90b3BDbHVzdGVyTGV2ZWwuXG5cdFx0XHRpZiAodG90YWxDb3VudCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG9iamVjdCwgZm9yIHBlcmZvcm1hbmNlLlxuXHRcdFx0dGhpcy5fcmVzZXRCb3VuZHMoKTtcblxuXHRcdFx0Ly8gQ2hpbGQgbWFya2Vycy5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkTGF0TG5nID0gbWFya2Vyc1tpXS5fbGF0bG5nO1xuXG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQoY2hpbGRMYXRMbmcpO1xuXG5cdFx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQ7XG5cdFx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoaWxkIGNsdXN0ZXJzLlxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkQ2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y2hpbGQgPSBjaGlsZENsdXN0ZXJzW2ldO1xuXG5cdFx0XHRcdC8vIFJlLWNvbXB1dGUgY2hpbGQgYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbiBmaXJzdCBpZiBuZWNlc3NhcnkuXG5cdFx0XHRcdGlmIChjaGlsZC5fYm91bmRzTmVlZFVwZGF0ZSkge1xuXHRcdFx0XHRcdGNoaWxkLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChjaGlsZC5fYm91bmRzKTtcblxuXHRcdFx0XHRjaGlsZExhdExuZyA9IGNoaWxkLl93TGF0TG5nO1xuXHRcdFx0XHRjaGlsZENvdW50ID0gY2hpbGQuX2NoaWxkQ291bnQ7XG5cblx0XHRcdFx0bGF0U3VtICs9IGNoaWxkTGF0TG5nLmxhdCAqIGNoaWxkQ291bnQ7XG5cdFx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmcgKiBjaGlsZENvdW50O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sYXRsbmcgPSB0aGlzLl93TGF0TG5nID0gbmV3IEwuTGF0TG5nKGxhdFN1bSAvIHRvdGFsQ291bnQsIGxuZ1N1bSAvIHRvdGFsQ291bnQpO1xuXG5cdFx0XHQvLyBSZXNldCBkaXJ0eSBmbGFnLlxuXHRcdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvL1NldCBvdXIgbWFya2VycyBwb3NpdGlvbiBhcyBnaXZlbiBhbmQgYWRkIGl0IHRvIHRoZSBtYXBcblx0XHRfYWRkVG9NYXA6IGZ1bmN0aW9uIChzdGFydFBvcykge1xuXHRcdFx0aWYgKHN0YXJ0UG9zKSB7XG5cdFx0XHRcdHRoaXMuX2JhY2t1cExhdGxuZyA9IHRoaXMuX2xhdGxuZztcblx0XHRcdFx0dGhpcy5zZXRMYXRMbmcoc3RhcnRQb3MpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW46IGZ1bmN0aW9uIChib3VuZHMsIGNlbnRlciwgbWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgbWF4Wm9vbSAtIDEsXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0dmFyIG1hcmtlcnMgPSBjLl9tYXJrZXJzLFxuXHRcdFx0XHRcdFx0aSwgbTtcblx0XHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdFx0Ly9Pbmx5IGRvIGl0IGlmIHRoZSBpY29uIGlzIHN0aWxsIG9uIHRoZSBtYXBcblx0XHRcdFx0XHRcdGlmIChtLl9pY29uKSB7XG5cdFx0XHRcdFx0XHRcdG0uX3NldFBvcyhjZW50ZXIpO1xuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHZhciBjaGlsZENsdXN0ZXJzID0gYy5fY2hpbGRDbHVzdGVycyxcblx0XHRcdFx0XHRcdGosIGNtO1xuXHRcdFx0XHRcdGZvciAoaiA9IGNoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRcdGNtID0gY2hpbGRDbHVzdGVyc1tqXTtcblx0XHRcdFx0XHRcdGlmIChjbS5faWNvbikge1xuXHRcdFx0XHRcdFx0XHRjbS5fc2V0UG9zKGNlbnRlcik7XG5cdFx0XHRcdFx0XHRcdGNtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcDogZnVuY3Rpb24gKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCBuZXdab29tTGV2ZWwsIG1hcE1pblpvb20sXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5Jbihib3VuZHMsIGMuX2dyb3VwLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGMuZ2V0TGF0TG5nKCkpLnJvdW5kKCksIHByZXZpb3VzWm9vbUxldmVsKTtcblxuXHRcdFx0XHRcdC8vVE9ETzogZGVwdGhUb0FuaW1hdGVJbiBhZmZlY3RzIF9pc1NpbmdsZVBhcmVudCwgaWYgdGhlcmUgaXMgYSBtdWx0aXpvb20gd2UgbWF5L21heSBub3QgYmUuXG5cdFx0XHRcdFx0Ly9BcyBhIGhhY2sgd2Ugb25seSBkbyBhIGFuaW1hdGlvbiBmcmVlIHpvb20gb24gYSBzaW5nbGUgbGV2ZWwgem9vbSwgaWYgc29tZW9uZSBkb2VzIG11bHRpcGxlIGxldmVscyB0aGVuIHdlIGFsd2F5cyBhbmltYXRlXG5cdFx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgLSAxID09PSBuZXdab29tTGV2ZWwpIHtcblx0XHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwpOyAvL0ltbWVkaWF0ZWx5IHJlbW92ZSBvdXIgY2hpbGRyZW4gYXMgd2UgYXJlIHJlcGxhY2luZyB0aGVtLiBUT0RPIHByZXZpb3VzQm91bmRzIG5vdCBib3VuZHNcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGMuX2FkZFRvTWFwKCk7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdF9yZWN1cnNpdmVseUJlY29tZVZpc2libGU6IGZ1bmN0aW9uIChib3VuZHMsIHpvb21MZXZlbCkge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgem9vbUxldmVsLCBudWxsLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRjLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcDogZnVuY3Rpb24gKHN0YXJ0UG9zLCB6b29tTGV2ZWwsIGJvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSAtIDEsIHpvb21MZXZlbCxcblx0XHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRpZiAoem9vbUxldmVsID09PSBjLl96b29tKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9BZGQgb3VyIGNoaWxkIG1hcmtlcnMgYXQgc3RhcnRQb3MgKHNvIHRoZXkgY2FuIGJlIGFuaW1hdGVkIG91dClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gYy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0dmFyIG5tID0gYy5fbWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMobm0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChzdGFydFBvcykge1xuXHRcdFx0XHRcdFx0XHRubS5fYmFja3VwTGF0bG5nID0gbm0uZ2V0TGF0TG5nKCk7XG5cblx0XHRcdFx0XHRcdFx0bm0uc2V0TGF0TG5nKHN0YXJ0UG9zKTtcblx0XHRcdFx0XHRcdFx0aWYgKG5tLmNsdXN0ZXJIaWRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm0uY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLmFkZExheWVyKG5tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Yy5fYWRkVG9NYXAoc3RhcnRQb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnM6IGZ1bmN0aW9uICh6b29tTGV2ZWwpIHtcblx0XHRcdC8vRml4IHBvc2l0aW9ucyBvZiBjaGlsZCBtYXJrZXJzXG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgbm0gPSB0aGlzLl9tYXJrZXJzW2ldO1xuXHRcdFx0XHRpZiAobm0uX2JhY2t1cExhdGxuZykge1xuXHRcdFx0XHRcdG5tLnNldExhdExuZyhubS5fYmFja3VwTGF0bG5nKTtcblx0XHRcdFx0XHRkZWxldGUgbm0uX2JhY2t1cExhdGxuZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoem9vbUxldmVsIC0gMSA9PT0gdGhpcy5fem9vbSkge1xuXHRcdFx0XHQvL1JlcG9zaXRpb24gY2hpbGQgY2x1c3RlcnNcblx0XHRcdFx0Zm9yICh2YXIgaiA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2pdLl9yZXN0b3JlUG9zaXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgayA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcblx0XHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2tdLl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyh6b29tTGV2ZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9yZXN0b3JlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9iYWNrdXBMYXRsbmcpIHtcblx0XHRcdFx0dGhpcy5zZXRMYXRMbmcodGhpcy5fYmFja3VwTGF0bG5nKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2JhY2t1cExhdGxuZztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9leGNlcHRCb3VuZHM6IElmIHNldCwgZG9uJ3QgcmVtb3ZlIGFueSBtYXJrZXJzL2NsdXN0ZXJzIGluIGl0XG5cdFx0X3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwOiBmdW5jdGlvbiAocHJldmlvdXNCb3VuZHMsIG1hcE1pblpvb20sIHpvb21MZXZlbCwgZXhjZXB0Qm91bmRzKSB7XG5cdFx0XHR2YXIgbSwgaTtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KHByZXZpb3VzQm91bmRzLCBtYXBNaW5ab29tIC0gMSwgem9vbUxldmVsIC0gMSxcblx0XHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHQvL1JlbW92ZSBtYXJrZXJzIGF0IGV2ZXJ5IGxldmVsXG5cdFx0XHRcdFx0Zm9yIChpID0gYy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IGMuX21hcmtlcnNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcblx0XHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Ly9SZW1vdmUgY2hpbGQgY2x1c3RlcnMgYXQganVzdCB0aGUgYm90dG9tIGxldmVsXG5cdFx0XHRcdFx0Zm9yIChpID0gYy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IGMuX2NoaWxkQ2x1c3RlcnNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcblx0XHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8vUnVuIHRoZSBnaXZlbiBmdW5jdGlvbnMgcmVjdXJzaXZlbHkgdG8gdGhpcyBhbmQgY2hpbGQgY2x1c3RlcnNcblx0XHQvLyBib3VuZHNUb0FwcGx5VG86IGEgTC5MYXRMbmdCb3VuZHMgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMgb2Ygd2hhdCBjbHVzdGVycyB0byByZWN1cnNlIGluIHRvXG5cdFx0Ly8gem9vbUxldmVsVG9TdGFydDogem9vbSBsZXZlbCB0byBzdGFydCBydW5uaW5nIGZ1bmN0aW9ucyAoaW5jbHVzaXZlKVxuXHRcdC8vIHpvb21MZXZlbFRvU3RvcDogem9vbSBsZXZlbCB0byBzdG9wIHJ1bm5pbmcgZnVuY3Rpb25zIChpbmNsdXNpdmUpXG5cdFx0Ly8gcnVuQXRFdmVyeUxldmVsOiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIEwuTWFya2VyQ2x1c3RlciBhcyBhbiBhcmd1bWVudCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIG9uIGV2ZXJ5IGxldmVsXG5cdFx0Ly8gcnVuQXRCb3R0b21MZXZlbDogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBMLk1hcmtlckNsdXN0ZXIgYXMgYW4gYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBhdCBvbmx5IHRoZSBib3R0b20gbGV2ZWxcblx0XHRfcmVjdXJzaXZlbHk6IGZ1bmN0aW9uIChib3VuZHNUb0FwcGx5VG8sIHpvb21MZXZlbFRvU3RhcnQsIHpvb21MZXZlbFRvU3RvcCwgcnVuQXRFdmVyeUxldmVsLCBydW5BdEJvdHRvbUxldmVsKSB7XG5cdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMsXG5cdFx0XHQgICAgem9vbSA9IHRoaXMuX3pvb20sXG5cdFx0XHQgICAgaSwgYztcblxuXHRcdFx0aWYgKHpvb21MZXZlbFRvU3RhcnQgPD0gem9vbSkge1xuXHRcdFx0XHRpZiAocnVuQXRFdmVyeUxldmVsKSB7XG5cdFx0XHRcdFx0cnVuQXRFdmVyeUxldmVsKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5BdEJvdHRvbUxldmVsICYmIHpvb20gPT09IHpvb21MZXZlbFRvU3RvcCkge1xuXHRcdFx0XHRcdHJ1bkF0Qm90dG9tTGV2ZWwodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHpvb20gPCB6b29tTGV2ZWxUb1N0YXJ0IHx8IHpvb20gPCB6b29tTGV2ZWxUb1N0b3ApIHtcblx0XHRcdFx0Zm9yIChpID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGMgPSBjaGlsZENsdXN0ZXJzW2ldO1xuXHRcdFx0XHRcdGlmIChjLl9ib3VuZHNOZWVkVXBkYXRlKSB7XG5cdFx0XHRcdFx0XHRjLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoYm91bmRzVG9BcHBseVRvLmludGVyc2VjdHMoYy5fYm91bmRzKSkge1xuXHRcdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHkoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIHdlIGFyZSB0aGUgcGFyZW50IG9mIG9ubHkgb25lIGNsdXN0ZXIgYW5kIHRoYXQgY2x1c3RlciBpcyB0aGUgc2FtZSBhcyB1c1xuXHRcdF9pc1NpbmdsZVBhcmVudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly9Eb24ndCBuZWVkIHRvIGNoZWNrIHRoaXMuX21hcmtlcnMgYXMgdGhlIHJlc3Qgd29uJ3Qgd29yayBpZiB0aGVyZSBhcmUgYW55XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggPiAwICYmIHRoaXMuX2NoaWxkQ2x1c3RlcnNbMF0uX2NoaWxkQ291bnQgPT09IHRoaXMuX2NoaWxkQ291bnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvKlxuXHQqIEV4dGVuZHMgTC5NYXJrZXIgdG8gaW5jbHVkZSB0d28gZXh0cmEgbWV0aG9kczogY2x1c3RlckhpZGUgYW5kIGNsdXN0ZXJTaG93LlxuXHQqIFxuXHQqIFRoZXkgd29yayBhcyBzZXRPcGFjaXR5KDApIGFuZCBzZXRPcGFjaXR5KDEpIHJlc3BlY3RpdmVseSwgYnV0XG5cdCogZG9uJ3Qgb3ZlcndyaXRlIHRoZSBvcHRpb25zLm9wYWNpdHlcblx0KiBcblx0Ki9cblxuXHRMLk1hcmtlci5pbmNsdWRlKHtcblx0XHRjbHVzdGVySGlkZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGJhY2t1cCA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDApO1xuXHRcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBiYWNrdXA7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdFxuXHRcdGNsdXN0ZXJTaG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cdH0pO1xuXG5cdEwuRGlzdGFuY2VHcmlkID0gZnVuY3Rpb24gKGNlbGxTaXplKSB7XG5cdFx0dGhpcy5fY2VsbFNpemUgPSBjZWxsU2l6ZTtcblx0XHR0aGlzLl9zcUNlbGxTaXplID0gY2VsbFNpemUgKiBjZWxsU2l6ZTtcblx0XHR0aGlzLl9ncmlkID0ge307XG5cdFx0dGhpcy5fb2JqZWN0UG9pbnQgPSB7IH07XG5cdH07XG5cblx0TC5EaXN0YW5jZUdyaWQucHJvdG90eXBlID0ge1xuXG5cdFx0YWRkT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xuXHRcdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcblx0XHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXG5cdFx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXG5cdFx0XHQgICAgcm93ID0gZ3JpZFt5XSA9IGdyaWRbeV0gfHwge30sXG5cdFx0XHQgICAgY2VsbCA9IHJvd1t4XSA9IHJvd1t4XSB8fCBbXSxcblx0XHRcdCAgICBzdGFtcCA9IEwuVXRpbC5zdGFtcChvYmopO1xuXG5cdFx0XHR0aGlzLl9vYmplY3RQb2ludFtzdGFtcF0gPSBwb2ludDtcblxuXHRcdFx0Y2VsbC5wdXNoKG9iaik7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZU9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcblx0XHRcdHRoaXMucmVtb3ZlT2JqZWN0KG9iaik7XG5cdFx0XHR0aGlzLmFkZE9iamVjdChvYmosIHBvaW50KTtcblx0XHR9LFxuXG5cdFx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCB3YXMgZm91bmRcblx0XHRyZW1vdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XG5cdFx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxuXHRcdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcblx0XHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZCxcblx0XHRcdCAgICByb3cgPSBncmlkW3ldID0gZ3JpZFt5XSB8fCB7fSxcblx0XHRcdCAgICBjZWxsID0gcm93W3hdID0gcm93W3hdIHx8IFtdLFxuXHRcdFx0ICAgIGksIGxlbjtcblxuXHRcdFx0ZGVsZXRlIHRoaXMuX29iamVjdFBvaW50W0wuVXRpbC5zdGFtcChvYmopXTtcblxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZiAoY2VsbFtpXSA9PT0gb2JqKSB7XG5cblx0XHRcdFx0XHRjZWxsLnNwbGljZShpLCAxKTtcblxuXHRcdFx0XHRcdGlmIChsZW4gPT09IDEpIHtcblx0XHRcdFx0XHRcdGRlbGV0ZSByb3dbeF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRlYWNoT2JqZWN0OiBmdW5jdGlvbiAoZm4sIGNvbnRleHQpIHtcblx0XHRcdHZhciBpLCBqLCBrLCBsZW4sIHJvdywgY2VsbCwgcmVtb3ZlZCxcblx0XHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZDtcblxuXHRcdFx0Zm9yIChpIGluIGdyaWQpIHtcblx0XHRcdFx0cm93ID0gZ3JpZFtpXTtcblxuXHRcdFx0XHRmb3IgKGogaW4gcm93KSB7XG5cdFx0XHRcdFx0Y2VsbCA9IHJvd1tqXTtcblxuXHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcblx0XHRcdFx0XHRcdHJlbW92ZWQgPSBmbi5jYWxsKGNvbnRleHQsIGNlbGxba10pO1xuXHRcdFx0XHRcdFx0aWYgKHJlbW92ZWQpIHtcblx0XHRcdFx0XHRcdFx0ay0tO1xuXHRcdFx0XHRcdFx0XHRsZW4tLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0TmVhck9iamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxuXHRcdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcblx0XHRcdCAgICBpLCBqLCBrLCByb3csIGNlbGwsIGxlbiwgb2JqLCBkaXN0LFxuXHRcdFx0ICAgIG9iamVjdFBvaW50ID0gdGhpcy5fb2JqZWN0UG9pbnQsXG5cdFx0XHQgICAgY2xvc2VzdERpc3RTcSA9IHRoaXMuX3NxQ2VsbFNpemUsXG5cdFx0XHQgICAgY2xvc2VzdCA9IG51bGw7XG5cblx0XHRcdGZvciAoaSA9IHkgLSAxOyBpIDw9IHkgKyAxOyBpKyspIHtcblx0XHRcdFx0cm93ID0gdGhpcy5fZ3JpZFtpXTtcblx0XHRcdFx0aWYgKHJvdykge1xuXG5cdFx0XHRcdFx0Zm9yIChqID0geCAtIDE7IGogPD0geCArIDE7IGorKykge1xuXHRcdFx0XHRcdFx0Y2VsbCA9IHJvd1tqXTtcblx0XHRcdFx0XHRcdGlmIChjZWxsKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuXHRcdFx0XHRcdFx0XHRcdG9iaiA9IGNlbGxba107XG5cdFx0XHRcdFx0XHRcdFx0ZGlzdCA9IHRoaXMuX3NxRGlzdChvYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV0sIHBvaW50KTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0U3EgfHxcblx0XHRcdFx0XHRcdFx0XHRcdGRpc3QgPD0gY2xvc2VzdERpc3RTcSAmJiBjbG9zZXN0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdFNxID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3QgPSBvYmo7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2xvc2VzdDtcblx0XHR9LFxuXG5cdFx0X2dldENvb3JkOiBmdW5jdGlvbiAoeCkge1xuXHRcdFx0dmFyIGNvb3JkID0gTWF0aC5mbG9vcih4IC8gdGhpcy5fY2VsbFNpemUpO1xuXHRcdFx0cmV0dXJuIGlzRmluaXRlKGNvb3JkKSA/IGNvb3JkIDogeDtcblx0XHR9LFxuXG5cdFx0X3NxRGlzdDogZnVuY3Rpb24gKHAsIHAyKSB7XG5cdFx0XHR2YXIgZHggPSBwMi54IC0gcC54LFxuXHRcdFx0ICAgIGR5ID0gcDIueSAtIHAueTtcblx0XHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblx0XHR9XG5cdH07XG5cblx0LyogQ29weXJpZ2h0IChjKSAyMDEyIHRoZSBhdXRob3JzIGxpc3RlZCBhdCB0aGUgZm9sbG93aW5nIFVSTCwgYW5kL29yXG5cdHRoZSBhdXRob3JzIG9mIHJlZmVyZW5jZWQgYXJ0aWNsZXMgb3IgaW5jb3Jwb3JhdGVkIGV4dGVybmFsIGNvZGU6XG5cdGh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP2FjdGlvbj1oaXN0b3J5Jm9mZnNldD0yMDEyMDQxMDE3NTI1NlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuXHRhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblx0XCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG5cdHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcblx0ZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5cdHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuXHR0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcblx0aW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcblx0RVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cblx0SU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcblx0Q0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcblx0VE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcblx0U09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblx0UmV0cmlldmVkIGZyb206IGh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP29sZGlkPTE4NDM0XG5cdCovXG5cblx0KGZ1bmN0aW9uICgpIHtcblx0XHRMLlF1aWNrSHVsbCA9IHtcblxuXHRcdFx0Lypcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjcHQgYSBwb2ludCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBiYXNlbGluZVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gYmwgdGhlIGJhc2VsaW5lLCBhcyByZXByZXNlbnRlZCBieSBhIHR3by1lbGVtZW50XG5cdFx0XHQgKiAgIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzLlxuXHRcdFx0ICogQHJldHVybnMge051bWJlcn0gYW4gYXBwcm94aW1hdGUgZGlzdGFuY2UgbWVhc3VyZVxuXHRcdFx0ICovXG5cdFx0XHRnZXREaXN0YW50OiBmdW5jdGlvbiAoY3B0LCBibCkge1xuXHRcdFx0XHR2YXIgdlkgPSBibFsxXS5sYXQgLSBibFswXS5sYXQsXG5cdFx0XHRcdFx0dlggPSBibFswXS5sbmcgLSBibFsxXS5sbmc7XG5cdFx0XHRcdHJldHVybiAodlggKiAoY3B0LmxhdCAtIGJsWzBdLmxhdCkgKyB2WSAqIChjcHQubG5nIC0gYmxbMF0ubG5nKSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gYmFzZUxpbmUgYSB0d28tZWxlbWVudCBhcnJheSBvZiBsYXRsbmcgb2JqZWN0c1xuXHRcdFx0ICogICByZXByZXNlbnRpbmcgdGhlIGJhc2VsaW5lIHRvIHByb2plY3QgZnJvbVxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5ncyBhbiBhcnJheSBvZiBsYXRsbmcgb2JqZWN0c1xuXHRcdFx0ICogQHJldHVybnMge09iamVjdH0gdGhlIG1heGltdW0gcG9pbnQgYW5kIGFsbCBuZXcgcG9pbnRzIHRvIHN0YXlcblx0XHRcdCAqICAgaW4gY29uc2lkZXJhdGlvbiBmb3IgdGhlIGh1bGwuXG5cdFx0XHQgKi9cblx0XHRcdGZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcblx0XHRcdFx0dmFyIG1heEQgPSAwLFxuXHRcdFx0XHRcdG1heFB0ID0gbnVsbCxcblx0XHRcdFx0XHRuZXdQb2ludHMgPSBbXSxcblx0XHRcdFx0XHRpLCBwdCwgZDtcblxuXHRcdFx0XHRmb3IgKGkgPSBsYXRMbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0cHQgPSBsYXRMbmdzW2ldO1xuXHRcdFx0XHRcdGQgPSB0aGlzLmdldERpc3RhbnQocHQsIGJhc2VMaW5lKTtcblxuXHRcdFx0XHRcdGlmIChkID4gMCkge1xuXHRcdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZCA+IG1heEQpIHtcblx0XHRcdFx0XHRcdG1heEQgPSBkO1xuXHRcdFx0XHRcdFx0bWF4UHQgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4geyBtYXhQb2ludDogbWF4UHQsIG5ld1BvaW50czogbmV3UG9pbnRzIH07XG5cdFx0XHR9LFxuXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBHaXZlbiBhIGJhc2VsaW5lLCBjb21wdXRlIHRoZSBjb252ZXggaHVsbCBvZiBsYXRMbmdzIGFzIGFuIGFycmF5XG5cdFx0XHQgKiBvZiBsYXRMbmdzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGxhdExuZ3Ncblx0XHRcdCAqIEByZXR1cm5zIHtBcnJheX1cblx0XHRcdCAqL1xuXHRcdFx0YnVpbGRDb252ZXhIdWxsOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcblx0XHRcdFx0dmFyIGNvbnZleEh1bGxCYXNlTGluZXMgPSBbXSxcblx0XHRcdFx0XHR0ID0gdGhpcy5maW5kTW9zdERpc3RhbnRQb2ludEZyb21CYXNlTGluZShiYXNlTGluZSwgbGF0TG5ncyk7XG5cblx0XHRcdFx0aWYgKHQubWF4UG9pbnQpIHsgLy8gaWYgdGhlcmUgaXMgc3RpbGwgYSBwb2ludCBcIm91dHNpZGVcIiB0aGUgYmFzZSBsaW5lXG5cdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcyA9XG5cdFx0XHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzLmNvbmNhdChcblx0XHRcdFx0XHRcdFx0dGhpcy5idWlsZENvbnZleEh1bGwoW2Jhc2VMaW5lWzBdLCB0Lm1heFBvaW50XSwgdC5uZXdQb2ludHMpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxuXHRcdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXG5cdFx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFt0Lm1heFBvaW50LCBiYXNlTGluZVsxXV0sIHQubmV3UG9pbnRzKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gY29udmV4SHVsbEJhc2VMaW5lcztcblx0XHRcdFx0fSBlbHNlIHsgIC8vIGlmIHRoZXJlIGlzIG5vIG1vcmUgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZSwgdGhlIGN1cnJlbnQgYmFzZSBsaW5lIGlzIHBhcnQgb2YgdGhlIGNvbnZleCBodWxsXG5cdFx0XHRcdFx0cmV0dXJuIFtiYXNlTGluZVswXV07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qXG5cdFx0XHQgKiBHaXZlbiBhbiBhcnJheSBvZiBsYXRsbmdzLCBjb21wdXRlIGEgY29udmV4IGh1bGwgYXMgYW4gYXJyYXlcblx0XHRcdCAqIG9mIGxhdGxuZ3Ncblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXG5cdFx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0XHQgKi9cblx0XHRcdGdldENvbnZleEh1bGw6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XG5cdFx0XHRcdC8vIGZpbmQgZmlyc3QgYmFzZWxpbmVcblx0XHRcdFx0dmFyIG1heExhdCA9IGZhbHNlLCBtaW5MYXQgPSBmYWxzZSxcblx0XHRcdFx0XHRtYXhMbmcgPSBmYWxzZSwgbWluTG5nID0gZmFsc2UsXG5cdFx0XHRcdFx0bWF4TGF0UHQgPSBudWxsLCBtaW5MYXRQdCA9IG51bGwsXG5cdFx0XHRcdFx0bWF4TG5nUHQgPSBudWxsLCBtaW5MbmdQdCA9IG51bGwsXG5cdFx0XHRcdFx0bWF4UHQgPSBudWxsLCBtaW5QdCA9IG51bGwsXG5cdFx0XHRcdFx0aTtcblxuXHRcdFx0XHRmb3IgKGkgPSBsYXRMbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0dmFyIHB0ID0gbGF0TG5nc1tpXTtcblx0XHRcdFx0XHRpZiAobWF4TGF0ID09PSBmYWxzZSB8fCBwdC5sYXQgPiBtYXhMYXQpIHtcblx0XHRcdFx0XHRcdG1heExhdFB0ID0gcHQ7XG5cdFx0XHRcdFx0XHRtYXhMYXQgPSBwdC5sYXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtaW5MYXQgPT09IGZhbHNlIHx8IHB0LmxhdCA8IG1pbkxhdCkge1xuXHRcdFx0XHRcdFx0bWluTGF0UHQgPSBwdDtcblx0XHRcdFx0XHRcdG1pbkxhdCA9IHB0LmxhdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1heExuZyA9PT0gZmFsc2UgfHwgcHQubG5nID4gbWF4TG5nKSB7XG5cdFx0XHRcdFx0XHRtYXhMbmdQdCA9IHB0O1xuXHRcdFx0XHRcdFx0bWF4TG5nID0gcHQubG5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWluTG5nID09PSBmYWxzZSB8fCBwdC5sbmcgPCBtaW5MbmcpIHtcblx0XHRcdFx0XHRcdG1pbkxuZ1B0ID0gcHQ7XG5cdFx0XHRcdFx0XHRtaW5MbmcgPSBwdC5sbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobWluTGF0ICE9PSBtYXhMYXQpIHtcblx0XHRcdFx0XHRtaW5QdCA9IG1pbkxhdFB0O1xuXHRcdFx0XHRcdG1heFB0ID0gbWF4TGF0UHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWluUHQgPSBtaW5MbmdQdDtcblx0XHRcdFx0XHRtYXhQdCA9IG1heExuZ1B0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNoID0gW10uY29uY2F0KHRoaXMuYnVpbGRDb252ZXhIdWxsKFttaW5QdCwgbWF4UHRdLCBsYXRMbmdzKSxcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFttYXhQdCwgbWluUHRdLCBsYXRMbmdzKSk7XG5cdFx0XHRcdHJldHVybiBjaDtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCkpO1xuXG5cdEwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcblx0XHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcblx0XHRcdFx0cG9pbnRzID0gW10sXG5cdFx0XHRcdHAsIGk7XG5cblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRwID0gY2hpbGRNYXJrZXJzW2ldLmdldExhdExuZygpO1xuXHRcdFx0XHRwb2ludHMucHVzaChwKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIEwuUXVpY2tIdWxsLmdldENvbnZleEh1bGwocG9pbnRzKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vVGhpcyBjb2RlIGlzIDEwMCUgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2phd2ovT3ZlcmxhcHBpbmdNYXJrZXJTcGlkZXJmaWVyLUxlYWZsZXRcblx0Ly9IdWdlIHRoYW5rcyB0byBqYXdqIGZvciBpbXBsZW1lbnRpbmcgaXQgZmlyc3QgdG8gbWFrZSBteSBqb2IgZWFzeSA6LSlcblxuXHRMLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XG5cblx0XHRfMlBJOiBNYXRoLlBJICogMixcblx0XHRfY2lyY2xlRm9vdFNlcGFyYXRpb246IDI1LCAvL3JlbGF0ZWQgdG8gY2lyY3VtZmVyZW5jZSBvZiBjaXJjbGVcblx0XHRfY2lyY2xlU3RhcnRBbmdsZTogMCxcblxuXHRcdF9zcGlyYWxGb290U2VwYXJhdGlvbjogIDI4LCAvL3JlbGF0ZWQgdG8gc2l6ZSBvZiBzcGlyYWwgKGV4cGVyaW1lbnQhKVxuXHRcdF9zcGlyYWxMZW5ndGhTdGFydDogMTEsXG5cdFx0X3NwaXJhbExlbmd0aEZhY3RvcjogNSxcblxuXHRcdF9jaXJjbGVTcGlyYWxTd2l0Y2hvdmVyOiA5LCAvL3Nob3cgc3BpcmFsIGluc3RlYWQgb2YgY2lyY2xlIGZyb20gdGhpcyBtYXJrZXIgY291bnQgdXB3YXJkcy5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIDAgLT4gYWx3YXlzIHNwaXJhbDsgSW5maW5pdHkgLT4gYWx3YXlzIGNpcmNsZVxuXG5cdFx0c3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9PT0gdGhpcyB8fCB0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKG51bGwsIHRydWUpLFxuXHRcdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0XHRjZW50ZXIgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXG5cdFx0XHRcdHBvc2l0aW9ucztcblxuXHRcdFx0dGhpcy5fZ3JvdXAuX3Vuc3BpZGVyZnkoKTtcblx0XHRcdHRoaXMuX2dyb3VwLl9zcGlkZXJmaWVkID0gdGhpcztcblxuXHRcdFx0Ly9UT0RPIE1heWJlOiBjaGlsZE1hcmtlcnMgb3JkZXIgYnkgZGlzdGFuY2UgdG8gY2VudGVyXG5cblx0XHRcdGlmICh0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5U2hhcGVQb3NpdGlvbnMpIHtcblx0XHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeVNoYXBlUG9zaXRpb25zKGNoaWxkTWFya2Vycy5sZW5ndGgsIGNlbnRlcik7XG5cdFx0XHR9IGVsc2UgaWYgKGNoaWxkTWFya2Vycy5sZW5ndGggPj0gdGhpcy5fY2lyY2xlU3BpcmFsU3dpdGNob3Zlcikge1xuXHRcdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c1NwaXJhbChjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2VudGVyLnkgKz0gMTA7IC8vIE90aGVyd2lzZSBjaXJjbGVzIGxvb2sgd3JvbmcgPT4gaGFjayBmb3Igc3RhbmRhcmQgYmx1ZSBpY29uLCByZW5kZXJzIGRpZmZlcmVudGx5IGZvciBvdGhlciBpY29ucy5cblx0XHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNDaXJjbGUoY2hpbGRNYXJrZXJzLmxlbmd0aCwgY2VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uU3BpZGVyZnkoY2hpbGRNYXJrZXJzLCBwb3NpdGlvbnMpO1xuXHRcdH0sXG5cblx0XHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHRcdC8vLyA8cGFyYW0gTmFtZT1cInpvb21EZXRhaWxzXCI+QXJndW1lbnQgZnJvbSB6b29tYW5pbSBpZiBiZWluZyBjYWxsZWQgaW4gYSB6b29tIGFuaW1hdGlvbiBvciBudWxsIG90aGVyd2lzZTwvcGFyYW0+XG5cdFx0XHRpZiAodGhpcy5fZ3JvdXAuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hbmltYXRpb25VbnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcblxuXHRcdFx0dGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xuXHRcdH0sXG5cblx0XHRfZ2VuZXJhdGVQb2ludHNDaXJjbGU6IGZ1bmN0aW9uIChjb3VudCwgY2VudGVyUHQpIHtcblx0XHRcdHZhciBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX2NpcmNsZUZvb3RTZXBhcmF0aW9uICogKDIgKyBjb3VudCksXG5cdFx0XHRcdGxlZ0xlbmd0aCA9IGNpcmN1bWZlcmVuY2UgLyB0aGlzLl8yUEksICAvL3JhZGl1cyBmcm9tIGNpcmN1bWZlcmVuY2Vcblx0XHRcdFx0YW5nbGVTdGVwID0gdGhpcy5fMlBJIC8gY291bnQsXG5cdFx0XHRcdHJlcyA9IFtdLFxuXHRcdFx0XHRpLCBhbmdsZTtcblxuXHRcdFx0bGVnTGVuZ3RoID0gTWF0aC5tYXgobGVnTGVuZ3RoLCAzNSk7IC8vIE1pbmltdW0gZGlzdGFuY2UgdG8gZ2V0IG91dHNpZGUgdGhlIGNsdXN0ZXIgaWNvbi5cblxuXHRcdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykgeyAvLyBDbG9ja3dpc2UsIGxpa2Ugc3BpcmFsLlxuXHRcdFx0XHRhbmdsZSA9IHRoaXMuX2NpcmNsZVN0YXJ0QW5nbGUgKyBpICogYW5nbGVTdGVwO1xuXHRcdFx0XHRyZXNbaV0gPSBuZXcgTC5Qb2ludChjZW50ZXJQdC54ICsgbGVnTGVuZ3RoICogTWF0aC5jb3MoYW5nbGUpLCBjZW50ZXJQdC55ICsgbGVnTGVuZ3RoICogTWF0aC5zaW4oYW5nbGUpKS5fcm91bmQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0X2dlbmVyYXRlUG9pbnRzU3BpcmFsOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XG5cdFx0XHR2YXIgc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyLFxuXHRcdFx0XHRsZWdMZW5ndGggPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aFN0YXJ0LFxuXHRcdFx0XHRzZXBhcmF0aW9uID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxGb290U2VwYXJhdGlvbixcblx0XHRcdFx0bGVuZ3RoRmFjdG9yID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhGYWN0b3IgKiB0aGlzLl8yUEksXG5cdFx0XHRcdGFuZ2xlID0gMCxcblx0XHRcdFx0cmVzID0gW10sXG5cdFx0XHRcdGk7XG5cblx0XHRcdHJlcy5sZW5ndGggPSBjb3VudDtcblxuXHRcdFx0Ly8gSGlnaGVyIGluZGV4LCBjbG9zZXIgcG9zaXRpb24gdG8gY2x1c3RlciBjZW50ZXIuXG5cdFx0XHRmb3IgKGkgPSBjb3VudDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0Ly8gU2tpcCB0aGUgZmlyc3QgcG9zaXRpb24sIHNvIHRoYXQgd2UgYXJlIGFscmVhZHkgZmFydGhlciBmcm9tIGNlbnRlciBhbmQgd2UgYXZvaWRcblx0XHRcdFx0Ly8gYmVpbmcgdW5kZXIgdGhlIGRlZmF1bHQgY2x1c3RlciBpY29uIChlc3BlY2lhbGx5IGltcG9ydGFudCBmb3IgQ2lyY2xlIE1hcmtlcnMpLlxuXHRcdFx0XHRpZiAoaSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YW5nbGUgKz0gc2VwYXJhdGlvbiAvIGxlZ0xlbmd0aCArIGkgKiAwLjAwMDU7XG5cdFx0XHRcdGxlZ0xlbmd0aCArPSBsZW5ndGhGYWN0b3IgLyBhbmdsZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHRcdGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKG51bGwsIHRydWUpLFxuXHRcdFx0XHRtLCBpO1xuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXG5cdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXG5cdFx0XHRcdGlmIChtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xuXHRcdFx0XHRcdG0uc2V0TGF0TG5nKG0uX3ByZVNwaWRlcmZ5TGF0bG5nKTtcblx0XHRcdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobS5fc3BpZGVyTGVnKSB7XG5cdFx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKG0uX3NwaWRlckxlZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG0uX3NwaWRlckxlZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5maXJlKCd1bnNwaWRlcmZpZWQnLCB7XG5cdFx0XHRcdGNsdXN0ZXI6IHRoaXMsXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xuXHRcdFx0fSk7XG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xuXHRcdFx0Z3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xuXHRcdH1cblx0fSk7XG5cblx0Ly9Ob24gQW5pbWF0ZWQgdmVyc2lvbnMgb2YgZXZlcnl0aGluZ1xuXHRMLk1hcmtlckNsdXN0ZXJOb25BbmltYXRlZCA9IEwuTWFya2VyQ2x1c3Rlci5leHRlbmQoe1xuXHRcdF9hbmltYXRpb25TcGlkZXJmeTogZnVuY3Rpb24gKGNoaWxkTWFya2VycywgcG9zaXRpb25zKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRsZWdPcHRpb25zID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMsXG5cdFx0XHRcdGksIG0sIGxlZywgbmV3UG9zO1xuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cblx0XHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIGxlZyBiZWZvcmUgdGhlIG1hcmtlciwgc28gdGhhdCBpbiBjYXNlIHRoZSBsYXR0ZXIgaXMgYSBjaXJjbGVNYXJrZXIsIHRoZSBsZWcgaXMgYmVoaW5kIGl0LlxuXHRcdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbdGhpcy5fbGF0bG5nLCBuZXdQb3NdLCBsZWdPcHRpb25zKTtcblx0XHRcdFx0bWFwLmFkZExheWVyKGxlZyk7XG5cdFx0XHRcdG0uX3NwaWRlckxlZyA9IGxlZztcblxuXHRcdFx0XHQvLyBOb3cgYWRkIHRoZSBtYXJrZXIuXG5cdFx0XHRcdG0uX3ByZVNwaWRlcmZ5TGF0bG5nID0gbS5fbGF0bG5nO1xuXHRcdFx0XHRtLnNldExhdExuZyhuZXdQb3MpO1xuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcblx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy9NYWtlIHRoZXNlIGFwcGVhciBvbiB0b3Agb2YgRVZFUllUSElOR1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmcuYWRkTGF5ZXIobSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblx0XHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XG5cdFx0XHRcdGNsdXN0ZXI6IHRoaXMsXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9hbmltYXRpb25VbnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vQW5pbWF0ZWQgdmVyc2lvbnMgaGVyZVxuXHRMLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XG5cblx0XHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xuXHRcdFx0dmFyIG1lID0gdGhpcyxcblx0XHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHR0aGlzTGF5ZXJMYXRMbmcgPSB0aGlzLl9sYXRsbmcsXG5cdFx0XHRcdHRoaXNMYXllclBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpc0xheWVyTGF0TG5nKSxcblx0XHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcblx0XHRcdFx0bGVnT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyksIC8vIENvcHkgdGhlIG9wdGlvbnMgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZW0gZm9yIGFuaW1hdGlvbi5cblx0XHRcdFx0ZmluYWxMZWdPcGFjaXR5ID0gbGVnT3B0aW9ucy5vcGFjaXR5LFxuXHRcdFx0XHRpLCBtLCBsZWcsIGxlZ1BhdGgsIGxlZ0xlbmd0aCwgbmV3UG9zO1xuXG5cdFx0XHRpZiAoZmluYWxMZWdPcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmluYWxMZWdPcGFjaXR5ID0gTC5NYXJrZXJDbHVzdGVyR3JvdXAucHJvdG90eXBlLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zLm9wYWNpdHk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdmcpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIGluaXRpYWwgb3BhY2l0eSBvZiB0aGUgc3BpZGVyIGxlZyBpcyBub3QgMCB0aGVuIGl0IGFwcGVhcnMgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuXHRcdFx0XHRsZWdPcHRpb25zLm9wYWNpdHkgPSAwO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgY2xhc3MgZm9yIENTUyB0cmFuc2l0aW9ucy5cblx0XHRcdFx0bGVnT3B0aW9ucy5jbGFzc05hbWUgPSAobGVnT3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LWNsdXN0ZXItc3BpZGVyLWxlZyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGRlZmluZWQgb3BhY2l0eS5cblx0XHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gZmluYWxMZWdPcGFjaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdC8vIEFkZCBtYXJrZXJzIGFuZCBzcGlkZXIgbGVncyB0byBtYXAsIGhpZGRlbiBhdCBvdXIgY2VudGVyIHBvaW50LlxuXHRcdFx0Ly8gVHJhdmVyc2UgaW4gYXNjZW5kaW5nIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IGlubmVyIGNpcmNsZU1hcmtlcnMgYXJlIG9uIHRvcCBvZiBmdXJ0aGVyIGxlZ3MuIE5vcm1hbCBtYXJrZXJzIGFyZSByZS1vcmRlcmVkIGJ5IG5ld1Bvc2l0aW9uLlxuXHRcdFx0Ly8gVGhlIHJldmVyc2Ugb3JkZXIgdHJpY2sgbm8gbG9uZ2VyIGltcHJvdmVzIHBlcmZvcm1hbmNlIG9uIG1vZGVybiBicm93c2Vycy5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZE1hcmtlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBsZWcgYmVmb3JlIHRoZSBtYXJrZXIsIHNvIHRoYXQgaW4gY2FzZSB0aGUgbGF0dGVyIGlzIGEgY2lyY2xlTWFya2VyLCB0aGUgbGVnIGlzIGJlaGluZCBpdC5cblx0XHRcdFx0bGVnID0gbmV3IEwuUG9seWxpbmUoW3RoaXNMYXllckxhdExuZywgbmV3UG9zXSwgbGVnT3B0aW9ucyk7XG5cdFx0XHRcdG1hcC5hZGRMYXllcihsZWcpO1xuXHRcdFx0XHRtLl9zcGlkZXJMZWcgPSBsZWc7XG5cblx0XHRcdFx0Ly8gRXhwbGFuYXRpb25zOiBodHRwczovL2pha2VhcmNoaWJhbGQuY29tLzIwMTMvYW5pbWF0ZWQtbGluZS1kcmF3aW5nLXN2Zy9cblx0XHRcdFx0Ly8gSW4gb3VyIGNhc2UgdGhlIHRyYW5zaXRpb24gcHJvcGVydHkgaXMgZGVjbGFyZWQgaW4gdGhlIENTUyBmaWxlLlxuXHRcdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcblx0XHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7IC8vIE5lZWQgYSBzbWFsbCBleHRyYSBsZW5ndGggdG8gYXZvaWQgcmVtYWluaW5nIGRvdCBpbiBGaXJlZm94LlxuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaGFycmF5ID0gbGVnTGVuZ3RoOyAvLyBKdXN0IDEgbGVuZ3RoIGlzIGVub3VnaCwgaXQgd2lsbCBiZSBkdXBsaWNhdGVkLlxuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IGxlZ0xlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbWFya2VyLCBhZGQgaXQgbm93IGFuZCB3ZSdsbCBhbmltYXRlIGl0IG91dFxuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcblx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy8gTWFrZSBub3JtYWwgbWFya2VycyBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobS5jbHVzdGVySGlkZSkge1xuXHRcdFx0XHRcdG0uY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVmVjdG9ycyBqdXN0IGdldCBpbW1lZGlhdGVseSBhZGRlZFxuXHRcdFx0XHRmZy5hZGRMYXllcihtKTtcblxuXHRcdFx0XHRpZiAobS5fc2V0UG9zKSB7XG5cdFx0XHRcdFx0bS5fc2V0UG9zKHRoaXNMYXllclBvcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuX2ZvcmNlTGF5b3V0KCk7XG5cdFx0XHRncm91cC5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdFx0Ly8gUmV2ZWFsIG1hcmtlcnMgYW5kIHNwaWRlciBsZWdzLlxuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHQvL01vdmUgbWFya2VyIHRvIG5ldyBwb3NpdGlvblxuXHRcdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcblx0XHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQW5pbWF0ZSBsZWcgKGFuaW1hdGlvbiBpcyBhY3R1YWxseSBkZWxlZ2F0ZWQgdG8gQ1NTIHRyYW5zaXRpb24pLlxuXHRcdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdFx0bGVnID0gbS5fc3BpZGVyTGVnO1xuXHRcdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XG5cdFx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gMDtcblx0XHRcdFx0XHQvL2xlZ1BhdGguc3R5bGUuc3Ryb2tlT3BhY2l0eSA9IGZpbmFsTGVnT3BhY2l0eTtcblx0XHRcdFx0XHRsZWcuc2V0U3R5bGUoe29wYWNpdHk6IGZpbmFsTGVnT3BhY2l0eX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoMC4zKTtcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcblx0XHRcdFx0Z3JvdXAuZmlyZSgnc3BpZGVyZmllZCcsIHtcblx0XHRcdFx0XHRjbHVzdGVyOiBtZSxcblx0XHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAyMDApO1xuXHRcdH0sXG5cblx0XHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XG5cdFx0XHR2YXIgbWUgPSB0aGlzLFxuXHRcdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHRcdHRoaXNMYXllclBvcyA9IHpvb21EZXRhaWxzID8gbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCB6b29tRGV0YWlscy56b29tLCB6b29tRGV0YWlscy5jZW50ZXIpIDogbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxuXHRcdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcblx0XHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcblx0XHRcdFx0bSwgaSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5vbkFuaW1hdGFibGU7XG5cblx0XHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcblx0XHRcdGdyb3VwLl9hbmltYXRpb25TdGFydCgpO1xuXG5cdFx0XHQvL01ha2UgdXMgdmlzaWJsZSBhbmQgYnJpbmcgdGhlIGNoaWxkIG1hcmtlcnMgYmFjayBpblxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDEpO1xuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0Ly9NYXJrZXIgd2FzIGFkZGVkIHRvIHVzIGFmdGVyIHdlIHdlcmUgc3BpZGVyZmllZFxuXHRcdFx0XHRpZiAoIW0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL0Nsb3NlIGFueSBwb3B1cCBvbiB0aGUgbWFya2VyIGZpcnN0LCBvdGhlcndpc2Ugc2V0dGluZyB0aGUgbG9jYXRpb24gb2YgdGhlIG1hcmtlciB3aWxsIG1ha2UgdGhlIG1hcCBzY3JvbGxcblx0XHRcdFx0bS5jbG9zZVBvcHVwKCk7XG5cblx0XHRcdFx0Ly9GaXggdXAgdGhlIGxvY2F0aW9uIHRvIHRoZSByZWFsIG9uZVxuXHRcdFx0XHRtLnNldExhdExuZyhtLl9wcmVTcGlkZXJmeUxhdGxuZyk7XG5cdFx0XHRcdGRlbGV0ZSBtLl9wcmVTcGlkZXJmeUxhdGxuZztcblxuXHRcdFx0XHQvL0hhY2sgb3ZlcnJpZGUgdGhlIGxvY2F0aW9uIHRvIGJlIG91ciBjZW50ZXJcblx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IHRydWU7XG5cdFx0XHRcdGlmIChtLl9zZXRQb3MpIHtcblx0XHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcblx0XHRcdFx0XHRub25BbmltYXRhYmxlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcblx0XHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub25BbmltYXRhYmxlKSB7XG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBbmltYXRlIHRoZSBzcGlkZXIgbGVnIGJhY2sgaW4gKGFuaW1hdGlvbiBpcyBhY3R1YWxseSBkZWxlZ2F0ZWQgdG8gQ1NTIHRyYW5zaXRpb24pLlxuXHRcdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdFx0bGVnID0gbS5fc3BpZGVyTGVnO1xuXHRcdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XG5cdFx0XHRcdFx0bGVnTGVuZ3RoID0gbGVnUGF0aC5nZXRUb3RhbExlbmd0aCgpICsgMC4xO1xuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IGxlZ0xlbmd0aDtcblx0XHRcdFx0XHRsZWcuc2V0U3R5bGUoe29wYWNpdHk6IDB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly9JZiB3ZSBoYXZlIG9ubHkgPD0gb25lIGNoaWxkIGxlZnQgdGhlbiB0aGF0IG1hcmtlciB3aWxsIGJlIHNob3duIG9uIHRoZSBtYXAgc28gZG9uJ3QgcmVtb3ZlIGl0IVxuXHRcdFx0XHR2YXIgc3RpbGxUaGVyZUNoaWxkQ291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXHRcdFx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcblx0XHRcdFx0XHRcdHN0aWxsVGhlcmVDaGlsZENvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXG5cdFx0XHRcdFx0aWYgKCFtLl9zcGlkZXJMZWcpIHsgLy9IYXMgYWxyZWFkeSBiZWVuIHVuc3BpZGVyZmllZFxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgwKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3RpbGxUaGVyZUNoaWxkQ291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcblx0XHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcblx0XHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xuXHRcdFx0XHRcdGNsdXN0ZXI6IG1lLFxuXHRcdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sIDIwMCk7XG5cdFx0fVxuXHR9KTtcblxuXG5cdEwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xuXHRcdC8vVGhlIE1hcmtlckNsdXN0ZXIgY3VycmVudGx5IHNwaWRlcmZpZWQgKGlmIGFueSlcblx0XHRfc3BpZGVyZmllZDogbnVsbCxcblxuXHRcdHVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0X3NwaWRlcmZpZXJPbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX3Vuc3BpZGVyZnlXcmFwcGVyLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fbWFwLm9uKCd6b29tc3RhcnQnLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbVN0YXJ0LCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdC8vQnJvd3NlcnMgd2l0aG91dCB6b29tQW5pbWF0aW9uIG9yIGEgYmlnIHpvb20gZG9uJ3QgZmlyZSB6b29tc3RhcnRcblx0XHRcdHRoaXMuX21hcC5vbignem9vbWVuZCcsIHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSwgdGhpcyk7XG5cblx0XHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0XHRcdFx0Ly9OZWVkcyB0byBoYXBwZW4gaW4gdGhlIHBhZ2Vsb2FkLCBub3QgYWZ0ZXIsIG9yIGFuaW1hdGlvbnMgZG9uJ3Qgd29yayBpbiB3ZWJraXRcblx0XHRcdFx0Ly8gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1NTIwMC9zdmctYW5pbWF0ZS13aXRoLWR5bmFtaWNhbGx5LWFkZGVkLWVsZW1lbnRzXG5cdFx0XHRcdC8vRGlzYWJsZSBvbiB0b3VjaCBicm93c2VycyBhcyB0aGUgYW5pbWF0aW9uIG1lc3NlcyB1cCBvbiBhIHRvdWNoIHpvb20gYW5kIGlzbid0IHZlcnkgbm90aWNhYmxlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zcGlkZXJmaWVyT25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5LCB0aGlzKTtcblxuXHRcdFx0Ly9FbnN1cmUgdGhhdCBtYXJrZXJzIGFyZSBiYWNrIHdoZXJlIHRoZXkgc2hvdWxkIGJlXG5cdFx0XHQvLyBVc2Ugbm8gYW5pbWF0aW9uIHRvIGF2b2lkIGEgc3RpY2t5IGxlYWZsZXQtY2x1c3Rlci1hbmltIGNsYXNzIG9uIG1hcFBhbmVcblx0XHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xuXHRcdH0sXG5cblx0XHQvL09uIHpvb20gc3RhcnQgd2UgYWRkIGEgem9vbWFuaW0gaGFuZGxlciBzbyB0aGF0IHdlIGFyZSBndWFyYW50ZWVkIHRvIGJlIGxhc3QgKGFmdGVyIG1hcmtlcnMgYXJlIGFuaW1hdGVkKVxuXHRcdC8vVGhpcyBtZWFucyB3ZSBjYW4gZGVmaW5lIHRoZSBhbmltYXRpb24gdGhleSBkbyByYXRoZXIgdGhhbiBNYXJrZXJzIGRvaW5nIGFuIGFuaW1hdGlvbiB0byB0aGVpciBhY3R1YWwgbG9jYXRpb25cblx0XHRfdW5zcGlkZXJmeVpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdF91bnNwaWRlcmZ5Wm9vbUFuaW06IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xuXHRcdFx0Ly9XYWl0IHVudGlsIHRoZSBmaXJzdCB6b29tYW5pbSBhZnRlciB0aGUgdXNlciBoYXMgZmluaXNoZWQgdG91Y2gtem9vbWluZyBiZWZvcmUgcnVubmluZyB0aGUgYW5pbWF0aW9uXG5cdFx0XHRpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX21hcC5fbWFwUGFuZSwgJ2xlYWZsZXQtdG91Y2hpbmcnKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoem9vbURldGFpbHMpO1xuXHRcdH0sXG5cblx0XHRfdW5zcGlkZXJmeVdyYXBwZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vLyA8c3VtbWFyeT5fdW5zcGlkZXJmeSBidXQgcGFzc2VzIG5vIGFyZ3VtZW50czwvc3VtbWFyeT5cblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblx0XHR9LFxuXG5cdFx0X3Vuc3BpZGVyZnk6IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcblx0XHRcdFx0dGhpcy5fc3BpZGVyZmllZC51bnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcblx0XHRcdFx0dGhpcy5fc3BpZGVyZmllZC5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vSWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBiZWluZyBzcGlkZXJmaWVkIHRoZW4gd2UgdW5zcGlkZXJmeSBpdCBzbyBpdCBpc24ndCBvbiB0aGUgbWFwIGFueW1vcmUgZXRjXG5cdFx0X3Vuc3BpZGVyZnlMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHRpZiAobGF5ZXIuX3NwaWRlckxlZykge1xuXHRcdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXG5cdFx0XHRcdGlmIChsYXllci5jbHVzdGVyU2hvdykge1xuXHRcdFx0XHRcdGxheWVyLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XHQvL1Bvc2l0aW9uIHdpbGwgYmUgZml4ZWQgdXAgaW1tZWRpYXRlbHkgaW4gX2FuaW1hdGlvblVuc3BpZGVyZnlcblx0XHRcdFx0aWYgKGxheWVyLnNldFpJbmRleE9mZnNldCkge1xuXHRcdFx0XHRcdGxheWVyLnNldFpJbmRleE9mZnNldCgwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihsYXllci5fc3BpZGVyTGVnKTtcblx0XHRcdFx0ZGVsZXRlIGxheWVyLl9zcGlkZXJMZWc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogQWRkcyAxIHB1YmxpYyBtZXRob2QgdG8gTUNHIGFuZCAxIHRvIEwuTWFya2VyIHRvIGZhY2lsaXRhdGUgY2hhbmdpbmdcblx0ICogbWFya2VycycgaWNvbiBvcHRpb25zIGFuZCByZWZyZXNoaW5nIHRoZWlyIGljb24gYW5kIHRoZWlyIHBhcmVudCBjbHVzdGVyc1xuXHQgKiBhY2NvcmRpbmdseSAoY2FzZSB3aGVyZSB0aGVpciBpY29uQ3JlYXRlRnVuY3Rpb24gdXNlcyBkYXRhIG9mIGNoaWxkTWFya2Vyc1xuXHQgKiB0byBtYWtlIHVwIHRoZSBjbHVzdGVyIGljb24pLlxuXHQgKi9cblxuXG5cdEwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGljb24gb2YgYWxsIGNsdXN0ZXJzIHdoaWNoIGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBtYXJrZXIocykuXG5cdFx0ICogSW4gc2luZ2xlTWFya2VyTW9kZSwgYWxzbyB1cGRhdGVzIHRoZSBnaXZlbiBtYXJrZXIocykgaWNvbi5cblx0XHQgKiBAcGFyYW0gbGF5ZXJzIEwuTWFya2VyQ2x1c3Rlckdyb3VwfEwuTGF5ZXJHcm91cHxBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKXxcblx0XHQgKiBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgKG9wdGlvbmFsKSBsaXN0IG9mIG1hcmtlcnMgKG9yIHNpbmdsZSBtYXJrZXIpIHdob3NlIHBhcmVudFxuXHRcdCAqIGNsdXN0ZXJzIG5lZWQgdG8gYmUgdXBkYXRlZC4gSWYgbm90IHByb3ZpZGVkLCByZXRyaWV2ZXMgYWxsIGNoaWxkIG1hcmtlcnMgb2YgdGhpcy5cblx0XHQgKiBAcmV0dXJucyB7TC5NYXJrZXJDbHVzdGVyR3JvdXB9XG5cdFx0ICovXG5cdFx0cmVmcmVzaENsdXN0ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0XHRpZiAoIWxheWVycykge1xuXHRcdFx0XHRsYXllcnMgPSB0aGlzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlckdyb3VwKSB7XG5cdFx0XHRcdGxheWVycyA9IGxheWVycy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0bGF5ZXJzID0gbGF5ZXJzLl9sYXllcnM7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHRsYXllcnMgPSBsYXllcnMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyKSB7XG5cdFx0XHRcdGxheWVycyA9IFtsYXllcnNdO1xuXHRcdFx0fSAvLyBlbHNlOiBtdXN0IGJlIGFuIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpXG5cdFx0XHR0aGlzLl9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZShsYXllcnMpO1xuXHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcblxuXHRcdFx0Ly8gSW4gY2FzZSBvZiBzaW5nbGVNYXJrZXJNb2RlLCBhbHNvIHJlLWRyYXcgdGhlIG1hcmtlcnMuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnNpbmdsZU1hcmtlck1vZGUpIHtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFNpbmdsZU1hcmtlck1vZGVNYXJrZXJzKGxheWVycyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTaW1wbHkgZmxhZ3MgYWxsIHBhcmVudCBjbHVzdGVycyBvZiB0aGUgZ2l2ZW4gbWFya2VycyBhcyBoYXZpbmcgYSBcImRpcnR5XCIgaWNvbi5cblx0XHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZTogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdFx0dmFyIGlkLCBwYXJlbnQ7XG5cblx0XHRcdC8vIEFzc3VtZXMgbGF5ZXJzIGlzIGFuIEFycmF5IG9yIGFuIE9iamVjdCB3aG9zZSBwcm90b3R5cGUgaXMgbm9uLWVudW1lcmFibGUuXG5cdFx0XHRmb3IgKGlkIGluIGxheWVycykge1xuXHRcdFx0XHQvLyBGbGFnIHBhcmVudCBjbHVzdGVycycgaWNvbiBhcyBcImRpcnR5XCIsIGFsbCB0aGUgd2F5IHVwLlxuXHRcdFx0XHQvLyBEdW1iIHByb2Nlc3MgdGhhdCBmbGFncyBtdWx0aXBsZSB0aW1lcyB1cHBlciBwYXJlbnRzLCBidXQgc3RpbGxcblx0XHRcdFx0Ly8gbXVjaCBtb3JlIGVmZmljaWVudCB0aGFuIHRyeWluZyB0byBiZSBzbWFydCBhbmQgbWFrZSBzaG9ydCBsaXN0cyxcblx0XHRcdFx0Ly8gYXQgbGVhc3QgaW4gdGhlIGNhc2Ugb2YgYSBoaWVyYXJjaHkgZm9sbG93aW5nIGEgcG93ZXIgbGF3OlxuXHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mbGFnLW5vZGVzLWluLXBvd2VyLWhpZXJhcmNoeS8yXG5cdFx0XHRcdHBhcmVudCA9IGxheWVyc1tpZF0uX19wYXJlbnQ7XG5cdFx0XHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdFx0XHRwYXJlbnQuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9fcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlLWRyYXdzIHRoZSBpY29uIG9mIHRoZSBzdXBwbGllZCBtYXJrZXJzLlxuXHRcdCAqIFRvIGJlIHVzZWQgaW4gc2luZ2xlTWFya2VyTW9kZSBvbmx5LlxuXHRcdCAqIEBwYXJhbSBsYXllcnMgQXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcikgbGlzdCBvZiBtYXJrZXJzLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdFx0dmFyIGlkLCBsYXllcjtcblxuXHRcdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcblx0XHRcdFx0bGF5ZXIgPSBsYXllcnNbaWRdO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkbyBub3Qgb3ZlcnJpZGUgbWFya2VycyB0aGF0IGRvIG5vdCBiZWxvbmcgdG8gVEhJUyBncm91cC5cblx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XG5cdFx0XHRcdFx0Ly8gTmVlZCB0byByZS1jcmVhdGUgdGhlIGljb24gZmlyc3QsIHRoZW4gcmUtZHJhdyB0aGUgbWFya2VyLlxuXHRcdFx0XHRcdGxheWVyLnNldEljb24odGhpcy5fb3ZlcnJpZGVNYXJrZXJJY29uKGxheWVyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdEwuTWFya2VyLmluY2x1ZGUoe1xuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIGdpdmVuIG9wdGlvbnMgaW4gdGhlIG1hcmtlcidzIGljb24gYW5kIHJlZnJlc2hlcyB0aGUgbWFya2VyLlxuXHRcdCAqIEBwYXJhbSBvcHRpb25zIG1hcCBvYmplY3Qgb2YgaWNvbiBvcHRpb25zLlxuXHRcdCAqIEBwYXJhbSBkaXJlY3RseVJlZnJlc2hDbHVzdGVycyBib29sZWFuIChvcHRpb25hbCkgdHJ1ZSB0byB0cmlnZ2VyXG5cdFx0ICogTUNHLnJlZnJlc2hDbHVzdGVyc09mKCkgcmlnaHQgYXdheSB3aXRoIHRoaXMgc2luZ2xlIG1hcmtlci5cblx0XHQgKiBAcmV0dXJucyB7TC5NYXJrZXJ9XG5cdFx0ICovXG5cdFx0cmVmcmVzaEljb25PcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucywgZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMpIHtcblx0XHRcdHZhciBpY29uID0gdGhpcy5vcHRpb25zLmljb247XG5cblx0XHRcdEwuc2V0T3B0aW9ucyhpY29uLCBvcHRpb25zKTtcblxuXHRcdFx0dGhpcy5zZXRJY29uKGljb24pO1xuXG5cdFx0XHQvLyBTaG9ydGN1dCB0byByZWZyZXNoIHRoZSBhc3NvY2lhdGVkIE1DRyBjbHVzdGVycyByaWdodCBhd2F5LlxuXHRcdFx0Ly8gVG8gYmUgdXNlZCB3aGVuIHJlZnJlc2hpbmcgYSBzaW5nbGUgbWFya2VyLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBiZXR0ZXIgdXNlIE1DRy5yZWZyZXNoQ2x1c3RlcnMoKSBvbmNlIGF0IHRoZSBlbmQgd2l0aFxuXHRcdFx0Ly8gdGhlIGxpc3Qgb2YgbW9kaWZpZWQgbWFya2Vycy5cblx0XHRcdGlmIChkaXJlY3RseVJlZnJlc2hDbHVzdGVycyAmJiB0aGlzLl9fcGFyZW50KSB7XG5cdFx0XHRcdHRoaXMuX19wYXJlbnQuX2dyb3VwLnJlZnJlc2hDbHVzdGVycyh0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9KTtcblxuXHRleHBvcnRzLk1hcmtlckNsdXN0ZXJHcm91cCA9IE1hcmtlckNsdXN0ZXJHcm91cDtcblx0ZXhwb3J0cy5NYXJrZXJDbHVzdGVyID0gTWFya2VyQ2x1c3RlcjtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0Lm1hcmtlcmNsdXN0ZXItc3JjLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/* @preserve\n * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  var version = \"1.9.4\";\n\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\r\n\r\n  // @function extend(dest: Object, src?: Object): Object\r\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\r\n  function extend(dest) {\r\n  \tvar i, j, len, src;\r\n\r\n  \tfor (j = 1, len = arguments.length; j < len; j++) {\r\n  \t\tsrc = arguments[j];\r\n  \t\tfor (i in src) {\r\n  \t\t\tdest[i] = src[i];\r\n  \t\t}\r\n  \t}\r\n  \treturn dest;\r\n  }\r\n\r\n  // @function create(proto: Object, properties?: Object): Object\r\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\r\n  var create$2 = Object.create || (function () {\r\n  \tfunction F() {}\r\n  \treturn function (proto) {\r\n  \t\tF.prototype = proto;\r\n  \t\treturn new F();\r\n  \t};\r\n  })();\r\n\r\n  // @function bind(fn: Function, ): Function\r\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\r\n  // Has a `L.bind()` shortcut.\r\n  function bind(fn, obj) {\r\n  \tvar slice = Array.prototype.slice;\r\n\r\n  \tif (fn.bind) {\r\n  \t\treturn fn.bind.apply(fn, slice.call(arguments, 1));\r\n  \t}\r\n\r\n  \tvar args = slice.call(arguments, 2);\r\n\r\n  \treturn function () {\r\n  \t\treturn fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\r\n  \t};\r\n  }\r\n\r\n  // @property lastId: Number\r\n  // Last unique ID used by [`stamp()`](#util-stamp)\r\n  var lastId = 0;\r\n\r\n  // @function stamp(obj: Object): Number\r\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\r\n  function stamp(obj) {\r\n  \tif (!('_leaflet_id' in obj)) {\r\n  \t\tobj['_leaflet_id'] = ++lastId;\r\n  \t}\r\n  \treturn obj._leaflet_id;\r\n  }\r\n\r\n  // @function throttle(fn: Function, time: Number, context: Object): Function\r\n  // Returns a function which executes function `fn` with the given scope `context`\r\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\r\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\r\n  // received by the bound function will be any arguments passed when binding the\r\n  // function, followed by any arguments passed when invoking the bound function.\r\n  // Has an `L.throttle` shortcut.\r\n  function throttle(fn, time, context) {\r\n  \tvar lock, args, wrapperFn, later;\r\n\r\n  \tlater = function () {\r\n  \t\t// reset lock and call if queued\r\n  \t\tlock = false;\r\n  \t\tif (args) {\r\n  \t\t\twrapperFn.apply(context, args);\r\n  \t\t\targs = false;\r\n  \t\t}\r\n  \t};\r\n\r\n  \twrapperFn = function () {\r\n  \t\tif (lock) {\r\n  \t\t\t// called too soon, queue to call later\r\n  \t\t\targs = arguments;\r\n\r\n  \t\t} else {\r\n  \t\t\t// call and lock until later\r\n  \t\t\tfn.apply(context, arguments);\r\n  \t\t\tsetTimeout(later, time);\r\n  \t\t\tlock = true;\r\n  \t\t}\r\n  \t};\r\n\r\n  \treturn wrapperFn;\r\n  }\r\n\r\n  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\r\n  // Returns the number `num` modulo `range` in such a way so it lies within\r\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\r\n  // `range[1]` unless `includeMax` is set to `true`.\r\n  function wrapNum(x, range, includeMax) {\r\n  \tvar max = range[1],\r\n  \t    min = range[0],\r\n  \t    d = max - min;\r\n  \treturn x === max && includeMax ? x : ((x - min) % d + d) % d + min;\r\n  }\r\n\r\n  // @function falseFn(): Function\r\n  // Returns a function which always returns `false`.\r\n  function falseFn() { return false; }\r\n\r\n  // @function formatNum(num: Number, precision?: Number|false): Number\r\n  // Returns the number `num` rounded with specified `precision`.\r\n  // The default `precision` value is 6 decimal places.\r\n  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\r\n  function formatNum(num, precision) {\r\n  \tif (precision === false) { return num; }\r\n  \tvar pow = Math.pow(10, precision === undefined ? 6 : precision);\r\n  \treturn Math.round(num * pow) / pow;\r\n  }\r\n\r\n  // @function trim(str: String): String\r\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\r\n  function trim(str) {\r\n  \treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n  }\r\n\r\n  // @function splitWords(str: String): String[]\r\n  // Trims and splits the string on whitespace and returns the array of parts.\r\n  function splitWords(str) {\r\n  \treturn trim(str).split(/\\s+/);\r\n  }\r\n\r\n  // @function setOptions(obj: Object, options: Object): Object\r\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\r\n  function setOptions(obj, options) {\r\n  \tif (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\r\n  \t\tobj.options = obj.options ? create$2(obj.options) : {};\r\n  \t}\r\n  \tfor (var i in options) {\r\n  \t\tobj.options[i] = options[i];\r\n  \t}\r\n  \treturn obj.options;\r\n  }\r\n\r\n  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\r\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\r\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\r\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\r\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\r\n  function getParamString(obj, existingUrl, uppercase) {\r\n  \tvar params = [];\r\n  \tfor (var i in obj) {\r\n  \t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n  \t}\r\n  \treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n  }\r\n\r\n  var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\r\n\r\n  // @function template(str: String, data: Object): String\r\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\r\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\r\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\r\n  // data values  they will be evaluated passing `data` as an argument.\r\n  function template(str, data) {\r\n  \treturn str.replace(templateRe, function (str, key) {\r\n  \t\tvar value = data[key];\r\n\r\n  \t\tif (value === undefined) {\r\n  \t\t\tthrow new Error('No value provided for variable ' + str);\r\n\r\n  \t\t} else if (typeof value === 'function') {\r\n  \t\t\tvalue = value(data);\r\n  \t\t}\r\n  \t\treturn value;\r\n  \t});\r\n  }\r\n\r\n  // @function isArray(obj): Boolean\r\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\r\n  var isArray = Array.isArray || function (obj) {\r\n  \treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n  };\r\n\r\n  // @function indexOf(array: Array, el: Object): Number\r\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\r\n  function indexOf(array, el) {\r\n  \tfor (var i = 0; i < array.length; i++) {\r\n  \t\tif (array[i] === el) { return i; }\r\n  \t}\r\n  \treturn -1;\r\n  }\r\n\r\n  // @property emptyImageUrl: String\r\n  // Data URI string containing a base64-encoded empty GIF image.\r\n  // Used as a hack to free memory from unused images on WebKit-powered\r\n  // mobile devices (by setting image `src` to this string).\r\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\r\n\r\n  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n  function getPrefixed(name) {\r\n  \treturn window['webkit' + name] || window['moz' + name] || window['ms' + name];\r\n  }\r\n\r\n  var lastTime = 0;\r\n\r\n  // fallback for IE 7-8\r\n  function timeoutDefer(fn) {\r\n  \tvar time = +new Date(),\r\n  \t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n  \tlastTime = time + timeToCall;\r\n  \treturn window.setTimeout(fn, timeToCall);\r\n  }\r\n\r\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||\r\n  \t\tgetPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };\r\n\r\n  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\r\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\r\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\r\n  // the browser doesn't have native support for\r\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\r\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\r\n  function requestAnimFrame(fn, context, immediate) {\r\n  \tif (immediate && requestFn === timeoutDefer) {\r\n  \t\tfn.call(context);\r\n  \t} else {\r\n  \t\treturn requestFn.call(window, bind(fn, context));\r\n  \t}\r\n  }\r\n\r\n  // @function cancelAnimFrame(id: Number): undefined\r\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\r\n  function cancelAnimFrame(id) {\r\n  \tif (id) {\r\n  \t\tcancelFn.call(window, id);\r\n  \t}\r\n  }\n\n  var Util = {\n    __proto__: null,\n    extend: extend,\n    create: create$2,\n    bind: bind,\n    get lastId () { return lastId; },\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  };\n\n  // @class Class\r\n  // @aka L.Class\r\n\r\n  // @section\r\n  // @uninheritable\r\n\r\n  // Thanks to John Resig and Dean Edwards for inspiration!\r\n\r\n  function Class() {}\r\n\r\n  Class.extend = function (props) {\r\n\r\n  \t// @function extend(props: Object): Function\r\n  \t// [Extends the current class](#class-inheritance) given the properties to be included.\r\n  \t// Returns a Javascript function that is a class constructor (to be called with `new`).\r\n  \tvar NewClass = function () {\r\n\r\n  \t\tsetOptions(this);\r\n\r\n  \t\t// call the constructor\r\n  \t\tif (this.initialize) {\r\n  \t\t\tthis.initialize.apply(this, arguments);\r\n  \t\t}\r\n\r\n  \t\t// call all constructor hooks\r\n  \t\tthis.callInitHooks();\r\n  \t};\r\n\r\n  \tvar parentProto = NewClass.__super__ = this.prototype;\r\n\r\n  \tvar proto = create$2(parentProto);\r\n  \tproto.constructor = NewClass;\r\n\r\n  \tNewClass.prototype = proto;\r\n\r\n  \t// inherit parent's statics\r\n  \tfor (var i in this) {\r\n  \t\tif (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\r\n  \t\t\tNewClass[i] = this[i];\r\n  \t\t}\r\n  \t}\r\n\r\n  \t// mix static properties into the class\r\n  \tif (props.statics) {\r\n  \t\textend(NewClass, props.statics);\r\n  \t}\r\n\r\n  \t// mix includes into the prototype\r\n  \tif (props.includes) {\r\n  \t\tcheckDeprecatedMixinEvents(props.includes);\r\n  \t\textend.apply(null, [proto].concat(props.includes));\r\n  \t}\r\n\r\n  \t// mix given properties into the prototype\r\n  \textend(proto, props);\r\n  \tdelete proto.statics;\r\n  \tdelete proto.includes;\r\n\r\n  \t// merge options\r\n  \tif (proto.options) {\r\n  \t\tproto.options = parentProto.options ? create$2(parentProto.options) : {};\r\n  \t\textend(proto.options, props.options);\r\n  \t}\r\n\r\n  \tproto._initHooks = [];\r\n\r\n  \t// add method for calling all hooks\r\n  \tproto.callInitHooks = function () {\r\n\r\n  \t\tif (this._initHooksCalled) { return; }\r\n\r\n  \t\tif (parentProto.callInitHooks) {\r\n  \t\t\tparentProto.callInitHooks.call(this);\r\n  \t\t}\r\n\r\n  \t\tthis._initHooksCalled = true;\r\n\r\n  \t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n  \t\t\tproto._initHooks[i].call(this);\r\n  \t\t}\r\n  \t};\r\n\r\n  \treturn NewClass;\r\n  };\r\n\r\n\r\n  // @function include(properties: Object): this\r\n  // [Includes a mixin](#class-includes) into the current class.\r\n  Class.include = function (props) {\r\n  \tvar parentOptions = this.prototype.options;\r\n  \textend(this.prototype, props);\r\n  \tif (props.options) {\r\n  \t\tthis.prototype.options = parentOptions;\r\n  \t\tthis.mergeOptions(props.options);\r\n  \t}\r\n  \treturn this;\r\n  };\r\n\r\n  // @function mergeOptions(options: Object): this\r\n  // [Merges `options`](#class-options) into the defaults of the class.\r\n  Class.mergeOptions = function (options) {\r\n  \textend(this.prototype.options, options);\r\n  \treturn this;\r\n  };\r\n\r\n  // @function addInitHook(fn: Function): this\r\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\r\n  Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n  \tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n  \tvar init = typeof fn === 'function' ? fn : function () {\r\n  \t\tthis[fn].apply(this, args);\r\n  \t};\r\n\r\n  \tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n  \tthis.prototype._initHooks.push(init);\r\n  \treturn this;\r\n  };\r\n\r\n  function checkDeprecatedMixinEvents(includes) {\r\n  \t/* global L: true */\r\n  \tif (typeof L === 'undefined' || !L || !L.Mixin) { return; }\r\n\r\n  \tincludes = isArray(includes) ? includes : [includes];\r\n\r\n  \tfor (var i = 0; i < includes.length; i++) {\r\n  \t\tif (includes[i] === L.Mixin.Events) {\r\n  \t\t\tconsole.warn('Deprecated include of L.Mixin.Events: ' +\r\n  \t\t\t\t'this property will be removed in future releases, ' +\r\n  \t\t\t\t'please inherit from L.Evented instead.', new Error().stack);\r\n  \t\t}\r\n  \t}\r\n  }\n\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\r\n\r\n  var Events = {\r\n  \t/* @method on(type: String, fn: Function, context?: Object): this\r\n  \t * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method on(eventMap: Object): this\r\n  \t * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  \t */\r\n  \ton: function (types, fn, context) {\r\n\r\n  \t\t// types can be a map of types/handlers\r\n  \t\tif (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\t// we don't process space-separated events here for performance;\r\n  \t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n  \t\t\t\tthis._on(type, types[type], fn);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\t// types can be a string of space-separated words\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tthis._on(types[i], fn, context);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t/* @method off(type: String, fn?: Function, context?: Object): this\r\n  \t * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off(eventMap: Object): this\r\n  \t * Removes a set of type/listener pairs.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off: this\r\n  \t * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n  \t */\r\n  \toff: function (types, fn, context) {\r\n\r\n  \t\tif (!arguments.length) {\r\n  \t\t\t// clear all listeners if called without arguments\r\n  \t\t\tdelete this._events;\r\n\r\n  \t\t} else if (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\tthis._off(type, types[type], fn);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tvar removeAll = arguments.length === 1;\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tif (removeAll) {\r\n  \t\t\t\t\tthis._off(types[i]);\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\tthis._off(types[i], fn, context);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// attach listener (without syntactic sugar now)\r\n  \t_on: function (type, fn, context, _once) {\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\t// check if fn already there\r\n  \t\tif (this._listens(type, fn, context) !== false) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (context === this) {\r\n  \t\t\t// Less memory footprint.\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n\r\n  \t\tvar newListener = {fn: fn, ctx: context};\r\n  \t\tif (_once) {\r\n  \t\t\tnewListener.once = true;\r\n  \t\t}\r\n\r\n  \t\tthis._events = this._events || {};\r\n  \t\tthis._events[type] = this._events[type] || [];\r\n  \t\tthis._events[type].push(newListener);\r\n  \t},\r\n\r\n  \t_off: function (type, fn, context) {\r\n  \t\tvar listeners,\r\n  \t\t    i,\r\n  \t\t    len;\r\n\r\n  \t\tif (!this._events) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tlisteners = this._events[type];\r\n  \t\tif (!listeners) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (arguments.length === 1) { // remove all\r\n  \t\t\tif (this._firingCount) {\r\n  \t\t\t\t// Set all removed listeners to noop\r\n  \t\t\t\t// so they are not called if remove happens in fire\r\n  \t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\t\t\tlisteners[i].fn = falseFn;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\t// clear all listeners for a type if function isn't specified\r\n  \t\t\tdelete this._events[type];\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\t// find fn and remove it\r\n  \t\tvar index = this._listens(type, fn, context);\r\n  \t\tif (index !== false) {\r\n  \t\t\tvar listener = listeners[index];\r\n  \t\t\tif (this._firingCount) {\r\n  \t\t\t\t// set the removed listener to noop so that's not called if remove happens in fire\r\n  \t\t\t\tlistener.fn = falseFn;\r\n\r\n  \t\t\t\t/* copy array in case events are being fired */\r\n  \t\t\t\tthis._events[type] = listeners = listeners.slice();\r\n  \t\t\t}\r\n  \t\t\tlisteners.splice(index, 1);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method fire(type: String, data?: Object, propagate?: Boolean): this\r\n  \t// Fires an event of the specified type. You can optionally provide a data\r\n  \t// object  the first argument of the listener function will contain its\r\n  \t// properties. The event can optionally be propagated to event parents.\r\n  \tfire: function (type, data, propagate) {\r\n  \t\tif (!this.listens(type, propagate)) { return this; }\r\n\r\n  \t\tvar event = extend({}, data, {\r\n  \t\t\ttype: type,\r\n  \t\t\ttarget: this,\r\n  \t\t\tsourceTarget: data && data.sourceTarget || this\r\n  \t\t});\r\n\r\n  \t\tif (this._events) {\r\n  \t\t\tvar listeners = this._events[type];\r\n  \t\t\tif (listeners) {\r\n  \t\t\t\tthis._firingCount = (this._firingCount + 1) || 1;\r\n  \t\t\t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\t\t\tvar l = listeners[i];\r\n  \t\t\t\t\t// off overwrites l.fn, so we need to copy fn to a var\r\n  \t\t\t\t\tvar fn = l.fn;\r\n  \t\t\t\t\tif (l.once) {\r\n  \t\t\t\t\t\tthis.off(type, fn, l.ctx);\r\n  \t\t\t\t\t}\r\n  \t\t\t\t\tfn.call(l.ctx || this, event);\r\n  \t\t\t\t}\r\n\r\n  \t\t\t\tthis._firingCount--;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (propagate) {\r\n  \t\t\t// propagate the event to parents (set with addEventParent)\r\n  \t\t\tthis._propagateEvent(event);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method listens(type: String, propagate?: Boolean): Boolean\r\n  \t// @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\r\n  \t// Returns `true` if a particular event type has any listeners attached to it.\r\n  \t// The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\r\n  \tlistens: function (type, fn, context, propagate) {\r\n  \t\tif (typeof type !== 'string') {\r\n  \t\t\tconsole.warn('\"string\" type argument expected');\r\n  \t\t}\r\n\r\n  \t\t// we don't overwrite the input `fn` value, because we need to use it for propagation\r\n  \t\tvar _fn = fn;\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tpropagate = !!fn;\r\n  \t\t\t_fn = undefined;\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n\r\n  \t\tvar listeners = this._events && this._events[type];\r\n  \t\tif (listeners && listeners.length) {\r\n  \t\t\tif (this._listens(type, _fn, context) !== false) {\r\n  \t\t\t\treturn true;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (propagate) {\r\n  \t\t\t// also check parents for listeners if event propagates\r\n  \t\t\tfor (var id in this._eventParents) {\r\n  \t\t\t\tif (this._eventParents[id].listens(type, fn, context, propagate)) { return true; }\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn false;\r\n  \t},\r\n\r\n  \t// returns the index (number) or false\r\n  \t_listens: function (type, fn, context) {\r\n  \t\tif (!this._events) {\r\n  \t\t\treturn false;\r\n  \t\t}\r\n\r\n  \t\tvar listeners = this._events[type] || [];\r\n  \t\tif (!fn) {\r\n  \t\t\treturn !!listeners.length;\r\n  \t\t}\r\n\r\n  \t\tif (context === this) {\r\n  \t\t\t// Less memory footprint.\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n\r\n  \t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\tif (listeners[i].fn === fn && listeners[i].ctx === context) {\r\n  \t\t\t\treturn i;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn false;\r\n\r\n  \t},\r\n\r\n  \t// @method once(): this\r\n  \t// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.\r\n  \tonce: function (types, fn, context) {\r\n\r\n  \t\t// types can be a map of types/handlers\r\n  \t\tif (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\t// we don't process space-separated events here for performance;\r\n  \t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n  \t\t\t\tthis._on(type, types[type], fn, true);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\t// types can be a string of space-separated words\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tthis._on(types[i], fn, context, true);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method addEventParent(obj: Evented): this\r\n  \t// Adds an event parent - an `Evented` that will receive propagated events\r\n  \taddEventParent: function (obj) {\r\n  \t\tthis._eventParents = this._eventParents || {};\r\n  \t\tthis._eventParents[stamp(obj)] = obj;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeEventParent(obj: Evented): this\r\n  \t// Removes an event parent, so it will stop receiving propagated events\r\n  \tremoveEventParent: function (obj) {\r\n  \t\tif (this._eventParents) {\r\n  \t\t\tdelete this._eventParents[stamp(obj)];\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_propagateEvent: function (e) {\r\n  \t\tfor (var id in this._eventParents) {\r\n  \t\t\tthis._eventParents[id].fire(e.type, extend({\r\n  \t\t\t\tlayer: e.target,\r\n  \t\t\t\tpropagatedFrom: e.target\r\n  \t\t\t}, e), true);\r\n  \t\t}\r\n  \t}\r\n  };\r\n\r\n  // aliases; we should ditch those eventually\r\n\r\n  // @method addEventListener(): this\r\n  // Alias to [`on()`](#evented-on)\r\n  Events.addEventListener = Events.on;\r\n\r\n  // @method removeEventListener(): this\r\n  // Alias to [`off()`](#evented-off)\r\n\r\n  // @method clearAllEventListeners(): this\r\n  // Alias to [`off()`](#evented-off)\r\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off;\r\n\r\n  // @method addOneTimeEventListener(): this\r\n  // Alias to [`once()`](#evented-once)\r\n  Events.addOneTimeEventListener = Events.once;\r\n\r\n  // @method fireEvent(): this\r\n  // Alias to [`fire()`](#evented-fire)\r\n  Events.fireEvent = Events.fire;\r\n\r\n  // @method hasEventListeners(): Boolean\r\n  // Alias to [`listens()`](#evented-listens)\r\n  Events.hasEventListeners = Events.listens;\r\n\r\n  var Evented = Class.extend(Events);\n\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function Point(x, y, round) {\r\n  \t// @property x: Number; The `x` coordinate of the point\r\n  \tthis.x = (round ? Math.round(x) : x);\r\n  \t// @property y: Number; The `y` coordinate of the point\r\n  \tthis.y = (round ? Math.round(y) : y);\r\n  }\r\n\r\n  var trunc = Math.trunc || function (v) {\r\n  \treturn v > 0 ? Math.floor(v) : Math.ceil(v);\r\n  };\r\n\r\n  Point.prototype = {\r\n\r\n  \t// @method clone(): Point\r\n  \t// Returns a copy of the current point.\r\n  \tclone: function () {\r\n  \t\treturn new Point(this.x, this.y);\r\n  \t},\r\n\r\n  \t// @method add(otherPoint: Point): Point\r\n  \t// Returns the result of addition of the current and the given points.\r\n  \tadd: function (point) {\r\n  \t\t// non-destructive, returns a new point\r\n  \t\treturn this.clone()._add(toPoint(point));\r\n  \t},\r\n\r\n  \t_add: function (point) {\r\n  \t\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n  \t\tthis.x += point.x;\r\n  \t\tthis.y += point.y;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method subtract(otherPoint: Point): Point\r\n  \t// Returns the result of subtraction of the given point from the current.\r\n  \tsubtract: function (point) {\r\n  \t\treturn this.clone()._subtract(toPoint(point));\r\n  \t},\r\n\r\n  \t_subtract: function (point) {\r\n  \t\tthis.x -= point.x;\r\n  \t\tthis.y -= point.y;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method divideBy(num: Number): Point\r\n  \t// Returns the result of division of the current point by the given number.\r\n  \tdivideBy: function (num) {\r\n  \t\treturn this.clone()._divideBy(num);\r\n  \t},\r\n\r\n  \t_divideBy: function (num) {\r\n  \t\tthis.x /= num;\r\n  \t\tthis.y /= num;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method multiplyBy(num: Number): Point\r\n  \t// Returns the result of multiplication of the current point by the given number.\r\n  \tmultiplyBy: function (num) {\r\n  \t\treturn this.clone()._multiplyBy(num);\r\n  \t},\r\n\r\n  \t_multiplyBy: function (num) {\r\n  \t\tthis.x *= num;\r\n  \t\tthis.y *= num;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method scaleBy(scale: Point): Point\r\n  \t// Multiply each coordinate of the current point by each coordinate of\r\n  \t// `scale`. In linear algebra terms, multiply the point by the\r\n  \t// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\r\n  \t// defined by `scale`.\r\n  \tscaleBy: function (point) {\r\n  \t\treturn new Point(this.x * point.x, this.y * point.y);\r\n  \t},\r\n\r\n  \t// @method unscaleBy(scale: Point): Point\r\n  \t// Inverse of `scaleBy`. Divide each coordinate of the current point by\r\n  \t// each coordinate of `scale`.\r\n  \tunscaleBy: function (point) {\r\n  \t\treturn new Point(this.x / point.x, this.y / point.y);\r\n  \t},\r\n\r\n  \t// @method round(): Point\r\n  \t// Returns a copy of the current point with rounded coordinates.\r\n  \tround: function () {\r\n  \t\treturn this.clone()._round();\r\n  \t},\r\n\r\n  \t_round: function () {\r\n  \t\tthis.x = Math.round(this.x);\r\n  \t\tthis.y = Math.round(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method floor(): Point\r\n  \t// Returns a copy of the current point with floored coordinates (rounded down).\r\n  \tfloor: function () {\r\n  \t\treturn this.clone()._floor();\r\n  \t},\r\n\r\n  \t_floor: function () {\r\n  \t\tthis.x = Math.floor(this.x);\r\n  \t\tthis.y = Math.floor(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method ceil(): Point\r\n  \t// Returns a copy of the current point with ceiled coordinates (rounded up).\r\n  \tceil: function () {\r\n  \t\treturn this.clone()._ceil();\r\n  \t},\r\n\r\n  \t_ceil: function () {\r\n  \t\tthis.x = Math.ceil(this.x);\r\n  \t\tthis.y = Math.ceil(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method trunc(): Point\r\n  \t// Returns a copy of the current point with truncated coordinates (rounded towards zero).\r\n  \ttrunc: function () {\r\n  \t\treturn this.clone()._trunc();\r\n  \t},\r\n\r\n  \t_trunc: function () {\r\n  \t\tthis.x = trunc(this.x);\r\n  \t\tthis.y = trunc(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method distanceTo(otherPoint: Point): Number\r\n  \t// Returns the cartesian distance between the current and the given points.\r\n  \tdistanceTo: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\tvar x = point.x - this.x,\r\n  \t\t    y = point.y - this.y;\r\n\r\n  \t\treturn Math.sqrt(x * x + y * y);\r\n  \t},\r\n\r\n  \t// @method equals(otherPoint: Point): Boolean\r\n  \t// Returns `true` if the given point has the same coordinates.\r\n  \tequals: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\treturn point.x === this.x &&\r\n  \t\t       point.y === this.y;\r\n  \t},\r\n\r\n  \t// @method contains(otherPoint: Point): Boolean\r\n  \t// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n  \tcontains: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n  \t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n  \t},\r\n\r\n  \t// @method toString(): String\r\n  \t// Returns a string representation of the point for debugging purposes.\r\n  \ttoString: function () {\r\n  \t\treturn 'Point(' +\r\n  \t\t        formatNum(this.x) + ', ' +\r\n  \t\t        formatNum(this.y) + ')';\r\n  \t}\r\n  };\r\n\r\n  // @factory L.point(x: Number, y: Number, round?: Boolean)\r\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\r\n\r\n  // @alternative\r\n  // @factory L.point(coords: Number[])\r\n  // Expects an array of the form `[x, y]` instead.\r\n\r\n  // @alternative\r\n  // @factory L.point(coords: Object)\r\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\r\n  function toPoint(x, y, round) {\r\n  \tif (x instanceof Point) {\r\n  \t\treturn x;\r\n  \t}\r\n  \tif (isArray(x)) {\r\n  \t\treturn new Point(x[0], x[1]);\r\n  \t}\r\n  \tif (x === undefined || x === null) {\r\n  \t\treturn x;\r\n  \t}\r\n  \tif (typeof x === 'object' && 'x' in x && 'y' in x) {\r\n  \t\treturn new Point(x.x, x.y);\r\n  \t}\r\n  \treturn new Point(x, y, round);\r\n  }\n\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function Bounds(a, b) {\r\n  \tif (!a) { return; }\r\n\r\n  \tvar points = b ? [a, b] : a;\r\n\r\n  \tfor (var i = 0, len = points.length; i < len; i++) {\r\n  \t\tthis.extend(points[i]);\r\n  \t}\r\n  }\r\n\r\n  Bounds.prototype = {\r\n  \t// @method extend(point: Point): this\r\n  \t// Extends the bounds to contain the given point.\r\n\r\n  \t// @alternative\r\n  \t// @method extend(otherBounds: Bounds): this\r\n  \t// Extend the bounds to contain the given bounds\r\n  \textend: function (obj) {\r\n  \t\tvar min2, max2;\r\n  \t\tif (!obj) { return this; }\r\n\r\n  \t\tif (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {\r\n  \t\t\tmin2 = max2 = toPoint(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toBounds(obj);\r\n  \t\t\tmin2 = obj.min;\r\n  \t\t\tmax2 = obj.max;\r\n\r\n  \t\t\tif (!min2 || !max2) { return this; }\r\n  \t\t}\r\n\r\n  \t\t// @property min: Point\r\n  \t\t// The top left corner of the rectangle.\r\n  \t\t// @property max: Point\r\n  \t\t// The bottom right corner of the rectangle.\r\n  \t\tif (!this.min && !this.max) {\r\n  \t\t\tthis.min = min2.clone();\r\n  \t\t\tthis.max = max2.clone();\r\n  \t\t} else {\r\n  \t\t\tthis.min.x = Math.min(min2.x, this.min.x);\r\n  \t\t\tthis.max.x = Math.max(max2.x, this.max.x);\r\n  \t\t\tthis.min.y = Math.min(min2.y, this.min.y);\r\n  \t\t\tthis.max.y = Math.max(max2.y, this.max.y);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getCenter(round?: Boolean): Point\r\n  \t// Returns the center point of the bounds.\r\n  \tgetCenter: function (round) {\r\n  \t\treturn toPoint(\r\n  \t\t        (this.min.x + this.max.x) / 2,\r\n  \t\t        (this.min.y + this.max.y) / 2, round);\r\n  \t},\r\n\r\n  \t// @method getBottomLeft(): Point\r\n  \t// Returns the bottom-left point of the bounds.\r\n  \tgetBottomLeft: function () {\r\n  \t\treturn toPoint(this.min.x, this.max.y);\r\n  \t},\r\n\r\n  \t// @method getTopRight(): Point\r\n  \t// Returns the top-right point of the bounds.\r\n  \tgetTopRight: function () { // -> Point\r\n  \t\treturn toPoint(this.max.x, this.min.y);\r\n  \t},\r\n\r\n  \t// @method getTopLeft(): Point\r\n  \t// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\r\n  \tgetTopLeft: function () {\r\n  \t\treturn this.min; // left, top\r\n  \t},\r\n\r\n  \t// @method getBottomRight(): Point\r\n  \t// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\r\n  \tgetBottomRight: function () {\r\n  \t\treturn this.max; // right, bottom\r\n  \t},\r\n\r\n  \t// @method getSize(): Point\r\n  \t// Returns the size of the given bounds\r\n  \tgetSize: function () {\r\n  \t\treturn this.max.subtract(this.min);\r\n  \t},\r\n\r\n  \t// @method contains(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle contains the given one.\r\n  \t// @alternative\r\n  \t// @method contains(point: Point): Boolean\r\n  \t// Returns `true` if the rectangle contains the given point.\r\n  \tcontains: function (obj) {\r\n  \t\tvar min, max;\r\n\r\n  \t\tif (typeof obj[0] === 'number' || obj instanceof Point) {\r\n  \t\t\tobj = toPoint(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toBounds(obj);\r\n  \t\t}\r\n\r\n  \t\tif (obj instanceof Bounds) {\r\n  \t\t\tmin = obj.min;\r\n  \t\t\tmax = obj.max;\r\n  \t\t} else {\r\n  \t\t\tmin = max = obj;\r\n  \t\t}\r\n\r\n  \t\treturn (min.x >= this.min.x) &&\r\n  \t\t       (max.x <= this.max.x) &&\r\n  \t\t       (min.y >= this.min.y) &&\r\n  \t\t       (max.y <= this.max.y);\r\n  \t},\r\n\r\n  \t// @method intersects(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle intersects the given bounds. Two bounds\r\n  \t// intersect if they have at least one point in common.\r\n  \tintersects: function (bounds) { // (Bounds) -> Boolean\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\tvar min = this.min,\r\n  \t\t    max = this.max,\r\n  \t\t    min2 = bounds.min,\r\n  \t\t    max2 = bounds.max,\r\n  \t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n  \t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n  \t\treturn xIntersects && yIntersects;\r\n  \t},\r\n\r\n  \t// @method overlaps(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle overlaps the given bounds. Two bounds\r\n  \t// overlap if their intersection is an area.\r\n  \toverlaps: function (bounds) { // (Bounds) -> Boolean\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\tvar min = this.min,\r\n  \t\t    max = this.max,\r\n  \t\t    min2 = bounds.min,\r\n  \t\t    max2 = bounds.max,\r\n  \t\t    xOverlaps = (max2.x > min.x) && (min2.x < max.x),\r\n  \t\t    yOverlaps = (max2.y > min.y) && (min2.y < max.y);\r\n\r\n  \t\treturn xOverlaps && yOverlaps;\r\n  \t},\r\n\r\n  \t// @method isValid(): Boolean\r\n  \t// Returns `true` if the bounds are properly initialized.\r\n  \tisValid: function () {\r\n  \t\treturn !!(this.min && this.max);\r\n  \t},\r\n\r\n\r\n  \t// @method pad(bufferRatio: Number): Bounds\r\n  \t// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\r\n  \t// For example, a ratio of 0.5 extends the bounds by 50% in each direction.\r\n  \t// Negative values will retract the bounds.\r\n  \tpad: function (bufferRatio) {\r\n  \t\tvar min = this.min,\r\n  \t\tmax = this.max,\r\n  \t\theightBuffer = Math.abs(min.x - max.x) * bufferRatio,\r\n  \t\twidthBuffer = Math.abs(min.y - max.y) * bufferRatio;\r\n\r\n\r\n  \t\treturn toBounds(\r\n  \t\t\ttoPoint(min.x - heightBuffer, min.y - widthBuffer),\r\n  \t\t\ttoPoint(max.x + heightBuffer, max.y + widthBuffer));\r\n  \t},\r\n\r\n\r\n  \t// @method equals(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle is equivalent to the given bounds.\r\n  \tequals: function (bounds) {\r\n  \t\tif (!bounds) { return false; }\r\n\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\treturn this.min.equals(bounds.getTopLeft()) &&\r\n  \t\t\tthis.max.equals(bounds.getBottomRight());\r\n  \t},\r\n  };\r\n\r\n\r\n  // @factory L.bounds(corner1: Point, corner2: Point)\r\n  // Creates a Bounds object from two corners coordinate pairs.\r\n  // @alternative\r\n  // @factory L.bounds(points: Point[])\r\n  // Creates a Bounds object from the given array of points.\r\n  function toBounds(a, b) {\r\n  \tif (!a || a instanceof Bounds) {\r\n  \t\treturn a;\r\n  \t}\r\n  \treturn new Bounds(a, b);\r\n  }\n\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])\r\n  \tif (!corner1) { return; }\r\n\r\n  \tvar latlngs = corner2 ? [corner1, corner2] : corner1;\r\n\r\n  \tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n  \t\tthis.extend(latlngs[i]);\r\n  \t}\r\n  }\r\n\r\n  LatLngBounds.prototype = {\r\n\r\n  \t// @method extend(latlng: LatLng): this\r\n  \t// Extend the bounds to contain the given point\r\n\r\n  \t// @alternative\r\n  \t// @method extend(otherBounds: LatLngBounds): this\r\n  \t// Extend the bounds to contain the given bounds\r\n  \textend: function (obj) {\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2, ne2;\r\n\r\n  \t\tif (obj instanceof LatLng) {\r\n  \t\t\tsw2 = obj;\r\n  \t\t\tne2 = obj;\r\n\r\n  \t\t} else if (obj instanceof LatLngBounds) {\r\n  \t\t\tsw2 = obj._southWest;\r\n  \t\t\tne2 = obj._northEast;\r\n\r\n  \t\t\tif (!sw2 || !ne2) { return this; }\r\n\r\n  \t\t} else {\r\n  \t\t\treturn obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\r\n  \t\t}\r\n\r\n  \t\tif (!sw && !ne) {\r\n  \t\t\tthis._southWest = new LatLng(sw2.lat, sw2.lng);\r\n  \t\t\tthis._northEast = new LatLng(ne2.lat, ne2.lng);\r\n  \t\t} else {\r\n  \t\t\tsw.lat = Math.min(sw2.lat, sw.lat);\r\n  \t\t\tsw.lng = Math.min(sw2.lng, sw.lng);\r\n  \t\t\tne.lat = Math.max(ne2.lat, ne.lat);\r\n  \t\t\tne.lng = Math.max(ne2.lng, ne.lng);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method pad(bufferRatio: Number): LatLngBounds\r\n  \t// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\r\n  \t// For example, a ratio of 0.5 extends the bounds by 50% in each direction.\r\n  \t// Negative values will retract the bounds.\r\n  \tpad: function (bufferRatio) {\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n  \t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n  \t\treturn new LatLngBounds(\r\n  \t\t        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n  \t\t        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n  \t},\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the center point of the bounds.\r\n  \tgetCenter: function () {\r\n  \t\treturn new LatLng(\r\n  \t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n  \t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n  \t},\r\n\r\n  \t// @method getSouthWest(): LatLng\r\n  \t// Returns the south-west point of the bounds.\r\n  \tgetSouthWest: function () {\r\n  \t\treturn this._southWest;\r\n  \t},\r\n\r\n  \t// @method getNorthEast(): LatLng\r\n  \t// Returns the north-east point of the bounds.\r\n  \tgetNorthEast: function () {\r\n  \t\treturn this._northEast;\r\n  \t},\r\n\r\n  \t// @method getNorthWest(): LatLng\r\n  \t// Returns the north-west point of the bounds.\r\n  \tgetNorthWest: function () {\r\n  \t\treturn new LatLng(this.getNorth(), this.getWest());\r\n  \t},\r\n\r\n  \t// @method getSouthEast(): LatLng\r\n  \t// Returns the south-east point of the bounds.\r\n  \tgetSouthEast: function () {\r\n  \t\treturn new LatLng(this.getSouth(), this.getEast());\r\n  \t},\r\n\r\n  \t// @method getWest(): Number\r\n  \t// Returns the west longitude of the bounds\r\n  \tgetWest: function () {\r\n  \t\treturn this._southWest.lng;\r\n  \t},\r\n\r\n  \t// @method getSouth(): Number\r\n  \t// Returns the south latitude of the bounds\r\n  \tgetSouth: function () {\r\n  \t\treturn this._southWest.lat;\r\n  \t},\r\n\r\n  \t// @method getEast(): Number\r\n  \t// Returns the east longitude of the bounds\r\n  \tgetEast: function () {\r\n  \t\treturn this._northEast.lng;\r\n  \t},\r\n\r\n  \t// @method getNorth(): Number\r\n  \t// Returns the north latitude of the bounds\r\n  \tgetNorth: function () {\r\n  \t\treturn this._northEast.lat;\r\n  \t},\r\n\r\n  \t// @method contains(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle contains the given one.\r\n\r\n  \t// @alternative\r\n  \t// @method contains (latlng: LatLng): Boolean\r\n  \t// Returns `true` if the rectangle contains the given point.\r\n  \tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n  \t\tif (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\r\n  \t\t\tobj = toLatLng(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toLatLngBounds(obj);\r\n  \t\t}\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2, ne2;\r\n\r\n  \t\tif (obj instanceof LatLngBounds) {\r\n  \t\t\tsw2 = obj.getSouthWest();\r\n  \t\t\tne2 = obj.getNorthEast();\r\n  \t\t} else {\r\n  \t\t\tsw2 = ne2 = obj;\r\n  \t\t}\r\n\r\n  \t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n  \t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n  \t},\r\n\r\n  \t// @method intersects(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\r\n  \tintersects: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2 = bounds.getSouthWest(),\r\n  \t\t    ne2 = bounds.getNorthEast(),\r\n\r\n  \t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n  \t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n  \t\treturn latIntersects && lngIntersects;\r\n  \t},\r\n\r\n  \t// @method overlaps(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\r\n  \toverlaps: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2 = bounds.getSouthWest(),\r\n  \t\t    ne2 = bounds.getNorthEast(),\r\n\r\n  \t\t    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),\r\n  \t\t    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);\r\n\r\n  \t\treturn latOverlaps && lngOverlaps;\r\n  \t},\r\n\r\n  \t// @method toBBoxString(): String\r\n  \t// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\r\n  \ttoBBoxString: function () {\r\n  \t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n  \t},\r\n\r\n  \t// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\r\n  \t// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\r\n  \tequals: function (bounds, maxMargin) {\r\n  \t\tif (!bounds) { return false; }\r\n\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\treturn this._southWest.equals(bounds.getSouthWest(), maxMargin) &&\r\n  \t\t       this._northEast.equals(bounds.getNorthEast(), maxMargin);\r\n  \t},\r\n\r\n  \t// @method isValid(): Boolean\r\n  \t// Returns `true` if the bounds are properly initialized.\r\n  \tisValid: function () {\r\n  \t\treturn !!(this._southWest && this._northEast);\r\n  \t}\r\n  };\r\n\r\n  // TODO International date line?\r\n\r\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\r\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\r\n\r\n  // @alternative\r\n  // @factory L.latLngBounds(latlngs: LatLng[])\r\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\r\n  function toLatLngBounds(a, b) {\r\n  \tif (a instanceof LatLngBounds) {\r\n  \t\treturn a;\r\n  \t}\r\n  \treturn new LatLngBounds(a, b);\r\n  }\n\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function LatLng(lat, lng, alt) {\r\n  \tif (isNaN(lat) || isNaN(lng)) {\r\n  \t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n  \t}\r\n\r\n  \t// @property lat: Number\r\n  \t// Latitude in degrees\r\n  \tthis.lat = +lat;\r\n\r\n  \t// @property lng: Number\r\n  \t// Longitude in degrees\r\n  \tthis.lng = +lng;\r\n\r\n  \t// @property alt: Number\r\n  \t// Altitude in meters (optional)\r\n  \tif (alt !== undefined) {\r\n  \t\tthis.alt = +alt;\r\n  \t}\r\n  }\r\n\r\n  LatLng.prototype = {\r\n  \t// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\r\n  \t// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\r\n  \tequals: function (obj, maxMargin) {\r\n  \t\tif (!obj) { return false; }\r\n\r\n  \t\tobj = toLatLng(obj);\r\n\r\n  \t\tvar margin = Math.max(\r\n  \t\t        Math.abs(this.lat - obj.lat),\r\n  \t\t        Math.abs(this.lng - obj.lng));\r\n\r\n  \t\treturn margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\r\n  \t},\r\n\r\n  \t// @method toString(): String\r\n  \t// Returns a string representation of the point (for debugging purposes).\r\n  \ttoString: function (precision) {\r\n  \t\treturn 'LatLng(' +\r\n  \t\t        formatNum(this.lat, precision) + ', ' +\r\n  \t\t        formatNum(this.lng, precision) + ')';\r\n  \t},\r\n\r\n  \t// @method distanceTo(otherLatLng: LatLng): Number\r\n  \t// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\r\n  \tdistanceTo: function (other) {\r\n  \t\treturn Earth.distance(this, toLatLng(other));\r\n  \t},\r\n\r\n  \t// @method wrap(): LatLng\r\n  \t// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\r\n  \twrap: function () {\r\n  \t\treturn Earth.wrapLatLng(this);\r\n  \t},\r\n\r\n  \t// @method toBounds(sizeInMeters: Number): LatLngBounds\r\n  \t// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\r\n  \ttoBounds: function (sizeInMeters) {\r\n  \t\tvar latAccuracy = 180 * sizeInMeters / 40075017,\r\n  \t\t    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\r\n\r\n  \t\treturn toLatLngBounds(\r\n  \t\t        [this.lat - latAccuracy, this.lng - lngAccuracy],\r\n  \t\t        [this.lat + latAccuracy, this.lng + lngAccuracy]);\r\n  \t},\r\n\r\n  \tclone: function () {\r\n  \t\treturn new LatLng(this.lat, this.lng, this.alt);\r\n  \t}\r\n  };\r\n\r\n\r\n\r\n  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\r\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\r\n\r\n  // @alternative\r\n  // @factory L.latLng(coords: Array): LatLng\r\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\r\n\r\n  // @alternative\r\n  // @factory L.latLng(coords: Object): LatLng\r\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\r\n\r\n  function toLatLng(a, b, c) {\r\n  \tif (a instanceof LatLng) {\r\n  \t\treturn a;\r\n  \t}\r\n  \tif (isArray(a) && typeof a[0] !== 'object') {\r\n  \t\tif (a.length === 3) {\r\n  \t\t\treturn new LatLng(a[0], a[1], a[2]);\r\n  \t\t}\r\n  \t\tif (a.length === 2) {\r\n  \t\t\treturn new LatLng(a[0], a[1]);\r\n  \t\t}\r\n  \t\treturn null;\r\n  \t}\r\n  \tif (a === undefined || a === null) {\r\n  \t\treturn a;\r\n  \t}\r\n  \tif (typeof a === 'object' && 'lat' in a) {\r\n  \t\treturn new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\r\n  \t}\r\n  \tif (b === undefined) {\r\n  \t\treturn null;\r\n  \t}\r\n  \treturn new LatLng(a, b, c);\r\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\r\n\r\n  var CRS = {\r\n  \t// @method latLngToPoint(latlng: LatLng, zoom: Number): Point\r\n  \t// Projects geographical coordinates into pixel coordinates for a given zoom.\r\n  \tlatLngToPoint: function (latlng, zoom) {\r\n  \t\tvar projectedPoint = this.projection.project(latlng),\r\n  \t\t    scale = this.scale(zoom);\r\n\r\n  \t\treturn this.transformation._transform(projectedPoint, scale);\r\n  \t},\r\n\r\n  \t// @method pointToLatLng(point: Point, zoom: Number): LatLng\r\n  \t// The inverse of `latLngToPoint`. Projects pixel coordinates on a given\r\n  \t// zoom into geographical coordinates.\r\n  \tpointToLatLng: function (point, zoom) {\r\n  \t\tvar scale = this.scale(zoom),\r\n  \t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n  \t\treturn this.projection.unproject(untransformedPoint);\r\n  \t},\r\n\r\n  \t// @method project(latlng: LatLng): Point\r\n  \t// Projects geographical coordinates into coordinates in units accepted for\r\n  \t// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\r\n  \tproject: function (latlng) {\r\n  \t\treturn this.projection.project(latlng);\r\n  \t},\r\n\r\n  \t// @method unproject(point: Point): LatLng\r\n  \t// Given a projected coordinate returns the corresponding LatLng.\r\n  \t// The inverse of `project`.\r\n  \tunproject: function (point) {\r\n  \t\treturn this.projection.unproject(point);\r\n  \t},\r\n\r\n  \t// @method scale(zoom: Number): Number\r\n  \t// Returns the scale used when transforming projected coordinates into\r\n  \t// pixel coordinates for a particular zoom. For example, it returns\r\n  \t// `256 * 2^zoom` for Mercator-based CRS.\r\n  \tscale: function (zoom) {\r\n  \t\treturn 256 * Math.pow(2, zoom);\r\n  \t},\r\n\r\n  \t// @method zoom(scale: Number): Number\r\n  \t// Inverse of `scale()`, returns the zoom level corresponding to a scale\r\n  \t// factor of `scale`.\r\n  \tzoom: function (scale) {\r\n  \t\treturn Math.log(scale / 256) / Math.LN2;\r\n  \t},\r\n\r\n  \t// @method getProjectedBounds(zoom: Number): Bounds\r\n  \t// Returns the projection's bounds scaled and transformed for the provided `zoom`.\r\n  \tgetProjectedBounds: function (zoom) {\r\n  \t\tif (this.infinite) { return null; }\r\n\r\n  \t\tvar b = this.projection.bounds,\r\n  \t\t    s = this.scale(zoom),\r\n  \t\t    min = this.transformation.transform(b.min, s),\r\n  \t\t    max = this.transformation.transform(b.max, s);\r\n\r\n  \t\treturn new Bounds(min, max);\r\n  \t},\r\n\r\n  \t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n  \t// Returns the distance between two geographical coordinates.\r\n\r\n  \t// @property code: String\r\n  \t// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\r\n  \t//\r\n  \t// @property wrapLng: Number[]\r\n  \t// An array of two numbers defining whether the longitude (horizontal) coordinate\r\n  \t// axis wraps around a given range and how. Defaults to `[-180, 180]` in most\r\n  \t// geographical CRSs. If `undefined`, the longitude axis does not wrap around.\r\n  \t//\r\n  \t// @property wrapLat: Number[]\r\n  \t// Like `wrapLng`, but for the latitude (vertical) axis.\r\n\r\n  \t// wrapLng: [min, max],\r\n  \t// wrapLat: [min, max],\r\n\r\n  \t// @property infinite: Boolean\r\n  \t// If true, the coordinate space will be unbounded (infinite in both axes)\r\n  \tinfinite: false,\r\n\r\n  \t// @method wrapLatLng(latlng: LatLng): LatLng\r\n  \t// Returns a `LatLng` where lat and lng has been wrapped according to the\r\n  \t// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\r\n  \twrapLatLng: function (latlng) {\r\n  \t\tvar lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\r\n  \t\t    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\r\n  \t\t    alt = latlng.alt;\r\n\r\n  \t\treturn new LatLng(lat, lng, alt);\r\n  \t},\r\n\r\n  \t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n  \t// Returns a `LatLngBounds` with the same size as the given one, ensuring\r\n  \t// that its center is within the CRS's bounds.\r\n  \t// Only accepts actual `L.LatLngBounds` instances, not arrays.\r\n  \twrapLatLngBounds: function (bounds) {\r\n  \t\tvar center = bounds.getCenter(),\r\n  \t\t    newCenter = this.wrapLatLng(center),\r\n  \t\t    latShift = center.lat - newCenter.lat,\r\n  \t\t    lngShift = center.lng - newCenter.lng;\r\n\r\n  \t\tif (latShift === 0 && lngShift === 0) {\r\n  \t\t\treturn bounds;\r\n  \t\t}\r\n\r\n  \t\tvar sw = bounds.getSouthWest(),\r\n  \t\t    ne = bounds.getNorthEast(),\r\n  \t\t    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\r\n  \t\t    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\r\n\r\n  \t\treturn new LatLngBounds(newSw, newNe);\r\n  \t}\r\n  };\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n  \twrapLng: [-180, 180],\n\n  \t// Mean Earth Radius, as recommended for use by\n  \t// the International Union of Geodesy and Geophysics,\n  \t// see https://rosettacode.org/wiki/Haversine_formula\n  \tR: 6371000,\n\n  \t// distance between two geographical points using spherical law of cosines approximation\n  \tdistance: function (latlng1, latlng2) {\n  \t\tvar rad = Math.PI / 180,\n  \t\t    lat1 = latlng1.lat * rad,\n  \t\t    lat2 = latlng2.lat * rad,\n  \t\t    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n  \t\t    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n  \t\t    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n  \t\t    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  \t\treturn this.R * c;\n  \t}\n  });\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection  the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\r\n\r\n  var earthRadius = 6378137;\r\n\r\n  var SphericalMercator = {\r\n\r\n  \tR: earthRadius,\r\n  \tMAX_LATITUDE: 85.0511287798,\r\n\r\n  \tproject: function (latlng) {\r\n  \t\tvar d = Math.PI / 180,\r\n  \t\t    max = this.MAX_LATITUDE,\r\n  \t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n  \t\t    sin = Math.sin(lat * d);\r\n\r\n  \t\treturn new Point(\r\n  \t\t\tthis.R * latlng.lng * d,\r\n  \t\t\tthis.R * Math.log((1 + sin) / (1 - sin)) / 2);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\tvar d = 180 / Math.PI;\r\n\r\n  \t\treturn new LatLng(\r\n  \t\t\t(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,\r\n  \t\t\tpoint.x * d / this.R);\r\n  \t},\r\n\r\n  \tbounds: (function () {\r\n  \t\tvar d = earthRadius * Math.PI;\r\n  \t\treturn new Bounds([-d, -d], [d, d]);\r\n  \t})()\r\n  };\n\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\r\n\r\n\r\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\r\n  // Creates a `Transformation` object with the given coefficients.\r\n  function Transformation(a, b, c, d) {\r\n  \tif (isArray(a)) {\r\n  \t\t// use array properties\r\n  \t\tthis._a = a[0];\r\n  \t\tthis._b = a[1];\r\n  \t\tthis._c = a[2];\r\n  \t\tthis._d = a[3];\r\n  \t\treturn;\r\n  \t}\r\n  \tthis._a = a;\r\n  \tthis._b = b;\r\n  \tthis._c = c;\r\n  \tthis._d = d;\r\n  }\r\n\r\n  Transformation.prototype = {\r\n  \t// @method transform(point: Point, scale?: Number): Point\r\n  \t// Returns a transformed point, optionally multiplied by the given scale.\r\n  \t// Only accepts actual `L.Point` instances, not arrays.\r\n  \ttransform: function (point, scale) { // (Point, Number) -> Point\r\n  \t\treturn this._transform(point.clone(), scale);\r\n  \t},\r\n\r\n  \t// destructive transform (faster)\r\n  \t_transform: function (point, scale) {\r\n  \t\tscale = scale || 1;\r\n  \t\tpoint.x = scale * (this._a * point.x + this._b);\r\n  \t\tpoint.y = scale * (this._c * point.y + this._d);\r\n  \t\treturn point;\r\n  \t},\r\n\r\n  \t// @method untransform(point: Point, scale?: Number): Point\r\n  \t// Returns the reverse transformation of the given point, optionally divided\r\n  \t// by the given scale. Only accepts actual `L.Point` instances, not arrays.\r\n  \tuntransform: function (point, scale) {\r\n  \t\tscale = scale || 1;\r\n  \t\treturn new Point(\r\n  \t\t        (point.x / scale - this._b) / this._a,\r\n  \t\t        (point.y / scale - this._d) / this._c);\r\n  \t}\r\n  };\r\n\r\n  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n\r\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n  // Instantiates a Transformation object with the given coefficients.\r\n\r\n  // @alternative\r\n  // @factory L.transformation(coefficients: Array): Transformation\r\n  // Expects an coefficients array of the form\r\n  // `[a: Number, b: Number, c: Number, d: Number]`.\r\n\r\n  function toTransformation(a, b, c, d) {\r\n  \treturn new Transformation(a, b, c, d);\r\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\r\n\r\n  var EPSG3857 = extend({}, Earth, {\r\n  \tcode: 'EPSG:3857',\r\n  \tprojection: SphericalMercator,\r\n\r\n  \ttransformation: (function () {\r\n  \t\tvar scale = 0.5 / (Math.PI * SphericalMercator.R);\r\n  \t\treturn toTransformation(scale, 0.5, -scale, 0.5);\r\n  \t}())\r\n  });\r\n\r\n  var EPSG900913 = extend({}, EPSG3857, {\r\n  \tcode: 'EPSG:900913'\r\n  });\n\n  // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n  function svgCreate(name) {\n  \treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n  function pointsToPath(rings, closed) {\n  \tvar str = '',\n  \ti, j, len, len2, points, p;\n\n  \tfor (i = 0, len = rings.length; i < len; i++) {\n  \t\tpoints = rings[i];\n\n  \t\tfor (j = 0, len2 = points.length; j < len2; j++) {\n  \t\t\tp = points[j];\n  \t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n  \t\t}\n\n  \t\t// closes the ring for polygons; \"x\" is VML syntax\n  \t\tstr += closed ? (Browser.svg ? 'z' : 'x') : '';\n  \t}\n\n  \t// SVG complains about empty path strings\n  \treturn str || 'M0 0';\n  }\n\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\r\n\r\n  var style = document.documentElement.style;\r\n\r\n  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\r\n  var ie = 'ActiveXObject' in window;\r\n\r\n  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\r\n  var ielt9 = ie && !document.addEventListener;\r\n\r\n  // @property edge: Boolean; `true` for the Edge web browser.\r\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);\r\n\r\n  // @property webkit: Boolean;\r\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\r\n  var webkit = userAgentContains('webkit');\r\n\r\n  // @property android: Boolean\r\n  // **Deprecated.** `true` for any browser running on an Android platform.\r\n  var android = userAgentContains('android');\r\n\r\n  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\r\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\r\n\r\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\r\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\r\n  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\r\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\r\n\r\n  // @property opera: Boolean; `true` for the Opera browser\r\n  var opera = !!window.opera;\r\n\r\n  // @property chrome: Boolean; `true` for the Chrome browser.\r\n  var chrome = !edge && userAgentContains('chrome');\r\n\r\n  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\r\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\r\n\r\n  // @property safari: Boolean; `true` for the Safari browser.\r\n  var safari = !chrome && userAgentContains('safari');\r\n\r\n  var phantom = userAgentContains('phantom');\r\n\r\n  // @property opera12: Boolean\r\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\r\n  var opera12 = 'OTransition' in style;\r\n\r\n  // @property win: Boolean; `true` when the browser is running in a Windows platform\r\n  var win = navigator.platform.indexOf('Win') === 0;\r\n\r\n  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\r\n  var ie3d = ie && ('transition' in style);\r\n\r\n  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\r\n  var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;\r\n\r\n  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\r\n  var gecko3d = 'MozPerspective' in style;\r\n\r\n  // @property any3d: Boolean\r\n  // `true` for all browsers supporting CSS transforms.\r\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\r\n\r\n  // @property mobile: Boolean; `true` for all browsers running in a mobile device.\r\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');\r\n\r\n  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\r\n  var mobileWebkit = mobile && webkit;\r\n\r\n  // @property mobileWebkit3d: Boolean\r\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\r\n  var mobileWebkit3d = mobile && webkit3d;\r\n\r\n  // @property msPointer: Boolean\r\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\r\n  var msPointer = !window.PointerEvent && window.MSPointerEvent;\r\n\r\n  // @property pointer: Boolean\r\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\r\n  var pointer = !!(window.PointerEvent || msPointer);\r\n\r\n  // @property touchNative: Boolean\r\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\r\n  // **This does not necessarily mean** that the browser is running in a computer with\r\n  // a touchscreen, it only means that the browser is capable of understanding\r\n  // touch events.\r\n  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;\r\n\r\n  // @property touch: Boolean\r\n  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\r\n  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\r\n  var touch = !window.L_NO_TOUCH && (touchNative || pointer);\r\n\r\n  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\r\n  var mobileOpera = mobile && opera;\r\n\r\n  // @property mobileGecko: Boolean\r\n  // `true` for gecko-based browsers running in a mobile device.\r\n  var mobileGecko = mobile && gecko;\r\n\r\n  // @property retina: Boolean\r\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\r\n  var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;\r\n\r\n  // @property passiveEvents: Boolean\r\n  // `true` for browsers that support passive events.\r\n  var passiveEvents = (function () {\r\n  \tvar supportsPassiveOption = false;\r\n  \ttry {\r\n  \t\tvar opts = Object.defineProperty({}, 'passive', {\r\n  \t\t\tget: function () { // eslint-disable-line getter-return\r\n  \t\t\t\tsupportsPassiveOption = true;\r\n  \t\t\t}\r\n  \t\t});\r\n  \t\twindow.addEventListener('testPassiveEventSupport', falseFn, opts);\r\n  \t\twindow.removeEventListener('testPassiveEventSupport', falseFn, opts);\r\n  \t} catch (e) {\r\n  \t\t// Errors can safely be ignored since this is only a browser support test.\r\n  \t}\r\n  \treturn supportsPassiveOption;\r\n  }());\r\n\r\n  // @property canvas: Boolean\r\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\r\n  var canvas$1 = (function () {\r\n  \treturn !!document.createElement('canvas').getContext;\r\n  }());\r\n\r\n  // @property svg: Boolean\r\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\r\n  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);\r\n\r\n  var inlineSvg = !!svg$1 && (function () {\r\n  \tvar div = document.createElement('div');\r\n  \tdiv.innerHTML = '<svg/>';\r\n  \treturn (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';\r\n  })();\r\n\r\n  // @property vml: Boolean\r\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\r\n  var vml = !svg$1 && (function () {\r\n  \ttry {\r\n  \t\tvar div = document.createElement('div');\r\n  \t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n  \t\tvar shape = div.firstChild;\r\n  \t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n  \t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n  \t} catch (e) {\r\n  \t\treturn false;\r\n  \t}\r\n  }());\r\n\r\n\r\n  // @property mac: Boolean; `true` when the browser is running in a Mac platform\r\n  var mac = navigator.platform.indexOf('Mac') === 0;\r\n\r\n  // @property mac: Boolean; `true` when the browser is running in a Linux platform\r\n  var linux = navigator.platform.indexOf('Linux') === 0;\r\n\r\n  function userAgentContains(str) {\r\n  \treturn navigator.userAgent.toLowerCase().indexOf(str) >= 0;\r\n  }\r\n\r\n\r\n  var Browser = {\r\n  \tie: ie,\r\n  \tielt9: ielt9,\r\n  \tedge: edge,\r\n  \twebkit: webkit,\r\n  \tandroid: android,\r\n  \tandroid23: android23,\r\n  \tandroidStock: androidStock,\r\n  \topera: opera,\r\n  \tchrome: chrome,\r\n  \tgecko: gecko,\r\n  \tsafari: safari,\r\n  \tphantom: phantom,\r\n  \topera12: opera12,\r\n  \twin: win,\r\n  \tie3d: ie3d,\r\n  \twebkit3d: webkit3d,\r\n  \tgecko3d: gecko3d,\r\n  \tany3d: any3d,\r\n  \tmobile: mobile,\r\n  \tmobileWebkit: mobileWebkit,\r\n  \tmobileWebkit3d: mobileWebkit3d,\r\n  \tmsPointer: msPointer,\r\n  \tpointer: pointer,\r\n  \ttouch: touch,\r\n  \ttouchNative: touchNative,\r\n  \tmobileOpera: mobileOpera,\r\n  \tmobileGecko: mobileGecko,\r\n  \tretina: retina,\r\n  \tpassiveEvents: passiveEvents,\r\n  \tcanvas: canvas$1,\r\n  \tsvg: svg$1,\r\n  \tvml: vml,\r\n  \tinlineSvg: inlineSvg,\r\n  \tmac: mac,\r\n  \tlinux: linux\r\n  };\n\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN =   Browser.msPointer ? 'MSPointerDown'   : 'pointerdown';\n  var POINTER_MOVE =   Browser.msPointer ? 'MSPointerMove'   : 'pointermove';\n  var POINTER_UP =     Browser.msPointer ? 'MSPointerUp'     : 'pointerup';\n  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var pEvent = {\n  \ttouchstart  : POINTER_DOWN,\n  \ttouchmove   : POINTER_MOVE,\n  \ttouchend    : POINTER_UP,\n  \ttouchcancel : POINTER_CANCEL\n  };\n  var handle = {\n  \ttouchstart  : _onPointerStart,\n  \ttouchmove   : _handlePointer,\n  \ttouchend    : _handlePointer,\n  \ttouchcancel : _handlePointer\n  };\n  var _pointers = {};\n  var _pointerDocListener = false;\n\n  // Provides a touch events wrapper for (ms)pointer events.\n  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler) {\n  \tif (type === 'touchstart') {\n  \t\t_addPointerDocListener();\n  \t}\n  \tif (!handle[type]) {\n  \t\tconsole.warn('wrong event specified:', type);\n  \t\treturn falseFn;\n  \t}\n  \thandler = handle[type].bind(this, handler);\n  \tobj.addEventListener(pEvent[type], handler, false);\n  \treturn handler;\n  }\n\n  function removePointerListener(obj, type, handler) {\n  \tif (!pEvent[type]) {\n  \t\tconsole.warn('wrong event specified:', type);\n  \t\treturn;\n  \t}\n  \tobj.removeEventListener(pEvent[type], handler, false);\n  }\n\n  function _globalPointerDown(e) {\n  \t_pointers[e.pointerId] = e;\n  }\n\n  function _globalPointerMove(e) {\n  \tif (_pointers[e.pointerId]) {\n  \t\t_pointers[e.pointerId] = e;\n  \t}\n  }\n\n  function _globalPointerUp(e) {\n  \tdelete _pointers[e.pointerId];\n  }\n\n  function _addPointerDocListener() {\n  \t// need to keep track of what pointers and how many are active to provide e.touches emulation\n  \tif (!_pointerDocListener) {\n  \t\t// we listen document as any drags that end by moving the touch off the screen get fired there\n  \t\tdocument.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n  \t\tdocument.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n  \t\tdocument.addEventListener(POINTER_UP, _globalPointerUp, true);\n  \t\tdocument.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n\n  \t\t_pointerDocListener = true;\n  \t}\n  }\n\n  function _handlePointer(handler, e) {\n  \tif (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) { return; }\n\n  \te.touches = [];\n  \tfor (var i in _pointers) {\n  \t\te.touches.push(_pointers[i]);\n  \t}\n  \te.changedTouches = [e];\n\n  \thandler(e);\n  }\n\n  function _onPointerStart(handler, e) {\n  \t// IE10 specific: MsTouch needs preventDefault. See #2000\n  \tif (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n  \t\tpreventDefault(e);\n  \t}\n  \t_handlePointer(handler, e);\n  }\n\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */\r\n\r\n  function makeDblclick(event) {\r\n  \t// in modern browsers `type` cannot be just overridden:\r\n  \t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\r\n  \tvar newEvent = {},\r\n  \t    prop, i;\r\n  \tfor (i in event) {\r\n  \t\tprop = event[i];\r\n  \t\tnewEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\r\n  \t}\r\n  \tevent = newEvent;\r\n  \tnewEvent.type = 'dblclick';\r\n  \tnewEvent.detail = 2;\r\n  \tnewEvent.isTrusted = false;\r\n  \tnewEvent._simulated = true; // for debug purposes\r\n  \treturn newEvent;\r\n  }\r\n\r\n  var delay = 200;\r\n  function addDoubleTapListener(obj, handler) {\r\n  \t// Most browsers handle double tap natively\r\n  \tobj.addEventListener('dblclick', handler);\r\n\r\n  \t// On some platforms the browser doesn't fire native dblclicks for touch events.\r\n  \t// It seems that in all such cases `detail` property of `click` event is always `1`.\r\n  \t// So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\r\n  \tvar last = 0,\r\n  \t    detail;\r\n  \tfunction simDblclick(e) {\r\n  \t\tif (e.detail !== 1) {\r\n  \t\t\tdetail = e.detail; // keep in sync to avoid false dblclick in some cases\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (e.pointerType === 'mouse' ||\r\n  \t\t\t(e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents)) {\r\n\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\t// When clicking on an <input>, the browser generates a click on its\r\n  \t\t// <label> (and vice versa) triggering two clicks in quick succession.\r\n  \t\t// This ignores clicks on elements which are a label with a 'for'\r\n  \t\t// attribute (or children of such a label), but not children of\r\n  \t\t// a <input>.\r\n  \t\tvar path = getPropagationPath(e);\r\n  \t\tif (path.some(function (el) {\r\n  \t\t\treturn el instanceof HTMLLabelElement && el.attributes.for;\r\n  \t\t}) &&\r\n  \t\t\t!path.some(function (el) {\r\n  \t\t\t\treturn (\r\n  \t\t\t\t\tel instanceof HTMLInputElement ||\r\n  \t\t\t\t\tel instanceof HTMLSelectElement\r\n  \t\t\t\t);\r\n  \t\t\t})\r\n  \t\t) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar now = Date.now();\r\n  \t\tif (now - last <= delay) {\r\n  \t\t\tdetail++;\r\n  \t\t\tif (detail === 2) {\r\n  \t\t\t\thandler(makeDblclick(e));\r\n  \t\t\t}\r\n  \t\t} else {\r\n  \t\t\tdetail = 1;\r\n  \t\t}\r\n  \t\tlast = now;\r\n  \t}\r\n\r\n  \tobj.addEventListener('click', simDblclick);\r\n\r\n  \treturn {\r\n  \t\tdblclick: handler,\r\n  \t\tsimDblclick: simDblclick\r\n  \t};\r\n  }\r\n\r\n  function removeDoubleTapListener(obj, handlers) {\r\n  \tobj.removeEventListener('dblclick', handlers.dblclick);\r\n  \tobj.removeEventListener('click', handlers.simDblclick);\r\n  }\n\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\r\n\r\n\r\n  // @property TRANSFORM: String\r\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\r\n  var TRANSFORM = testProp(\r\n  \t['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\n  // @property TRANSITION: String\r\n  // Vendor-prefixed transition style name.\r\n  var TRANSITION = testProp(\r\n  \t['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\n  // @property TRANSITION_END: String\r\n  // Vendor-prefixed transitionend event name.\r\n  var TRANSITION_END =\r\n  \tTRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\r\n\r\n\r\n  // @function get(id: String|HTMLElement): HTMLElement\r\n  // Returns an element given its DOM id, or returns the element itself\r\n  // if it was passed directly.\r\n  function get(id) {\r\n  \treturn typeof id === 'string' ? document.getElementById(id) : id;\r\n  }\r\n\r\n  // @function getStyle(el: HTMLElement, styleAttrib: String): String\r\n  // Returns the value for a certain style attribute on an element,\r\n  // including computed values or values set through CSS.\r\n  function getStyle(el, style) {\r\n  \tvar value = el.style[style] || (el.currentStyle && el.currentStyle[style]);\r\n\r\n  \tif ((!value || value === 'auto') && document.defaultView) {\r\n  \t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n  \t\tvalue = css ? css[style] : null;\r\n  \t}\r\n  \treturn value === 'auto' ? null : value;\r\n  }\r\n\r\n  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\r\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\r\n  function create$1(tagName, className, container) {\r\n  \tvar el = document.createElement(tagName);\r\n  \tel.className = className || '';\r\n\r\n  \tif (container) {\r\n  \t\tcontainer.appendChild(el);\r\n  \t}\r\n  \treturn el;\r\n  }\r\n\r\n  // @function remove(el: HTMLElement)\r\n  // Removes `el` from its parent element\r\n  function remove(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent) {\r\n  \t\tparent.removeChild(el);\r\n  \t}\r\n  }\r\n\r\n  // @function empty(el: HTMLElement)\r\n  // Removes all of `el`'s children elements from `el`\r\n  function empty(el) {\r\n  \twhile (el.firstChild) {\r\n  \t\tel.removeChild(el.firstChild);\r\n  \t}\r\n  }\r\n\r\n  // @function toFront(el: HTMLElement)\r\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\r\n  function toFront(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent && parent.lastChild !== el) {\r\n  \t\tparent.appendChild(el);\r\n  \t}\r\n  }\r\n\r\n  // @function toBack(el: HTMLElement)\r\n  // Makes `el` the first child of its parent, so it renders behind the other children.\r\n  function toBack(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent && parent.firstChild !== el) {\r\n  \t\tparent.insertBefore(el, parent.firstChild);\r\n  \t}\r\n  }\r\n\r\n  // @function hasClass(el: HTMLElement, name: String): Boolean\r\n  // Returns `true` if the element's class attribute contains `name`.\r\n  function hasClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\treturn el.classList.contains(name);\r\n  \t}\r\n  \tvar className = getClass(el);\r\n  \treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n  }\r\n\r\n  // @function addClass(el: HTMLElement, name: String)\r\n  // Adds `name` to the element's class attribute.\r\n  function addClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\tvar classes = splitWords(name);\r\n  \t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n  \t\t\tel.classList.add(classes[i]);\r\n  \t\t}\r\n  \t} else if (!hasClass(el, name)) {\r\n  \t\tvar className = getClass(el);\r\n  \t\tsetClass(el, (className ? className + ' ' : '') + name);\r\n  \t}\r\n  }\r\n\r\n  // @function removeClass(el: HTMLElement, name: String)\r\n  // Removes `name` from the element's class attribute.\r\n  function removeClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\tel.classList.remove(name);\r\n  \t} else {\r\n  \t\tsetClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n  \t}\r\n  }\r\n\r\n  // @function setClass(el: HTMLElement, name: String)\r\n  // Sets the element's class.\r\n  function setClass(el, name) {\r\n  \tif (el.className.baseVal === undefined) {\r\n  \t\tel.className = name;\r\n  \t} else {\r\n  \t\t// in case of SVG element\r\n  \t\tel.className.baseVal = name;\r\n  \t}\r\n  }\r\n\r\n  // @function getClass(el: HTMLElement): String\r\n  // Returns the element's class.\r\n  function getClass(el) {\r\n  \t// Check if the element is an SVGElementInstance and use the correspondingElement instead\r\n  \t// (Required for linked SVG elements in IE11.)\r\n  \tif (el.correspondingElement) {\r\n  \t\tel = el.correspondingElement;\r\n  \t}\r\n  \treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n  }\r\n\r\n  // @function setOpacity(el: HTMLElement, opacity: Number)\r\n  // Set the opacity of an element (including old IE support).\r\n  // `opacity` must be a number from `0` to `1`.\r\n  function setOpacity(el, value) {\r\n  \tif ('opacity' in el.style) {\r\n  \t\tel.style.opacity = value;\r\n  \t} else if ('filter' in el.style) {\r\n  \t\t_setOpacityIE(el, value);\r\n  \t}\r\n  }\r\n\r\n  function _setOpacityIE(el, value) {\r\n  \tvar filter = false,\r\n  \t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n  \t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n  \ttry {\r\n  \t\tfilter = el.filters.item(filterName);\r\n  \t} catch (e) {\r\n  \t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n  \t\t// it isn't needed and breaks transparent pngs.\r\n  \t\tif (value === 1) { return; }\r\n  \t}\r\n\r\n  \tvalue = Math.round(value * 100);\r\n\r\n  \tif (filter) {\r\n  \t\tfilter.Enabled = (value !== 100);\r\n  \t\tfilter.Opacity = value;\r\n  \t} else {\r\n  \t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n  \t}\r\n  }\r\n\r\n  // @function testProp(props: String[]): String|false\r\n  // Goes through the array of style names and returns the first name\r\n  // that is a valid style name for an element. If no such name is found,\r\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\r\n  function testProp(props) {\r\n  \tvar style = document.documentElement.style;\r\n\r\n  \tfor (var i = 0; i < props.length; i++) {\r\n  \t\tif (props[i] in style) {\r\n  \t\t\treturn props[i];\r\n  \t\t}\r\n  \t}\r\n  \treturn false;\r\n  }\r\n\r\n  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\r\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\r\n  // and optionally scaled by `scale`. Does not have an effect if the\r\n  // browser doesn't support 3D CSS transforms.\r\n  function setTransform(el, offset, scale) {\r\n  \tvar pos = offset || new Point(0, 0);\r\n\r\n  \tel.style[TRANSFORM] =\r\n  \t\t(Browser.ie3d ?\r\n  \t\t\t'translate(' + pos.x + 'px,' + pos.y + 'px)' :\r\n  \t\t\t'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +\r\n  \t\t(scale ? ' scale(' + scale + ')' : '');\r\n  }\r\n\r\n  // @function setPosition(el: HTMLElement, position: Point)\r\n  // Sets the position of `el` to coordinates specified by `position`,\r\n  // using CSS translate or top/left positioning depending on the browser\r\n  // (used by Leaflet internally to position its layers).\r\n  function setPosition(el, point) {\r\n\r\n  \t/*eslint-disable */\r\n  \tel._leaflet_pos = point;\r\n  \t/* eslint-enable */\r\n\r\n  \tif (Browser.any3d) {\r\n  \t\tsetTransform(el, point);\r\n  \t} else {\r\n  \t\tel.style.left = point.x + 'px';\r\n  \t\tel.style.top = point.y + 'px';\r\n  \t}\r\n  }\r\n\r\n  // @function getPosition(el: HTMLElement): Point\r\n  // Returns the coordinates of an element previously positioned with setPosition.\r\n  function getPosition(el) {\r\n  \t// this method is only used for elements previously positioned using setPosition,\r\n  \t// so it's safe to cache the position for performance\r\n\r\n  \treturn el._leaflet_pos || new Point(0, 0);\r\n  }\r\n\r\n  // @function disableTextSelection()\r\n  // Prevents the user from generating `selectstart` DOM events, usually generated\r\n  // when the user drags the mouse through a page with text. Used internally\r\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\r\n  // the map. Affects drag interactions on the whole document.\r\n\r\n  // @function enableTextSelection()\r\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\r\n  var disableTextSelection;\r\n  var enableTextSelection;\r\n  var _userSelect;\r\n  if ('onselectstart' in document) {\r\n  \tdisableTextSelection = function () {\r\n  \t\ton(window, 'selectstart', preventDefault);\r\n  \t};\r\n  \tenableTextSelection = function () {\r\n  \t\toff(window, 'selectstart', preventDefault);\r\n  \t};\r\n  } else {\r\n  \tvar userSelectProperty = testProp(\r\n  \t\t['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n  \tdisableTextSelection = function () {\r\n  \t\tif (userSelectProperty) {\r\n  \t\t\tvar style = document.documentElement.style;\r\n  \t\t\t_userSelect = style[userSelectProperty];\r\n  \t\t\tstyle[userSelectProperty] = 'none';\r\n  \t\t}\r\n  \t};\r\n  \tenableTextSelection = function () {\r\n  \t\tif (userSelectProperty) {\r\n  \t\t\tdocument.documentElement.style[userSelectProperty] = _userSelect;\r\n  \t\t\t_userSelect = undefined;\r\n  \t\t}\r\n  \t};\r\n  }\r\n\r\n  // @function disableImageDrag()\r\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\r\n  // for `dragstart` DOM events, usually generated when the user drags an image.\r\n  function disableImageDrag() {\r\n  \ton(window, 'dragstart', preventDefault);\r\n  }\r\n\r\n  // @function enableImageDrag()\r\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\r\n  function enableImageDrag() {\r\n  \toff(window, 'dragstart', preventDefault);\r\n  }\r\n\r\n  var _outlineElement, _outlineStyle;\r\n  // @function preventOutline(el: HTMLElement)\r\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\r\n  // of the element `el` invisible. Used internally by Leaflet to prevent\r\n  // focusable elements from displaying an outline when the user performs a\r\n  // drag interaction on them.\r\n  function preventOutline(element) {\r\n  \twhile (element.tabIndex === -1) {\r\n  \t\telement = element.parentNode;\r\n  \t}\r\n  \tif (!element.style) { return; }\r\n  \trestoreOutline();\r\n  \t_outlineElement = element;\r\n  \t_outlineStyle = element.style.outlineStyle;\r\n  \telement.style.outlineStyle = 'none';\r\n  \ton(window, 'keydown', restoreOutline);\r\n  }\r\n\r\n  // @function restoreOutline()\r\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\r\n  function restoreOutline() {\r\n  \tif (!_outlineElement) { return; }\r\n  \t_outlineElement.style.outlineStyle = _outlineStyle;\r\n  \t_outlineElement = undefined;\r\n  \t_outlineStyle = undefined;\r\n  \toff(window, 'keydown', restoreOutline);\r\n  }\r\n\r\n  // @function getSizedParentNode(el: HTMLElement): HTMLElement\r\n  // Finds the closest parent node which size (width and height) is not null.\r\n  function getSizedParentNode(element) {\r\n  \tdo {\r\n  \t\telement = element.parentNode;\r\n  \t} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\r\n  \treturn element;\r\n  }\r\n\r\n  // @function getScale(el: HTMLElement): Object\r\n  // Computes the CSS scale currently applied on the element.\r\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\r\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\r\n  function getScale(element) {\r\n  \tvar rect = element.getBoundingClientRect(); // Read-only in old browsers.\r\n\r\n  \treturn {\r\n  \t\tx: rect.width / element.offsetWidth || 1,\r\n  \t\ty: rect.height / element.offsetHeight || 1,\r\n  \t\tboundingClientRect: rect\r\n  \t};\r\n  }\n\n  var DomUtil = {\n    __proto__: null,\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    get disableTextSelection () { return disableTextSelection; },\n    get enableTextSelection () { return enableTextSelection; },\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\r\n\r\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\r\n\r\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n  // Adds a listener function (`fn`) to a particular DOM event type of the\r\n  // element `el`. You can optionally specify the context of the listener\r\n  // (object the `this` keyword will point to). You can also pass several\r\n  // space-separated types (e.g. `'click dblclick'`).\r\n\r\n  // @alternative\r\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\r\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  function on(obj, types, fn, context) {\r\n\r\n  \tif (types && typeof types === 'object') {\r\n  \t\tfor (var type in types) {\r\n  \t\t\taddOne(obj, type, types[type], fn);\r\n  \t\t}\r\n  \t} else {\r\n  \t\ttypes = splitWords(types);\r\n\r\n  \t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\taddOne(obj, types[i], fn, context);\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  var eventsKey = '_leaflet_events';\r\n\r\n  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n  // Removes a previously added listener function.\r\n  // Note that if you passed a custom context to on, you must pass the same\r\n  // context to `off` in order to remove the listener.\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\r\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement, types: String): this\r\n  // Removes all previously added listeners of given types.\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement): this\r\n  // Removes all previously added listeners from given HTMLElement\r\n  function off(obj, types, fn, context) {\r\n\r\n  \tif (arguments.length === 1) {\r\n  \t\tbatchRemove(obj);\r\n  \t\tdelete obj[eventsKey];\r\n\r\n  \t} else if (types && typeof types === 'object') {\r\n  \t\tfor (var type in types) {\r\n  \t\t\tremoveOne(obj, type, types[type], fn);\r\n  \t\t}\r\n\r\n  \t} else {\r\n  \t\ttypes = splitWords(types);\r\n\r\n  \t\tif (arguments.length === 2) {\r\n  \t\t\tbatchRemove(obj, function (type) {\r\n  \t\t\t\treturn indexOf(types, type) !== -1;\r\n  \t\t\t});\r\n  \t\t} else {\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tremoveOne(obj, types[i], fn, context);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  function batchRemove(obj, filterFn) {\r\n  \tfor (var id in obj[eventsKey]) {\r\n  \t\tvar type = id.split(/\\d/)[0];\r\n  \t\tif (!filterFn || filterFn(type)) {\r\n  \t\t\tremoveOne(obj, type, null, null, id);\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  var mouseSubst = {\r\n  \tmouseenter: 'mouseover',\r\n  \tmouseleave: 'mouseout',\r\n  \twheel: !('onwheel' in window) && 'mousewheel'\r\n  };\r\n\r\n  function addOne(obj, type, fn, context) {\r\n  \tvar id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\r\n\r\n  \tif (obj[eventsKey] && obj[eventsKey][id]) { return this; }\r\n\r\n  \tvar handler = function (e) {\r\n  \t\treturn fn.call(context || obj, e || window.event);\r\n  \t};\r\n\r\n  \tvar originalHandler = handler;\r\n\r\n  \tif (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\r\n  \t\t// Needs DomEvent.Pointer.js\r\n  \t\thandler = addPointerListener(obj, type, handler);\r\n\r\n  \t} else if (Browser.touch && (type === 'dblclick')) {\r\n  \t\thandler = addDoubleTapListener(obj, handler);\r\n\r\n  \t} else if ('addEventListener' in obj) {\r\n\r\n  \t\tif (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {\r\n  \t\t\tobj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {passive: false} : false);\r\n\r\n  \t\t} else if (type === 'mouseenter' || type === 'mouseleave') {\r\n  \t\t\thandler = function (e) {\r\n  \t\t\t\te = e || window.event;\r\n  \t\t\t\tif (isExternalTarget(obj, e)) {\r\n  \t\t\t\t\toriginalHandler(e);\r\n  \t\t\t\t}\r\n  \t\t\t};\r\n  \t\t\tobj.addEventListener(mouseSubst[type], handler, false);\r\n\r\n  \t\t} else {\r\n  \t\t\tobj.addEventListener(type, originalHandler, false);\r\n  \t\t}\r\n\r\n  \t} else {\r\n  \t\tobj.attachEvent('on' + type, handler);\r\n  \t}\r\n\r\n  \tobj[eventsKey] = obj[eventsKey] || {};\r\n  \tobj[eventsKey][id] = handler;\r\n  }\r\n\r\n  function removeOne(obj, type, fn, context, id) {\r\n  \tid = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');\r\n  \tvar handler = obj[eventsKey] && obj[eventsKey][id];\r\n\r\n  \tif (!handler) { return this; }\r\n\r\n  \tif (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\r\n  \t\tremovePointerListener(obj, type, handler);\r\n\r\n  \t} else if (Browser.touch && (type === 'dblclick')) {\r\n  \t\tremoveDoubleTapListener(obj, handler);\r\n\r\n  \t} else if ('removeEventListener' in obj) {\r\n\r\n  \t\tobj.removeEventListener(mouseSubst[type] || type, handler, false);\r\n\r\n  \t} else {\r\n  \t\tobj.detachEvent('on' + type, handler);\r\n  \t}\r\n\r\n  \tobj[eventsKey][id] = null;\r\n  }\r\n\r\n  // @function stopPropagation(ev: DOMEvent): this\r\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\r\n  // ```js\r\n  // L.DomEvent.on(div, 'click', function (ev) {\r\n  // \tL.DomEvent.stopPropagation(ev);\r\n  // });\r\n  // ```\r\n  function stopPropagation(e) {\r\n\r\n  \tif (e.stopPropagation) {\r\n  \t\te.stopPropagation();\r\n  \t} else if (e.originalEvent) {  // In case of Leaflet event.\r\n  \t\te.originalEvent._stopped = true;\r\n  \t} else {\r\n  \t\te.cancelBubble = true;\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  // @function disableScrollPropagation(el: HTMLElement): this\r\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\r\n  function disableScrollPropagation(el) {\r\n  \taddOne(el, 'wheel', stopPropagation);\r\n  \treturn this;\r\n  }\r\n\r\n  // @function disableClickPropagation(el: HTMLElement): this\r\n  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\r\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\r\n  function disableClickPropagation(el) {\r\n  \ton(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);\r\n  \tel['_leaflet_disable_click'] = true;\r\n  \treturn this;\r\n  }\r\n\r\n  // @function preventDefault(ev: DOMEvent): this\r\n  // Prevents the default action of the DOM Event `ev` from happening (such as\r\n  // following a link in the href of the a element, or doing a POST request\r\n  // with page reload when a `<form>` is submitted).\r\n  // Use it inside listener functions.\r\n  function preventDefault(e) {\r\n  \tif (e.preventDefault) {\r\n  \t\te.preventDefault();\r\n  \t} else {\r\n  \t\te.returnValue = false;\r\n  \t}\r\n  \treturn this;\r\n  }\r\n\r\n  // @function stop(ev: DOMEvent): this\r\n  // Does `stopPropagation` and `preventDefault` at the same time.\r\n  function stop(e) {\r\n  \tpreventDefault(e);\r\n  \tstopPropagation(e);\r\n  \treturn this;\r\n  }\r\n\r\n  // @function getPropagationPath(ev: DOMEvent): Array\r\n  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\r\n  // Returns an array containing the `HTMLElement`s that the given DOM event\r\n  // should propagate to (if not stopped).\r\n  function getPropagationPath(ev) {\r\n  \tif (ev.composedPath) {\r\n  \t\treturn ev.composedPath();\r\n  \t}\r\n\r\n  \tvar path = [];\r\n  \tvar el = ev.target;\r\n\r\n  \twhile (el) {\r\n  \t\tpath.push(el);\r\n  \t\tel = el.parentNode;\r\n  \t}\r\n  \treturn path;\r\n  }\r\n\r\n\r\n  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\r\n  // Gets normalized mouse position from a DOM event relative to the\r\n  // `container` (border excluded) or to the whole page if not specified.\r\n  function getMousePosition(e, container) {\r\n  \tif (!container) {\r\n  \t\treturn new Point(e.clientX, e.clientY);\r\n  \t}\r\n\r\n  \tvar scale = getScale(container),\r\n  \t    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\r\n\r\n  \treturn new Point(\r\n  \t\t// offset.left/top values are in page scale (like clientX/Y),\r\n  \t\t// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\r\n  \t\t(e.clientX - offset.left) / scale.x - container.clientLeft,\r\n  \t\t(e.clientY - offset.top) / scale.y - container.clientTop\r\n  \t);\r\n  }\r\n\r\n\r\n  //  except , Safari and\r\n  // We need double the scroll pixels (see #7403 and #4538) for all Browsers\r\n  // except OSX (Mac) -> 3x, Chrome running on Linux 1x\r\n\r\n  var wheelPxFactor =\r\n  \t(Browser.linux && Browser.chrome) ? window.devicePixelRatio :\r\n  \tBrowser.mac ? window.devicePixelRatio * 3 :\r\n  \twindow.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\r\n  // @function getWheelDelta(ev: DOMEvent): Number\r\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\r\n  // pixels scrolled (negative if scrolling down).\r\n  // Events from pointing devices without precise scrolling are mapped to\r\n  // a best guess of 60 pixels.\r\n  function getWheelDelta(e) {\r\n  \treturn (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\r\n  \t       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels\r\n  \t       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines\r\n  \t       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages\r\n  \t       (e.deltaX || e.deltaZ) ? 0 :\t// Skip horizontal/depth wheel events\r\n  \t       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\r\n  \t       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines\r\n  \t       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\r\n  \t       0;\r\n  }\r\n\r\n  // check if element really left/entered the event target (for mouseenter/mouseleave)\r\n  function isExternalTarget(el, e) {\r\n\r\n  \tvar related = e.relatedTarget;\r\n\r\n  \tif (!related) { return true; }\r\n\r\n  \ttry {\r\n  \t\twhile (related && (related !== el)) {\r\n  \t\t\trelated = related.parentNode;\r\n  \t\t}\r\n  \t} catch (err) {\r\n  \t\treturn false;\r\n  \t}\r\n  \treturn (related !== el);\r\n  }\n\n  var DomEvent = {\n    __proto__: null,\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getPropagationPath: getPropagationPath,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n\n  \t// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n  \t// Run an animation of a given element to a new position, optionally setting\n  \t// duration in seconds (`0.25` by default) and easing linearity factor (3rd\n  \t// argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n  \t// `0.5` by default).\n  \trun: function (el, newPos, duration, easeLinearity) {\n  \t\tthis.stop();\n\n  \t\tthis._el = el;\n  \t\tthis._inProgress = true;\n  \t\tthis._duration = duration || 0.25;\n  \t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n  \t\tthis._startPos = getPosition(el);\n  \t\tthis._offset = newPos.subtract(this._startPos);\n  \t\tthis._startTime = +new Date();\n\n  \t\t// @event start: Event\n  \t\t// Fired when the animation starts\n  \t\tthis.fire('start');\n\n  \t\tthis._animate();\n  \t},\n\n  \t// @method stop()\n  \t// Stops the animation (if currently running).\n  \tstop: function () {\n  \t\tif (!this._inProgress) { return; }\n\n  \t\tthis._step(true);\n  \t\tthis._complete();\n  \t},\n\n  \t_animate: function () {\n  \t\t// animation loop\n  \t\tthis._animId = requestAnimFrame(this._animate, this);\n  \t\tthis._step();\n  \t},\n\n  \t_step: function (round) {\n  \t\tvar elapsed = (+new Date()) - this._startTime,\n  \t\t    duration = this._duration * 1000;\n\n  \t\tif (elapsed < duration) {\n  \t\t\tthis._runFrame(this._easeOut(elapsed / duration), round);\n  \t\t} else {\n  \t\t\tthis._runFrame(1);\n  \t\t\tthis._complete();\n  \t\t}\n  \t},\n\n  \t_runFrame: function (progress, round) {\n  \t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n  \t\tif (round) {\n  \t\t\tpos._round();\n  \t\t}\n  \t\tsetPosition(this._el, pos);\n\n  \t\t// @event step: Event\n  \t\t// Fired continuously during the animation.\n  \t\tthis.fire('step');\n  \t},\n\n  \t_complete: function () {\n  \t\tcancelAnimFrame(this._animId);\n\n  \t\tthis._inProgress = false;\n  \t\t// @event end: Event\n  \t\t// Fired when the animation ends.\n  \t\tthis.fire('end');\n  \t},\n\n  \t_easeOut: function (t) {\n  \t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n  \t}\n  });\n\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API  it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\r\n\r\n  var Map = Evented.extend({\r\n\r\n  \toptions: {\r\n  \t\t// @section Map State Options\r\n  \t\t// @option crs: CRS = L.CRS.EPSG3857\r\n  \t\t// The [Coordinate Reference System](#crs) to use. Don't change this if you're not\r\n  \t\t// sure what it means.\r\n  \t\tcrs: EPSG3857,\r\n\r\n  \t\t// @option center: LatLng = undefined\r\n  \t\t// Initial geographic center of the map\r\n  \t\tcenter: undefined,\r\n\r\n  \t\t// @option zoom: Number = undefined\r\n  \t\t// Initial map zoom level\r\n  \t\tzoom: undefined,\r\n\r\n  \t\t// @option minZoom: Number = *\r\n  \t\t// Minimum zoom level of the map.\r\n  \t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n  \t\t// the lowest of their `minZoom` options will be used instead.\r\n  \t\tminZoom: undefined,\r\n\r\n  \t\t// @option maxZoom: Number = *\r\n  \t\t// Maximum zoom level of the map.\r\n  \t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n  \t\t// the highest of their `maxZoom` options will be used instead.\r\n  \t\tmaxZoom: undefined,\r\n\r\n  \t\t// @option layers: Layer[] = []\r\n  \t\t// Array of layers that will be added to the map initially\r\n  \t\tlayers: [],\r\n\r\n  \t\t// @option maxBounds: LatLngBounds = null\r\n  \t\t// When this option is set, the map restricts the view to the given\r\n  \t\t// geographical bounds, bouncing the user back if the user tries to pan\r\n  \t\t// outside the view. To set the restriction dynamically, use\r\n  \t\t// [`setMaxBounds`](#map-setmaxbounds) method.\r\n  \t\tmaxBounds: undefined,\r\n\r\n  \t\t// @option renderer: Renderer = *\r\n  \t\t// The default method for drawing vector layers on the map. `L.SVG`\r\n  \t\t// or `L.Canvas` by default depending on browser support.\r\n  \t\trenderer: undefined,\r\n\r\n\r\n  \t\t// @section Animation Options\r\n  \t\t// @option zoomAnimation: Boolean = true\r\n  \t\t// Whether the map zoom animation is enabled. By default it's enabled\r\n  \t\t// in all browsers that support CSS3 Transitions except Android.\r\n  \t\tzoomAnimation: true,\r\n\r\n  \t\t// @option zoomAnimationThreshold: Number = 4\r\n  \t\t// Won't animate zoom if the zoom difference exceeds this value.\r\n  \t\tzoomAnimationThreshold: 4,\r\n\r\n  \t\t// @option fadeAnimation: Boolean = true\r\n  \t\t// Whether the tile fade animation is enabled. By default it's enabled\r\n  \t\t// in all browsers that support CSS3 Transitions except Android.\r\n  \t\tfadeAnimation: true,\r\n\r\n  \t\t// @option markerZoomAnimation: Boolean = true\r\n  \t\t// Whether markers animate their zoom with the zoom animation, if disabled\r\n  \t\t// they will disappear for the length of the animation. By default it's\r\n  \t\t// enabled in all browsers that support CSS3 Transitions except Android.\r\n  \t\tmarkerZoomAnimation: true,\r\n\r\n  \t\t// @option transform3DLimit: Number = 2^23\r\n  \t\t// Defines the maximum size of a CSS translation transform. The default\r\n  \t\t// value should not be changed unless a web browser positions layers in\r\n  \t\t// the wrong place after doing a large `panBy`.\r\n  \t\ttransform3DLimit: 8388608, // Precision limit of a 32-bit float\r\n\r\n  \t\t// @section Interaction Options\r\n  \t\t// @option zoomSnap: Number = 1\r\n  \t\t// Forces the map's zoom level to always be a multiple of this, particularly\r\n  \t\t// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\r\n  \t\t// By default, the zoom level snaps to the nearest integer; lower values\r\n  \t\t// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\r\n  \t\t// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\r\n  \t\tzoomSnap: 1,\r\n\r\n  \t\t// @option zoomDelta: Number = 1\r\n  \t\t// Controls how much the map's zoom level will change after a\r\n  \t\t// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\r\n  \t\t// or `-` on the keyboard, or using the [zoom controls](#control-zoom).\r\n  \t\t// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\r\n  \t\tzoomDelta: 1,\r\n\r\n  \t\t// @option trackResize: Boolean = true\r\n  \t\t// Whether the map automatically handles browser window resize to update itself.\r\n  \t\ttrackResize: true\r\n  \t},\r\n\r\n  \tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\t// Make sure to assign internal flags at the beginning,\r\n  \t\t// to avoid inconsistent state in some edge cases.\r\n  \t\tthis._handlers = [];\r\n  \t\tthis._layers = {};\r\n  \t\tthis._zoomBoundLayers = {};\r\n  \t\tthis._sizeChanged = true;\r\n\r\n  \t\tthis._initContainer(id);\r\n  \t\tthis._initLayout();\r\n\r\n  \t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n  \t\tthis._onResize = bind(this._onResize, this);\r\n\r\n  \t\tthis._initEvents();\r\n\r\n  \t\tif (options.maxBounds) {\r\n  \t\t\tthis.setMaxBounds(options.maxBounds);\r\n  \t\t}\r\n\r\n  \t\tif (options.zoom !== undefined) {\r\n  \t\t\tthis._zoom = this._limitZoom(options.zoom);\r\n  \t\t}\r\n\r\n  \t\tif (options.center && options.zoom !== undefined) {\r\n  \t\t\tthis.setView(toLatLng(options.center), options.zoom, {reset: true});\r\n  \t\t}\r\n\r\n  \t\tthis.callInitHooks();\r\n\r\n  \t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\r\n  \t\tthis._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera &&\r\n  \t\t\t\tthis.options.zoomAnimation;\r\n\r\n  \t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\r\n  \t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tthis._createAnimProxy();\r\n  \t\t\ton(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\r\n  \t\t}\r\n\r\n  \t\tthis._addLayers(this.options.layers);\r\n  \t},\r\n\r\n\r\n  \t// @section Methods for modifying map state\r\n\r\n  \t// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\r\n  \t// Sets the view of the map (geographical center and zoom) with the given\r\n  \t// animation options.\r\n  \tsetView: function (center, zoom, options) {\r\n\r\n  \t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\r\n  \t\tcenter = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\r\n  \t\toptions = options || {};\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tif (this._loaded && !options.reset && options !== true) {\r\n\r\n  \t\t\tif (options.animate !== undefined) {\r\n  \t\t\t\toptions.zoom = extend({animate: options.animate}, options.zoom);\r\n  \t\t\t\toptions.pan = extend({animate: options.animate, duration: options.duration}, options.pan);\r\n  \t\t\t}\r\n\r\n  \t\t\t// try animating pan or zoom\r\n  \t\t\tvar moved = (this._zoom !== zoom) ?\r\n  \t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\r\n  \t\t\t\tthis._tryAnimatedPan(center, options.pan);\r\n\r\n  \t\t\tif (moved) {\r\n  \t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\r\n  \t\t\t\tclearTimeout(this._sizeTimer);\r\n  \t\t\t\treturn this;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// animation didn't start, just reset the map view\r\n  \t\tthis._resetView(center, zoom, options.pan && options.pan.noMoveStart);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setZoom(zoom: Number, options?: Zoom/pan options): this\r\n  \t// Sets the zoom of the map.\r\n  \tsetZoom: function (zoom, options) {\r\n  \t\tif (!this._loaded) {\r\n  \t\t\tthis._zoom = zoom;\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n  \t},\r\n\r\n  \t// @method zoomIn(delta?: Number, options?: Zoom options): this\r\n  \t// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n  \tzoomIn: function (delta, options) {\r\n  \t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n  \t\treturn this.setZoom(this._zoom + delta, options);\r\n  \t},\r\n\r\n  \t// @method zoomOut(delta?: Number, options?: Zoom options): this\r\n  \t// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n  \tzoomOut: function (delta, options) {\r\n  \t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n  \t\treturn this.setZoom(this._zoom - delta, options);\r\n  \t},\r\n\r\n  \t// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\r\n  \t// Zooms the map while keeping a specified geographical point on the map\r\n  \t// stationary (e.g. used internally for scroll zoom and double-click zoom).\r\n  \t// @alternative\r\n  \t// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\r\n  \t// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\r\n  \tsetZoomAround: function (latlng, zoom, options) {\r\n  \t\tvar scale = this.getZoomScale(zoom),\r\n  \t\t    viewHalf = this.getSize().divideBy(2),\r\n  \t\t    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n  \t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n  \t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n  \t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n  \t},\r\n\r\n  \t_getBoundsCenterZoom: function (bounds, options) {\r\n\r\n  \t\toptions = options || {};\r\n  \t\tbounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\r\n\r\n  \t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n  \t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n  \t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n  \t\tzoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n  \t\tif (zoom === Infinity) {\r\n  \t\t\treturn {\r\n  \t\t\t\tcenter: bounds.getCenter(),\r\n  \t\t\t\tzoom: zoom\r\n  \t\t\t};\r\n  \t\t}\r\n\r\n  \t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n  \t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n  \t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n  \t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n  \t\treturn {\r\n  \t\t\tcenter: center,\r\n  \t\t\tzoom: zoom\r\n  \t\t};\r\n  \t},\r\n\r\n  \t// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n  \t// Sets a map view that contains the given geographical bounds with the\r\n  \t// maximum zoom level possible.\r\n  \tfitBounds: function (bounds, options) {\r\n\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (!bounds.isValid()) {\r\n  \t\t\tthrow new Error('Bounds are not valid.');\r\n  \t\t}\r\n\r\n  \t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n  \t\treturn this.setView(target.center, target.zoom, options);\r\n  \t},\r\n\r\n  \t// @method fitWorld(options?: fitBounds options): this\r\n  \t// Sets a map view that mostly contains the whole world with the maximum\r\n  \t// zoom level possible.\r\n  \tfitWorld: function (options) {\r\n  \t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n  \t},\r\n\r\n  \t// @method panTo(latlng: LatLng, options?: Pan options): this\r\n  \t// Pans the map to a given center.\r\n  \tpanTo: function (center, options) { // (LatLng)\r\n  \t\treturn this.setView(center, this._zoom, {pan: options});\r\n  \t},\r\n\r\n  \t// @method panBy(offset: Point, options?: Pan options): this\r\n  \t// Pans the map by a given number of pixels (animated).\r\n  \tpanBy: function (offset, options) {\r\n  \t\toffset = toPoint(offset).round();\r\n  \t\toptions = options || {};\r\n\r\n  \t\tif (!offset.x && !offset.y) {\r\n  \t\t\treturn this.fire('moveend');\r\n  \t\t}\r\n  \t\t// If we pan too far, Chrome gets issues with tiles\r\n  \t\t// and makes them disappear or appear in the wrong place (slightly offset) #2602\r\n  \t\tif (options.animate !== true && !this.getSize().contains(offset)) {\r\n  \t\t\tthis._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tif (!this._panAnim) {\r\n  \t\t\tthis._panAnim = new PosAnimation();\r\n\r\n  \t\t\tthis._panAnim.on({\r\n  \t\t\t\t'step': this._onPanTransitionStep,\r\n  \t\t\t\t'end': this._onPanTransitionEnd\r\n  \t\t\t}, this);\r\n  \t\t}\r\n\r\n  \t\t// don't fire movestart if animating inertia\r\n  \t\tif (!options.noMoveStart) {\r\n  \t\t\tthis.fire('movestart');\r\n  \t\t}\r\n\r\n  \t\t// animate pan unless animate: false specified\r\n  \t\tif (options.animate !== false) {\r\n  \t\t\taddClass(this._mapPane, 'leaflet-pan-anim');\r\n\r\n  \t\t\tvar newPos = this._getMapPanePos().subtract(offset).round();\r\n  \t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\r\n  \t\t} else {\r\n  \t\t\tthis._rawPanBy(offset);\r\n  \t\t\tthis.fire('move').fire('moveend');\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\r\n  \t// Sets the view of the map (geographical center and zoom) performing a smooth\r\n  \t// pan-zoom animation.\r\n  \tflyTo: function (targetCenter, targetZoom, options) {\r\n\r\n  \t\toptions = options || {};\r\n  \t\tif (options.animate === false || !Browser.any3d) {\r\n  \t\t\treturn this.setView(targetCenter, targetZoom, options);\r\n  \t\t}\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tvar from = this.project(this.getCenter()),\r\n  \t\t    to = this.project(targetCenter),\r\n  \t\t    size = this.getSize(),\r\n  \t\t    startZoom = this._zoom;\r\n\r\n  \t\ttargetCenter = toLatLng(targetCenter);\r\n  \t\ttargetZoom = targetZoom === undefined ? startZoom : targetZoom;\r\n\r\n  \t\tvar w0 = Math.max(size.x, size.y),\r\n  \t\t    w1 = w0 * this.getZoomScale(startZoom, targetZoom),\r\n  \t\t    u1 = (to.distanceTo(from)) || 1,\r\n  \t\t    rho = 1.42,\r\n  \t\t    rho2 = rho * rho;\r\n\r\n  \t\tfunction r(i) {\r\n  \t\t\tvar s1 = i ? -1 : 1,\r\n  \t\t\t    s2 = i ? w1 : w0,\r\n  \t\t\t    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\r\n  \t\t\t    b1 = 2 * s2 * rho2 * u1,\r\n  \t\t\t    b = t1 / b1,\r\n  \t\t\t    sq = Math.sqrt(b * b + 1) - b;\r\n\r\n  \t\t\t    // workaround for floating point precision bug when sq = 0, log = -Infinite,\r\n  \t\t\t    // thus triggering an infinite loop in flyTo\r\n  \t\t\t    var log = sq < 0.000000001 ? -18 : Math.log(sq);\r\n\r\n  \t\t\treturn log;\r\n  \t\t}\r\n\r\n  \t\tfunction sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }\r\n  \t\tfunction cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }\r\n  \t\tfunction tanh(n) { return sinh(n) / cosh(n); }\r\n\r\n  \t\tvar r0 = r(0);\r\n\r\n  \t\tfunction w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }\r\n  \t\tfunction u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }\r\n\r\n  \t\tfunction easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }\r\n\r\n  \t\tvar start = Date.now(),\r\n  \t\t    S = (r(1) - r0) / rho,\r\n  \t\t    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\r\n\r\n  \t\tfunction frame() {\r\n  \t\t\tvar t = (Date.now() - start) / duration,\r\n  \t\t\t    s = easeOut(t) * S;\r\n\r\n  \t\t\tif (t <= 1) {\r\n  \t\t\t\tthis._flyToFrame = requestAnimFrame(frame, this);\r\n\r\n  \t\t\t\tthis._move(\r\n  \t\t\t\t\tthis.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),\r\n  \t\t\t\t\tthis.getScaleZoom(w0 / w(s), startZoom),\r\n  \t\t\t\t\t{flyTo: true});\r\n\r\n  \t\t\t} else {\r\n  \t\t\t\tthis\r\n  \t\t\t\t\t._move(targetCenter, targetZoom)\r\n  \t\t\t\t\t._moveEnd(true);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._moveStart(true, options.noMoveStart);\r\n\r\n  \t\tframe.call(this);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n  \t// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\r\n  \t// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\r\n  \tflyToBounds: function (bounds, options) {\r\n  \t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n  \t\treturn this.flyTo(target.center, target.zoom, options);\r\n  \t},\r\n\r\n  \t// @method setMaxBounds(bounds: LatLngBounds): this\r\n  \t// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\r\n  \tsetMaxBounds: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (this.listens('moveend', this._panInsideMaxBounds)) {\r\n  \t\t\tthis.off('moveend', this._panInsideMaxBounds);\r\n  \t\t}\r\n\r\n  \t\tif (!bounds.isValid()) {\r\n  \t\t\tthis.options.maxBounds = null;\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tthis.options.maxBounds = bounds;\r\n\r\n  \t\tif (this._loaded) {\r\n  \t\t\tthis._panInsideMaxBounds();\r\n  \t\t}\r\n\r\n  \t\treturn this.on('moveend', this._panInsideMaxBounds);\r\n  \t},\r\n\r\n  \t// @method setMinZoom(zoom: Number): this\r\n  \t// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\r\n  \tsetMinZoom: function (zoom) {\r\n  \t\tvar oldZoom = this.options.minZoom;\r\n  \t\tthis.options.minZoom = zoom;\r\n\r\n  \t\tif (this._loaded && oldZoom !== zoom) {\r\n  \t\t\tthis.fire('zoomlevelschange');\r\n\r\n  \t\t\tif (this.getZoom() < this.options.minZoom) {\r\n  \t\t\t\treturn this.setZoom(zoom);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setMaxZoom(zoom: Number): this\r\n  \t// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\r\n  \tsetMaxZoom: function (zoom) {\r\n  \t\tvar oldZoom = this.options.maxZoom;\r\n  \t\tthis.options.maxZoom = zoom;\r\n\r\n  \t\tif (this._loaded && oldZoom !== zoom) {\r\n  \t\t\tthis.fire('zoomlevelschange');\r\n\r\n  \t\t\tif (this.getZoom() > this.options.maxZoom) {\r\n  \t\t\t\treturn this.setZoom(zoom);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\r\n  \t// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\r\n  \tpanInsideBounds: function (bounds, options) {\r\n  \t\tthis._enforcingBounds = true;\r\n  \t\tvar center = this.getCenter(),\r\n  \t\t    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\r\n\r\n  \t\tif (!center.equals(newCenter)) {\r\n  \t\t\tthis.panTo(newCenter, options);\r\n  \t\t}\r\n\r\n  \t\tthis._enforcingBounds = false;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method panInside(latlng: LatLng, options?: padding options): this\r\n  \t// Pans the map the minimum amount to make the `latlng` visible. Use\r\n  \t// padding options to fit the display to more restricted bounds.\r\n  \t// If `latlng` is already within the (optionally padded) display bounds,\r\n  \t// the map will not be panned.\r\n  \tpanInside: function (latlng, options) {\r\n  \t\toptions = options || {};\r\n\r\n  \t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n  \t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n  \t\t    pixelCenter = this.project(this.getCenter()),\r\n  \t\t    pixelPoint = this.project(latlng),\r\n  \t\t    pixelBounds = this.getPixelBounds(),\r\n  \t\t    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\r\n  \t\t    paddedSize = paddedBounds.getSize();\r\n\r\n  \t\tif (!paddedBounds.contains(pixelPoint)) {\r\n  \t\t\tthis._enforcingBounds = true;\r\n  \t\t\tvar centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\r\n  \t\t\tvar offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\r\n  \t\t\tpixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\r\n  \t\t\tpixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\r\n  \t\t\tthis.panTo(this.unproject(pixelCenter), options);\r\n  \t\t\tthis._enforcingBounds = false;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method invalidateSize(options: Zoom/pan options): this\r\n  \t// Checks if the map container size changed and updates the map if so \r\n  \t// call it after you've changed the map size dynamically, also animating\r\n  \t// pan by default. If `options.pan` is `false`, panning will not occur.\r\n  \t// If `options.debounceMoveend` is `true`, it will delay `moveend` event so\r\n  \t// that it doesn't happen often even if the method is called many\r\n  \t// times in a row.\r\n\r\n  \t// @alternative\r\n  \t// @method invalidateSize(animate: Boolean): this\r\n  \t// Checks if the map container size changed and updates the map if so \r\n  \t// call it after you've changed the map size dynamically, also animating\r\n  \t// pan by default.\r\n  \tinvalidateSize: function (options) {\r\n  \t\tif (!this._loaded) { return this; }\r\n\r\n  \t\toptions = extend({\r\n  \t\t\tanimate: false,\r\n  \t\t\tpan: true\r\n  \t\t}, options === true ? {animate: true} : options);\r\n\r\n  \t\tvar oldSize = this.getSize();\r\n  \t\tthis._sizeChanged = true;\r\n  \t\tthis._lastCenter = null;\r\n\r\n  \t\tvar newSize = this.getSize(),\r\n  \t\t    oldCenter = oldSize.divideBy(2).round(),\r\n  \t\t    newCenter = newSize.divideBy(2).round(),\r\n  \t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n  \t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n  \t\tif (options.animate && options.pan) {\r\n  \t\t\tthis.panBy(offset);\r\n\r\n  \t\t} else {\r\n  \t\t\tif (options.pan) {\r\n  \t\t\t\tthis._rawPanBy(offset);\r\n  \t\t\t}\r\n\r\n  \t\t\tthis.fire('move');\r\n\r\n  \t\t\tif (options.debounceMoveend) {\r\n  \t\t\t\tclearTimeout(this._sizeTimer);\r\n  \t\t\t\tthis._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\r\n  \t\t\t} else {\r\n  \t\t\t\tthis.fire('moveend');\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// @section Map state change events\r\n  \t\t// @event resize: ResizeEvent\r\n  \t\t// Fired when the map is resized.\r\n  \t\treturn this.fire('resize', {\r\n  \t\t\toldSize: oldSize,\r\n  \t\t\tnewSize: newSize\r\n  \t\t});\r\n  \t},\r\n\r\n  \t// @section Methods for modifying map state\r\n  \t// @method stop(): this\r\n  \t// Stops the currently running `panTo` or `flyTo` animation, if any.\r\n  \tstop: function () {\r\n  \t\tthis.setZoom(this._limitZoom(this._zoom));\r\n  \t\tif (!this.options.zoomSnap) {\r\n  \t\t\tthis.fire('viewreset');\r\n  \t\t}\r\n  \t\treturn this._stop();\r\n  \t},\r\n\r\n  \t// @section Geolocation methods\r\n  \t// @method locate(options?: Locate options): this\r\n  \t// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\r\n  \t// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\r\n  \t// and optionally sets the map view to the user's location with respect to\r\n  \t// detection accuracy (or to the world view if geolocation failed).\r\n  \t// Note that, if your page doesn't use HTTPS, this method will fail in\r\n  \t// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\r\n  \t// See `Locate options` for more details.\r\n  \tlocate: function (options) {\r\n\r\n  \t\toptions = this._locateOptions = extend({\r\n  \t\t\ttimeout: 10000,\r\n  \t\t\twatch: false\r\n  \t\t\t// setView: false\r\n  \t\t\t// maxZoom: <Number>\r\n  \t\t\t// maximumAge: 0\r\n  \t\t\t// enableHighAccuracy: false\r\n  \t\t}, options);\r\n\r\n  \t\tif (!('geolocation' in navigator)) {\r\n  \t\t\tthis._handleGeolocationError({\r\n  \t\t\t\tcode: 0,\r\n  \t\t\t\tmessage: 'Geolocation not supported.'\r\n  \t\t\t});\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tvar onResponse = bind(this._handleGeolocationResponse, this),\r\n  \t\t    onError = bind(this._handleGeolocationError, this);\r\n\r\n  \t\tif (options.watch) {\r\n  \t\t\tthis._locationWatchId =\r\n  \t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n  \t\t} else {\r\n  \t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method stopLocate(): this\r\n  \t// Stops watching location previously initiated by `map.locate({watch: true})`\r\n  \t// and aborts resetting the map view if map.locate was called with\r\n  \t// `{setView: true}`.\r\n  \tstopLocate: function () {\r\n  \t\tif (navigator.geolocation && navigator.geolocation.clearWatch) {\r\n  \t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n  \t\t}\r\n  \t\tif (this._locateOptions) {\r\n  \t\t\tthis._locateOptions.setView = false;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_handleGeolocationError: function (error) {\r\n  \t\tif (!this._container._leaflet_id) { return; }\r\n\r\n  \t\tvar c = error.code,\r\n  \t\t    message = error.message ||\r\n  \t\t            (c === 1 ? 'permission denied' :\r\n  \t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n  \t\tif (this._locateOptions.setView && !this._loaded) {\r\n  \t\t\tthis.fitWorld();\r\n  \t\t}\r\n\r\n  \t\t// @section Location events\r\n  \t\t// @event locationerror: ErrorEvent\r\n  \t\t// Fired when geolocation (using the [`locate`](#map-locate) method) failed.\r\n  \t\tthis.fire('locationerror', {\r\n  \t\t\tcode: c,\r\n  \t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n  \t\t});\r\n  \t},\r\n\r\n  \t_handleGeolocationResponse: function (pos) {\r\n  \t\tif (!this._container._leaflet_id) { return; }\r\n\r\n  \t\tvar lat = pos.coords.latitude,\r\n  \t\t    lng = pos.coords.longitude,\r\n  \t\t    latlng = new LatLng(lat, lng),\r\n  \t\t    bounds = latlng.toBounds(pos.coords.accuracy * 2),\r\n  \t\t    options = this._locateOptions;\r\n\r\n  \t\tif (options.setView) {\r\n  \t\t\tvar zoom = this.getBoundsZoom(bounds);\r\n  \t\t\tthis.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\r\n  \t\t}\r\n\r\n  \t\tvar data = {\r\n  \t\t\tlatlng: latlng,\r\n  \t\t\tbounds: bounds,\r\n  \t\t\ttimestamp: pos.timestamp\r\n  \t\t};\r\n\r\n  \t\tfor (var i in pos.coords) {\r\n  \t\t\tif (typeof pos.coords[i] === 'number') {\r\n  \t\t\t\tdata[i] = pos.coords[i];\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// @event locationfound: LocationEvent\r\n  \t\t// Fired when geolocation (using the [`locate`](#map-locate) method)\r\n  \t\t// went successfully.\r\n  \t\tthis.fire('locationfound', data);\r\n  \t},\r\n\r\n  \t// TODO Appropriate docs section?\r\n  \t// @section Other Methods\r\n  \t// @method addHandler(name: String, HandlerClass: Function): this\r\n  \t// Adds a new `Handler` to the map, given its name and constructor function.\r\n  \taddHandler: function (name, HandlerClass) {\r\n  \t\tif (!HandlerClass) { return this; }\r\n\r\n  \t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n  \t\tthis._handlers.push(handler);\r\n\r\n  \t\tif (this.options[name]) {\r\n  \t\t\thandler.enable();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method remove(): this\r\n  \t// Destroys the map and clears all related event listeners.\r\n  \tremove: function () {\r\n\r\n  \t\tthis._initEvents(true);\r\n  \t\tif (this.options.maxBounds) { this.off('moveend', this._panInsideMaxBounds); }\r\n\r\n  \t\tif (this._containerId !== this._container._leaflet_id) {\r\n  \t\t\tthrow new Error('Map container is being reused by another instance');\r\n  \t\t}\r\n\r\n  \t\ttry {\r\n  \t\t\t// throws error in IE6-8\r\n  \t\t\tdelete this._container._leaflet_id;\r\n  \t\t\tdelete this._containerId;\r\n  \t\t} catch (e) {\r\n  \t\t\t/*eslint-disable */\r\n  \t\t\tthis._container._leaflet_id = undefined;\r\n  \t\t\t/* eslint-enable */\r\n  \t\t\tthis._containerId = undefined;\r\n  \t\t}\r\n\r\n  \t\tif (this._locationWatchId !== undefined) {\r\n  \t\t\tthis.stopLocate();\r\n  \t\t}\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tremove(this._mapPane);\r\n\r\n  \t\tif (this._clearControlPos) {\r\n  \t\t\tthis._clearControlPos();\r\n  \t\t}\r\n  \t\tif (this._resizeRequest) {\r\n  \t\t\tcancelAnimFrame(this._resizeRequest);\r\n  \t\t\tthis._resizeRequest = null;\r\n  \t\t}\r\n\r\n  \t\tthis._clearHandlers();\r\n\r\n  \t\tif (this._loaded) {\r\n  \t\t\t// @section Map state change events\r\n  \t\t\t// @event unload: Event\r\n  \t\t\t// Fired when the map is destroyed with [remove](#map-remove) method.\r\n  \t\t\tthis.fire('unload');\r\n  \t\t}\r\n\r\n  \t\tvar i;\r\n  \t\tfor (i in this._layers) {\r\n  \t\t\tthis._layers[i].remove();\r\n  \t\t}\r\n  \t\tfor (i in this._panes) {\r\n  \t\t\tremove(this._panes[i]);\r\n  \t\t}\r\n\r\n  \t\tthis._layers = [];\r\n  \t\tthis._panes = [];\r\n  \t\tdelete this._mapPane;\r\n  \t\tdelete this._renderer;\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n  \t// @method createPane(name: String, container?: HTMLElement): HTMLElement\r\n  \t// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\r\n  \t// then returns it. The pane is created as a child of `container`, or\r\n  \t// as a child of the main map pane if not set.\r\n  \tcreatePane: function (name, container) {\r\n  \t\tvar className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\r\n  \t\t    pane = create$1('div', className, container || this._mapPane);\r\n\r\n  \t\tif (name) {\r\n  \t\t\tthis._panes[name] = pane;\r\n  \t\t}\r\n  \t\treturn pane;\r\n  \t},\r\n\r\n  \t// @section Methods for Getting Map State\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the geographical center of the map view\r\n  \tgetCenter: function () {\r\n  \t\tthis._checkIfLoaded();\r\n\r\n  \t\tif (this._lastCenter && !this._moved()) {\r\n  \t\t\treturn this._lastCenter.clone();\r\n  \t\t}\r\n  \t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n  \t},\r\n\r\n  \t// @method getZoom(): Number\r\n  \t// Returns the current zoom level of the map view\r\n  \tgetZoom: function () {\r\n  \t\treturn this._zoom;\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Returns the geographical bounds visible in the current map view\r\n  \tgetBounds: function () {\r\n  \t\tvar bounds = this.getPixelBounds(),\r\n  \t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n  \t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n  \t\treturn new LatLngBounds(sw, ne);\r\n  \t},\r\n\r\n  \t// @method getMinZoom(): Number\r\n  \t// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\r\n  \tgetMinZoom: function () {\r\n  \t\treturn this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\r\n  \t},\r\n\r\n  \t// @method getMaxZoom(): Number\r\n  \t// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\r\n  \tgetMaxZoom: function () {\r\n  \t\treturn this.options.maxZoom === undefined ?\r\n  \t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n  \t\t\tthis.options.maxZoom;\r\n  \t},\r\n\r\n  \t// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\r\n  \t// Returns the maximum zoom level on which the given bounds fit to the map\r\n  \t// view in its entirety. If `inside` (optional) is set to `true`, the method\r\n  \t// instead returns the minimum zoom level on which the map view fits into\r\n  \t// the given bounds in its entirety.\r\n  \tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n  \t\tpadding = toPoint(padding || [0, 0]);\r\n\r\n  \t\tvar zoom = this.getZoom() || 0,\r\n  \t\t    min = this.getMinZoom(),\r\n  \t\t    max = this.getMaxZoom(),\r\n  \t\t    nw = bounds.getNorthWest(),\r\n  \t\t    se = bounds.getSouthEast(),\r\n  \t\t    size = this.getSize().subtract(padding),\r\n  \t\t    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\r\n  \t\t    snap = Browser.any3d ? this.options.zoomSnap : 1,\r\n  \t\t    scalex = size.x / boundsSize.x,\r\n  \t\t    scaley = size.y / boundsSize.y,\r\n  \t\t    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\r\n\r\n  \t\tzoom = this.getScaleZoom(scale, zoom);\r\n\r\n  \t\tif (snap) {\r\n  \t\t\tzoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\r\n  \t\t\tzoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\r\n  \t\t}\r\n\r\n  \t\treturn Math.max(min, Math.min(max, zoom));\r\n  \t},\r\n\r\n  \t// @method getSize(): Point\r\n  \t// Returns the current size of the map container (in pixels).\r\n  \tgetSize: function () {\r\n  \t\tif (!this._size || this._sizeChanged) {\r\n  \t\t\tthis._size = new Point(\r\n  \t\t\t\tthis._container.clientWidth || 0,\r\n  \t\t\t\tthis._container.clientHeight || 0);\r\n\r\n  \t\t\tthis._sizeChanged = false;\r\n  \t\t}\r\n  \t\treturn this._size.clone();\r\n  \t},\r\n\r\n  \t// @method getPixelBounds(): Bounds\r\n  \t// Returns the bounds of the current map view in projected pixel\r\n  \t// coordinates (sometimes useful in layer and overlay implementations).\r\n  \tgetPixelBounds: function (center, zoom) {\r\n  \t\tvar topLeftPoint = this._getTopLeftPoint(center, zoom);\r\n  \t\treturn new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n  \t},\r\n\r\n  \t// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\r\n  \t// the map pane? \"left point of the map layer\" can be confusing, specially\r\n  \t// since there can be negative offsets.\r\n  \t// @method getPixelOrigin(): Point\r\n  \t// Returns the projected pixel coordinates of the top left point of\r\n  \t// the map layer (useful in custom layer and overlay implementations).\r\n  \tgetPixelOrigin: function () {\r\n  \t\tthis._checkIfLoaded();\r\n  \t\treturn this._pixelOrigin;\r\n  \t},\r\n\r\n  \t// @method getPixelWorldBounds(zoom?: Number): Bounds\r\n  \t// Returns the world's bounds in pixel coordinates for zoom level `zoom`.\r\n  \t// If `zoom` is omitted, the map's current zoom level is used.\r\n  \tgetPixelWorldBounds: function (zoom) {\r\n  \t\treturn this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n\r\n  \t// @method getPane(pane: String|HTMLElement): HTMLElement\r\n  \t// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\r\n  \tgetPane: function (pane) {\r\n  \t\treturn typeof pane === 'string' ? this._panes[pane] : pane;\r\n  \t},\r\n\r\n  \t// @method getPanes(): Object\r\n  \t// Returns a plain object containing the names of all [panes](#map-pane) as keys and\r\n  \t// the panes as values.\r\n  \tgetPanes: function () {\r\n  \t\treturn this._panes;\r\n  \t},\r\n\r\n  \t// @method getContainer: HTMLElement\r\n  \t// Returns the HTML element that contains the map.\r\n  \tgetContainer: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n\r\n  \t// @section Conversion Methods\r\n\r\n  \t// @method getZoomScale(toZoom: Number, fromZoom: Number): Number\r\n  \t// Returns the scale factor to be applied to a map transition from zoom level\r\n  \t// `fromZoom` to `toZoom`. Used internally to help with zoom animations.\r\n  \tgetZoomScale: function (toZoom, fromZoom) {\r\n  \t\t// TODO replace with universal implementation after refactoring projections\r\n  \t\tvar crs = this.options.crs;\r\n  \t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n  \t\treturn crs.scale(toZoom) / crs.scale(fromZoom);\r\n  \t},\r\n\r\n  \t// @method getScaleZoom(scale: Number, fromZoom: Number): Number\r\n  \t// Returns the zoom level that the map would end up at, if it is at `fromZoom`\r\n  \t// level and everything is scaled by a factor of `scale`. Inverse of\r\n  \t// [`getZoomScale`](#map-getZoomScale).\r\n  \tgetScaleZoom: function (scale, fromZoom) {\r\n  \t\tvar crs = this.options.crs;\r\n  \t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n  \t\tvar zoom = crs.zoom(scale * crs.scale(fromZoom));\r\n  \t\treturn isNaN(zoom) ? Infinity : zoom;\r\n  \t},\r\n\r\n  \t// @method project(latlng: LatLng, zoom: Number): Point\r\n  \t// Projects a geographical coordinate `LatLng` according to the projection\r\n  \t// of the map's CRS, then scales it according to `zoom` and the CRS's\r\n  \t// `Transformation`. The result is pixel coordinate relative to\r\n  \t// the CRS origin.\r\n  \tproject: function (latlng, zoom) {\r\n  \t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n  \t\treturn this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\r\n  \t},\r\n\r\n  \t// @method unproject(point: Point, zoom: Number): LatLng\r\n  \t// Inverse of [`project`](#map-project).\r\n  \tunproject: function (point, zoom) {\r\n  \t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n  \t\treturn this.options.crs.pointToLatLng(toPoint(point), zoom);\r\n  \t},\r\n\r\n  \t// @method layerPointToLatLng(point: Point): LatLng\r\n  \t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n  \t// returns the corresponding geographical coordinate (for the current zoom level).\r\n  \tlayerPointToLatLng: function (point) {\r\n  \t\tvar projectedPoint = toPoint(point).add(this.getPixelOrigin());\r\n  \t\treturn this.unproject(projectedPoint);\r\n  \t},\r\n\r\n  \t// @method latLngToLayerPoint(latlng: LatLng): Point\r\n  \t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n  \t// relative to the [origin pixel](#map-getpixelorigin).\r\n  \tlatLngToLayerPoint: function (latlng) {\r\n  \t\tvar projectedPoint = this.project(toLatLng(latlng))._round();\r\n  \t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n  \t},\r\n\r\n  \t// @method wrapLatLng(latlng: LatLng): LatLng\r\n  \t// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\r\n  \t// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\r\n  \t// CRS's bounds.\r\n  \t// By default this means longitude is wrapped around the dateline so its\r\n  \t// value is between -180 and +180 degrees.\r\n  \twrapLatLng: function (latlng) {\r\n  \t\treturn this.options.crs.wrapLatLng(toLatLng(latlng));\r\n  \t},\r\n\r\n  \t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n  \t// Returns a `LatLngBounds` with the same size as the given one, ensuring that\r\n  \t// its center is within the CRS's bounds.\r\n  \t// By default this means the center longitude is wrapped around the dateline so its\r\n  \t// value is between -180 and +180 degrees, and the majority of the bounds\r\n  \t// overlaps the CRS's bounds.\r\n  \twrapLatLngBounds: function (latlng) {\r\n  \t\treturn this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\r\n  \t},\r\n\r\n  \t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n  \t// Returns the distance between two geographical coordinates according to\r\n  \t// the map's CRS. By default this measures distance in meters.\r\n  \tdistance: function (latlng1, latlng2) {\r\n  \t\treturn this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\r\n  \t},\r\n\r\n  \t// @method containerPointToLayerPoint(point: Point): Point\r\n  \t// Given a pixel coordinate relative to the map container, returns the corresponding\r\n  \t// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\r\n  \tcontainerPointToLayerPoint: function (point) { // (Point)\r\n  \t\treturn toPoint(point).subtract(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t// @method layerPointToContainerPoint(point: Point): Point\r\n  \t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n  \t// returns the corresponding pixel coordinate relative to the map container.\r\n  \tlayerPointToContainerPoint: function (point) { // (Point)\r\n  \t\treturn toPoint(point).add(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t// @method containerPointToLatLng(point: Point): LatLng\r\n  \t// Given a pixel coordinate relative to the map container, returns\r\n  \t// the corresponding geographical coordinate (for the current zoom level).\r\n  \tcontainerPointToLatLng: function (point) {\r\n  \t\tvar layerPoint = this.containerPointToLayerPoint(toPoint(point));\r\n  \t\treturn this.layerPointToLatLng(layerPoint);\r\n  \t},\r\n\r\n  \t// @method latLngToContainerPoint(latlng: LatLng): Point\r\n  \t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n  \t// relative to the map container.\r\n  \tlatLngToContainerPoint: function (latlng) {\r\n  \t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\r\n  \t},\r\n\r\n  \t// @method mouseEventToContainerPoint(ev: MouseEvent): Point\r\n  \t// Given a MouseEvent object, returns the pixel coordinate relative to the\r\n  \t// map container where the event took place.\r\n  \tmouseEventToContainerPoint: function (e) {\r\n  \t\treturn getMousePosition(e, this._container);\r\n  \t},\r\n\r\n  \t// @method mouseEventToLayerPoint(ev: MouseEvent): Point\r\n  \t// Given a MouseEvent object, returns the pixel coordinate relative to\r\n  \t// the [origin pixel](#map-getpixelorigin) where the event took place.\r\n  \tmouseEventToLayerPoint: function (e) {\r\n  \t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n  \t},\r\n\r\n  \t// @method mouseEventToLatLng(ev: MouseEvent): LatLng\r\n  \t// Given a MouseEvent object, returns geographical coordinate where the\r\n  \t// event took place.\r\n  \tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n  \t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n  \t},\r\n\r\n\r\n  \t// map initialization methods\r\n\r\n  \t_initContainer: function (id) {\r\n  \t\tvar container = this._container = get(id);\r\n\r\n  \t\tif (!container) {\r\n  \t\t\tthrow new Error('Map container not found.');\r\n  \t\t} else if (container._leaflet_id) {\r\n  \t\t\tthrow new Error('Map container is already initialized.');\r\n  \t\t}\r\n\r\n  \t\ton(container, 'scroll', this._onScroll, this);\r\n  \t\tthis._containerId = stamp(container);\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar container = this._container;\r\n\r\n  \t\tthis._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\r\n\r\n  \t\taddClass(container, 'leaflet-container' +\r\n  \t\t\t(Browser.touch ? ' leaflet-touch' : '') +\r\n  \t\t\t(Browser.retina ? ' leaflet-retina' : '') +\r\n  \t\t\t(Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n  \t\t\t(Browser.safari ? ' leaflet-safari' : '') +\r\n  \t\t\t(this._fadeAnimated ? ' leaflet-fade-anim' : ''));\r\n\r\n  \t\tvar position = getStyle(container, 'position');\r\n\r\n  \t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\r\n  \t\t\tcontainer.style.position = 'relative';\r\n  \t\t}\r\n\r\n  \t\tthis._initPanes();\r\n\r\n  \t\tif (this._initControlPos) {\r\n  \t\t\tthis._initControlPos();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_initPanes: function () {\r\n  \t\tvar panes = this._panes = {};\r\n  \t\tthis._paneRenderers = {};\r\n\r\n  \t\t// @section\r\n  \t\t//\r\n  \t\t// Panes are DOM elements used to control the ordering of layers on the map. You\r\n  \t\t// can access panes with [`map.getPane`](#map-getpane) or\r\n  \t\t// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\r\n  \t\t// [`map.createPane`](#map-createpane) method.\r\n  \t\t//\r\n  \t\t// Every map has the following default panes that differ only in zIndex.\r\n  \t\t//\r\n  \t\t// @pane mapPane: HTMLElement = 'auto'\r\n  \t\t// Pane that contains all other map panes\r\n\r\n  \t\tthis._mapPane = this.createPane('mapPane', this._container);\r\n  \t\tsetPosition(this._mapPane, new Point(0, 0));\r\n\r\n  \t\t// @pane tilePane: HTMLElement = 200\r\n  \t\t// Pane for `GridLayer`s and `TileLayer`s\r\n  \t\tthis.createPane('tilePane');\r\n  \t\t// @pane overlayPane: HTMLElement = 400\r\n  \t\t// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\r\n  \t\tthis.createPane('overlayPane');\r\n  \t\t// @pane shadowPane: HTMLElement = 500\r\n  \t\t// Pane for overlay shadows (e.g. `Marker` shadows)\r\n  \t\tthis.createPane('shadowPane');\r\n  \t\t// @pane markerPane: HTMLElement = 600\r\n  \t\t// Pane for `Icon`s of `Marker`s\r\n  \t\tthis.createPane('markerPane');\r\n  \t\t// @pane tooltipPane: HTMLElement = 650\r\n  \t\t// Pane for `Tooltip`s.\r\n  \t\tthis.createPane('tooltipPane');\r\n  \t\t// @pane popupPane: HTMLElement = 700\r\n  \t\t// Pane for `Popup`s.\r\n  \t\tthis.createPane('popupPane');\r\n\r\n  \t\tif (!this.options.markerZoomAnimation) {\r\n  \t\t\taddClass(panes.markerPane, 'leaflet-zoom-hide');\r\n  \t\t\taddClass(panes.shadowPane, 'leaflet-zoom-hide');\r\n  \t\t}\r\n  \t},\r\n\r\n\r\n  \t// private methods that modify map state\r\n\r\n  \t// @section Map state change events\r\n  \t_resetView: function (center, zoom, noMoveStart) {\r\n  \t\tsetPosition(this._mapPane, new Point(0, 0));\r\n\r\n  \t\tvar loading = !this._loaded;\r\n  \t\tthis._loaded = true;\r\n  \t\tzoom = this._limitZoom(zoom);\r\n\r\n  \t\tthis.fire('viewprereset');\r\n\r\n  \t\tvar zoomChanged = this._zoom !== zoom;\r\n  \t\tthis\r\n  \t\t\t._moveStart(zoomChanged, noMoveStart)\r\n  \t\t\t._move(center, zoom)\r\n  \t\t\t._moveEnd(zoomChanged);\r\n\r\n  \t\t// @event viewreset: Event\r\n  \t\t// Fired when the map needs to redraw its content (this usually happens\r\n  \t\t// on map zoom or load). Very useful for creating custom overlays.\r\n  \t\tthis.fire('viewreset');\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the map is initialized (when its center and zoom are set\r\n  \t\t// for the first time).\r\n  \t\tif (loading) {\r\n  \t\t\tthis.fire('load');\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_moveStart: function (zoomChanged, noMoveStart) {\r\n  \t\t// @event zoomstart: Event\r\n  \t\t// Fired when the map zoom is about to change (e.g. before zoom animation).\r\n  \t\t// @event movestart: Event\r\n  \t\t// Fired when the view of the map starts changing (e.g. user starts dragging the map).\r\n  \t\tif (zoomChanged) {\r\n  \t\t\tthis.fire('zoomstart');\r\n  \t\t}\r\n  \t\tif (!noMoveStart) {\r\n  \t\t\tthis.fire('movestart');\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_move: function (center, zoom, data, supressEvent) {\r\n  \t\tif (zoom === undefined) {\r\n  \t\t\tzoom = this._zoom;\r\n  \t\t}\r\n  \t\tvar zoomChanged = this._zoom !== zoom;\r\n\r\n  \t\tthis._zoom = zoom;\r\n  \t\tthis._lastCenter = center;\r\n  \t\tthis._pixelOrigin = this._getNewPixelOrigin(center);\r\n\r\n  \t\tif (!supressEvent) {\r\n  \t\t\t// @event zoom: Event\r\n  \t\t\t// Fired repeatedly during any change in zoom level,\r\n  \t\t\t// including zoom and fly animations.\r\n  \t\t\tif (zoomChanged || (data && data.pinch)) {\t// Always fire 'zoom' if pinching because #3530\r\n  \t\t\t\tthis.fire('zoom', data);\r\n  \t\t\t}\r\n\r\n  \t\t\t// @event move: Event\r\n  \t\t\t// Fired repeatedly during any movement of the map,\r\n  \t\t\t// including pan and fly animations.\r\n  \t\t\tthis.fire('move', data);\r\n  \t\t} else if (data && data.pinch) {\t// Always fire 'zoom' if pinching because #3530\r\n  \t\t\tthis.fire('zoom', data);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_moveEnd: function (zoomChanged) {\r\n  \t\t// @event zoomend: Event\r\n  \t\t// Fired when the map zoom changed, after any animations.\r\n  \t\tif (zoomChanged) {\r\n  \t\t\tthis.fire('zoomend');\r\n  \t\t}\r\n\r\n  \t\t// @event moveend: Event\r\n  \t\t// Fired when the center of the map stops changing\r\n  \t\t// (e.g. user stopped dragging the map or after non-centered zoom).\r\n  \t\treturn this.fire('moveend');\r\n  \t},\r\n\r\n  \t_stop: function () {\r\n  \t\tcancelAnimFrame(this._flyToFrame);\r\n  \t\tif (this._panAnim) {\r\n  \t\t\tthis._panAnim.stop();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_rawPanBy: function (offset) {\r\n  \t\tsetPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n  \t},\r\n\r\n  \t_getZoomSpan: function () {\r\n  \t\treturn this.getMaxZoom() - this.getMinZoom();\r\n  \t},\r\n\r\n  \t_panInsideMaxBounds: function () {\r\n  \t\tif (!this._enforcingBounds) {\r\n  \t\t\tthis.panInsideBounds(this.options.maxBounds);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_checkIfLoaded: function () {\r\n  \t\tif (!this._loaded) {\r\n  \t\t\tthrow new Error('Set map center and zoom first.');\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// DOM event handling\r\n\r\n  \t// @section Interaction events\r\n  \t_initEvents: function (remove) {\r\n  \t\tthis._targets = {};\r\n  \t\tthis._targets[stamp(this._container)] = this;\r\n\r\n  \t\tvar onOff = remove ? off : on;\r\n\r\n  \t\t// @event click: MouseEvent\r\n  \t\t// Fired when the user clicks (or taps) the map.\r\n  \t\t// @event dblclick: MouseEvent\r\n  \t\t// Fired when the user double-clicks (or double-taps) the map.\r\n  \t\t// @event mousedown: MouseEvent\r\n  \t\t// Fired when the user pushes the mouse button on the map.\r\n  \t\t// @event mouseup: MouseEvent\r\n  \t\t// Fired when the user releases the mouse button on the map.\r\n  \t\t// @event mouseover: MouseEvent\r\n  \t\t// Fired when the mouse enters the map.\r\n  \t\t// @event mouseout: MouseEvent\r\n  \t\t// Fired when the mouse leaves the map.\r\n  \t\t// @event mousemove: MouseEvent\r\n  \t\t// Fired while the mouse moves over the map.\r\n  \t\t// @event contextmenu: MouseEvent\r\n  \t\t// Fired when the user pushes the right mouse button on the map, prevents\r\n  \t\t// default browser context menu from showing if there are listeners on\r\n  \t\t// this event. Also fired on mobile when the user holds a single touch\r\n  \t\t// for a second (also called long press).\r\n  \t\t// @event keypress: KeyboardEvent\r\n  \t\t// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\r\n  \t\t// @event keydown: KeyboardEvent\r\n  \t\t// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\r\n  \t\t// the `keydown` event is fired for keys that produce a character value and for keys\r\n  \t\t// that do not produce a character value.\r\n  \t\t// @event keyup: KeyboardEvent\r\n  \t\t// Fired when the user releases a key from the keyboard while the map is focused.\r\n  \t\tonOff(this._container, 'click dblclick mousedown mouseup ' +\r\n  \t\t\t'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\r\n\r\n  \t\tif (this.options.trackResize) {\r\n  \t\t\tonOff(window, 'resize', this._onResize, this);\r\n  \t\t}\r\n\r\n  \t\tif (Browser.any3d && this.options.transform3DLimit) {\r\n  \t\t\t(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_onResize: function () {\r\n  \t\tcancelAnimFrame(this._resizeRequest);\r\n  \t\tthis._resizeRequest = requestAnimFrame(\r\n  \t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this);\r\n  \t},\r\n\r\n  \t_onScroll: function () {\r\n  \t\tthis._container.scrollTop  = 0;\r\n  \t\tthis._container.scrollLeft = 0;\r\n  \t},\r\n\r\n  \t_onMoveEnd: function () {\r\n  \t\tvar pos = this._getMapPanePos();\r\n  \t\tif (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\r\n  \t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\r\n  \t\t\t// a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\r\n  \t\t\tthis._resetView(this.getCenter(), this.getZoom());\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_findEventTargets: function (e, type) {\r\n  \t\tvar targets = [],\r\n  \t\t    target,\r\n  \t\t    isHover = type === 'mouseout' || type === 'mouseover',\r\n  \t\t    src = e.target || e.srcElement,\r\n  \t\t    dragging = false;\r\n\r\n  \t\twhile (src) {\r\n  \t\t\ttarget = this._targets[stamp(src)];\r\n  \t\t\tif (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\r\n  \t\t\t\t// Prevent firing click after you just dragged an object.\r\n  \t\t\t\tdragging = true;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t\tif (target && target.listens(type, true)) {\r\n  \t\t\t\tif (isHover && !isExternalTarget(src, e)) { break; }\r\n  \t\t\t\ttargets.push(target);\r\n  \t\t\t\tif (isHover) { break; }\r\n  \t\t\t}\r\n  \t\t\tif (src === this._container) { break; }\r\n  \t\t\tsrc = src.parentNode;\r\n  \t\t}\r\n  \t\tif (!targets.length && !dragging && !isHover && this.listens(type, true)) {\r\n  \t\t\ttargets = [this];\r\n  \t\t}\r\n  \t\treturn targets;\r\n  \t},\r\n\r\n  \t_isClickDisabled: function (el) {\r\n  \t\twhile (el && el !== this._container) {\r\n  \t\t\tif (el['_leaflet_disable_click']) { return true; }\r\n  \t\t\tel = el.parentNode;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_handleDOMEvent: function (e) {\r\n  \t\tvar el = (e.target || e.srcElement);\r\n  \t\tif (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar type = e.type;\r\n\r\n  \t\tif (type === 'mousedown') {\r\n  \t\t\t// prevents outline when clicking on keyboard-focusable element\r\n  \t\t\tpreventOutline(el);\r\n  \t\t}\r\n\r\n  \t\tthis._fireDOMEvent(e, type);\r\n  \t},\r\n\r\n  \t_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\r\n\r\n  \t_fireDOMEvent: function (e, type, canvasTargets) {\r\n\r\n  \t\tif (e.type === 'click') {\r\n  \t\t\t// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\r\n  \t\t\t// @event preclick: MouseEvent\r\n  \t\t\t// Fired before mouse click on the map (sometimes useful when you\r\n  \t\t\t// want something to happen on click before any existing click\r\n  \t\t\t// handlers start running).\r\n  \t\t\tvar synth = extend({}, e);\r\n  \t\t\tsynth.type = 'preclick';\r\n  \t\t\tthis._fireDOMEvent(synth, synth.type, canvasTargets);\r\n  \t\t}\r\n\r\n  \t\t// Find the layer the event is propagating from and its parents.\r\n  \t\tvar targets = this._findEventTargets(e, type);\r\n\r\n  \t\tif (canvasTargets) {\r\n  \t\t\tvar filtered = []; // pick only targets with listeners\r\n  \t\t\tfor (var i = 0; i < canvasTargets.length; i++) {\r\n  \t\t\t\tif (canvasTargets[i].listens(type, true)) {\r\n  \t\t\t\t\tfiltered.push(canvasTargets[i]);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\ttargets = filtered.concat(targets);\r\n  \t\t}\r\n\r\n  \t\tif (!targets.length) { return; }\r\n\r\n  \t\tif (type === 'contextmenu') {\r\n  \t\t\tpreventDefault(e);\r\n  \t\t}\r\n\r\n  \t\tvar target = targets[0];\r\n  \t\tvar data = {\r\n  \t\t\toriginalEvent: e\r\n  \t\t};\r\n\r\n  \t\tif (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\r\n  \t\t\tvar isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\r\n  \t\t\tdata.containerPoint = isMarker ?\r\n  \t\t\t\tthis.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\r\n  \t\t\tdata.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\r\n  \t\t\tdata.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\r\n  \t\t}\r\n\r\n  \t\tfor (i = 0; i < targets.length; i++) {\r\n  \t\t\ttargets[i].fire(type, data, true);\r\n  \t\t\tif (data.originalEvent._stopped ||\r\n  \t\t\t\t(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_draggableMoved: function (obj) {\r\n  \t\tobj = obj.dragging && obj.dragging.enabled() ? obj : this;\r\n  \t\treturn (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());\r\n  \t},\r\n\r\n  \t_clearHandlers: function () {\r\n  \t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n  \t\t\tthis._handlers[i].disable();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n\r\n  \t// @method whenReady(fn: Function, context?: Object): this\r\n  \t// Runs the given function `fn` when the map gets initialized with\r\n  \t// a view (center and zoom) and at least one layer, or immediately\r\n  \t// if it's already initialized, optionally passing a function context.\r\n  \twhenReady: function (callback, context) {\r\n  \t\tif (this._loaded) {\r\n  \t\t\tcallback.call(context || this, {target: this});\r\n  \t\t} else {\r\n  \t\t\tthis.on('load', callback, context);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n\r\n  \t// private methods for getting map state\r\n\r\n  \t_getMapPanePos: function () {\r\n  \t\treturn getPosition(this._mapPane) || new Point(0, 0);\r\n  \t},\r\n\r\n  \t_moved: function () {\r\n  \t\tvar pos = this._getMapPanePos();\r\n  \t\treturn pos && !pos.equals([0, 0]);\r\n  \t},\r\n\r\n  \t_getTopLeftPoint: function (center, zoom) {\r\n  \t\tvar pixelOrigin = center && zoom !== undefined ?\r\n  \t\t\tthis._getNewPixelOrigin(center, zoom) :\r\n  \t\t\tthis.getPixelOrigin();\r\n  \t\treturn pixelOrigin.subtract(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t_getNewPixelOrigin: function (center, zoom) {\r\n  \t\tvar viewHalf = this.getSize()._divideBy(2);\r\n  \t\treturn this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\r\n  \t},\r\n\r\n  \t_latLngToNewLayerPoint: function (latlng, zoom, center) {\r\n  \t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n  \t\treturn this.project(latlng, zoom)._subtract(topLeft);\r\n  \t},\r\n\r\n  \t_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\r\n  \t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n  \t\treturn toBounds([\r\n  \t\t\tthis.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)\r\n  \t\t]);\r\n  \t},\r\n\r\n  \t// layer point of the current center\r\n  \t_getCenterLayerPoint: function () {\r\n  \t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n  \t},\r\n\r\n  \t// offset of the specified place to the current center in pixels\r\n  \t_getCenterOffset: function (latlng) {\r\n  \t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n  \t},\r\n\r\n  \t// adjust center for view to get inside bounds\r\n  \t_limitCenter: function (center, zoom, bounds) {\r\n\r\n  \t\tif (!bounds) { return center; }\r\n\r\n  \t\tvar centerPoint = this.project(center, zoom),\r\n  \t\t    viewHalf = this.getSize().divideBy(2),\r\n  \t\t    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n  \t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n  \t\t// If offset is less than a pixel, ignore.\r\n  \t\t// This prevents unstable projections from getting into\r\n  \t\t// an infinite loop of tiny offsets.\r\n  \t\tif (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\r\n  \t\t\treturn center;\r\n  \t\t}\r\n\r\n  \t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n  \t},\r\n\r\n  \t// adjust offset for view to get inside bounds\r\n  \t_limitOffset: function (offset, bounds) {\r\n  \t\tif (!bounds) { return offset; }\r\n\r\n  \t\tvar viewBounds = this.getPixelBounds(),\r\n  \t\t    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n  \t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n  \t},\r\n\r\n  \t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n  \t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n  \t\tvar projectedMaxBounds = toBounds(\r\n  \t\t        this.project(maxBounds.getNorthEast(), zoom),\r\n  \t\t        this.project(maxBounds.getSouthWest(), zoom)\r\n  \t\t    ),\r\n  \t\t    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\r\n  \t\t    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\r\n\r\n  \t\t    dx = this._rebound(minOffset.x, -maxOffset.x),\r\n  \t\t    dy = this._rebound(minOffset.y, -maxOffset.y);\r\n\r\n  \t\treturn new Point(dx, dy);\r\n  \t},\r\n\r\n  \t_rebound: function (left, right) {\r\n  \t\treturn left + right > 0 ?\r\n  \t\t\tMath.round(left - right) / 2 :\r\n  \t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n  \t},\r\n\r\n  \t_limitZoom: function (zoom) {\r\n  \t\tvar min = this.getMinZoom(),\r\n  \t\t    max = this.getMaxZoom(),\r\n  \t\t    snap = Browser.any3d ? this.options.zoomSnap : 1;\r\n  \t\tif (snap) {\r\n  \t\t\tzoom = Math.round(zoom / snap) * snap;\r\n  \t\t}\r\n  \t\treturn Math.max(min, Math.min(max, zoom));\r\n  \t},\r\n\r\n  \t_onPanTransitionStep: function () {\r\n  \t\tthis.fire('move');\r\n  \t},\r\n\r\n  \t_onPanTransitionEnd: function () {\r\n  \t\tremoveClass(this._mapPane, 'leaflet-pan-anim');\r\n  \t\tthis.fire('moveend');\r\n  \t},\r\n\r\n  \t_tryAnimatedPan: function (center, options) {\r\n  \t\t// difference between the new and current centers in pixels\r\n  \t\tvar offset = this._getCenterOffset(center)._trunc();\r\n\r\n  \t\t// don't animate too far unless animate: true specified in options\r\n  \t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n  \t\tthis.panBy(offset, options);\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_createAnimProxy: function () {\r\n\r\n  \t\tvar proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\r\n  \t\tthis._panes.mapPane.appendChild(proxy);\r\n\r\n  \t\tthis.on('zoomanim', function (e) {\r\n  \t\t\tvar prop = TRANSFORM,\r\n  \t\t\t    transform = this._proxy.style[prop];\r\n\r\n  \t\t\tsetTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\r\n\r\n  \t\t\t// workaround for case when transform is the same and so transitionend event is not fired\r\n  \t\t\tif (transform === this._proxy.style[prop] && this._animatingZoom) {\r\n  \t\t\t\tthis._onZoomTransitionEnd();\r\n  \t\t\t}\r\n  \t\t}, this);\r\n\r\n  \t\tthis.on('load moveend', this._animMoveEnd, this);\r\n\r\n  \t\tthis._on('unload', this._destroyAnimProxy, this);\r\n  \t},\r\n\r\n  \t_destroyAnimProxy: function () {\r\n  \t\tremove(this._proxy);\r\n  \t\tthis.off('load moveend', this._animMoveEnd, this);\r\n  \t\tdelete this._proxy;\r\n  \t},\r\n\r\n  \t_animMoveEnd: function () {\r\n  \t\tvar c = this.getCenter(),\r\n  \t\t    z = this.getZoom();\r\n  \t\tsetTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\r\n  \t},\r\n\r\n  \t_catchTransitionEnd: function (e) {\r\n  \t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\r\n  \t\t\tthis._onZoomTransitionEnd();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_nothingToAnimate: function () {\r\n  \t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\r\n  \t},\r\n\r\n  \t_tryAnimatedZoom: function (center, zoom, options) {\r\n\r\n  \t\tif (this._animatingZoom) { return true; }\r\n\r\n  \t\toptions = options || {};\r\n\r\n  \t\t// don't animate if disabled, not supported or zoom difference is too large\r\n  \t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\r\n  \t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\r\n\r\n  \t\t// offset is the pixel coords of the zoom origin relative to the current center\r\n  \t\tvar scale = this.getZoomScale(zoom),\r\n  \t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\r\n\r\n  \t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\r\n  \t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n  \t\trequestAnimFrame(function () {\r\n  \t\t\tthis\r\n  \t\t\t    ._moveStart(true, options.noMoveStart || false)\r\n  \t\t\t    ._animateZoom(center, zoom, true);\r\n  \t\t}, this);\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_animateZoom: function (center, zoom, startAnim, noUpdate) {\r\n  \t\tif (!this._mapPane) { return; }\r\n\r\n  \t\tif (startAnim) {\r\n  \t\t\tthis._animatingZoom = true;\r\n\r\n  \t\t\t// remember what center/zoom to set after animation\r\n  \t\t\tthis._animateToCenter = center;\r\n  \t\t\tthis._animateToZoom = zoom;\r\n\r\n  \t\t\taddClass(this._mapPane, 'leaflet-zoom-anim');\r\n  \t\t}\r\n\r\n  \t\t// @section Other Events\r\n  \t\t// @event zoomanim: ZoomAnimEvent\r\n  \t\t// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\r\n  \t\tthis.fire('zoomanim', {\r\n  \t\t\tcenter: center,\r\n  \t\t\tzoom: zoom,\r\n  \t\t\tnoUpdate: noUpdate\r\n  \t\t});\r\n\r\n  \t\tif (!this._tempFireZoomEvent) {\r\n  \t\t\tthis._tempFireZoomEvent = this._zoom !== this._animateToZoom;\r\n  \t\t}\r\n\r\n  \t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n  \t\t// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\r\n  \t\tsetTimeout(bind(this._onZoomTransitionEnd, this), 250);\r\n  \t},\r\n\r\n  \t_onZoomTransitionEnd: function () {\r\n  \t\tif (!this._animatingZoom) { return; }\r\n\r\n  \t\tif (this._mapPane) {\r\n  \t\t\tremoveClass(this._mapPane, 'leaflet-zoom-anim');\r\n  \t\t}\r\n\r\n  \t\tthis._animatingZoom = false;\r\n\r\n  \t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n  \t\tif (this._tempFireZoomEvent) {\r\n  \t\t\tthis.fire('zoom');\r\n  \t\t}\r\n  \t\tdelete this._tempFireZoomEvent;\r\n\r\n  \t\tthis.fire('move');\r\n\r\n  \t\tthis._moveEnd(true);\r\n  \t}\r\n  });\r\n\r\n  // @section\r\n\r\n  // @factory L.map(id: String, options?: Map options)\r\n  // Instantiates a map object given the DOM ID of a `<div>` element\r\n  // and optionally an object literal with `Map options`.\r\n  //\r\n  // @alternative\r\n  // @factory L.map(el: HTMLElement, options?: Map options)\r\n  // Instantiates a map object given an instance of a `<div>` HTML element\r\n  // and optionally an object literal with `Map options`.\r\n  function createMap(id, options) {\r\n  \treturn new Map(id, options);\r\n  }\n\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\r\n\r\n  var Control = Class.extend({\r\n  \t// @section\r\n  \t// @aka Control Options\r\n  \toptions: {\r\n  \t\t// @option position: String = 'topright'\r\n  \t\t// The position of the control (one of the map corners). Possible values are `'topleft'`,\r\n  \t\t// `'topright'`, `'bottomleft'` or `'bottomright'`\r\n  \t\tposition: 'topright'\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \t/* @section\r\n  \t * Classes extending L.Control will inherit the following methods:\r\n  \t *\r\n  \t * @method getPosition: string\r\n  \t * Returns the position of the control.\r\n  \t */\r\n  \tgetPosition: function () {\r\n  \t\treturn this.options.position;\r\n  \t},\r\n\r\n  \t// @method setPosition(position: string): this\r\n  \t// Sets the position of the control.\r\n  \tsetPosition: function (position) {\r\n  \t\tvar map = this._map;\r\n\r\n  \t\tif (map) {\r\n  \t\t\tmap.removeControl(this);\r\n  \t\t}\r\n\r\n  \t\tthis.options.position = position;\r\n\r\n  \t\tif (map) {\r\n  \t\t\tmap.addControl(this);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getContainer: HTMLElement\r\n  \t// Returns the HTMLElement that contains the control.\r\n  \tgetContainer: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \t// @method addTo(map: Map): this\r\n  \t// Adds the control to the given map.\r\n  \taddTo: function (map) {\r\n  \t\tthis.remove();\r\n  \t\tthis._map = map;\r\n\r\n  \t\tvar container = this._container = this.onAdd(map),\r\n  \t\t    pos = this.getPosition(),\r\n  \t\t    corner = map._controlCorners[pos];\r\n\r\n  \t\taddClass(container, 'leaflet-control');\r\n\r\n  \t\tif (pos.indexOf('bottom') !== -1) {\r\n  \t\t\tcorner.insertBefore(container, corner.firstChild);\r\n  \t\t} else {\r\n  \t\t\tcorner.appendChild(container);\r\n  \t\t}\r\n\r\n  \t\tthis._map.on('unload', this.remove, this);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method remove: this\r\n  \t// Removes the control from the map it is currently active on.\r\n  \tremove: function () {\r\n  \t\tif (!this._map) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tremove(this._container);\r\n\r\n  \t\tif (this.onRemove) {\r\n  \t\t\tthis.onRemove(this._map);\r\n  \t\t}\r\n\r\n  \t\tthis._map.off('unload', this.remove, this);\r\n  \t\tthis._map = null;\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_refocusOnMap: function (e) {\r\n  \t\t// if map exists and event is not a keyboard event\r\n  \t\tif (this._map && e && e.screenX > 0 && e.screenY > 0) {\r\n  \t\t\tthis._map.getContainer().focus();\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  var control = function (options) {\r\n  \treturn new Control(options);\r\n  };\r\n\r\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\r\n\r\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\r\n  Map.include({\r\n  \t// @method addControl(control: Control): this\r\n  \t// Adds the given control to the map\r\n  \taddControl: function (control) {\r\n  \t\tcontrol.addTo(this);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeControl(control: Control): this\r\n  \t// Removes the given control from the map\r\n  \tremoveControl: function (control) {\r\n  \t\tcontrol.remove();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initControlPos: function () {\r\n  \t\tvar corners = this._controlCorners = {},\r\n  \t\t    l = 'leaflet-',\r\n  \t\t    container = this._controlContainer =\r\n  \t\t            create$1('div', l + 'control-container', this._container);\r\n\r\n  \t\tfunction createCorner(vSide, hSide) {\r\n  \t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n  \t\t\tcorners[vSide + hSide] = create$1('div', className, container);\r\n  \t\t}\r\n\r\n  \t\tcreateCorner('top', 'left');\r\n  \t\tcreateCorner('top', 'right');\r\n  \t\tcreateCorner('bottom', 'left');\r\n  \t\tcreateCorner('bottom', 'right');\r\n  \t},\r\n\r\n  \t_clearControlPos: function () {\r\n  \t\tfor (var i in this._controlCorners) {\r\n  \t\t\tremove(this._controlCorners[i]);\r\n  \t\t}\r\n  \t\tremove(this._controlContainer);\r\n  \t\tdelete this._controlCorners;\r\n  \t\tdelete this._controlContainer;\r\n  \t}\r\n  });\n\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\r\n\r\n  var Layers = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Layers options\r\n  \toptions: {\r\n  \t\t// @option collapsed: Boolean = true\r\n  \t\t// If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\r\n  \t\tcollapsed: true,\r\n  \t\tposition: 'topright',\r\n\r\n  \t\t// @option autoZIndex: Boolean = true\r\n  \t\t// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\r\n  \t\tautoZIndex: true,\r\n\r\n  \t\t// @option hideSingleBase: Boolean = false\r\n  \t\t// If `true`, the base layers in the control will be hidden when there is only one.\r\n  \t\thideSingleBase: false,\r\n\r\n  \t\t// @option sortLayers: Boolean = false\r\n  \t\t// Whether to sort the layers. When `false`, layers will keep the order\r\n  \t\t// in which they were added to the control.\r\n  \t\tsortLayers: false,\r\n\r\n  \t\t// @option sortFunction: Function = *\r\n  \t\t// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\r\n  \t\t// that will be used for sorting the layers, when `sortLayers` is `true`.\r\n  \t\t// The function receives both the `L.Layer` instances and their names, as in\r\n  \t\t// `sortFunction(layerA, layerB, nameA, nameB)`.\r\n  \t\t// By default, it sorts layers alphabetically by their name.\r\n  \t\tsortFunction: function (layerA, layerB, nameA, nameB) {\r\n  \t\t\treturn nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tinitialize: function (baseLayers, overlays, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layerControlInputs = [];\r\n  \t\tthis._layers = [];\r\n  \t\tthis._lastZIndex = 0;\r\n  \t\tthis._handlingClick = false;\r\n  \t\tthis._preventClick = false;\r\n\r\n  \t\tfor (var i in baseLayers) {\r\n  \t\t\tthis._addLayer(baseLayers[i], i);\r\n  \t\t}\r\n\r\n  \t\tfor (i in overlays) {\r\n  \t\t\tthis._addLayer(overlays[i], i, true);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._initLayout();\r\n  \t\tthis._update();\r\n\r\n  \t\tthis._map = map;\r\n  \t\tmap.on('zoomend', this._checkDisabledLayers, this);\r\n\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n  \t\t\tthis._layers[i].layer.on('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \taddTo: function (map) {\r\n  \t\tControl.prototype.addTo.call(this, map);\r\n  \t\t// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\r\n  \t\treturn this._expandIfNotCollapsed();\r\n  \t},\r\n\r\n  \tonRemove: function () {\r\n  \t\tthis._map.off('zoomend', this._checkDisabledLayers, this);\r\n\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n  \t\t\tthis._layers[i].layer.off('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addBaseLayer(layer: Layer, name: String): this\r\n  \t// Adds a base layer (radio button entry) with the given name to the control.\r\n  \taddBaseLayer: function (layer, name) {\r\n  \t\tthis._addLayer(layer, name);\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method addOverlay(layer: Layer, name: String): this\r\n  \t// Adds an overlay (checkbox entry) with the given name to the control.\r\n  \taddOverlay: function (layer, name) {\r\n  \t\tthis._addLayer(layer, name, true);\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method removeLayer(layer: Layer): this\r\n  \t// Remove the given layer from the control.\r\n  \tremoveLayer: function (layer) {\r\n  \t\tlayer.off('add remove', this._onLayerChange, this);\r\n\r\n  \t\tvar obj = this._getLayer(stamp(layer));\r\n  \t\tif (obj) {\r\n  \t\t\tthis._layers.splice(this._layers.indexOf(obj), 1);\r\n  \t\t}\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method expand(): this\r\n  \t// Expand the control container if collapsed.\r\n  \texpand: function () {\r\n  \t\taddClass(this._container, 'leaflet-control-layers-expanded');\r\n  \t\tthis._section.style.height = null;\r\n  \t\tvar acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\r\n  \t\tif (acceptableHeight < this._section.clientHeight) {\r\n  \t\t\taddClass(this._section, 'leaflet-control-layers-scrollbar');\r\n  \t\t\tthis._section.style.height = acceptableHeight + 'px';\r\n  \t\t} else {\r\n  \t\t\tremoveClass(this._section, 'leaflet-control-layers-scrollbar');\r\n  \t\t}\r\n  \t\tthis._checkDisabledLayers();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method collapse(): this\r\n  \t// Collapse the control container if expanded.\r\n  \tcollapse: function () {\r\n  \t\tremoveClass(this._container, 'leaflet-control-layers-expanded');\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar className = 'leaflet-control-layers',\r\n  \t\t    container = this._container = create$1('div', className),\r\n  \t\t    collapsed = this.options.collapsed;\r\n\r\n  \t\t// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\r\n  \t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n  \t\tdisableClickPropagation(container);\r\n  \t\tdisableScrollPropagation(container);\r\n\r\n  \t\tvar section = this._section = create$1('section', className + '-list');\r\n\r\n  \t\tif (collapsed) {\r\n  \t\t\tthis._map.on('click', this.collapse, this);\r\n\r\n  \t\t\ton(container, {\r\n  \t\t\t\tmouseenter: this._expandSafely,\r\n  \t\t\t\tmouseleave: this.collapse\r\n  \t\t\t}, this);\r\n  \t\t}\r\n\r\n  \t\tvar link = this._layersLink = create$1('a', className + '-toggle', container);\r\n  \t\tlink.href = '#';\r\n  \t\tlink.title = 'Layers';\r\n  \t\tlink.setAttribute('role', 'button');\r\n\r\n  \t\ton(link, {\r\n  \t\t\tkeydown: function (e) {\r\n  \t\t\t\tif (e.keyCode === 13) {\r\n  \t\t\t\t\tthis._expandSafely();\r\n  \t\t\t\t}\r\n  \t\t\t},\r\n  \t\t\t// Certain screen readers intercept the key event and instead send a click event\r\n  \t\t\tclick: function (e) {\r\n  \t\t\t\tpreventDefault(e);\r\n  \t\t\t\tthis._expandSafely();\r\n  \t\t\t}\r\n  \t\t}, this);\r\n\r\n  \t\tif (!collapsed) {\r\n  \t\t\tthis.expand();\r\n  \t\t}\r\n\r\n  \t\tthis._baseLayersList = create$1('div', className + '-base', section);\r\n  \t\tthis._separator = create$1('div', className + '-separator', section);\r\n  \t\tthis._overlaysList = create$1('div', className + '-overlays', section);\r\n\r\n  \t\tcontainer.appendChild(section);\r\n  \t},\r\n\r\n  \t_getLayer: function (id) {\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n\r\n  \t\t\tif (this._layers[i] && stamp(this._layers[i].layer) === id) {\r\n  \t\t\t\treturn this._layers[i];\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_addLayer: function (layer, name, overlay) {\r\n  \t\tif (this._map) {\r\n  \t\t\tlayer.on('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n\r\n  \t\tthis._layers.push({\r\n  \t\t\tlayer: layer,\r\n  \t\t\tname: name,\r\n  \t\t\toverlay: overlay\r\n  \t\t});\r\n\r\n  \t\tif (this.options.sortLayers) {\r\n  \t\t\tthis._layers.sort(bind(function (a, b) {\r\n  \t\t\t\treturn this.options.sortFunction(a.layer, b.layer, a.name, b.name);\r\n  \t\t\t}, this));\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n  \t\t\tthis._lastZIndex++;\r\n  \t\t\tlayer.setZIndex(this._lastZIndex);\r\n  \t\t}\r\n\r\n  \t\tthis._expandIfNotCollapsed();\r\n  \t},\r\n\r\n  \t_update: function () {\r\n  \t\tif (!this._container) { return this; }\r\n\r\n  \t\tempty(this._baseLayersList);\r\n  \t\tempty(this._overlaysList);\r\n\r\n  \t\tthis._layerControlInputs = [];\r\n  \t\tvar baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;\r\n\r\n  \t\tfor (i = 0; i < this._layers.length; i++) {\r\n  \t\t\tobj = this._layers[i];\r\n  \t\t\tthis._addItem(obj);\r\n  \t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n  \t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n  \t\t\tbaseLayersCount += !obj.overlay ? 1 : 0;\r\n  \t\t}\r\n\r\n  \t\t// Hide base layers section if there's only one layer.\r\n  \t\tif (this.options.hideSingleBase) {\r\n  \t\t\tbaseLayersPresent = baseLayersPresent && baseLayersCount > 1;\r\n  \t\t\tthis._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\r\n  \t\t}\r\n\r\n  \t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_onLayerChange: function (e) {\r\n  \t\tif (!this._handlingClick) {\r\n  \t\t\tthis._update();\r\n  \t\t}\r\n\r\n  \t\tvar obj = this._getLayer(stamp(e.target));\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Layer events\r\n  \t\t// @event baselayerchange: LayersControlEvent\r\n  \t\t// Fired when the base layer is changed through the [layers control](#control-layers).\r\n  \t\t// @event overlayadd: LayersControlEvent\r\n  \t\t// Fired when an overlay is selected through the [layers control](#control-layers).\r\n  \t\t// @event overlayremove: LayersControlEvent\r\n  \t\t// Fired when an overlay is deselected through the [layers control](#control-layers).\r\n  \t\t// @namespace Control.Layers\r\n  \t\tvar type = obj.overlay ?\r\n  \t\t\t(e.type === 'add' ? 'overlayadd' : 'overlayremove') :\r\n  \t\t\t(e.type === 'add' ? 'baselayerchange' : null);\r\n\r\n  \t\tif (type) {\r\n  \t\t\tthis._map.fire(type, obj);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\r\n  \t_createRadioElement: function (name, checked) {\r\n\r\n  \t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' +\r\n  \t\t\t\tname + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\r\n\r\n  \t\tvar radioFragment = document.createElement('div');\r\n  \t\tradioFragment.innerHTML = radioHtml;\r\n\r\n  \t\treturn radioFragment.firstChild;\r\n  \t},\r\n\r\n  \t_addItem: function (obj) {\r\n  \t\tvar label = document.createElement('label'),\r\n  \t\t    checked = this._map.hasLayer(obj.layer),\r\n  \t\t    input;\r\n\r\n  \t\tif (obj.overlay) {\r\n  \t\t\tinput = document.createElement('input');\r\n  \t\t\tinput.type = 'checkbox';\r\n  \t\t\tinput.className = 'leaflet-control-layers-selector';\r\n  \t\t\tinput.defaultChecked = checked;\r\n  \t\t} else {\r\n  \t\t\tinput = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\r\n  \t\t}\r\n\r\n  \t\tthis._layerControlInputs.push(input);\r\n  \t\tinput.layerId = stamp(obj.layer);\r\n\r\n  \t\ton(input, 'click', this._onInputClick, this);\r\n\r\n  \t\tvar name = document.createElement('span');\r\n  \t\tname.innerHTML = ' ' + obj.name;\r\n\r\n  \t\t// Helps from preventing layer control flicker when checkboxes are disabled\r\n  \t\t// https://github.com/Leaflet/Leaflet/issues/2771\r\n  \t\tvar holder = document.createElement('span');\r\n\r\n  \t\tlabel.appendChild(holder);\r\n  \t\tholder.appendChild(input);\r\n  \t\tholder.appendChild(name);\r\n\r\n  \t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n  \t\tcontainer.appendChild(label);\r\n\r\n  \t\tthis._checkDisabledLayers();\r\n  \t\treturn label;\r\n  \t},\r\n\r\n  \t_onInputClick: function () {\r\n  \t\t// expanding the control on mobile with a click can cause adding a layer - we don't want this\r\n  \t\tif (this._preventClick) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar inputs = this._layerControlInputs,\r\n  \t\t    input, layer;\r\n  \t\tvar addedLayers = [],\r\n  \t\t    removedLayers = [];\r\n\r\n  \t\tthis._handlingClick = true;\r\n\r\n  \t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n  \t\t\tinput = inputs[i];\r\n  \t\t\tlayer = this._getLayer(input.layerId).layer;\r\n\r\n  \t\t\tif (input.checked) {\r\n  \t\t\t\taddedLayers.push(layer);\r\n  \t\t\t} else if (!input.checked) {\r\n  \t\t\t\tremovedLayers.push(layer);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// Bugfix issue 2318: Should remove all old layers before readding new ones\r\n  \t\tfor (i = 0; i < removedLayers.length; i++) {\r\n  \t\t\tif (this._map.hasLayer(removedLayers[i])) {\r\n  \t\t\t\tthis._map.removeLayer(removedLayers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tfor (i = 0; i < addedLayers.length; i++) {\r\n  \t\t\tif (!this._map.hasLayer(addedLayers[i])) {\r\n  \t\t\t\tthis._map.addLayer(addedLayers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._handlingClick = false;\r\n\r\n  \t\tthis._refocusOnMap();\r\n  \t},\r\n\r\n  \t_checkDisabledLayers: function () {\r\n  \t\tvar inputs = this._layerControlInputs,\r\n  \t\t    input,\r\n  \t\t    layer,\r\n  \t\t    zoom = this._map.getZoom();\r\n\r\n  \t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n  \t\t\tinput = inputs[i];\r\n  \t\t\tlayer = this._getLayer(input.layerId).layer;\r\n  \t\t\tinput.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||\r\n  \t\t\t                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);\r\n\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_expandIfNotCollapsed: function () {\r\n  \t\tif (this._map && !this.options.collapsed) {\r\n  \t\t\tthis.expand();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_expandSafely: function () {\r\n  \t\tvar section = this._section;\r\n  \t\tthis._preventClick = true;\r\n  \t\ton(section, 'click', preventDefault);\r\n  \t\tthis.expand();\r\n  \t\tvar that = this;\r\n  \t\tsetTimeout(function () {\r\n  \t\t\toff(section, 'click', preventDefault);\r\n  \t\t\tthat._preventClick = false;\r\n  \t\t});\r\n  \t}\r\n\r\n  });\r\n\r\n\r\n  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\r\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\r\n  var layers = function (baseLayers, overlays, options) {\r\n  \treturn new Layers(baseLayers, overlays, options);\r\n  };\n\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\r\n\r\n  var Zoom = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Zoom options\r\n  \toptions: {\r\n  \t\tposition: 'topleft',\r\n\r\n  \t\t// @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\r\n  \t\t// The text set on the 'zoom in' button.\r\n  \t\tzoomInText: '<span aria-hidden=\"true\">+</span>',\r\n\r\n  \t\t// @option zoomInTitle: String = 'Zoom in'\r\n  \t\t// The title set on the 'zoom in' button.\r\n  \t\tzoomInTitle: 'Zoom in',\r\n\r\n  \t\t// @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\r\n  \t\t// The text set on the 'zoom out' button.\r\n  \t\tzoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\r\n\r\n  \t\t// @option zoomOutTitle: String = 'Zoom out'\r\n  \t\t// The title set on the 'zoom out' button.\r\n  \t\tzoomOutTitle: 'Zoom out'\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tvar zoomName = 'leaflet-control-zoom',\r\n  \t\t    container = create$1('div', zoomName + ' leaflet-bar'),\r\n  \t\t    options = this.options;\r\n\r\n  \t\tthis._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,\r\n  \t\t        zoomName + '-in',  container, this._zoomIn);\r\n  \t\tthis._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,\r\n  \t\t        zoomName + '-out', container, this._zoomOut);\r\n\r\n  \t\tthis._updateDisabled();\r\n  \t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n  \t\treturn container;\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n  \t},\r\n\r\n  \tdisable: function () {\r\n  \t\tthis._disabled = true;\r\n  \t\tthis._updateDisabled();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tenable: function () {\r\n  \t\tthis._disabled = false;\r\n  \t\tthis._updateDisabled();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_zoomIn: function (e) {\r\n  \t\tif (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\r\n  \t\t\tthis._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_zoomOut: function (e) {\r\n  \t\tif (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\r\n  \t\t\tthis._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_createButton: function (html, title, className, container, fn) {\r\n  \t\tvar link = create$1('a', className, container);\r\n  \t\tlink.innerHTML = html;\r\n  \t\tlink.href = '#';\r\n  \t\tlink.title = title;\r\n\r\n  \t\t/*\r\n  \t\t * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n  \t\t */\r\n  \t\tlink.setAttribute('role', 'button');\r\n  \t\tlink.setAttribute('aria-label', title);\r\n\r\n  \t\tdisableClickPropagation(link);\r\n  \t\ton(link, 'click', stop);\r\n  \t\ton(link, 'click', fn, this);\r\n  \t\ton(link, 'click', this._refocusOnMap, this);\r\n\r\n  \t\treturn link;\r\n  \t},\r\n\r\n  \t_updateDisabled: function () {\r\n  \t\tvar map = this._map,\r\n  \t\t    className = 'leaflet-disabled';\r\n\r\n  \t\tremoveClass(this._zoomInButton, className);\r\n  \t\tremoveClass(this._zoomOutButton, className);\r\n  \t\tthis._zoomInButton.setAttribute('aria-disabled', 'false');\r\n  \t\tthis._zoomOutButton.setAttribute('aria-disabled', 'false');\r\n\r\n  \t\tif (this._disabled || map._zoom === map.getMinZoom()) {\r\n  \t\t\taddClass(this._zoomOutButton, className);\r\n  \t\t\tthis._zoomOutButton.setAttribute('aria-disabled', 'true');\r\n  \t\t}\r\n  \t\tif (this._disabled || map._zoom === map.getMaxZoom()) {\r\n  \t\t\taddClass(this._zoomInButton, className);\r\n  \t\t\tthis._zoomInButton.setAttribute('aria-disabled', 'true');\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  // @namespace Map\r\n  // @section Control options\r\n  // @option zoomControl: Boolean = true\r\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\r\n  Map.mergeOptions({\r\n  \tzoomControl: true\r\n  });\r\n\r\n  Map.addInitHook(function () {\r\n  \tif (this.options.zoomControl) {\r\n  \t\t// @section Controls\r\n  \t\t// @property zoomControl: Control.Zoom\r\n  \t\t// The default zoom control (only available if the\r\n  \t\t// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\r\n  \t\tthis.zoomControl = new Zoom();\r\n  \t\tthis.addControl(this.zoomControl);\r\n  \t}\r\n  });\r\n\r\n  // @namespace Control.Zoom\r\n  // @factory L.control.zoom(options: Control.Zoom options)\r\n  // Creates a zoom control\r\n  var zoom = function (options) {\r\n  \treturn new Zoom(options);\r\n  };\n\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n  var Scale = Control.extend({\n  \t// @section\n  \t// @aka Control.Scale options\n  \toptions: {\n  \t\tposition: 'bottomleft',\n\n  \t\t// @option maxWidth: Number = 100\n  \t\t// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n  \t\tmaxWidth: 100,\n\n  \t\t// @option metric: Boolean = True\n  \t\t// Whether to show the metric scale line (m/km).\n  \t\tmetric: true,\n\n  \t\t// @option imperial: Boolean = True\n  \t\t// Whether to show the imperial scale line (mi/ft).\n  \t\timperial: true\n\n  \t\t// @option updateWhenIdle: Boolean = false\n  \t\t// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n  \t},\n\n  \tonAdd: function (map) {\n  \t\tvar className = 'leaflet-control-scale',\n  \t\t    container = create$1('div', className),\n  \t\t    options = this.options;\n\n  \t\tthis._addScales(options, className + '-line', container);\n\n  \t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n  \t\tmap.whenReady(this._update, this);\n\n  \t\treturn container;\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n  \t},\n\n  \t_addScales: function (options, className, container) {\n  \t\tif (options.metric) {\n  \t\t\tthis._mScale = create$1('div', className, container);\n  \t\t}\n  \t\tif (options.imperial) {\n  \t\t\tthis._iScale = create$1('div', className, container);\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\tvar map = this._map,\n  \t\t    y = map.getSize().y / 2;\n\n  \t\tvar maxMeters = map.distance(\n  \t\t\tmap.containerPointToLatLng([0, y]),\n  \t\t\tmap.containerPointToLatLng([this.options.maxWidth, y]));\n\n  \t\tthis._updateScales(maxMeters);\n  \t},\n\n  \t_updateScales: function (maxMeters) {\n  \t\tif (this.options.metric && maxMeters) {\n  \t\t\tthis._updateMetric(maxMeters);\n  \t\t}\n  \t\tif (this.options.imperial && maxMeters) {\n  \t\t\tthis._updateImperial(maxMeters);\n  \t\t}\n  \t},\n\n  \t_updateMetric: function (maxMeters) {\n  \t\tvar meters = this._getRoundNum(maxMeters),\n  \t\t    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\n  \t\tthis._updateScale(this._mScale, label, meters / maxMeters);\n  \t},\n\n  \t_updateImperial: function (maxMeters) {\n  \t\tvar maxFeet = maxMeters * 3.2808399,\n  \t\t    maxMiles, miles, feet;\n\n  \t\tif (maxFeet > 5280) {\n  \t\t\tmaxMiles = maxFeet / 5280;\n  \t\t\tmiles = this._getRoundNum(maxMiles);\n  \t\t\tthis._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n\n  \t\t} else {\n  \t\t\tfeet = this._getRoundNum(maxFeet);\n  \t\t\tthis._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n  \t\t}\n  \t},\n\n  \t_updateScale: function (scale, text, ratio) {\n  \t\tscale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n  \t\tscale.innerHTML = text;\n  \t},\n\n  \t_getRoundNum: function (num) {\n  \t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n  \t\t    d = num / pow10;\n\n  \t\td = d >= 10 ? 10 :\n  \t\t    d >= 5 ? 5 :\n  \t\t    d >= 3 ? 3 :\n  \t\t    d >= 2 ? 2 : 1;\n\n  \t\treturn pow10 * d;\n  \t}\n  });\n\n\n  // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n  var scale = function (options) {\n  \treturn new Scale(options);\n  };\n\n  var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\r\n\r\n\r\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\r\n\r\n  var Attribution = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Attribution options\r\n  \toptions: {\r\n  \t\tposition: 'bottomright',\r\n\r\n  \t\t// @option prefix: String|false = 'Leaflet'\r\n  \t\t// The HTML text shown before the attributions. Pass `false` to disable.\r\n  \t\tprefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._attributions = {};\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tmap.attributionControl = this;\r\n  \t\tthis._container = create$1('div', 'leaflet-control-attribution');\r\n  \t\tdisableClickPropagation(this._container);\r\n\r\n  \t\t// TODO ugly, refactor\r\n  \t\tfor (var i in map._layers) {\r\n  \t\t\tif (map._layers[i].getAttribution) {\r\n  \t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._update();\r\n\r\n  \t\tmap.on('layeradd', this._addAttribution, this);\r\n\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tmap.off('layeradd', this._addAttribution, this);\r\n  \t},\r\n\r\n  \t_addAttribution: function (ev) {\r\n  \t\tif (ev.layer.getAttribution) {\r\n  \t\t\tthis.addAttribution(ev.layer.getAttribution());\r\n  \t\t\tev.layer.once('remove', function () {\r\n  \t\t\t\tthis.removeAttribution(ev.layer.getAttribution());\r\n  \t\t\t}, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setPrefix(prefix: String|false): this\r\n  \t// The HTML text shown before the attributions. Pass `false` to disable.\r\n  \tsetPrefix: function (prefix) {\r\n  \t\tthis.options.prefix = prefix;\r\n  \t\tthis._update();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method addAttribution(text: String): this\r\n  \t// Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\r\n  \taddAttribution: function (text) {\r\n  \t\tif (!text) { return this; }\r\n\r\n  \t\tif (!this._attributions[text]) {\r\n  \t\t\tthis._attributions[text] = 0;\r\n  \t\t}\r\n  \t\tthis._attributions[text]++;\r\n\r\n  \t\tthis._update();\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeAttribution(text: String): this\r\n  \t// Removes an attribution text.\r\n  \tremoveAttribution: function (text) {\r\n  \t\tif (!text) { return this; }\r\n\r\n  \t\tif (this._attributions[text]) {\r\n  \t\t\tthis._attributions[text]--;\r\n  \t\t\tthis._update();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_update: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tvar attribs = [];\r\n\r\n  \t\tfor (var i in this._attributions) {\r\n  \t\t\tif (this._attributions[i]) {\r\n  \t\t\t\tattribs.push(i);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tvar prefixAndAttribs = [];\r\n\r\n  \t\tif (this.options.prefix) {\r\n  \t\t\tprefixAndAttribs.push(this.options.prefix);\r\n  \t\t}\r\n  \t\tif (attribs.length) {\r\n  \t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n  \t\t}\r\n\r\n  \t\tthis._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\r\n  \t}\r\n  });\r\n\r\n  // @namespace Map\r\n  // @section Control options\r\n  // @option attributionControl: Boolean = true\r\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\r\n  Map.mergeOptions({\r\n  \tattributionControl: true\r\n  });\r\n\r\n  Map.addInitHook(function () {\r\n  \tif (this.options.attributionControl) {\r\n  \t\tnew Attribution().addTo(this);\r\n  \t}\r\n  });\r\n\r\n  // @namespace Control.Attribution\r\n  // @factory L.control.attribution(options: Control.Attribution options)\r\n  // Creates an attribution control.\r\n  var attribution = function (options) {\r\n  \treturn new Attribution(options);\r\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n  \t},\n\n  \t// @method enable(): this\n  \t// Enables the handler\n  \tenable: function () {\n  \t\tif (this._enabled) { return this; }\n\n  \t\tthis._enabled = true;\n  \t\tthis.addHooks();\n  \t\treturn this;\n  \t},\n\n  \t// @method disable(): this\n  \t// Disables the handler\n  \tdisable: function () {\n  \t\tif (!this._enabled) { return this; }\n\n  \t\tthis._enabled = false;\n  \t\tthis.removeHooks();\n  \t\treturn this;\n  \t},\n\n  \t// @method enabled(): Boolean\n  \t// Returns `true` if the handler is enabled\n  \tenabled: function () {\n  \t\treturn !!this._enabled;\n  \t}\n\n  \t// @section Extension methods\n  \t// Classes inheriting from `Handler` must implement the two following methods:\n  \t// @method addHooks()\n  \t// Called when the handler is enabled, should add event hooks.\n  \t// @method removeHooks()\n  \t// Called when the handler is disabled, should remove the event hooks added previously.\n  });\n\n  // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n  Handler.addTo = function (map, name) {\n  \tmap.addHandler(name, this);\n  \treturn this;\n  };\n\n  var Mixin = {Events: Events};\n\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\r\n\r\n  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\r\n\r\n  var Draggable = Evented.extend({\r\n\r\n  \toptions: {\r\n  \t\t// @section\r\n  \t\t// @aka Draggable options\r\n  \t\t// @option clickTolerance: Number = 3\r\n  \t\t// The max number of pixels a user can shift the mouse pointer during a click\r\n  \t\t// for it to be considered a valid click (as opposed to a mouse drag).\r\n  \t\tclickTolerance: 3\r\n  \t},\r\n\r\n  \t// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\r\n  \t// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\r\n  \tinitialize: function (element, dragStartTarget, preventOutline, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._element = element;\r\n  \t\tthis._dragStartTarget = dragStartTarget || element;\r\n  \t\tthis._preventOutline = preventOutline;\r\n  \t},\r\n\r\n  \t// @method enable()\r\n  \t// Enables the dragging ability\r\n  \tenable: function () {\r\n  \t\tif (this._enabled) { return; }\r\n\r\n  \t\ton(this._dragStartTarget, START, this._onDown, this);\r\n\r\n  \t\tthis._enabled = true;\r\n  \t},\r\n\r\n  \t// @method disable()\r\n  \t// Disables the dragging ability\r\n  \tdisable: function () {\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\t// If we're currently dragging this draggable,\r\n  \t\t// disabling it counts as first ending the drag.\r\n  \t\tif (Draggable._dragging === this) {\r\n  \t\t\tthis.finishDrag(true);\r\n  \t\t}\r\n\r\n  \t\toff(this._dragStartTarget, START, this._onDown, this);\r\n\r\n  \t\tthis._enabled = false;\r\n  \t\tthis._moved = false;\r\n  \t},\r\n\r\n  \t_onDown: function (e) {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\tthis._moved = false;\r\n\r\n  \t\tif (hasClass(this._element, 'leaflet-zoom-anim')) { return; }\r\n\r\n  \t\tif (e.touches && e.touches.length !== 1) {\r\n  \t\t\t// Finish dragging to avoid conflict with touchZoom\r\n  \t\t\tif (Draggable._dragging === this) {\r\n  \t\t\t\tthis.finishDrag();\r\n  \t\t\t}\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n  \t\tDraggable._dragging = this;  // Prevent dragging multiple objects at once.\r\n\r\n  \t\tif (this._preventOutline) {\r\n  \t\t\tpreventOutline(this._element);\r\n  \t\t}\r\n\r\n  \t\tdisableImageDrag();\r\n  \t\tdisableTextSelection();\r\n\r\n  \t\tif (this._moving) { return; }\r\n\r\n  \t\t// @event down: Event\r\n  \t\t// Fired when a drag is about to start.\r\n  \t\tthis.fire('down');\r\n\r\n  \t\tvar first = e.touches ? e.touches[0] : e,\r\n  \t\t    sizedParent = getSizedParentNode(this._element);\r\n\r\n  \t\tthis._startPoint = new Point(first.clientX, first.clientY);\r\n  \t\tthis._startPos = getPosition(this._element);\r\n\r\n  \t\t// Cache the scale, so that we can continuously compensate for it during drag (_onMove).\r\n  \t\tthis._parentScale = getScale(sizedParent);\r\n\r\n  \t\tvar mouseevent = e.type === 'mousedown';\r\n  \t\ton(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);\r\n  \t\ton(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);\r\n  \t},\r\n\r\n  \t_onMove: function (e) {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\tif (e.touches && e.touches.length > 1) {\r\n  \t\t\tthis._moved = true;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n  \t\t    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\r\n\r\n  \t\tif (!offset.x && !offset.y) { return; }\r\n  \t\tif (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }\r\n\r\n  \t\t// We assume that the parent container's position, border and scale do not change for the duration of the drag.\r\n  \t\t// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\r\n  \t\t// and we can use the cached value for the scale.\r\n  \t\toffset.x /= this._parentScale.x;\r\n  \t\toffset.y /= this._parentScale.y;\r\n\r\n  \t\tpreventDefault(e);\r\n\r\n  \t\tif (!this._moved) {\r\n  \t\t\t// @event dragstart: Event\r\n  \t\t\t// Fired when a drag starts\r\n  \t\t\tthis.fire('dragstart');\r\n\r\n  \t\t\tthis._moved = true;\r\n\r\n  \t\t\taddClass(document.body, 'leaflet-dragging');\r\n\r\n  \t\t\tthis._lastTarget = e.target || e.srcElement;\r\n  \t\t\t// IE and Edge do not give the <use> element, so fetch it\r\n  \t\t\t// if necessary\r\n  \t\t\tif (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\r\n  \t\t\t\tthis._lastTarget = this._lastTarget.correspondingUseElement;\r\n  \t\t\t}\r\n  \t\t\taddClass(this._lastTarget, 'leaflet-drag-target');\r\n  \t\t}\r\n\r\n  \t\tthis._newPos = this._startPos.add(offset);\r\n  \t\tthis._moving = true;\r\n\r\n  \t\tthis._lastEvent = e;\r\n  \t\tthis._updatePosition();\r\n  \t},\r\n\r\n  \t_updatePosition: function () {\r\n  \t\tvar e = {originalEvent: this._lastEvent};\r\n\r\n  \t\t// @event predrag: Event\r\n  \t\t// Fired continuously during dragging *before* each corresponding\r\n  \t\t// update of the element's position.\r\n  \t\tthis.fire('predrag', e);\r\n  \t\tsetPosition(this._element, this._newPos);\r\n\r\n  \t\t// @event drag: Event\r\n  \t\t// Fired continuously during dragging.\r\n  \t\tthis.fire('drag', e);\r\n  \t},\r\n\r\n  \t_onUp: function () {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n  \t\tthis.finishDrag();\r\n  \t},\r\n\r\n  \tfinishDrag: function (noInertia) {\r\n  \t\tremoveClass(document.body, 'leaflet-dragging');\r\n\r\n  \t\tif (this._lastTarget) {\r\n  \t\t\tremoveClass(this._lastTarget, 'leaflet-drag-target');\r\n  \t\t\tthis._lastTarget = null;\r\n  \t\t}\r\n\r\n  \t\toff(document, 'mousemove touchmove', this._onMove, this);\r\n  \t\toff(document, 'mouseup touchend touchcancel', this._onUp, this);\r\n\r\n  \t\tenableImageDrag();\r\n  \t\tenableTextSelection();\r\n\r\n  \t\tvar fireDragend = this._moved && this._moving;\r\n\r\n  \t\tthis._moving = false;\r\n  \t\tDraggable._dragging = false;\r\n\r\n  \t\tif (fireDragend) {\r\n  \t\t\t// @event dragend: DragEndEvent\r\n  \t\t\t// Fired when the drag ends.\r\n  \t\t\tthis.fire('dragend', {\r\n  \t\t\t\tnoInertia: noInertia,\r\n  \t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n  \t\t\t});\r\n  \t\t}\r\n  \t}\r\n\r\n  });\n\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\r\n\r\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\r\n  function clipPolygon(points, bounds, round) {\r\n  \tvar clippedPoints,\r\n  \t    edges = [1, 4, 2, 8],\r\n  \t    i, j, k,\r\n  \t    a, b,\r\n  \t    len, edge, p;\r\n\r\n  \tfor (i = 0, len = points.length; i < len; i++) {\r\n  \t\tpoints[i]._code = _getBitCode(points[i], bounds);\r\n  \t}\r\n\r\n  \t// for each edge (left, bottom, right, top)\r\n  \tfor (k = 0; k < 4; k++) {\r\n  \t\tedge = edges[k];\r\n  \t\tclippedPoints = [];\r\n\r\n  \t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n  \t\t\ta = points[i];\r\n  \t\t\tb = points[j];\r\n\r\n  \t\t\t// if a is inside the clip window\r\n  \t\t\tif (!(a._code & edge)) {\r\n  \t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n  \t\t\t\tif (b._code & edge) {\r\n  \t\t\t\t\tp = _getEdgeIntersection(b, a, edge, bounds, round);\r\n  \t\t\t\t\tp._code = _getBitCode(p, bounds);\r\n  \t\t\t\t\tclippedPoints.push(p);\r\n  \t\t\t\t}\r\n  \t\t\t\tclippedPoints.push(a);\r\n\r\n  \t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n  \t\t\t} else if (!(b._code & edge)) {\r\n  \t\t\t\tp = _getEdgeIntersection(b, a, edge, bounds, round);\r\n  \t\t\t\tp._code = _getBitCode(p, bounds);\r\n  \t\t\t\tclippedPoints.push(p);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tpoints = clippedPoints;\r\n  \t}\r\n\r\n  \treturn points;\r\n  }\r\n\r\n  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */\r\n  function polygonCenter(latlngs, crs) {\r\n  \tvar i, j, p1, p2, f, area, x, y, center;\r\n\r\n  \tif (!latlngs || latlngs.length === 0) {\r\n  \t\tthrow new Error('latlngs not passed');\r\n  \t}\r\n\r\n  \tif (!isFlat(latlngs)) {\r\n  \t\tconsole.warn('latlngs are not flat! Only the first ring will be used');\r\n  \t\tlatlngs = latlngs[0];\r\n  \t}\r\n\r\n  \tvar centroidLatLng = toLatLng([0, 0]);\r\n\r\n  \tvar bounds = toLatLngBounds(latlngs);\r\n  \tvar areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\r\n  \t// tests showed that below 1700 rounding errors are happening\r\n  \tif (areaBounds < 1700) {\r\n  \t\t// getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\r\n  \t\tcentroidLatLng = centroid(latlngs);\r\n  \t}\r\n\r\n  \tvar len = latlngs.length;\r\n  \tvar points = [];\r\n  \tfor (i = 0; i < len; i++) {\r\n  \t\tvar latlng = toLatLng(latlngs[i]);\r\n  \t\tpoints.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\r\n  \t}\r\n\r\n  \tarea = x = y = 0;\r\n\r\n  \t// polygon centroid algorithm;\r\n  \tfor (i = 0, j = len - 1; i < len; j = i++) {\r\n  \t\tp1 = points[i];\r\n  \t\tp2 = points[j];\r\n\r\n  \t\tf = p1.y * p2.x - p2.y * p1.x;\r\n  \t\tx += (p1.x + p2.x) * f;\r\n  \t\ty += (p1.y + p2.y) * f;\r\n  \t\tarea += f * 3;\r\n  \t}\r\n\r\n  \tif (area === 0) {\r\n  \t\t// Polygon is so small that all points are on same pixel.\r\n  \t\tcenter = points[0];\r\n  \t} else {\r\n  \t\tcenter = [x / area, y / area];\r\n  \t}\r\n\r\n  \tvar latlngCenter = crs.unproject(toPoint(center));\r\n  \treturn toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\r\n  }\r\n\r\n  /* @function centroid(latlngs: LatLng[]): LatLng\r\n   * Returns the 'center of mass' of the passed LatLngs.\r\n   */\r\n  function centroid(coords) {\r\n  \tvar latSum = 0;\r\n  \tvar lngSum = 0;\r\n  \tvar len = 0;\r\n  \tfor (var i = 0; i < coords.length; i++) {\r\n  \t\tvar latlng = toLatLng(coords[i]);\r\n  \t\tlatSum += latlng.lat;\r\n  \t\tlngSum += latlng.lng;\r\n  \t\tlen++;\r\n  \t}\r\n  \treturn toLatLng([latSum / len, lngSum / len]);\r\n  }\n\n  var PolyUtil = {\n    __proto__: null,\n    clipPolygon: clipPolygon,\n    polygonCenter: polygonCenter,\n    centroid: centroid\n  };\n\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\r\n\r\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n  // Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n  // @function simplify(points: Point[], tolerance: Number): Point[]\r\n  // Dramatically reduces the number of points in a polyline while retaining\r\n  // its shape and returns a new array of simplified points, using the\r\n  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\r\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\r\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\r\n  // simplification (lesser value means higher quality but slower and with more points).\r\n  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\r\n  function simplify(points, tolerance) {\r\n  \tif (!tolerance || !points.length) {\r\n  \t\treturn points.slice();\r\n  \t}\r\n\r\n  \tvar sqTolerance = tolerance * tolerance;\r\n\r\n  \t    // stage 1: vertex reduction\r\n  \t    points = _reducePoints(points, sqTolerance);\r\n\r\n  \t    // stage 2: Douglas-Peucker simplification\r\n  \t    points = _simplifyDP(points, sqTolerance);\r\n\r\n  \treturn points;\r\n  }\r\n\r\n  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\r\n  // Returns the distance between point `p` and segment `p1` to `p2`.\r\n  function pointToSegmentDistance(p, p1, p2) {\r\n  \treturn Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\r\n  }\r\n\r\n  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\r\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\r\n  function closestPointOnSegment(p, p1, p2) {\r\n  \treturn _sqClosestPointOnSegment(p, p1, p2);\r\n  }\r\n\r\n  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\r\n  function _simplifyDP(points, sqTolerance) {\r\n\r\n  \tvar len = points.length,\r\n  \t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n  \t    markers = new ArrayConstructor(len);\r\n\r\n  \t    markers[0] = markers[len - 1] = 1;\r\n\r\n  \t_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n  \tvar i,\r\n  \t    newPoints = [];\r\n\r\n  \tfor (i = 0; i < len; i++) {\r\n  \t\tif (markers[i]) {\r\n  \t\t\tnewPoints.push(points[i]);\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn newPoints;\r\n  }\r\n\r\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\r\n\r\n  \tvar maxSqDist = 0,\r\n  \tindex, i, sqDist;\r\n\r\n  \tfor (i = first + 1; i <= last - 1; i++) {\r\n  \t\tsqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n  \t\tif (sqDist > maxSqDist) {\r\n  \t\t\tindex = i;\r\n  \t\t\tmaxSqDist = sqDist;\r\n  \t\t}\r\n  \t}\r\n\r\n  \tif (maxSqDist > sqTolerance) {\r\n  \t\tmarkers[index] = 1;\r\n\r\n  \t\t_simplifyDPStep(points, markers, sqTolerance, first, index);\r\n  \t\t_simplifyDPStep(points, markers, sqTolerance, index, last);\r\n  \t}\r\n  }\r\n\r\n  // reduce points that are too close to each other to a single point\r\n  function _reducePoints(points, sqTolerance) {\r\n  \tvar reducedPoints = [points[0]];\r\n\r\n  \tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n  \t\tif (_sqDist(points[i], points[prev]) > sqTolerance) {\r\n  \t\t\treducedPoints.push(points[i]);\r\n  \t\t\tprev = i;\r\n  \t\t}\r\n  \t}\r\n  \tif (prev < len - 1) {\r\n  \t\treducedPoints.push(points[len - 1]);\r\n  \t}\r\n  \treturn reducedPoints;\r\n  }\r\n\r\n  var _lastCode;\r\n\r\n  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\r\n  // Clips the segment a to b by rectangular bounds with the\r\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\r\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\r\n  // points that are on the screen or near, increasing performance.\r\n  function clipSegment(a, b, bounds, useLastCode, round) {\r\n  \tvar codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\r\n  \t    codeB = _getBitCode(b, bounds),\r\n\r\n  \t    codeOut, p, newCode;\r\n\r\n  \t    // save 2nd code to avoid calculating it on the next segment\r\n  \t    _lastCode = codeB;\r\n\r\n  \twhile (true) {\r\n  \t\t// if a,b is inside the clip window (trivial accept)\r\n  \t\tif (!(codeA | codeB)) {\r\n  \t\t\treturn [a, b];\r\n  \t\t}\r\n\r\n  \t\t// if a,b is outside the clip window (trivial reject)\r\n  \t\tif (codeA & codeB) {\r\n  \t\t\treturn false;\r\n  \t\t}\r\n\r\n  \t\t// other cases\r\n  \t\tcodeOut = codeA || codeB;\r\n  \t\tp = _getEdgeIntersection(a, b, codeOut, bounds, round);\r\n  \t\tnewCode = _getBitCode(p, bounds);\r\n\r\n  \t\tif (codeOut === codeA) {\r\n  \t\t\ta = p;\r\n  \t\t\tcodeA = newCode;\r\n  \t\t} else {\r\n  \t\t\tb = p;\r\n  \t\t\tcodeB = newCode;\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  function _getEdgeIntersection(a, b, code, bounds, round) {\r\n  \tvar dx = b.x - a.x,\r\n  \t    dy = b.y - a.y,\r\n  \t    min = bounds.min,\r\n  \t    max = bounds.max,\r\n  \t    x, y;\r\n\r\n  \tif (code & 8) { // top\r\n  \t\tx = a.x + dx * (max.y - a.y) / dy;\r\n  \t\ty = max.y;\r\n\r\n  \t} else if (code & 4) { // bottom\r\n  \t\tx = a.x + dx * (min.y - a.y) / dy;\r\n  \t\ty = min.y;\r\n\r\n  \t} else if (code & 2) { // right\r\n  \t\tx = max.x;\r\n  \t\ty = a.y + dy * (max.x - a.x) / dx;\r\n\r\n  \t} else if (code & 1) { // left\r\n  \t\tx = min.x;\r\n  \t\ty = a.y + dy * (min.x - a.x) / dx;\r\n  \t}\r\n\r\n  \treturn new Point(x, y, round);\r\n  }\r\n\r\n  function _getBitCode(p, bounds) {\r\n  \tvar code = 0;\r\n\r\n  \tif (p.x < bounds.min.x) { // left\r\n  \t\tcode |= 1;\r\n  \t} else if (p.x > bounds.max.x) { // right\r\n  \t\tcode |= 2;\r\n  \t}\r\n\r\n  \tif (p.y < bounds.min.y) { // bottom\r\n  \t\tcode |= 4;\r\n  \t} else if (p.y > bounds.max.y) { // top\r\n  \t\tcode |= 8;\r\n  \t}\r\n\r\n  \treturn code;\r\n  }\r\n\r\n  // square distance (to avoid unnecessary Math.sqrt calls)\r\n  function _sqDist(p1, p2) {\r\n  \tvar dx = p2.x - p1.x,\r\n  \t    dy = p2.y - p1.y;\r\n  \treturn dx * dx + dy * dy;\r\n  }\r\n\r\n  // return closest point on segment or distance to that point\r\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\r\n  \tvar x = p1.x,\r\n  \t    y = p1.y,\r\n  \t    dx = p2.x - x,\r\n  \t    dy = p2.y - y,\r\n  \t    dot = dx * dx + dy * dy,\r\n  \t    t;\r\n\r\n  \tif (dot > 0) {\r\n  \t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n  \t\tif (t > 1) {\r\n  \t\t\tx = p2.x;\r\n  \t\t\ty = p2.y;\r\n  \t\t} else if (t > 0) {\r\n  \t\t\tx += dx * t;\r\n  \t\t\ty += dy * t;\r\n  \t\t}\r\n  \t}\r\n\r\n  \tdx = p.x - x;\r\n  \tdy = p.y - y;\r\n\r\n  \treturn sqDist ? dx * dx + dy * dy : new Point(x, y);\r\n  }\r\n\r\n\r\n  // @function isFlat(latlngs: LatLng[]): Boolean\r\n  // Returns true if `latlngs` is a flat array, false is nested.\r\n  function isFlat(latlngs) {\r\n  \treturn !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\r\n  }\r\n\r\n  function _flat(latlngs) {\r\n  \tconsole.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\r\n  \treturn isFlat(latlngs);\r\n  }\r\n\r\n  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */\r\n  function polylineCenter(latlngs, crs) {\r\n  \tvar i, halfDist, segDist, dist, p1, p2, ratio, center;\r\n\r\n  \tif (!latlngs || latlngs.length === 0) {\r\n  \t\tthrow new Error('latlngs not passed');\r\n  \t}\r\n\r\n  \tif (!isFlat(latlngs)) {\r\n  \t\tconsole.warn('latlngs are not flat! Only the first ring will be used');\r\n  \t\tlatlngs = latlngs[0];\r\n  \t}\r\n\r\n  \tvar centroidLatLng = toLatLng([0, 0]);\r\n\r\n  \tvar bounds = toLatLngBounds(latlngs);\r\n  \tvar areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\r\n  \t// tests showed that below 1700 rounding errors are happening\r\n  \tif (areaBounds < 1700) {\r\n  \t\t// getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\r\n  \t\tcentroidLatLng = centroid(latlngs);\r\n  \t}\r\n\r\n  \tvar len = latlngs.length;\r\n  \tvar points = [];\r\n  \tfor (i = 0; i < len; i++) {\r\n  \t\tvar latlng = toLatLng(latlngs[i]);\r\n  \t\tpoints.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));\r\n  \t}\r\n\r\n  \tfor (i = 0, halfDist = 0; i < len - 1; i++) {\r\n  \t\thalfDist += points[i].distanceTo(points[i + 1]) / 2;\r\n  \t}\r\n\r\n  \t// The line is so small in the current view that all points are on the same pixel.\r\n  \tif (halfDist === 0) {\r\n  \t\tcenter = points[0];\r\n  \t} else {\r\n  \t\tfor (i = 0, dist = 0; i < len - 1; i++) {\r\n  \t\t\tp1 = points[i];\r\n  \t\t\tp2 = points[i + 1];\r\n  \t\t\tsegDist = p1.distanceTo(p2);\r\n  \t\t\tdist += segDist;\r\n\r\n  \t\t\tif (dist > halfDist) {\r\n  \t\t\t\tratio = (dist - halfDist) / segDist;\r\n  \t\t\t\tcenter = [\r\n  \t\t\t\t\tp2.x - ratio * (p2.x - p1.x),\r\n  \t\t\t\t\tp2.y - ratio * (p2.y - p1.y)\r\n  \t\t\t\t];\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \tvar latlngCenter = crs.unproject(toPoint(center));\r\n  \treturn toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);\r\n  }\n\n  var LineUtil = {\n    __proto__: null,\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat,\n    polylineCenter: polylineCenter\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection  the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\r\n\r\n  var LonLat = {\r\n  \tproject: function (latlng) {\r\n  \t\treturn new Point(latlng.lng, latlng.lat);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\treturn new LatLng(point.y, point.x);\r\n  \t},\r\n\r\n  \tbounds: new Bounds([-180, -90], [180, 90])\r\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\r\n\r\n  var Mercator = {\r\n  \tR: 6378137,\r\n  \tR_MINOR: 6356752.314245179,\r\n\r\n  \tbounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\r\n\r\n  \tproject: function (latlng) {\r\n  \t\tvar d = Math.PI / 180,\r\n  \t\t    r = this.R,\r\n  \t\t    y = latlng.lat * d,\r\n  \t\t    tmp = this.R_MINOR / r,\r\n  \t\t    e = Math.sqrt(1 - tmp * tmp),\r\n  \t\t    con = e * Math.sin(y);\r\n\r\n  \t\tvar ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\r\n  \t\ty = -r * Math.log(Math.max(ts, 1E-10));\r\n\r\n  \t\treturn new Point(latlng.lng * d * r, y);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\tvar d = 180 / Math.PI,\r\n  \t\t    r = this.R,\r\n  \t\t    tmp = this.R_MINOR / r,\r\n  \t\t    e = Math.sqrt(1 - tmp * tmp),\r\n  \t\t    ts = Math.exp(-point.y / r),\r\n  \t\t    phi = Math.PI / 2 - 2 * Math.atan(ts);\r\n\r\n  \t\tfor (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\r\n  \t\t\tcon = e * Math.sin(phi);\r\n  \t\t\tcon = Math.pow((1 - con) / (1 + con), e / 2);\r\n  \t\t\tdphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\r\n  \t\t\tphi += dphi;\r\n  \t\t}\r\n\r\n  \t\treturn new LatLng(phi * d, point.x * d / r);\r\n  \t}\r\n  };\n\n  /*\n   * @class Projection\n\n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n\n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n\n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n\n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n\n   * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n\n   */\n\n  var index = {\n    __proto__: null,\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\r\n  var EPSG3395 = extend({}, Earth, {\r\n  \tcode: 'EPSG:3395',\r\n  \tprojection: Mercator,\r\n\r\n  \ttransformation: (function () {\r\n  \t\tvar scale = 0.5 / (Math.PI * Mercator.R);\r\n  \t\treturn toTransformation(scale, 0.5, -scale, 0.5);\r\n  \t}())\r\n  });\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\r\n\r\n  var EPSG4326 = extend({}, Earth, {\r\n  \tcode: 'EPSG:4326',\r\n  \tprojection: LonLat,\r\n  \ttransformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\r\n  });\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n  \tprojection: LonLat,\n  \ttransformation: toTransformation(1, 0, -1, 0),\n\n  \tscale: function (zoom) {\n  \t\treturn Math.pow(2, zoom);\n  \t},\n\n  \tzoom: function (scale) {\n  \t\treturn Math.log(scale) / Math.LN2;\n  \t},\n\n  \tdistance: function (latlng1, latlng2) {\n  \t\tvar dx = latlng2.lng - latlng1.lng,\n  \t\t    dy = latlng2.lat - latlng1.lat;\n\n  \t\treturn Math.sqrt(dx * dx + dy * dy);\n  \t},\n\n  \tinfinite: true\n  });\n\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n\n  var Layer = Evented.extend({\n\n  \t// Classes extending `L.Layer` will inherit the following options:\n  \toptions: {\n  \t\t// @option pane: String = 'overlayPane'\n  \t\t// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n  \t\tpane: 'overlayPane',\n\n  \t\t// @option attribution: String = null\n  \t\t// String to be shown in the attribution control, e.g. \" OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n  \t\tattribution: null,\n\n  \t\tbubblingMouseEvents: true\n  \t},\n\n  \t/* @section\n  \t * Classes extending `L.Layer` will inherit the following methods:\n  \t *\n  \t * @method addTo(map: Map|LayerGroup): this\n  \t * Adds the layer to the given map or layer group.\n  \t */\n  \taddTo: function (map) {\n  \t\tmap.addLayer(this);\n  \t\treturn this;\n  \t},\n\n  \t// @method remove: this\n  \t// Removes the layer from the map it is currently active on.\n  \tremove: function () {\n  \t\treturn this.removeFrom(this._map || this._mapToAdd);\n  \t},\n\n  \t// @method removeFrom(map: Map): this\n  \t// Removes the layer from the given map\n  \t//\n  \t// @alternative\n  \t// @method removeFrom(group: LayerGroup): this\n  \t// Removes the layer from the given `LayerGroup`\n  \tremoveFrom: function (obj) {\n  \t\tif (obj) {\n  \t\t\tobj.removeLayer(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getPane(name? : String): HTMLElement\n  \t// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n  \tgetPane: function (name) {\n  \t\treturn this._map.getPane(name ? (this.options[name] || name) : this.options.pane);\n  \t},\n\n  \taddInteractiveTarget: function (targetEl) {\n  \t\tthis._map._targets[stamp(targetEl)] = this;\n  \t\treturn this;\n  \t},\n\n  \tremoveInteractiveTarget: function (targetEl) {\n  \t\tdelete this._map._targets[stamp(targetEl)];\n  \t\treturn this;\n  \t},\n\n  \t// @method getAttribution: String\n  \t// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n  \tgetAttribution: function () {\n  \t\treturn this.options.attribution;\n  \t},\n\n  \t_layerAdd: function (e) {\n  \t\tvar map = e.target;\n\n  \t\t// check in case layer gets added and then removed before the map is ready\n  \t\tif (!map.hasLayer(this)) { return; }\n\n  \t\tthis._map = map;\n  \t\tthis._zoomAnimated = map._zoomAnimated;\n\n  \t\tif (this.getEvents) {\n  \t\t\tvar events = this.getEvents();\n  \t\t\tmap.on(events, this);\n  \t\t\tthis.once('remove', function () {\n  \t\t\t\tmap.off(events, this);\n  \t\t\t}, this);\n  \t\t}\n\n  \t\tthis.onAdd(map);\n\n  \t\tthis.fire('add');\n  \t\tmap.fire('layeradd', {layer: this});\n  \t}\n  });\n\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n  Map.include({\n  \t// @method addLayer(layer: Layer): this\n  \t// Adds the given layer to the map\n  \taddLayer: function (layer) {\n  \t\tif (!layer._layerAdd) {\n  \t\t\tthrow new Error('The provided object is not a Layer.');\n  \t\t}\n\n  \t\tvar id = stamp(layer);\n  \t\tif (this._layers[id]) { return this; }\n  \t\tthis._layers[id] = layer;\n\n  \t\tlayer._mapToAdd = this;\n\n  \t\tif (layer.beforeAdd) {\n  \t\t\tlayer.beforeAdd(this);\n  \t\t}\n\n  \t\tthis.whenReady(layer._layerAdd, layer);\n\n  \t\treturn this;\n  \t},\n\n  \t// @method removeLayer(layer: Layer): this\n  \t// Removes the given layer from the map.\n  \tremoveLayer: function (layer) {\n  \t\tvar id = stamp(layer);\n\n  \t\tif (!this._layers[id]) { return this; }\n\n  \t\tif (this._loaded) {\n  \t\t\tlayer.onRemove(this);\n  \t\t}\n\n  \t\tdelete this._layers[id];\n\n  \t\tif (this._loaded) {\n  \t\t\tthis.fire('layerremove', {layer: layer});\n  \t\t\tlayer.fire('remove');\n  \t\t}\n\n  \t\tlayer._map = layer._mapToAdd = null;\n\n  \t\treturn this;\n  \t},\n\n  \t// @method hasLayer(layer: Layer): Boolean\n  \t// Returns `true` if the given layer is currently added to the map\n  \thasLayer: function (layer) {\n  \t\treturn stamp(layer) in this._layers;\n  \t},\n\n  \t/* @method eachLayer(fn: Function, context?: Object): this\n  \t * Iterates over the layers of the map, optionally specifying context of the iterator function.\n  \t * ```\n  \t * map.eachLayer(function(layer){\n  \t *     layer.bindPopup('Hello');\n  \t * });\n  \t * ```\n  \t */\n  \teachLayer: function (method, context) {\n  \t\tfor (var i in this._layers) {\n  \t\t\tmethod.call(context, this._layers[i]);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t_addLayers: function (layers) {\n  \t\tlayers = layers ? (isArray(layers) ? layers : [layers]) : [];\n\n  \t\tfor (var i = 0, len = layers.length; i < len; i++) {\n  \t\t\tthis.addLayer(layers[i]);\n  \t\t}\n  \t},\n\n  \t_addZoomLimit: function (layer) {\n  \t\tif (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n  \t\t\tthis._zoomBoundLayers[stamp(layer)] = layer;\n  \t\t\tthis._updateZoomLevels();\n  \t\t}\n  \t},\n\n  \t_removeZoomLimit: function (layer) {\n  \t\tvar id = stamp(layer);\n\n  \t\tif (this._zoomBoundLayers[id]) {\n  \t\t\tdelete this._zoomBoundLayers[id];\n  \t\t\tthis._updateZoomLevels();\n  \t\t}\n  \t},\n\n  \t_updateZoomLevels: function () {\n  \t\tvar minZoom = Infinity,\n  \t\t    maxZoom = -Infinity,\n  \t\t    oldZoomSpan = this._getZoomSpan();\n\n  \t\tfor (var i in this._zoomBoundLayers) {\n  \t\t\tvar options = this._zoomBoundLayers[i].options;\n\n  \t\t\tminZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n  \t\t\tmaxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n  \t\t}\n\n  \t\tthis._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n  \t\tthis._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n  \t\t// @section Map state change events\n  \t\t// @event zoomlevelschange: Event\n  \t\t// Fired when the number of zoomlevels on the map is changed due\n  \t\t// to adding or removing a layer.\n  \t\tif (oldZoomSpan !== this._getZoomSpan()) {\n  \t\t\tthis.fire('zoomlevelschange');\n  \t\t}\n\n  \t\tif (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n  \t\t\tthis.setZoom(this._layersMaxZoom);\n  \t\t}\n  \t\tif (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n  \t\t\tthis.setZoom(this._layersMinZoom);\n  \t\t}\n  \t}\n  });\n\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var LayerGroup = Layer.extend({\r\n\r\n  \tinitialize: function (layers, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layers = {};\r\n\r\n  \t\tvar i, len;\r\n\r\n  \t\tif (layers) {\r\n  \t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n  \t\t\t\tthis.addLayer(layers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addLayer(layer: Layer): this\r\n  \t// Adds the given layer to the group.\r\n  \taddLayer: function (layer) {\r\n  \t\tvar id = this.getLayerId(layer);\r\n\r\n  \t\tthis._layers[id] = layer;\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._map.addLayer(layer);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeLayer(layer: Layer): this\r\n  \t// Removes the given layer from the group.\r\n  \t// @alternative\r\n  \t// @method removeLayer(id: Number): this\r\n  \t// Removes the layer with the given internal ID from the group.\r\n  \tremoveLayer: function (layer) {\r\n  \t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n  \t\tif (this._map && this._layers[id]) {\r\n  \t\t\tthis._map.removeLayer(this._layers[id]);\r\n  \t\t}\r\n\r\n  \t\tdelete this._layers[id];\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method hasLayer(layer: Layer): Boolean\r\n  \t// Returns `true` if the given layer is currently added to the group.\r\n  \t// @alternative\r\n  \t// @method hasLayer(id: Number): Boolean\r\n  \t// Returns `true` if the given internal ID is currently added to the group.\r\n  \thasLayer: function (layer) {\r\n  \t\tvar layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\r\n  \t\treturn layerId in this._layers;\r\n  \t},\r\n\r\n  \t// @method clearLayers(): this\r\n  \t// Removes all the layers from the group.\r\n  \tclearLayers: function () {\r\n  \t\treturn this.eachLayer(this.removeLayer, this);\r\n  \t},\r\n\r\n  \t// @method invoke(methodName: String, ): this\r\n  \t// Calls `methodName` on every layer contained in this group, passing any\r\n  \t// additional parameters. Has no effect if the layers contained do not\r\n  \t// implement `methodName`.\r\n  \tinvoke: function (methodName) {\r\n  \t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n  \t\t    i, layer;\r\n\r\n  \t\tfor (i in this._layers) {\r\n  \t\t\tlayer = this._layers[i];\r\n\r\n  \t\t\tif (layer[methodName]) {\r\n  \t\t\t\tlayer[methodName].apply(layer, args);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis.eachLayer(map.addLayer, map);\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tthis.eachLayer(map.removeLayer, map);\r\n  \t},\r\n\r\n  \t// @method eachLayer(fn: Function, context?: Object): this\r\n  \t// Iterates over the layers of the group, optionally specifying context of the iterator function.\r\n  \t// ```js\r\n  \t// group.eachLayer(function (layer) {\r\n  \t// \tlayer.bindPopup('Hello');\r\n  \t// });\r\n  \t// ```\r\n  \teachLayer: function (method, context) {\r\n  \t\tfor (var i in this._layers) {\r\n  \t\t\tmethod.call(context, this._layers[i]);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getLayer(id: Number): Layer\r\n  \t// Returns the layer with the given internal ID.\r\n  \tgetLayer: function (id) {\r\n  \t\treturn this._layers[id];\r\n  \t},\r\n\r\n  \t// @method getLayers(): Layer[]\r\n  \t// Returns an array of all the layers added to the group.\r\n  \tgetLayers: function () {\r\n  \t\tvar layers = [];\r\n  \t\tthis.eachLayer(layers.push, layers);\r\n  \t\treturn layers;\r\n  \t},\r\n\r\n  \t// @method setZIndex(zIndex: Number): this\r\n  \t// Calls `setZIndex` on every layer contained in this group, passing the z-index.\r\n  \tsetZIndex: function (zIndex) {\r\n  \t\treturn this.invoke('setZIndex', zIndex);\r\n  \t},\r\n\r\n  \t// @method getLayerId(layer: Layer): Number\r\n  \t// Returns the internal ID for a layer\r\n  \tgetLayerId: function (layer) {\r\n  \t\treturn stamp(layer);\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.layerGroup(layers?: Layer[], options?: Object)\r\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\r\n  var layerGroup = function (layers, options) {\r\n  \treturn new LayerGroup(layers, options);\r\n  };\n\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var FeatureGroup = LayerGroup.extend({\r\n\r\n  \taddLayer: function (layer) {\r\n  \t\tif (this.hasLayer(layer)) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tlayer.addEventParent(this);\r\n\r\n  \t\tLayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n  \t\t// @event layeradd: LayerEvent\r\n  \t\t// Fired when a layer is added to this `FeatureGroup`\r\n  \t\treturn this.fire('layeradd', {layer: layer});\r\n  \t},\r\n\r\n  \tremoveLayer: function (layer) {\r\n  \t\tif (!this.hasLayer(layer)) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\tif (layer in this._layers) {\r\n  \t\t\tlayer = this._layers[layer];\r\n  \t\t}\r\n\r\n  \t\tlayer.removeEventParent(this);\r\n\r\n  \t\tLayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n  \t\t// @event layerremove: LayerEvent\r\n  \t\t// Fired when a layer is removed from this `FeatureGroup`\r\n  \t\treturn this.fire('layerremove', {layer: layer});\r\n  \t},\r\n\r\n  \t// @method setStyle(style: Path options): this\r\n  \t// Sets the given path options to each layer of the group that has a `setStyle` method.\r\n  \tsetStyle: function (style) {\r\n  \t\treturn this.invoke('setStyle', style);\r\n  \t},\r\n\r\n  \t// @method bringToFront(): this\r\n  \t// Brings the layer group to the top of all other layers\r\n  \tbringToFront: function () {\r\n  \t\treturn this.invoke('bringToFront');\r\n  \t},\r\n\r\n  \t// @method bringToBack(): this\r\n  \t// Brings the layer group to the back of all other layers\r\n  \tbringToBack: function () {\r\n  \t\treturn this.invoke('bringToBack');\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\r\n  \tgetBounds: function () {\r\n  \t\tvar bounds = new LatLngBounds();\r\n\r\n  \t\tfor (var id in this._layers) {\r\n  \t\t\tvar layer = this._layers[id];\r\n  \t\t\tbounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\r\n  \t\t}\r\n  \t\treturn bounds;\r\n  \t}\r\n  });\r\n\r\n  // @factory L.featureGroup(layers?: Layer[], options?: Object)\r\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\r\n  var featureGroup = function (layers, options) {\r\n  \treturn new FeatureGroup(layers, options);\r\n  };\n\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\r\n\r\n  var Icon = Class.extend({\r\n\r\n  \t/* @section\r\n  \t * @aka Icon options\r\n  \t *\r\n  \t * @option iconUrl: String = null\r\n  \t * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n  \t *\r\n  \t * @option iconRetinaUrl: String = null\r\n  \t * The URL to a retina sized version of the icon image (absolute or relative to your\r\n  \t * script path). Used for Retina screen devices.\r\n  \t *\r\n  \t * @option iconSize: Point = null\r\n  \t * Size of the icon image in pixels.\r\n  \t *\r\n  \t * @option iconAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n  \t * will be aligned so that this point is at the marker's geographical location. Centered\r\n  \t * by default if size is specified, also can be set in CSS with negative margins.\r\n  \t *\r\n  \t * @option popupAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option tooltipAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option shadowUrl: String = null\r\n  \t * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n  \t *\r\n  \t * @option shadowRetinaUrl: String = null\r\n  \t *\r\n  \t * @option shadowSize: Point = null\r\n  \t * Size of the shadow image in pixels.\r\n  \t *\r\n  \t * @option shadowAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n  \t * as iconAnchor if not specified).\r\n  \t *\r\n  \t * @option className: String = ''\r\n  \t * A custom class name to assign to both icon and shadow images. Empty by default.\r\n  \t */\r\n\r\n  \toptions: {\r\n  \t\tpopupAnchor: [0, 0],\r\n  \t\ttooltipAnchor: [0, 0],\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \t// @method createIcon(oldIcon?: HTMLElement): HTMLElement\r\n  \t// Called internally when the icon has to be shown, returns a `<img>` HTML element\r\n  \t// styled according to the options.\r\n  \tcreateIcon: function (oldIcon) {\r\n  \t\treturn this._createIcon('icon', oldIcon);\r\n  \t},\r\n\r\n  \t// @method createShadow(oldIcon?: HTMLElement): HTMLElement\r\n  \t// As `createIcon`, but for the shadow beneath it.\r\n  \tcreateShadow: function (oldIcon) {\r\n  \t\treturn this._createIcon('shadow', oldIcon);\r\n  \t},\r\n\r\n  \t_createIcon: function (name, oldIcon) {\r\n  \t\tvar src = this._getIconUrl(name);\r\n\r\n  \t\tif (!src) {\r\n  \t\t\tif (name === 'icon') {\r\n  \t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n  \t\t\t}\r\n  \t\t\treturn null;\r\n  \t\t}\r\n\r\n  \t\tvar img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\r\n  \t\tthis._setIconStyles(img, name);\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\timg.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\treturn img;\r\n  \t},\r\n\r\n  \t_setIconStyles: function (img, name) {\r\n  \t\tvar options = this.options;\r\n  \t\tvar sizeOption = options[name + 'Size'];\r\n\r\n  \t\tif (typeof sizeOption === 'number') {\r\n  \t\t\tsizeOption = [sizeOption, sizeOption];\r\n  \t\t}\r\n\r\n  \t\tvar size = toPoint(sizeOption),\r\n  \t\t    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\r\n  \t\t            size && size.divideBy(2, true));\r\n\r\n  \t\timg.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\r\n\r\n  \t\tif (anchor) {\r\n  \t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n  \t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n  \t\t}\r\n\r\n  \t\tif (size) {\r\n  \t\t\timg.style.width  = size.x + 'px';\r\n  \t\t\timg.style.height = size.y + 'px';\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_createImg: function (src, el) {\r\n  \t\tel = el || document.createElement('img');\r\n  \t\tel.src = src;\r\n  \t\treturn el;\r\n  \t},\r\n\r\n  \t_getIconUrl: function (name) {\r\n  \t\treturn Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.icon(options: Icon options)\r\n  // Creates an icon instance with the given options.\r\n  function icon(options) {\r\n  \treturn new Icon(options);\r\n  }\n\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n  var IconDefault = Icon.extend({\n\n  \toptions: {\n  \t\ticonUrl:       'marker-icon.png',\n  \t\ticonRetinaUrl: 'marker-icon-2x.png',\n  \t\tshadowUrl:     'marker-shadow.png',\n  \t\ticonSize:    [25, 41],\n  \t\ticonAnchor:  [12, 41],\n  \t\tpopupAnchor: [1, -34],\n  \t\ttooltipAnchor: [16, -28],\n  \t\tshadowSize:  [41, 41]\n  \t},\n\n  \t_getIconUrl: function (name) {\n  \t\tif (typeof IconDefault.imagePath !== 'string') {\t// Deprecated, backwards-compatibility only\n  \t\t\tIconDefault.imagePath = this._detectIconPath();\n  \t\t}\n\n  \t\t// @option imagePath: String\n  \t\t// `Icon.Default` will try to auto-detect the location of the\n  \t\t// blue icon images. If you are placing these images in a non-standard\n  \t\t// way, set this option to point to the right path.\n  \t\treturn (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n  \t},\n\n  \t_stripUrl: function (path) {\t// separate function to use in tests\n  \t\tvar strip = function (str, re, idx) {\n  \t\t\tvar match = re.exec(str);\n  \t\t\treturn match && match[idx];\n  \t\t};\n  \t\tpath = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n  \t\treturn path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n  \t},\n\n  \t_detectIconPath: function () {\n  \t\tvar el = create$1('div',  'leaflet-default-icon-path', document.body);\n  \t\tvar path = getStyle(el, 'background-image') ||\n  \t\t           getStyle(el, 'backgroundImage');\t// IE8\n\n  \t\tdocument.body.removeChild(el);\n  \t\tpath = this._stripUrl(path);\n  \t\tif (path) { return path; }\n  \t\tvar link = document.querySelector('link[href$=\"leaflet.css\"]');\n  \t\tif (!link) { return ''; }\n  \t\treturn link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);\n  \t}\n  });\n\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n  \tinitialize: function (marker) {\n  \t\tthis._marker = marker;\n  \t},\n\n  \taddHooks: function () {\n  \t\tvar icon = this._marker._icon;\n\n  \t\tif (!this._draggable) {\n  \t\t\tthis._draggable = new Draggable(icon, icon, true);\n  \t\t}\n\n  \t\tthis._draggable.on({\n  \t\t\tdragstart: this._onDragStart,\n  \t\t\tpredrag: this._onPreDrag,\n  \t\t\tdrag: this._onDrag,\n  \t\t\tdragend: this._onDragEnd\n  \t\t}, this).enable();\n\n  \t\taddClass(icon, 'leaflet-marker-draggable');\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._draggable.off({\n  \t\t\tdragstart: this._onDragStart,\n  \t\t\tpredrag: this._onPreDrag,\n  \t\t\tdrag: this._onDrag,\n  \t\t\tdragend: this._onDragEnd\n  \t\t}, this).disable();\n\n  \t\tif (this._marker._icon) {\n  \t\t\tremoveClass(this._marker._icon, 'leaflet-marker-draggable');\n  \t\t}\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._draggable && this._draggable._moved;\n  \t},\n\n  \t_adjustPan: function (e) {\n  \t\tvar marker = this._marker,\n  \t\t    map = marker._map,\n  \t\t    speed = this._marker.options.autoPanSpeed,\n  \t\t    padding = this._marker.options.autoPanPadding,\n  \t\t    iconPos = getPosition(marker._icon),\n  \t\t    bounds = map.getPixelBounds(),\n  \t\t    origin = map.getPixelOrigin();\n\n  \t\tvar panBounds = toBounds(\n  \t\t\tbounds.min._subtract(origin).add(padding),\n  \t\t\tbounds.max._subtract(origin).subtract(padding)\n  \t\t);\n\n  \t\tif (!panBounds.contains(iconPos)) {\n  \t\t\t// Compute incremental movement\n  \t\t\tvar movement = toPoint(\n  \t\t\t\t(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -\n  \t\t\t\t(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),\n\n  \t\t\t\t(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -\n  \t\t\t\t(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)\n  \t\t\t).multiplyBy(speed);\n\n  \t\t\tmap.panBy(movement, {animate: false});\n\n  \t\t\tthis._draggable._newPos._add(movement);\n  \t\t\tthis._draggable._startPos._add(movement);\n\n  \t\t\tsetPosition(marker._icon, this._draggable._newPos);\n  \t\t\tthis._onDrag(e);\n\n  \t\t\tthis._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n  \t\t}\n  \t},\n\n  \t_onDragStart: function () {\n  \t\t// @section Dragging events\n  \t\t// @event dragstart: Event\n  \t\t// Fired when the user starts dragging the marker.\n\n  \t\t// @event movestart: Event\n  \t\t// Fired when the marker starts moving (because of dragging).\n\n  \t\tthis._oldLatLng = this._marker.getLatLng();\n\n  \t\t// When using ES6 imports it could not be set when `Popup` was not imported as well\n  \t\tthis._marker.closePopup && this._marker.closePopup();\n\n  \t\tthis._marker\n  \t\t\t.fire('movestart')\n  \t\t\t.fire('dragstart');\n  \t},\n\n  \t_onPreDrag: function (e) {\n  \t\tif (this._marker.options.autoPan) {\n  \t\t\tcancelAnimFrame(this._panRequest);\n  \t\t\tthis._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n  \t\t}\n  \t},\n\n  \t_onDrag: function (e) {\n  \t\tvar marker = this._marker,\n  \t\t    shadow = marker._shadow,\n  \t\t    iconPos = getPosition(marker._icon),\n  \t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n  \t\t// update shadow position\n  \t\tif (shadow) {\n  \t\t\tsetPosition(shadow, iconPos);\n  \t\t}\n\n  \t\tmarker._latlng = latlng;\n  \t\te.latlng = latlng;\n  \t\te.oldLatLng = this._oldLatLng;\n\n  \t\t// @event drag: Event\n  \t\t// Fired repeatedly while the user drags the marker.\n  \t\tmarker\n  \t\t    .fire('move', e)\n  \t\t    .fire('drag', e);\n  \t},\n\n  \t_onDragEnd: function (e) {\n  \t\t// @event dragend: DragEndEvent\n  \t\t// Fired when the user stops dragging the marker.\n\n  \t\t cancelAnimFrame(this._panRequest);\n\n  \t\t// @event moveend: Event\n  \t\t// Fired when the marker stops moving (because of dragging).\n  \t\tdelete this._oldLatLng;\n  \t\tthis._marker\n  \t\t    .fire('moveend')\n  \t\t    .fire('dragend', e);\n  \t}\n  });\n\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var Marker = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka Marker options\r\n  \toptions: {\r\n  \t\t// @option icon: Icon = *\r\n  \t\t// Icon instance to use for rendering the marker.\r\n  \t\t// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\r\n  \t\t// If not specified, a common instance of `L.Icon.Default` is used.\r\n  \t\ticon: new IconDefault(),\r\n\r\n  \t\t// Option inherited from \"Interactive layer\" abstract class\r\n  \t\tinteractive: true,\r\n\r\n  \t\t// @option keyboard: Boolean = true\r\n  \t\t// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\r\n  \t\tkeyboard: true,\r\n\r\n  \t\t// @option title: String = ''\r\n  \t\t// Text for the browser tooltip that appear on marker hover (no tooltip by default).\r\n  \t\t// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\r\n  \t\ttitle: '',\r\n\r\n  \t\t// @option alt: String = 'Marker'\r\n  \t\t// Text for the `alt` attribute of the icon image.\r\n  \t\t// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\r\n  \t\talt: 'Marker',\r\n\r\n  \t\t// @option zIndexOffset: Number = 0\r\n  \t\t// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\r\n  \t\tzIndexOffset: 0,\r\n\r\n  \t\t// @option opacity: Number = 1.0\r\n  \t\t// The opacity of the marker.\r\n  \t\topacity: 1,\r\n\r\n  \t\t// @option riseOnHover: Boolean = false\r\n  \t\t// If `true`, the marker will get on top of others when you hover the mouse over it.\r\n  \t\triseOnHover: false,\r\n\r\n  \t\t// @option riseOffset: Number = 250\r\n  \t\t// The z-index offset used for the `riseOnHover` feature.\r\n  \t\triseOffset: 250,\r\n\r\n  \t\t// @option pane: String = 'markerPane'\r\n  \t\t// `Map pane` where the markers icon will be added.\r\n  \t\tpane: 'markerPane',\r\n\r\n  \t\t// @option shadowPane: String = 'shadowPane'\r\n  \t\t// `Map pane` where the markers shadow will be added.\r\n  \t\tshadowPane: 'shadowPane',\r\n\r\n  \t\t// @option bubblingMouseEvents: Boolean = false\r\n  \t\t// When `true`, a mouse event on this marker will trigger the same event on the map\r\n  \t\t// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\r\n  \t\tbubblingMouseEvents: false,\r\n\r\n  \t\t// @option autoPanOnFocus: Boolean = true\r\n  \t\t// When `true`, the map will pan whenever the marker is focused (via\r\n  \t\t// e.g. pressing `tab` on the keyboard) to ensure the marker is\r\n  \t\t// visible within the map's bounds\r\n  \t\tautoPanOnFocus: true,\r\n\r\n  \t\t// @section Draggable marker options\r\n  \t\t// @option draggable: Boolean = false\r\n  \t\t// Whether the marker is draggable with mouse/touch or not.\r\n  \t\tdraggable: false,\r\n\r\n  \t\t// @option autoPan: Boolean = false\r\n  \t\t// Whether to pan the map when dragging this marker near its edge or not.\r\n  \t\tautoPan: false,\r\n\r\n  \t\t// @option autoPanPadding: Point = Point(50, 50)\r\n  \t\t// Distance (in pixels to the left/right and to the top/bottom) of the\r\n  \t\t// map edge to start panning the map.\r\n  \t\tautoPanPadding: [50, 50],\r\n\r\n  \t\t// @option autoPanSpeed: Number = 10\r\n  \t\t// Number of pixels the map should pan by.\r\n  \t\tautoPanSpeed: 10\r\n  \t},\r\n\r\n  \t/* @section\r\n  \t *\r\n  \t * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n  \t */\r\n\r\n  \tinitialize: function (latlng, options) {\r\n  \t\tsetOptions(this, options);\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n  \t\t}\r\n\r\n  \t\tthis._initIcon();\r\n  \t\tthis.update();\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tif (this.dragging && this.dragging.enabled()) {\r\n  \t\t\tthis.options.draggable = true;\r\n  \t\t\tthis.dragging.removeHooks();\r\n  \t\t}\r\n  \t\tdelete this.dragging;\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n  \t\t}\r\n\r\n  \t\tthis._removeIcon();\r\n  \t\tthis._removeShadow();\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\treturn {\r\n  \t\t\tzoom: this.update,\r\n  \t\t\tviewreset: this.update\r\n  \t\t};\r\n  \t},\r\n\r\n  \t// @method getLatLng: LatLng\r\n  \t// Returns the current geographical position of the marker.\r\n  \tgetLatLng: function () {\r\n  \t\treturn this._latlng;\r\n  \t},\r\n\r\n  \t// @method setLatLng(latlng: LatLng): this\r\n  \t// Changes the marker position to the given point.\r\n  \tsetLatLng: function (latlng) {\r\n  \t\tvar oldLatLng = this._latlng;\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t\tthis.update();\r\n\r\n  \t\t// @event move: Event\r\n  \t\t// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\r\n  \t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\r\n  \t},\r\n\r\n  \t// @method setZIndexOffset(offset: Number): this\r\n  \t// Changes the [zIndex offset](#marker-zindexoffset) of the marker.\r\n  \tsetZIndexOffset: function (offset) {\r\n  \t\tthis.options.zIndexOffset = offset;\r\n  \t\treturn this.update();\r\n  \t},\r\n\r\n  \t// @method getIcon: Icon\r\n  \t// Returns the current icon used by the marker\r\n  \tgetIcon: function () {\r\n  \t\treturn this.options.icon;\r\n  \t},\r\n\r\n  \t// @method setIcon(icon: Icon): this\r\n  \t// Changes the marker icon.\r\n  \tsetIcon: function (icon) {\r\n\r\n  \t\tthis.options.icon = icon;\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._initIcon();\r\n  \t\t\tthis.update();\r\n  \t\t}\r\n\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis.bindPopup(this._popup, this._popup.options);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tgetElement: function () {\r\n  \t\treturn this._icon;\r\n  \t},\r\n\r\n  \tupdate: function () {\r\n\r\n  \t\tif (this._icon && this._map) {\r\n  \t\t\tvar pos = this._map.latLngToLayerPoint(this._latlng).round();\r\n  \t\t\tthis._setPos(pos);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initIcon: function () {\r\n  \t\tvar options = this.options,\r\n  \t\t    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\r\n\r\n  \t\tvar icon = options.icon.createIcon(this._icon),\r\n  \t\t    addIcon = false;\r\n\r\n  \t\t// if we're not reusing the icon, remove the old one and init new one\r\n  \t\tif (icon !== this._icon) {\r\n  \t\t\tif (this._icon) {\r\n  \t\t\t\tthis._removeIcon();\r\n  \t\t\t}\r\n  \t\t\taddIcon = true;\r\n\r\n  \t\t\tif (options.title) {\r\n  \t\t\t\ticon.title = options.title;\r\n  \t\t\t}\r\n\r\n  \t\t\tif (icon.tagName === 'IMG') {\r\n  \t\t\t\ticon.alt = options.alt || '';\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\taddClass(icon, classToAdd);\r\n\r\n  \t\tif (options.keyboard) {\r\n  \t\t\ticon.tabIndex = '0';\r\n  \t\t\ticon.setAttribute('role', 'button');\r\n  \t\t}\r\n\r\n  \t\tthis._icon = icon;\r\n\r\n  \t\tif (options.riseOnHover) {\r\n  \t\t\tthis.on({\r\n  \t\t\t\tmouseover: this._bringToFront,\r\n  \t\t\t\tmouseout: this._resetZIndex\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoPanOnFocus) {\r\n  \t\t\ton(icon, 'focus', this._panOnFocus, this);\r\n  \t\t}\r\n\r\n  \t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n  \t\t    addShadow = false;\r\n\r\n  \t\tif (newShadow !== this._shadow) {\r\n  \t\t\tthis._removeShadow();\r\n  \t\t\taddShadow = true;\r\n  \t\t}\r\n\r\n  \t\tif (newShadow) {\r\n  \t\t\taddClass(newShadow, classToAdd);\r\n  \t\t\tnewShadow.alt = '';\r\n  \t\t}\r\n  \t\tthis._shadow = newShadow;\r\n\r\n\r\n  \t\tif (options.opacity < 1) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n\r\n\r\n  \t\tif (addIcon) {\r\n  \t\t\tthis.getPane().appendChild(this._icon);\r\n  \t\t}\r\n  \t\tthis._initInteraction();\r\n  \t\tif (newShadow && addShadow) {\r\n  \t\t\tthis.getPane(options.shadowPane).appendChild(this._shadow);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_removeIcon: function () {\r\n  \t\tif (this.options.riseOnHover) {\r\n  \t\t\tthis.off({\r\n  \t\t\t\tmouseover: this._bringToFront,\r\n  \t\t\t\tmouseout: this._resetZIndex\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoPanOnFocus) {\r\n  \t\t\toff(this._icon, 'focus', this._panOnFocus, this);\r\n  \t\t}\r\n\r\n  \t\tremove(this._icon);\r\n  \t\tthis.removeInteractiveTarget(this._icon);\r\n\r\n  \t\tthis._icon = null;\r\n  \t},\r\n\r\n  \t_removeShadow: function () {\r\n  \t\tif (this._shadow) {\r\n  \t\t\tremove(this._shadow);\r\n  \t\t}\r\n  \t\tthis._shadow = null;\r\n  \t},\r\n\r\n  \t_setPos: function (pos) {\r\n\r\n  \t\tif (this._icon) {\r\n  \t\t\tsetPosition(this._icon, pos);\r\n  \t\t}\r\n\r\n  \t\tif (this._shadow) {\r\n  \t\t\tsetPosition(this._shadow, pos);\r\n  \t\t}\r\n\r\n  \t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n  \t\tthis._resetZIndex();\r\n  \t},\r\n\r\n  \t_updateZIndex: function (offset) {\r\n  \t\tif (this._icon) {\r\n  \t\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_animateZoom: function (opt) {\r\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n  \t\tthis._setPos(pos);\r\n  \t},\r\n\r\n  \t_initInteraction: function () {\r\n\r\n  \t\tif (!this.options.interactive) { return; }\r\n\r\n  \t\taddClass(this._icon, 'leaflet-interactive');\r\n\r\n  \t\tthis.addInteractiveTarget(this._icon);\r\n\r\n  \t\tif (MarkerDrag) {\r\n  \t\t\tvar draggable = this.options.draggable;\r\n  \t\t\tif (this.dragging) {\r\n  \t\t\t\tdraggable = this.dragging.enabled();\r\n  \t\t\t\tthis.dragging.disable();\r\n  \t\t\t}\r\n\r\n  \t\t\tthis.dragging = new MarkerDrag(this);\r\n\r\n  \t\t\tif (draggable) {\r\n  \t\t\t\tthis.dragging.enable();\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setOpacity(opacity: Number): this\r\n  \t// Changes the opacity of the marker.\r\n  \tsetOpacity: function (opacity) {\r\n  \t\tthis.options.opacity = opacity;\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_updateOpacity: function () {\r\n  \t\tvar opacity = this.options.opacity;\r\n\r\n  \t\tif (this._icon) {\r\n  \t\t\tsetOpacity(this._icon, opacity);\r\n  \t\t}\r\n\r\n  \t\tif (this._shadow) {\r\n  \t\t\tsetOpacity(this._shadow, opacity);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_bringToFront: function () {\r\n  \t\tthis._updateZIndex(this.options.riseOffset);\r\n  \t},\r\n\r\n  \t_resetZIndex: function () {\r\n  \t\tthis._updateZIndex(0);\r\n  \t},\r\n\r\n  \t_panOnFocus: function () {\r\n  \t\tvar map = this._map;\r\n  \t\tif (!map) { return; }\r\n\r\n  \t\tvar iconOpts = this.options.icon.options;\r\n  \t\tvar size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\r\n  \t\tvar anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\r\n\r\n  \t\tmap.panInside(this._latlng, {\r\n  \t\t\tpaddingTopLeft: anchor,\r\n  \t\t\tpaddingBottomRight: size.subtract(anchor)\r\n  \t\t});\r\n  \t},\r\n\r\n  \t_getPopupAnchor: function () {\r\n  \t\treturn this.options.icon.options.popupAnchor;\r\n  \t},\r\n\r\n  \t_getTooltipAnchor: function () {\r\n  \t\treturn this.options.icon.options.tooltipAnchor;\r\n  \t}\r\n  });\r\n\r\n\r\n  // factory L.marker(latlng: LatLng, options? : Marker options)\r\n\r\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\r\n  // Instantiates a Marker object given a geographical point and optionally an options object.\r\n  function marker(latlng, options) {\r\n  \treturn new Marker(latlng, options);\r\n  }\n\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n  var Path = Layer.extend({\n\n  \t// @section\n  \t// @aka Path options\n  \toptions: {\n  \t\t// @option stroke: Boolean = true\n  \t\t// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n  \t\tstroke: true,\n\n  \t\t// @option color: String = '#3388ff'\n  \t\t// Stroke color\n  \t\tcolor: '#3388ff',\n\n  \t\t// @option weight: Number = 3\n  \t\t// Stroke width in pixels\n  \t\tweight: 3,\n\n  \t\t// @option opacity: Number = 1.0\n  \t\t// Stroke opacity\n  \t\topacity: 1,\n\n  \t\t// @option lineCap: String= 'round'\n  \t\t// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n  \t\tlineCap: 'round',\n\n  \t\t// @option lineJoin: String = 'round'\n  \t\t// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n  \t\tlineJoin: 'round',\n\n  \t\t// @option dashArray: String = null\n  \t\t// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n  \t\tdashArray: null,\n\n  \t\t// @option dashOffset: String = null\n  \t\t// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n  \t\tdashOffset: null,\n\n  \t\t// @option fill: Boolean = depends\n  \t\t// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n  \t\tfill: false,\n\n  \t\t// @option fillColor: String = *\n  \t\t// Fill color. Defaults to the value of the [`color`](#path-color) option\n  \t\tfillColor: null,\n\n  \t\t// @option fillOpacity: Number = 0.2\n  \t\t// Fill opacity.\n  \t\tfillOpacity: 0.2,\n\n  \t\t// @option fillRule: String = 'evenodd'\n  \t\t// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n  \t\tfillRule: 'evenodd',\n\n  \t\t// className: '',\n\n  \t\t// Option inherited from \"Interactive layer\" abstract class\n  \t\tinteractive: true,\n\n  \t\t// @option bubblingMouseEvents: Boolean = true\n  \t\t// When `true`, a mouse event on this path will trigger the same event on the map\n  \t\t// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n  \t\tbubblingMouseEvents: true\n  \t},\n\n  \tbeforeAdd: function (map) {\n  \t\t// Renderer is set here because we need to call renderer.getEvents\n  \t\t// before this.getEvents.\n  \t\tthis._renderer = map.getRenderer(this);\n  \t},\n\n  \tonAdd: function () {\n  \t\tthis._renderer._initPath(this);\n  \t\tthis._reset();\n  \t\tthis._renderer._addPath(this);\n  \t},\n\n  \tonRemove: function () {\n  \t\tthis._renderer._removePath(this);\n  \t},\n\n  \t// @method redraw(): this\n  \t// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n  \tredraw: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._renderer._updatePath(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method setStyle(style: Path options): this\n  \t// Changes the appearance of a Path based on the options in the `Path options` object.\n  \tsetStyle: function (style) {\n  \t\tsetOptions(this, style);\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._updateStyle(this);\n  \t\t\tif (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n  \t\t\t\tthis._updateBounds();\n  \t\t\t}\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToFront(): this\n  \t// Brings the layer to the top of all path layers.\n  \tbringToFront: function () {\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._bringToFront(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToBack(): this\n  \t// Brings the layer to the bottom of all path layers.\n  \tbringToBack: function () {\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._bringToBack(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \tgetElement: function () {\n  \t\treturn this._path;\n  \t},\n\n  \t_reset: function () {\n  \t\t// defined in child classes\n  \t\tthis._project();\n  \t\tthis._update();\n  \t},\n\n  \t_clickTolerance: function () {\n  \t\t// used when doing hit detection for Canvas layers\n  \t\treturn (this.options.stroke ? this.options.weight / 2 : 0) +\n  \t\t  (this._renderer.options.tolerance || 0);\n  \t}\n  });\n\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n\n  \t// @section\n  \t// @aka CircleMarker options\n  \toptions: {\n  \t\tfill: true,\n\n  \t\t// @option radius: Number = 10\n  \t\t// Radius of the circle marker, in pixels\n  \t\tradius: 10\n  \t},\n\n  \tinitialize: function (latlng, options) {\n  \t\tsetOptions(this, options);\n  \t\tthis._latlng = toLatLng(latlng);\n  \t\tthis._radius = this.options.radius;\n  \t},\n\n  \t// @method setLatLng(latLng: LatLng): this\n  \t// Sets the position of a circle marker to a new location.\n  \tsetLatLng: function (latlng) {\n  \t\tvar oldLatLng = this._latlng;\n  \t\tthis._latlng = toLatLng(latlng);\n  \t\tthis.redraw();\n\n  \t\t// @event move: Event\n  \t\t// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n  \t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\n  \t},\n\n  \t// @method getLatLng(): LatLng\n  \t// Returns the current geographical position of the circle marker\n  \tgetLatLng: function () {\n  \t\treturn this._latlng;\n  \t},\n\n  \t// @method setRadius(radius: Number): this\n  \t// Sets the radius of a circle marker. Units are in pixels.\n  \tsetRadius: function (radius) {\n  \t\tthis.options.radius = this._radius = radius;\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method getRadius(): Number\n  \t// Returns the current radius of the circle\n  \tgetRadius: function () {\n  \t\treturn this._radius;\n  \t},\n\n  \tsetStyle : function (options) {\n  \t\tvar radius = options && options.radius || this._radius;\n  \t\tPath.prototype.setStyle.call(this, options);\n  \t\tthis.setRadius(radius);\n  \t\treturn this;\n  \t},\n\n  \t_project: function () {\n  \t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\n  \t\tthis._updateBounds();\n  \t},\n\n  \t_updateBounds: function () {\n  \t\tvar r = this._radius,\n  \t\t    r2 = this._radiusY || r,\n  \t\t    w = this._clickTolerance(),\n  \t\t    p = [r + w, r2 + w];\n  \t\tthis._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._updatePath();\n  \t\t}\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updateCircle(this);\n  \t},\n\n  \t_empty: function () {\n  \t\treturn this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p) {\n  \t\treturn p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n  \t}\n  });\n\n\n  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n  function circleMarker(latlng, options) {\n  \treturn new CircleMarker(latlng, options);\n  }\n\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n  var Circle = CircleMarker.extend({\n\n  \tinitialize: function (latlng, options, legacyOptions) {\n  \t\tif (typeof options === 'number') {\n  \t\t\t// Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n  \t\t\toptions = extend({}, legacyOptions, {radius: options});\n  \t\t}\n  \t\tsetOptions(this, options);\n  \t\tthis._latlng = toLatLng(latlng);\n\n  \t\tif (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }\n\n  \t\t// @section\n  \t\t// @aka Circle options\n  \t\t// @option radius: Number; Radius of the circle, in meters.\n  \t\tthis._mRadius = this.options.radius;\n  \t},\n\n  \t// @method setRadius(radius: Number): this\n  \t// Sets the radius of a circle. Units are in meters.\n  \tsetRadius: function (radius) {\n  \t\tthis._mRadius = radius;\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method getRadius(): Number\n  \t// Returns the current radius of a circle. Units are in meters.\n  \tgetRadius: function () {\n  \t\treturn this._mRadius;\n  \t},\n\n  \t// @method getBounds(): LatLngBounds\n  \t// Returns the `LatLngBounds` of the path.\n  \tgetBounds: function () {\n  \t\tvar half = [this._radius, this._radiusY || this._radius];\n\n  \t\treturn new LatLngBounds(\n  \t\t\tthis._map.layerPointToLatLng(this._point.subtract(half)),\n  \t\t\tthis._map.layerPointToLatLng(this._point.add(half)));\n  \t},\n\n  \tsetStyle: Path.prototype.setStyle,\n\n  \t_project: function () {\n\n  \t\tvar lng = this._latlng.lng,\n  \t\t    lat = this._latlng.lat,\n  \t\t    map = this._map,\n  \t\t    crs = map.options.crs;\n\n  \t\tif (crs.distance === Earth.distance) {\n  \t\t\tvar d = Math.PI / 180,\n  \t\t\t    latR = (this._mRadius / Earth.R) / d,\n  \t\t\t    top = map.project([lat + latR, lng]),\n  \t\t\t    bottom = map.project([lat - latR, lng]),\n  \t\t\t    p = top.add(bottom).divideBy(2),\n  \t\t\t    lat2 = map.unproject(p).lat,\n  \t\t\t    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /\n  \t\t\t            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n  \t\t\tif (isNaN(lngR) || lngR === 0) {\n  \t\t\t\tlngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n  \t\t\t}\n\n  \t\t\tthis._point = p.subtract(map.getPixelOrigin());\n  \t\t\tthis._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n  \t\t\tthis._radiusY = p.y - top.y;\n\n  \t\t} else {\n  \t\t\tvar latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n\n  \t\t\tthis._point = map.latLngToLayerPoint(this._latlng);\n  \t\t\tthis._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n  \t\t}\n\n  \t\tthis._updateBounds();\n  \t}\n  });\n\n  // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n  function circle(latlng, options, legacyOptions) {\n  \treturn new Circle(latlng, options, legacyOptions);\n  }\n\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n\n  \t// @section\n  \t// @aka Polyline options\n  \toptions: {\n  \t\t// @option smoothFactor: Number = 1.0\n  \t\t// How much to simplify the polyline on each zoom level. More means\n  \t\t// better performance and smoother look, and less means more accurate representation.\n  \t\tsmoothFactor: 1.0,\n\n  \t\t// @option noClip: Boolean = false\n  \t\t// Disable polyline clipping.\n  \t\tnoClip: false\n  \t},\n\n  \tinitialize: function (latlngs, options) {\n  \t\tsetOptions(this, options);\n  \t\tthis._setLatLngs(latlngs);\n  \t},\n\n  \t// @method getLatLngs(): LatLng[]\n  \t// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n  \tgetLatLngs: function () {\n  \t\treturn this._latlngs;\n  \t},\n\n  \t// @method setLatLngs(latlngs: LatLng[]): this\n  \t// Replaces all the points in the polyline with the given array of geographical points.\n  \tsetLatLngs: function (latlngs) {\n  \t\tthis._setLatLngs(latlngs);\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method isEmpty(): Boolean\n  \t// Returns `true` if the Polyline has no LatLngs.\n  \tisEmpty: function () {\n  \t\treturn !this._latlngs.length;\n  \t},\n\n  \t// @method closestLayerPoint(p: Point): Point\n  \t// Returns the point closest to `p` on the Polyline.\n  \tclosestLayerPoint: function (p) {\n  \t\tvar minDistance = Infinity,\n  \t\t    minPoint = null,\n  \t\t    closest = _sqClosestPointOnSegment,\n  \t\t    p1, p2;\n\n  \t\tfor (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n  \t\t\tvar points = this._parts[j];\n\n  \t\t\tfor (var i = 1, len = points.length; i < len; i++) {\n  \t\t\t\tp1 = points[i - 1];\n  \t\t\t\tp2 = points[i];\n\n  \t\t\t\tvar sqDist = closest(p, p1, p2, true);\n\n  \t\t\t\tif (sqDist < minDistance) {\n  \t\t\t\t\tminDistance = sqDist;\n  \t\t\t\t\tminPoint = closest(p, p1, p2);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (minPoint) {\n  \t\t\tminPoint.distance = Math.sqrt(minDistance);\n  \t\t}\n  \t\treturn minPoint;\n  \t},\n\n  \t// @method getCenter(): LatLng\n  \t// Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n  \tgetCenter: function () {\n  \t\t// throws error when not yet added to map as this center calculation requires projected coordinates\n  \t\tif (!this._map) {\n  \t\t\tthrow new Error('Must add layer to map before using getCenter()');\n  \t\t}\n  \t\treturn polylineCenter(this._defaultShape(), this._map.options.crs);\n  \t},\n\n  \t// @method getBounds(): LatLngBounds\n  \t// Returns the `LatLngBounds` of the path.\n  \tgetBounds: function () {\n  \t\treturn this._bounds;\n  \t},\n\n  \t// @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n  \t// Adds a given point to the polyline. By default, adds to the first ring of\n  \t// the polyline in case of a multi-polyline, but can be overridden by passing\n  \t// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n  \taddLatLng: function (latlng, latlngs) {\n  \t\tlatlngs = latlngs || this._defaultShape();\n  \t\tlatlng = toLatLng(latlng);\n  \t\tlatlngs.push(latlng);\n  \t\tthis._bounds.extend(latlng);\n  \t\treturn this.redraw();\n  \t},\n\n  \t_setLatLngs: function (latlngs) {\n  \t\tthis._bounds = new LatLngBounds();\n  \t\tthis._latlngs = this._convertLatLngs(latlngs);\n  \t},\n\n  \t_defaultShape: function () {\n  \t\treturn isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n  \t},\n\n  \t// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n  \t_convertLatLngs: function (latlngs) {\n  \t\tvar result = [],\n  \t\t    flat = isFlat(latlngs);\n\n  \t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\n  \t\t\tif (flat) {\n  \t\t\t\tresult[i] = toLatLng(latlngs[i]);\n  \t\t\t\tthis._bounds.extend(result[i]);\n  \t\t\t} else {\n  \t\t\t\tresult[i] = this._convertLatLngs(latlngs[i]);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn result;\n  \t},\n\n  \t_project: function () {\n  \t\tvar pxBounds = new Bounds();\n  \t\tthis._rings = [];\n  \t\tthis._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n  \t\tif (this._bounds.isValid() && pxBounds.isValid()) {\n  \t\t\tthis._rawPxBounds = pxBounds;\n  \t\t\tthis._updateBounds();\n  \t\t}\n  \t},\n\n  \t_updateBounds: function () {\n  \t\tvar w = this._clickTolerance(),\n  \t\t    p = new Point(w, w);\n\n  \t\tif (!this._rawPxBounds) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis._pxBounds = new Bounds([\n  \t\t\tthis._rawPxBounds.min.subtract(p),\n  \t\t\tthis._rawPxBounds.max.add(p)\n  \t\t]);\n  \t},\n\n  \t// recursively turns latlngs into a set of rings with projected coordinates\n  \t_projectLatlngs: function (latlngs, result, projectedBounds) {\n  \t\tvar flat = latlngs[0] instanceof LatLng,\n  \t\t    len = latlngs.length,\n  \t\t    i, ring;\n\n  \t\tif (flat) {\n  \t\t\tring = [];\n  \t\t\tfor (i = 0; i < len; i++) {\n  \t\t\t\tring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n  \t\t\t\tprojectedBounds.extend(ring[i]);\n  \t\t\t}\n  \t\t\tresult.push(ring);\n  \t\t} else {\n  \t\t\tfor (i = 0; i < len; i++) {\n  \t\t\t\tthis._projectLatlngs(latlngs[i], result, projectedBounds);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t// clip polyline by renderer bounds so that we have less to render for performance\n  \t_clipPoints: function () {\n  \t\tvar bounds = this._renderer._bounds;\n\n  \t\tthis._parts = [];\n  \t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.options.noClip) {\n  \t\t\tthis._parts = this._rings;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar parts = this._parts,\n  \t\t    i, j, k, len, len2, segment, points;\n\n  \t\tfor (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n  \t\t\tpoints = this._rings[i];\n\n  \t\t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\n  \t\t\t\tsegment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n  \t\t\t\tif (!segment) { continue; }\n\n  \t\t\t\tparts[k] = parts[k] || [];\n  \t\t\t\tparts[k].push(segment[0]);\n\n  \t\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\n  \t\t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n  \t\t\t\t\tparts[k].push(segment[1]);\n  \t\t\t\t\tk++;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t// simplify each clipped part of the polyline for performance\n  \t_simplifyPoints: function () {\n  \t\tvar parts = this._parts,\n  \t\t    tolerance = this.options.smoothFactor;\n\n  \t\tfor (var i = 0, len = parts.length; i < len; i++) {\n  \t\t\tparts[i] = simplify(parts[i], tolerance);\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\tif (!this._map) { return; }\n\n  \t\tthis._clipPoints();\n  \t\tthis._simplifyPoints();\n  \t\tthis._updatePath();\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updatePoly(this);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p, closed) {\n  \t\tvar i, j, k, len, len2, part,\n  \t\t    w = this._clickTolerance();\n\n  \t\tif (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }\n\n  \t\t// hit detection for polylines\n  \t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n  \t\t\tpart = this._parts[i];\n\n  \t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n  \t\t\t\tif (!closed && (j === 0)) { continue; }\n\n  \t\t\t\tif (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t}\n  });\n\n  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n  function polyline(latlngs, options) {\n  \treturn new Polyline(latlngs, options);\n  }\n\n  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n  Polyline._flat = _flat;\n\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n\n  \toptions: {\n  \t\tfill: true\n  \t},\n\n  \tisEmpty: function () {\n  \t\treturn !this._latlngs.length || !this._latlngs[0].length;\n  \t},\n\n  \t// @method getCenter(): LatLng\n  \t// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n  \tgetCenter: function () {\n  \t\t// throws error when not yet added to map as this center calculation requires projected coordinates\n  \t\tif (!this._map) {\n  \t\t\tthrow new Error('Must add layer to map before using getCenter()');\n  \t\t}\n  \t\treturn polygonCenter(this._defaultShape(), this._map.options.crs);\n  \t},\n\n  \t_convertLatLngs: function (latlngs) {\n  \t\tvar result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n  \t\t    len = result.length;\n\n  \t\t// remove last point if it equals first one\n  \t\tif (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n  \t\t\tresult.pop();\n  \t\t}\n  \t\treturn result;\n  \t},\n\n  \t_setLatLngs: function (latlngs) {\n  \t\tPolyline.prototype._setLatLngs.call(this, latlngs);\n  \t\tif (isFlat(this._latlngs)) {\n  \t\t\tthis._latlngs = [this._latlngs];\n  \t\t}\n  \t},\n\n  \t_defaultShape: function () {\n  \t\treturn isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n  \t},\n\n  \t_clipPoints: function () {\n  \t\t// polygons need a different clipping algorithm so we redefine that\n\n  \t\tvar bounds = this._renderer._bounds,\n  \t\t    w = this.options.weight,\n  \t\t    p = new Point(w, w);\n\n  \t\t// increase clip padding by stroke width to avoid stroke on clip edges\n  \t\tbounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n\n  \t\tthis._parts = [];\n  \t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.options.noClip) {\n  \t\t\tthis._parts = this._rings;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n  \t\t\tclipped = clipPolygon(this._rings[i], bounds, true);\n  \t\t\tif (clipped.length) {\n  \t\t\t\tthis._parts.push(clipped);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updatePoly(this, true);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p) {\n  \t\tvar inside = false,\n  \t\t    part, p1, p2, i, j, k, len, len2;\n\n  \t\tif (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }\n\n  \t\t// ray casting algorithm for detecting if point is in polygon\n  \t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n  \t\t\tpart = this._parts[i];\n\n  \t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n  \t\t\t\tp1 = part[j];\n  \t\t\t\tp2 = part[k];\n\n  \t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n  \t\t\t\t\tinside = !inside;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// also check if it's on polygon stroke\n  \t\treturn inside || Polyline.prototype._containsPoint.call(this, p, true);\n  \t}\n\n  });\n\n\n  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n  function polygon(latlngs, options) {\n  \treturn new Polygon(latlngs, options);\n  }\n\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var GeoJSON = FeatureGroup.extend({\r\n\r\n  \t/* @section\r\n  \t * @aka GeoJSON options\r\n  \t *\r\n  \t * @option pointToLayer: Function = *\r\n  \t * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n  \t * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n  \t * The default is to spawn a default `Marker`:\r\n  \t * ```js\r\n  \t * function(geoJsonPoint, latlng) {\r\n  \t * \treturn L.marker(latlng);\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option style: Function = *\r\n  \t * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n  \t * called internally when data is added.\r\n  \t * The default value is to not override any defaults:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn {}\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option onEachFeature: Function = *\r\n  \t * A `Function` that will be called once for each created `Feature`, after it has\r\n  \t * been created and styled. Useful for attaching events and popups to features.\r\n  \t * The default is to do nothing with the newly created layers:\r\n  \t * ```js\r\n  \t * function (feature, layer) {}\r\n  \t * ```\r\n  \t *\r\n  \t * @option filter: Function = *\r\n  \t * A `Function` that will be used to decide whether to include a feature or not.\r\n  \t * The default is to include all features:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn true;\r\n  \t * }\r\n  \t * ```\r\n  \t * Note: dynamically changing the `filter` option will have effect only on newly\r\n  \t * added data. It will _not_ re-evaluate already included features.\r\n  \t *\r\n  \t * @option coordsToLatLng: Function = *\r\n  \t * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n  \t * The default is the `coordsToLatLng` static method.\r\n  \t *\r\n  \t * @option markersInheritOptions: Boolean = false\r\n  \t * Whether default Markers for \"Point\" type Features inherit from group options.\r\n  \t */\r\n\r\n  \tinitialize: function (geojson, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layers = {};\r\n\r\n  \t\tif (geojson) {\r\n  \t\t\tthis.addData(geojson);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addData( <GeoJSON> data ): this\r\n  \t// Adds a GeoJSON object to the layer.\r\n  \taddData: function (geojson) {\r\n  \t\tvar features = isArray(geojson) ? geojson : geojson.features,\r\n  \t\t    i, len, feature;\r\n\r\n  \t\tif (features) {\r\n  \t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n  \t\t\t\t// only add this if geometry or geometries are set and not null\r\n  \t\t\t\tfeature = features[i];\r\n  \t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n  \t\t\t\t\tthis.addData(feature);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tvar options = this.options;\r\n\r\n  \t\tif (options.filter && !options.filter(geojson)) { return this; }\r\n\r\n  \t\tvar layer = geometryToLayer(geojson, options);\r\n  \t\tif (!layer) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\tlayer.feature = asFeature(geojson);\r\n\r\n  \t\tlayer.defaultOptions = layer.options;\r\n  \t\tthis.resetStyle(layer);\r\n\r\n  \t\tif (options.onEachFeature) {\r\n  \t\t\toptions.onEachFeature(geojson, layer);\r\n  \t\t}\r\n\r\n  \t\treturn this.addLayer(layer);\r\n  \t},\r\n\r\n  \t// @method resetStyle( <Path> layer? ): this\r\n  \t// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\r\n  \t// If `layer` is omitted, the style of all features in the current layer is reset.\r\n  \tresetStyle: function (layer) {\r\n  \t\tif (layer === undefined) {\r\n  \t\t\treturn this.eachLayer(this.resetStyle, this);\r\n  \t\t}\r\n  \t\t// reset any custom styles\r\n  \t\tlayer.options = extend({}, layer.defaultOptions);\r\n  \t\tthis._setLayerStyle(layer, this.options.style);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setStyle( <Function> style ): this\r\n  \t// Changes styles of GeoJSON vector layers with the given style function.\r\n  \tsetStyle: function (style) {\r\n  \t\treturn this.eachLayer(function (layer) {\r\n  \t\t\tthis._setLayerStyle(layer, style);\r\n  \t\t}, this);\r\n  \t},\r\n\r\n  \t_setLayerStyle: function (layer, style) {\r\n  \t\tif (layer.setStyle) {\r\n  \t\t\tif (typeof style === 'function') {\r\n  \t\t\t\tstyle = style(layer.feature);\r\n  \t\t\t}\r\n  \t\t\tlayer.setStyle(style);\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  // @section\r\n  // There are several static functions which can be called without instantiating L.GeoJSON:\r\n\r\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\r\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\r\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\r\n  // functions if provided as options.\r\n  function geometryToLayer(geojson, options) {\r\n\r\n  \tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n  \t    coords = geometry ? geometry.coordinates : null,\r\n  \t    layers = [],\r\n  \t    pointToLayer = options && options.pointToLayer,\r\n  \t    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\r\n  \t    latlng, latlngs, i, len;\r\n\r\n  \tif (!coords && !geometry) {\r\n  \t\treturn null;\r\n  \t}\r\n\r\n  \tswitch (geometry.type) {\r\n  \tcase 'Point':\r\n  \t\tlatlng = _coordsToLatLng(coords);\r\n  \t\treturn _pointToLayer(pointToLayer, geojson, latlng, options);\r\n\r\n  \tcase 'MultiPoint':\r\n  \t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n  \t\t\tlatlng = _coordsToLatLng(coords[i]);\r\n  \t\t\tlayers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tcase 'LineString':\r\n  \tcase 'MultiLineString':\r\n  \t\tlatlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\r\n  \t\treturn new Polyline(latlngs, options);\r\n\r\n  \tcase 'Polygon':\r\n  \tcase 'MultiPolygon':\r\n  \t\tlatlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\r\n  \t\treturn new Polygon(latlngs, options);\r\n\r\n  \tcase 'GeometryCollection':\r\n  \t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n  \t\t\tvar geoLayer = geometryToLayer({\r\n  \t\t\t\tgeometry: geometry.geometries[i],\r\n  \t\t\t\ttype: 'Feature',\r\n  \t\t\t\tproperties: geojson.properties\r\n  \t\t\t}, options);\r\n\r\n  \t\t\tif (geoLayer) {\r\n  \t\t\t\tlayers.push(geoLayer);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tcase 'FeatureCollection':\r\n  \t\tfor (i = 0, len = geometry.features.length; i < len; i++) {\r\n  \t\t\tvar featureLayer = geometryToLayer(geometry.features[i], options);\r\n\r\n  \t\t\tif (featureLayer) {\r\n  \t\t\t\tlayers.push(featureLayer);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tdefault:\r\n  \t\tthrow new Error('Invalid GeoJSON object.');\r\n  \t}\r\n  }\r\n\r\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\r\n  \treturn pointToLayerFn ?\r\n  \t\tpointToLayerFn(geojson, latlng) :\r\n  \t\tnew Marker(latlng, options && options.markersInheritOptions && options);\r\n  }\r\n\r\n  // @function coordsToLatLng(coords: Array): LatLng\r\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\r\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\r\n  function coordsToLatLng(coords) {\r\n  \treturn new LatLng(coords[1], coords[0], coords[2]);\r\n  }\r\n\r\n  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\r\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\r\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\r\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\r\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\r\n  \tvar latlngs = [];\r\n\r\n  \tfor (var i = 0, len = coords.length, latlng; i < len; i++) {\r\n  \t\tlatlng = levelsDeep ?\r\n  \t\t\tcoordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :\r\n  \t\t\t(_coordsToLatLng || coordsToLatLng)(coords[i]);\r\n\r\n  \t\tlatlngs.push(latlng);\r\n  \t}\r\n\r\n  \treturn latlngs;\r\n  }\r\n\r\n  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\r\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\r\n  function latLngToCoords(latlng, precision) {\r\n  \tlatlng = toLatLng(latlng);\r\n  \treturn latlng.alt !== undefined ?\r\n  \t\t[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :\r\n  \t\t[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\r\n  }\r\n\r\n  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\r\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\r\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\r\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\r\n  \tvar coords = [];\r\n\r\n  \tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n  \t\t// Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\r\n  \t\tcoords.push(levelsDeep ?\r\n  \t\t\tlatLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) :\r\n  \t\t\tlatLngToCoords(latlngs[i], precision));\r\n  \t}\r\n\r\n  \tif (!levelsDeep && closed && coords.length > 0) {\r\n  \t\tcoords.push(coords[0].slice());\r\n  \t}\r\n\r\n  \treturn coords;\r\n  }\r\n\r\n  function getFeature(layer, newGeometry) {\r\n  \treturn layer.feature ?\r\n  \t\textend({}, layer.feature, {geometry: newGeometry}) :\r\n  \t\tasFeature(newGeometry);\r\n  }\r\n\r\n  // @function asFeature(geojson: Object): Object\r\n  // Normalize GeoJSON geometries/features into GeoJSON features.\r\n  function asFeature(geojson) {\r\n  \tif (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\r\n  \t\treturn geojson;\r\n  \t}\r\n\r\n  \treturn {\r\n  \t\ttype: 'Feature',\r\n  \t\tproperties: {},\r\n  \t\tgeometry: geojson\r\n  \t};\r\n  }\r\n\r\n  var PointToGeoJSON = {\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: 'Point',\r\n  \t\t\tcoordinates: latLngToCoords(this.getLatLng(), precision)\r\n  \t\t});\r\n  \t}\r\n  };\r\n\r\n  // @namespace Marker\r\n  // @section Other methods\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\r\n  Marker.include(PointToGeoJSON);\r\n\r\n  // @namespace CircleMarker\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\r\n  Circle.include(PointToGeoJSON);\r\n  CircleMarker.include(PointToGeoJSON);\r\n\r\n\r\n  // @namespace Polyline\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\r\n  Polyline.include({\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\tvar multi = !isFlat(this._latlngs);\r\n\r\n  \t\tvar coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: (multi ? 'Multi' : '') + 'LineString',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t}\r\n  });\r\n\r\n  // @namespace Polygon\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\r\n  Polygon.include({\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\tvar holes = !isFlat(this._latlngs),\r\n  \t\t    multi = holes && !isFlat(this._latlngs[0]);\r\n\r\n  \t\tvar coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\r\n\r\n  \t\tif (!holes) {\r\n  \t\t\tcoords = [coords];\r\n  \t\t}\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: (multi ? 'Multi' : '') + 'Polygon',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t}\r\n  });\r\n\r\n\r\n  // @namespace LayerGroup\r\n  LayerGroup.include({\r\n  \ttoMultiPoint: function (precision) {\r\n  \t\tvar coords = [];\r\n\r\n  \t\tthis.eachLayer(function (layer) {\r\n  \t\t\tcoords.push(layer.toGeoJSON(precision).geometry.coordinates);\r\n  \t\t});\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: 'MultiPoint',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t},\r\n\r\n  \t// @method toGeoJSON(precision?: Number|false): Object\r\n  \t// Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  \t// Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\r\n  \ttoGeoJSON: function (precision) {\r\n\r\n  \t\tvar type = this.feature && this.feature.geometry && this.feature.geometry.type;\r\n\r\n  \t\tif (type === 'MultiPoint') {\r\n  \t\t\treturn this.toMultiPoint(precision);\r\n  \t\t}\r\n\r\n  \t\tvar isGeometryCollection = type === 'GeometryCollection',\r\n  \t\t    jsons = [];\r\n\r\n  \t\tthis.eachLayer(function (layer) {\r\n  \t\t\tif (layer.toGeoJSON) {\r\n  \t\t\t\tvar json = layer.toGeoJSON(precision);\r\n  \t\t\t\tif (isGeometryCollection) {\r\n  \t\t\t\t\tjsons.push(json.geometry);\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\tvar feature = asFeature(json);\r\n  \t\t\t\t\t// Squash nested feature collections\r\n  \t\t\t\t\tif (feature.type === 'FeatureCollection') {\r\n  \t\t\t\t\t\tjsons.push.apply(jsons, feature.features);\r\n  \t\t\t\t\t} else {\r\n  \t\t\t\t\t\tjsons.push(feature);\r\n  \t\t\t\t\t}\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t});\r\n\r\n  \t\tif (isGeometryCollection) {\r\n  \t\t\treturn getFeature(this, {\r\n  \t\t\t\tgeometries: jsons,\r\n  \t\t\t\ttype: 'GeometryCollection'\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\treturn {\r\n  \t\t\ttype: 'FeatureCollection',\r\n  \t\t\tfeatures: jsons\r\n  \t\t};\r\n  \t}\r\n  });\r\n\r\n  // @namespace GeoJSON\r\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\r\n  // Creates a GeoJSON layer. Optionally accepts an object in\r\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\r\n  // (you can alternatively add it later with `addData` method) and an `options` object.\r\n  function geoJSON(geojson, options) {\r\n  \treturn new GeoJSON(geojson, options);\r\n  }\r\n\r\n  // Backward compatibility.\r\n  var geoJson = geoJSON;\n\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var ImageOverlay = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka ImageOverlay options\r\n  \toptions: {\r\n  \t\t// @option opacity: Number = 1.0\r\n  \t\t// The opacity of the image overlay.\r\n  \t\topacity: 1,\r\n\r\n  \t\t// @option alt: String = ''\r\n  \t\t// Text for the `alt` attribute of the image (useful for accessibility).\r\n  \t\talt: '',\r\n\r\n  \t\t// @option interactive: Boolean = false\r\n  \t\t// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\r\n  \t\tinteractive: false,\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the image.\r\n  \t\t// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false,\r\n\r\n  \t\t// @option errorOverlayUrl: String = ''\r\n  \t\t// URL to the overlay image to show in place of the overlay that failed to load.\r\n  \t\terrorOverlayUrl: '',\r\n\r\n  \t\t// @option zIndex: Number = 1\r\n  \t\t// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\r\n  \t\tzIndex: 1,\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom class name to assign to the image. Empty by default.\r\n  \t\tclassName: ''\r\n  \t},\r\n\r\n  \tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n  \t\tthis._url = url;\r\n  \t\tthis._bounds = toLatLngBounds(bounds);\r\n\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \tonAdd: function () {\r\n  \t\tif (!this._image) {\r\n  \t\t\tthis._initImage();\r\n\r\n  \t\t\tif (this.options.opacity < 1) {\r\n  \t\t\t\tthis._updateOpacity();\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\taddClass(this._image, 'leaflet-interactive');\r\n  \t\t\tthis.addInteractiveTarget(this._image);\r\n  \t\t}\r\n\r\n  \t\tthis.getPane().appendChild(this._image);\r\n  \t\tthis._reset();\r\n  \t},\r\n\r\n  \tonRemove: function () {\r\n  \t\tremove(this._image);\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\tthis.removeInteractiveTarget(this._image);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setOpacity(opacity: Number): this\r\n  \t// Sets the opacity of the overlay.\r\n  \tsetOpacity: function (opacity) {\r\n  \t\tthis.options.opacity = opacity;\r\n\r\n  \t\tif (this._image) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tsetStyle: function (styleOpts) {\r\n  \t\tif (styleOpts.opacity) {\r\n  \t\t\tthis.setOpacity(styleOpts.opacity);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToFront(): this\r\n  \t// Brings the layer to the top of all overlays.\r\n  \tbringToFront: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoFront(this._image);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToBack(): this\r\n  \t// Brings the layer to the bottom of all overlays.\r\n  \tbringToBack: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoBack(this._image);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setUrl(url: String): this\r\n  \t// Changes the URL of the image.\r\n  \tsetUrl: function (url) {\r\n  \t\tthis._url = url;\r\n\r\n  \t\tif (this._image) {\r\n  \t\t\tthis._image.src = url;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setBounds(bounds: LatLngBounds): this\r\n  \t// Update the bounds that this ImageOverlay covers\r\n  \tsetBounds: function (bounds) {\r\n  \t\tthis._bounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._reset();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = {\r\n  \t\t\tzoom: this._reset,\r\n  \t\t\tviewreset: this._reset\r\n  \t\t};\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tevents.zoomanim = this._animateZoom;\r\n  \t\t}\r\n\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t// @method setZIndex(value: Number): this\r\n  \t// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\r\n  \tsetZIndex: function (value) {\r\n  \t\tthis.options.zIndex = value;\r\n  \t\tthis._updateZIndex();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Get the bounds that this ImageOverlay covers\r\n  \tgetBounds: function () {\r\n  \t\treturn this._bounds;\r\n  \t},\r\n\r\n  \t// @method getElement(): HTMLElement\r\n  \t// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\r\n  \t// used by this overlay.\r\n  \tgetElement: function () {\r\n  \t\treturn this._image;\r\n  \t},\r\n\r\n  \t_initImage: function () {\r\n  \t\tvar wasElementSupplied = this._url.tagName === 'IMG';\r\n  \t\tvar img = this._image = wasElementSupplied ? this._url : create$1('img');\r\n\r\n  \t\taddClass(img, 'leaflet-image-layer');\r\n  \t\tif (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }\r\n  \t\tif (this.options.className) { addClass(img, this.options.className); }\r\n\r\n  \t\timg.onselectstart = falseFn;\r\n  \t\timg.onmousemove = falseFn;\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the ImageOverlay layer has loaded its image\r\n  \t\timg.onload = bind(this.fire, this, 'load');\r\n  \t\timg.onerror = bind(this._overlayOnError, this, 'error');\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\timg.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\tif (this.options.zIndex) {\r\n  \t\t\tthis._updateZIndex();\r\n  \t\t}\r\n\r\n  \t\tif (wasElementSupplied) {\r\n  \t\t\tthis._url = img.src;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\timg.src = this._url;\r\n  \t\timg.alt = this.options.alt;\r\n  \t},\r\n\r\n  \t_animateZoom: function (e) {\r\n  \t\tvar scale = this._map.getZoomScale(e.zoom),\r\n  \t\t    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\r\n\r\n  \t\tsetTransform(this._image, offset, scale);\r\n  \t},\r\n\r\n  \t_reset: function () {\r\n  \t\tvar image = this._image,\r\n  \t\t    bounds = new Bounds(\r\n  \t\t        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n  \t\t        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\r\n  \t\t    size = bounds.getSize();\r\n\r\n  \t\tsetPosition(image, bounds.min);\r\n\r\n  \t\timage.style.width  = size.x + 'px';\r\n  \t\timage.style.height = size.y + 'px';\r\n  \t},\r\n\r\n  \t_updateOpacity: function () {\r\n  \t\tsetOpacity(this._image, this.options.opacity);\r\n  \t},\r\n\r\n  \t_updateZIndex: function () {\r\n  \t\tif (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\r\n  \t\t\tthis._image.style.zIndex = this.options.zIndex;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_overlayOnError: function () {\r\n  \t\t// @event error: Event\r\n  \t\t// Fired when the ImageOverlay layer fails to load its image\r\n  \t\tthis.fire('error');\r\n\r\n  \t\tvar errorUrl = this.options.errorOverlayUrl;\r\n  \t\tif (errorUrl && this._url !== errorUrl) {\r\n  \t\t\tthis._url = errorUrl;\r\n  \t\t\tthis._image.src = errorUrl;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the center of the ImageOverlay.\r\n  \tgetCenter: function () {\r\n  \t\treturn this._bounds.getCenter();\r\n  \t}\r\n  });\r\n\r\n  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\r\n  // Instantiates an image overlay object given the URL of the image and the\r\n  // geographical bounds it is tied to.\r\n  var imageOverlay = function (url, bounds, options) {\r\n  \treturn new ImageOverlay(url, bounds, options);\r\n  };\n\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var VideoOverlay = ImageOverlay.extend({\r\n\r\n  \t// @section\r\n  \t// @aka VideoOverlay options\r\n  \toptions: {\r\n  \t\t// @option autoplay: Boolean = true\r\n  \t\t// Whether the video starts playing automatically when loaded.\r\n  \t\t// On some browsers autoplay will only work with `muted: true`\r\n  \t\tautoplay: true,\r\n\r\n  \t\t// @option loop: Boolean = true\r\n  \t\t// Whether the video will loop back to the beginning when played.\r\n  \t\tloop: true,\r\n\r\n  \t\t// @option keepAspectRatio: Boolean = true\r\n  \t\t// Whether the video will save aspect ratio after the projection.\r\n  \t\t// Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\r\n  \t\tkeepAspectRatio: true,\r\n\r\n  \t\t// @option muted: Boolean = false\r\n  \t\t// Whether the video starts on mute when loaded.\r\n  \t\tmuted: false,\r\n\r\n  \t\t// @option playsInline: Boolean = true\r\n  \t\t// Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\r\n  \t\tplaysInline: true\r\n  \t},\r\n\r\n  \t_initImage: function () {\r\n  \t\tvar wasElementSupplied = this._url.tagName === 'VIDEO';\r\n  \t\tvar vid = this._image = wasElementSupplied ? this._url : create$1('video');\r\n\r\n  \t\taddClass(vid, 'leaflet-image-layer');\r\n  \t\tif (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }\r\n  \t\tif (this.options.className) { addClass(vid, this.options.className); }\r\n\r\n  \t\tvid.onselectstart = falseFn;\r\n  \t\tvid.onmousemove = falseFn;\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the video has finished loading the first frame\r\n  \t\tvid.onloadeddata = bind(this.fire, this, 'load');\r\n\r\n  \t\tif (wasElementSupplied) {\r\n  \t\t\tvar sourceElements = vid.getElementsByTagName('source');\r\n  \t\t\tvar sources = [];\r\n  \t\t\tfor (var j = 0; j < sourceElements.length; j++) {\r\n  \t\t\t\tsources.push(sourceElements[j].src);\r\n  \t\t\t}\r\n\r\n  \t\t\tthis._url = (sourceElements.length > 0) ? sources : [vid.src];\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (!isArray(this._url)) { this._url = [this._url]; }\r\n\r\n  \t\tif (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\r\n  \t\t\tvid.style['objectFit'] = 'fill';\r\n  \t\t}\r\n  \t\tvid.autoplay = !!this.options.autoplay;\r\n  \t\tvid.loop = !!this.options.loop;\r\n  \t\tvid.muted = !!this.options.muted;\r\n  \t\tvid.playsInline = !!this.options.playsInline;\r\n  \t\tfor (var i = 0; i < this._url.length; i++) {\r\n  \t\t\tvar source = create$1('source');\r\n  \t\t\tsource.src = this._url[i];\r\n  \t\t\tvid.appendChild(source);\r\n  \t\t}\r\n  \t}\r\n\r\n  \t// @method getElement(): HTMLVideoElement\r\n  \t// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\r\n  \t// used by this overlay.\r\n  });\r\n\r\n\r\n  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\r\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\r\n  // geographical bounds it is tied to.\r\n\r\n  function videoOverlay(video, bounds, options) {\r\n  \treturn new VideoOverlay(video, bounds, options);\r\n  }\n\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n  var SVGOverlay = ImageOverlay.extend({\n  \t_initImage: function () {\n  \t\tvar el = this._image = this._url;\n\n  \t\taddClass(el, 'leaflet-image-layer');\n  \t\tif (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }\n  \t\tif (this.options.className) { addClass(el, this.options.className); }\n\n  \t\tel.onselectstart = falseFn;\n  \t\tel.onmousemove = falseFn;\n  \t}\n\n  \t// @method getElement(): SVGElement\n  \t// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n  \t// used by this overlay.\n  });\n\n\n  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n  \treturn new SVGOverlay(el, bounds, options);\n  }\n\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */\r\n\r\n  // @namespace DivOverlay\r\n  var DivOverlay = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka DivOverlay options\r\n  \toptions: {\r\n  \t\t// @option interactive: Boolean = false\r\n  \t\t// If true, the popup/tooltip will listen to the mouse events.\r\n  \t\tinteractive: false,\r\n\r\n  \t\t// @option offset: Point = Point(0, 0)\r\n  \t\t// The offset of the overlay position.\r\n  \t\toffset: [0, 0],\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom CSS class name to assign to the overlay.\r\n  \t\tclassName: '',\r\n\r\n  \t\t// @option pane: String = undefined\r\n  \t\t// `Map pane` where the overlay will be added.\r\n  \t\tpane: undefined,\r\n\r\n  \t\t// @option content: String|HTMLElement|Function = ''\r\n  \t\t// Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\r\n  \t\t// passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\r\n  \t\tcontent: ''\r\n  \t},\r\n\r\n  \tinitialize: function (options, source) {\r\n  \t\tif (options && (options instanceof LatLng || isArray(options))) {\r\n  \t\t\tthis._latlng = toLatLng(options);\r\n  \t\t\tsetOptions(this, source);\r\n  \t\t} else {\r\n  \t\t\tsetOptions(this, options);\r\n  \t\t\tthis._source = source;\r\n  \t\t}\r\n  \t\tif (this.options.content) {\r\n  \t\t\tthis._content = this.options.content;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method openOn(map: Map): this\r\n  \t// Adds the overlay to the map.\r\n  \t// Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\r\n  \topenOn: function (map) {\r\n  \t\tmap = arguments.length ? map : this._source._map; // experimental, not the part of public api\r\n  \t\tif (!map.hasLayer(this)) {\r\n  \t\t\tmap.addLayer(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method close(): this\r\n  \t// Closes the overlay.\r\n  \t// Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\r\n  \t// and `layer.closePopup()`/`.closeTooltip()`.\r\n  \tclose: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._map.removeLayer(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method toggle(layer?: Layer): this\r\n  \t// Opens or closes the overlay bound to layer depending on its current state.\r\n  \t// Argument may be omitted only for overlay bound to layer.\r\n  \t// Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\r\n  \ttoggle: function (layer) {\r\n  \t\tif (this._map) {\r\n  \t\t\tthis.close();\r\n  \t\t} else {\r\n  \t\t\tif (arguments.length) {\r\n  \t\t\t\tthis._source = layer;\r\n  \t\t\t} else {\r\n  \t\t\t\tlayer = this._source;\r\n  \t\t\t}\r\n  \t\t\tthis._prepareOpen();\r\n\r\n  \t\t\t// open the overlay on the map\r\n  \t\t\tthis.openOn(layer._map);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._zoomAnimated = map._zoomAnimated;\r\n\r\n  \t\tif (!this._container) {\r\n  \t\t\tthis._initLayout();\r\n  \t\t}\r\n\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 0);\r\n  \t\t}\r\n\r\n  \t\tclearTimeout(this._removeTimeout);\r\n  \t\tthis.getPane().appendChild(this._container);\r\n  \t\tthis.update();\r\n\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 1);\r\n  \t\t}\r\n\r\n  \t\tthis.bringToFront();\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\taddClass(this._container, 'leaflet-interactive');\r\n  \t\t\tthis.addInteractiveTarget(this._container);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 0);\r\n  \t\t\tthis._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\r\n  \t\t} else {\r\n  \t\t\tremove(this._container);\r\n  \t\t}\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\tremoveClass(this._container, 'leaflet-interactive');\r\n  \t\t\tthis.removeInteractiveTarget(this._container);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @namespace DivOverlay\r\n  \t// @method getLatLng: LatLng\r\n  \t// Returns the geographical point of the overlay.\r\n  \tgetLatLng: function () {\r\n  \t\treturn this._latlng;\r\n  \t},\r\n\r\n  \t// @method setLatLng(latlng: LatLng): this\r\n  \t// Sets the geographical point where the overlay will open.\r\n  \tsetLatLng: function (latlng) {\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._updatePosition();\r\n  \t\t\tthis._adjustPan();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getContent: String|HTMLElement\r\n  \t// Returns the content of the overlay.\r\n  \tgetContent: function () {\r\n  \t\treturn this._content;\r\n  \t},\r\n\r\n  \t// @method setContent(htmlContent: String|HTMLElement|Function): this\r\n  \t// Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\r\n  \t// The function should return a `String` or `HTMLElement` to be used in the overlay.\r\n  \tsetContent: function (content) {\r\n  \t\tthis._content = content;\r\n  \t\tthis.update();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getElement: String|HTMLElement\r\n  \t// Returns the HTML container of the overlay.\r\n  \tgetElement: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \t// @method update: null\r\n  \t// Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\r\n  \tupdate: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tthis._container.style.visibility = 'hidden';\r\n\r\n  \t\tthis._updateContent();\r\n  \t\tthis._updateLayout();\r\n  \t\tthis._updatePosition();\r\n\r\n  \t\tthis._container.style.visibility = '';\r\n\r\n  \t\tthis._adjustPan();\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = {\r\n  \t\t\tzoom: this._updatePosition,\r\n  \t\t\tviewreset: this._updatePosition\r\n  \t\t};\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tevents.zoomanim = this._animateZoom;\r\n  \t\t}\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t// @method isOpen: Boolean\r\n  \t// Returns `true` when the overlay is visible on the map.\r\n  \tisOpen: function () {\r\n  \t\treturn !!this._map && this._map.hasLayer(this);\r\n  \t},\r\n\r\n  \t// @method bringToFront: this\r\n  \t// Brings this overlay in front of other overlays (in the same map pane).\r\n  \tbringToFront: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoFront(this._container);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToBack: this\r\n  \t// Brings this overlay to the back of other overlays (in the same map pane).\r\n  \tbringToBack: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoBack(this._container);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\r\n  \t_prepareOpen: function (latlng) {\r\n  \t\tvar source = this._source;\r\n  \t\tif (!source._map) { return false; }\r\n\r\n  \t\tif (source instanceof FeatureGroup) {\r\n  \t\t\tsource = null;\r\n  \t\t\tvar layers = this._source._layers;\r\n  \t\t\tfor (var id in layers) {\r\n  \t\t\t\tif (layers[id]._map) {\r\n  \t\t\t\t\tsource = layers[id];\r\n  \t\t\t\t\tbreak;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\tif (!source) { return false; } // Unable to get source layer.\r\n\r\n  \t\t\t// set overlay source to this layer\r\n  \t\t\tthis._source = source;\r\n  \t\t}\r\n\r\n  \t\tif (!latlng) {\r\n  \t\t\tif (source.getCenter) {\r\n  \t\t\t\tlatlng = source.getCenter();\r\n  \t\t\t} else if (source.getLatLng) {\r\n  \t\t\t\tlatlng = source.getLatLng();\r\n  \t\t\t} else if (source.getBounds) {\r\n  \t\t\t\tlatlng = source.getBounds().getCenter();\r\n  \t\t\t} else {\r\n  \t\t\t\tthrow new Error('Unable to get source layer LatLng.');\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthis.setLatLng(latlng);\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\t// update the overlay (content, layout, etc...)\r\n  \t\t\tthis.update();\r\n  \t\t}\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_updateContent: function () {\r\n  \t\tif (!this._content) { return; }\r\n\r\n  \t\tvar node = this._contentNode;\r\n  \t\tvar content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;\r\n\r\n  \t\tif (typeof content === 'string') {\r\n  \t\t\tnode.innerHTML = content;\r\n  \t\t} else {\r\n  \t\t\twhile (node.hasChildNodes()) {\r\n  \t\t\t\tnode.removeChild(node.firstChild);\r\n  \t\t\t}\r\n  \t\t\tnode.appendChild(content);\r\n  \t\t}\r\n\r\n  \t\t// @namespace DivOverlay\r\n  \t\t// @section DivOverlay events\r\n  \t\t// @event contentupdate: Event\r\n  \t\t// Fired when the content of the overlay is updated\r\n  \t\tthis.fire('contentupdate');\r\n  \t},\r\n\r\n  \t_updatePosition: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n  \t\t    offset = toPoint(this.options.offset),\r\n  \t\t    anchor = this._getAnchor();\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tsetPosition(this._container, pos.add(anchor));\r\n  \t\t} else {\r\n  \t\t\toffset = offset.add(pos).add(anchor);\r\n  \t\t}\r\n\r\n  \t\tvar bottom = this._containerBottom = -offset.y,\r\n  \t\t    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\r\n\r\n  \t\t// bottom position the overlay in case the height of the overlay changes (images loading etc)\r\n  \t\tthis._container.style.bottom = bottom + 'px';\r\n  \t\tthis._container.style.left = left + 'px';\r\n  \t},\r\n\r\n  \t_getAnchor: function () {\r\n  \t\treturn [0, 0];\r\n  \t}\r\n\r\n  });\r\n\r\n  Map.include({\r\n  \t_initOverlay: function (OverlayClass, content, latlng, options) {\r\n  \t\tvar overlay = content;\r\n  \t\tif (!(overlay instanceof OverlayClass)) {\r\n  \t\t\toverlay = new OverlayClass(options).setContent(content);\r\n  \t\t}\r\n  \t\tif (latlng) {\r\n  \t\t\toverlay.setLatLng(latlng);\r\n  \t\t}\r\n  \t\treturn overlay;\r\n  \t}\r\n  });\r\n\r\n\r\n  Layer.include({\r\n  \t_initOverlay: function (OverlayClass, old, content, options) {\r\n  \t\tvar overlay = content;\r\n  \t\tif (overlay instanceof OverlayClass) {\r\n  \t\t\tsetOptions(overlay, options);\r\n  \t\t\toverlay._source = this;\r\n  \t\t} else {\r\n  \t\t\toverlay = (old && !options) ? old : new OverlayClass(options, this);\r\n  \t\t\toverlay.setContent(content);\r\n  \t\t}\r\n  \t\treturn overlay;\r\n  \t}\r\n  });\n\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\r\n\r\n\r\n  // @namespace Popup\r\n  var Popup = DivOverlay.extend({\r\n\r\n  \t// @section\r\n  \t// @aka Popup options\r\n  \toptions: {\r\n  \t\t// @option pane: String = 'popupPane'\r\n  \t\t// `Map pane` where the popup will be added.\r\n  \t\tpane: 'popupPane',\r\n\r\n  \t\t// @option offset: Point = Point(0, 7)\r\n  \t\t// The offset of the popup position.\r\n  \t\toffset: [0, 7],\r\n\r\n  \t\t// @option maxWidth: Number = 300\r\n  \t\t// Max width of the popup, in pixels.\r\n  \t\tmaxWidth: 300,\r\n\r\n  \t\t// @option minWidth: Number = 50\r\n  \t\t// Min width of the popup, in pixels.\r\n  \t\tminWidth: 50,\r\n\r\n  \t\t// @option maxHeight: Number = null\r\n  \t\t// If set, creates a scrollable container of the given height\r\n  \t\t// inside a popup if its content exceeds it.\r\n  \t\t// The scrollable container can be styled using the\r\n  \t\t// `leaflet-popup-scrolled` CSS class selector.\r\n  \t\tmaxHeight: null,\r\n\r\n  \t\t// @option autoPan: Boolean = true\r\n  \t\t// Set it to `false` if you don't want the map to do panning animation\r\n  \t\t// to fit the opened popup.\r\n  \t\tautoPan: true,\r\n\r\n  \t\t// @option autoPanPaddingTopLeft: Point = null\r\n  \t\t// The margin between the popup and the top left corner of the map\r\n  \t\t// view after autopanning was performed.\r\n  \t\tautoPanPaddingTopLeft: null,\r\n\r\n  \t\t// @option autoPanPaddingBottomRight: Point = null\r\n  \t\t// The margin between the popup and the bottom right corner of the map\r\n  \t\t// view after autopanning was performed.\r\n  \t\tautoPanPaddingBottomRight: null,\r\n\r\n  \t\t// @option autoPanPadding: Point = Point(5, 5)\r\n  \t\t// Equivalent of setting both top left and bottom right autopan padding to the same value.\r\n  \t\tautoPanPadding: [5, 5],\r\n\r\n  \t\t// @option keepInView: Boolean = false\r\n  \t\t// Set it to `true` if you want to prevent users from panning the popup\r\n  \t\t// off of the screen while it is open.\r\n  \t\tkeepInView: false,\r\n\r\n  \t\t// @option closeButton: Boolean = true\r\n  \t\t// Controls the presence of a close button in the popup.\r\n  \t\tcloseButton: true,\r\n\r\n  \t\t// @option autoClose: Boolean = true\r\n  \t\t// Set it to `false` if you want to override the default behavior of\r\n  \t\t// the popup closing when another popup is opened.\r\n  \t\tautoClose: true,\r\n\r\n  \t\t// @option closeOnEscapeKey: Boolean = true\r\n  \t\t// Set it to `false` if you want to override the default behavior of\r\n  \t\t// the ESC key for closing of the popup.\r\n  \t\tcloseOnEscapeKey: true,\r\n\r\n  \t\t// @option closeOnClick: Boolean = *\r\n  \t\t// Set it if you want to override the default behavior of the popup closing when user clicks\r\n  \t\t// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom CSS class name to assign to the popup.\r\n  \t\tclassName: ''\r\n  \t},\r\n\r\n  \t// @namespace Popup\r\n  \t// @method openOn(map: Map): this\r\n  \t// Alternative to `map.openPopup(popup)`.\r\n  \t// Adds the popup to the map and closes the previous one.\r\n  \topenOn: function (map) {\r\n  \t\tmap = arguments.length ? map : this._source._map; // experimental, not the part of public api\r\n\r\n  \t\tif (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\r\n  \t\t\tmap.removeLayer(map._popup);\r\n  \t\t}\r\n  \t\tmap._popup = this;\r\n\r\n  \t\treturn DivOverlay.prototype.openOn.call(this, map);\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tDivOverlay.prototype.onAdd.call(this, map);\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event popupopen: PopupEvent\r\n  \t\t// Fired when a popup is opened in the map\r\n  \t\tmap.fire('popupopen', {popup: this});\r\n\r\n  \t\tif (this._source) {\r\n  \t\t\t// @namespace Layer\r\n  \t\t\t// @section Popup events\r\n  \t\t\t// @event popupopen: PopupEvent\r\n  \t\t\t// Fired when a popup bound to this layer is opened\r\n  \t\t\tthis._source.fire('popupopen', {popup: this}, true);\r\n  \t\t\t// For non-path layers, we toggle the popup when clicking\r\n  \t\t\t// again the layer, so prevent the map to reopen it.\r\n  \t\t\tif (!(this._source instanceof Path)) {\r\n  \t\t\t\tthis._source.on('preclick', stopPropagation);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tDivOverlay.prototype.onRemove.call(this, map);\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event popupclose: PopupEvent\r\n  \t\t// Fired when a popup in the map is closed\r\n  \t\tmap.fire('popupclose', {popup: this});\r\n\r\n  \t\tif (this._source) {\r\n  \t\t\t// @namespace Layer\r\n  \t\t\t// @section Popup events\r\n  \t\t\t// @event popupclose: PopupEvent\r\n  \t\t\t// Fired when a popup bound to this layer is closed\r\n  \t\t\tthis._source.fire('popupclose', {popup: this}, true);\r\n  \t\t\tif (!(this._source instanceof Path)) {\r\n  \t\t\t\tthis._source.off('preclick', stopPropagation);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = DivOverlay.prototype.getEvents.call(this);\r\n\r\n  \t\tif (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n  \t\t\tevents.preclick = this.close;\r\n  \t\t}\r\n\r\n  \t\tif (this.options.keepInView) {\r\n  \t\t\tevents.moveend = this._adjustPan;\r\n  \t\t}\r\n\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar prefix = 'leaflet-popup',\r\n  \t\t    container = this._container = create$1('div',\r\n  \t\t\tprefix + ' ' + (this.options.className || '') +\r\n  \t\t\t' leaflet-zoom-animated');\r\n\r\n  \t\tvar wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\r\n  \t\tthis._contentNode = create$1('div', prefix + '-content', wrapper);\r\n\r\n  \t\tdisableClickPropagation(container);\r\n  \t\tdisableScrollPropagation(this._contentNode);\r\n  \t\ton(container, 'contextmenu', stopPropagation);\r\n\r\n  \t\tthis._tipContainer = create$1('div', prefix + '-tip-container', container);\r\n  \t\tthis._tip = create$1('div', prefix + '-tip', this._tipContainer);\r\n\r\n  \t\tif (this.options.closeButton) {\r\n  \t\t\tvar closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\r\n  \t\t\tcloseButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399\r\n  \t\t\tcloseButton.setAttribute('aria-label', 'Close popup');\r\n  \t\t\tcloseButton.href = '#close';\r\n  \t\t\tcloseButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\r\n\r\n  \t\t\ton(closeButton, 'click', function (ev) {\r\n  \t\t\t\tpreventDefault(ev);\r\n  \t\t\t\tthis.close();\r\n  \t\t\t}, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_updateLayout: function () {\r\n  \t\tvar container = this._contentNode,\r\n  \t\t    style = container.style;\r\n\r\n  \t\tstyle.width = '';\r\n  \t\tstyle.whiteSpace = 'nowrap';\r\n\r\n  \t\tvar width = container.offsetWidth;\r\n  \t\twidth = Math.min(width, this.options.maxWidth);\r\n  \t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n  \t\tstyle.width = (width + 1) + 'px';\r\n  \t\tstyle.whiteSpace = '';\r\n\r\n  \t\tstyle.height = '';\r\n\r\n  \t\tvar height = container.offsetHeight,\r\n  \t\t    maxHeight = this.options.maxHeight,\r\n  \t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n  \t\tif (maxHeight && height > maxHeight) {\r\n  \t\t\tstyle.height = maxHeight + 'px';\r\n  \t\t\taddClass(container, scrolledClass);\r\n  \t\t} else {\r\n  \t\t\tremoveClass(container, scrolledClass);\r\n  \t\t}\r\n\r\n  \t\tthis._containerWidth = this._container.offsetWidth;\r\n  \t},\r\n\r\n  \t_animateZoom: function (e) {\r\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\r\n  \t\t    anchor = this._getAnchor();\r\n  \t\tsetPosition(this._container, pos.add(anchor));\r\n  \t},\r\n\r\n  \t_adjustPan: function () {\r\n  \t\tif (!this.options.autoPan) { return; }\r\n  \t\tif (this._map._panAnim) { this._map._panAnim.stop(); }\r\n\r\n  \t\t// We can endlessly recurse if keepInView is set and the view resets.\r\n  \t\t// Let's guard against that by exiting early if we're responding to our own autopan.\r\n  \t\tif (this._autopanning) {\r\n  \t\t\tthis._autopanning = false;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar map = this._map,\r\n  \t\t    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\r\n  \t\t    containerHeight = this._container.offsetHeight + marginBottom,\r\n  \t\t    containerWidth = this._containerWidth,\r\n  \t\t    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n  \t\tlayerPos._add(getPosition(this._container));\r\n\r\n  \t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n  \t\t    padding = toPoint(this.options.autoPanPadding),\r\n  \t\t    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\r\n  \t\t    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\r\n  \t\t    size = map.getSize(),\r\n  \t\t    dx = 0,\r\n  \t\t    dy = 0;\r\n\r\n  \t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n  \t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n  \t\t}\r\n  \t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n  \t\t\tdx = containerPos.x - paddingTL.x;\r\n  \t\t}\r\n  \t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n  \t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n  \t\t}\r\n  \t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n  \t\t\tdy = containerPos.y - paddingTL.y;\r\n  \t\t}\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event autopanstart: Event\r\n  \t\t// Fired when the map starts autopanning when opening a popup.\r\n  \t\tif (dx || dy) {\r\n  \t\t\t// Track that we're autopanning, as this function will be re-ran on moveend\r\n  \t\t\tif (this.options.keepInView) {\r\n  \t\t\t\tthis._autopanning = true;\r\n  \t\t\t}\r\n\r\n  \t\t\tmap\r\n  \t\t\t    .fire('autopanstart')\r\n  \t\t\t    .panBy([dx, dy]);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_getAnchor: function () {\r\n  \t\t// Where should we anchor the popup on the source layer?\r\n  \t\treturn toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\r\n  \t}\r\n\r\n  });\r\n\r\n  // @namespace Popup\r\n  // @factory L.popup(options?: Popup options, source?: Layer)\r\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\r\n  // @alternative\r\n  // @factory L.popup(latlng: LatLng, options?: Popup options)\r\n  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\r\n  var popup = function (options, source) {\r\n  \treturn new Popup(options, source);\r\n  };\r\n\r\n\r\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\r\n  Map.mergeOptions({\r\n  \tclosePopupOnClick: true\r\n  });\r\n\r\n\r\n  // @namespace Map\r\n  // @section Methods for Layers and Controls\r\n  Map.include({\r\n  \t// @method openPopup(popup: Popup): this\r\n  \t// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\r\n  \t// @alternative\r\n  \t// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\r\n  \t// Creates a popup with the specified content and options and opens it in the given point on a map.\r\n  \topenPopup: function (popup, latlng, options) {\r\n  \t\tthis._initOverlay(Popup, popup, latlng, options)\r\n  \t\t  .openOn(this);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method closePopup(popup?: Popup): this\r\n  \t// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\r\n  \tclosePopup: function (popup) {\r\n  \t\tpopup = arguments.length ? popup : this._popup;\r\n  \t\tif (popup) {\r\n  \t\t\tpopup.close();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t}\r\n  });\r\n\r\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\r\n\r\n  // @section Popup methods\r\n  Layer.include({\r\n\r\n  \t// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\r\n  \t// Binds a popup to the layer with the passed `content` and sets up the\r\n  \t// necessary event listeners. If a `Function` is passed it will receive\r\n  \t// the layer as the first argument and should return a `String` or `HTMLElement`.\r\n  \tbindPopup: function (content, options) {\r\n  \t\tthis._popup = this._initOverlay(Popup, this._popup, content, options);\r\n  \t\tif (!this._popupHandlersAdded) {\r\n  \t\t\tthis.on({\r\n  \t\t\t\tclick: this._openPopup,\r\n  \t\t\t\tkeypress: this._onKeyPress,\r\n  \t\t\t\tremove: this.closePopup,\r\n  \t\t\t\tmove: this._movePopup\r\n  \t\t\t});\r\n  \t\t\tthis._popupHandlersAdded = true;\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method unbindPopup(): this\r\n  \t// Removes the popup previously bound with `bindPopup`.\r\n  \tunbindPopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis.off({\r\n  \t\t\t\tclick: this._openPopup,\r\n  \t\t\t\tkeypress: this._onKeyPress,\r\n  \t\t\t\tremove: this.closePopup,\r\n  \t\t\t\tmove: this._movePopup\r\n  \t\t\t});\r\n  \t\t\tthis._popupHandlersAdded = false;\r\n  \t\t\tthis._popup = null;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method openPopup(latlng?: LatLng): this\r\n  \t// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\r\n  \topenPopup: function (latlng) {\r\n  \t\tif (this._popup) {\r\n  \t\t\tif (!(this instanceof FeatureGroup)) {\r\n  \t\t\t\tthis._popup._source = this;\r\n  \t\t\t}\r\n  \t\t\tif (this._popup._prepareOpen(latlng || this._latlng)) {\r\n  \t\t\t\t// open the popup on the map\r\n  \t\t\t\tthis._popup.openOn(this._map);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method closePopup(): this\r\n  \t// Closes the popup bound to this layer if it is open.\r\n  \tclosePopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.close();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method togglePopup(): this\r\n  \t// Opens or closes the popup bound to this layer depending on its current state.\r\n  \ttogglePopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.toggle(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method isPopupOpen(): boolean\r\n  \t// Returns `true` if the popup bound to this layer is currently open.\r\n  \tisPopupOpen: function () {\r\n  \t\treturn (this._popup ? this._popup.isOpen() : false);\r\n  \t},\r\n\r\n  \t// @method setPopupContent(content: String|HTMLElement|Popup): this\r\n  \t// Sets the content of the popup bound to this layer.\r\n  \tsetPopupContent: function (content) {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.setContent(content);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getPopup(): Popup\r\n  \t// Returns the popup bound to this layer.\r\n  \tgetPopup: function () {\r\n  \t\treturn this._popup;\r\n  \t},\r\n\r\n  \t_openPopup: function (e) {\r\n  \t\tif (!this._popup || !this._map) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\t// prevent map click\r\n  \t\tstop(e);\r\n\r\n  \t\tvar target = e.layer || e.target;\r\n  \t\tif (this._popup._source === target && !(target instanceof Path)) {\r\n  \t\t\t// treat it like a marker and figure out\r\n  \t\t\t// if we should toggle it open/closed\r\n  \t\t\tif (this._map.hasLayer(this._popup)) {\r\n  \t\t\t\tthis.closePopup();\r\n  \t\t\t} else {\r\n  \t\t\t\tthis.openPopup(e.latlng);\r\n  \t\t\t}\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\tthis._popup._source = target;\r\n  \t\tthis.openPopup(e.latlng);\r\n  \t},\r\n\r\n  \t_movePopup: function (e) {\r\n  \t\tthis._popup.setLatLng(e.latlng);\r\n  \t},\r\n\r\n  \t_onKeyPress: function (e) {\r\n  \t\tif (e.originalEvent.keyCode === 13) {\r\n  \t\t\tthis._openPopup(e);\r\n  \t\t}\r\n  \t}\r\n  });\n\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n\n\n  // @namespace Tooltip\n  var Tooltip = DivOverlay.extend({\n\n  \t// @section\n  \t// @aka Tooltip options\n  \toptions: {\n  \t\t// @option pane: String = 'tooltipPane'\n  \t\t// `Map pane` where the tooltip will be added.\n  \t\tpane: 'tooltipPane',\n\n  \t\t// @option offset: Point = Point(0, 0)\n  \t\t// Optional offset of the tooltip position.\n  \t\toffset: [0, 0],\n\n  \t\t// @option direction: String = 'auto'\n  \t\t// Direction where to open the tooltip. Possible values are: `right`, `left`,\n  \t\t// `top`, `bottom`, `center`, `auto`.\n  \t\t// `auto` will dynamically switch between `right` and `left` according to the tooltip\n  \t\t// position on the map.\n  \t\tdirection: 'auto',\n\n  \t\t// @option permanent: Boolean = false\n  \t\t// Whether to open the tooltip permanently or only on mouseover.\n  \t\tpermanent: false,\n\n  \t\t// @option sticky: Boolean = false\n  \t\t// If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n  \t\tsticky: false,\n\n  \t\t// @option opacity: Number = 0.9\n  \t\t// Tooltip container opacity.\n  \t\topacity: 0.9\n  \t},\n\n  \tonAdd: function (map) {\n  \t\tDivOverlay.prototype.onAdd.call(this, map);\n  \t\tthis.setOpacity(this.options.opacity);\n\n  \t\t// @namespace Map\n  \t\t// @section Tooltip events\n  \t\t// @event tooltipopen: TooltipEvent\n  \t\t// Fired when a tooltip is opened in the map.\n  \t\tmap.fire('tooltipopen', {tooltip: this});\n\n  \t\tif (this._source) {\n  \t\t\tthis.addEventParent(this._source);\n\n  \t\t\t// @namespace Layer\n  \t\t\t// @section Tooltip events\n  \t\t\t// @event tooltipopen: TooltipEvent\n  \t\t\t// Fired when a tooltip bound to this layer is opened.\n  \t\t\tthis._source.fire('tooltipopen', {tooltip: this}, true);\n  \t\t}\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tDivOverlay.prototype.onRemove.call(this, map);\n\n  \t\t// @namespace Map\n  \t\t// @section Tooltip events\n  \t\t// @event tooltipclose: TooltipEvent\n  \t\t// Fired when a tooltip in the map is closed.\n  \t\tmap.fire('tooltipclose', {tooltip: this});\n\n  \t\tif (this._source) {\n  \t\t\tthis.removeEventParent(this._source);\n\n  \t\t\t// @namespace Layer\n  \t\t\t// @section Tooltip events\n  \t\t\t// @event tooltipclose: TooltipEvent\n  \t\t\t// Fired when a tooltip bound to this layer is closed.\n  \t\t\tthis._source.fire('tooltipclose', {tooltip: this}, true);\n  \t\t}\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = DivOverlay.prototype.getEvents.call(this);\n\n  \t\tif (!this.options.permanent) {\n  \t\t\tevents.preclick = this.close;\n  \t\t}\n\n  \t\treturn events;\n  \t},\n\n  \t_initLayout: function () {\n  \t\tvar prefix = 'leaflet-tooltip',\n  \t\t    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n\n  \t\tthis._contentNode = this._container = create$1('div', className);\n\n  \t\tthis._container.setAttribute('role', 'tooltip');\n  \t\tthis._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));\n  \t},\n\n  \t_updateLayout: function () {},\n\n  \t_adjustPan: function () {},\n\n  \t_setPosition: function (pos) {\n  \t\tvar subX, subY,\n  \t\t    map = this._map,\n  \t\t    container = this._container,\n  \t\t    centerPoint = map.latLngToContainerPoint(map.getCenter()),\n  \t\t    tooltipPoint = map.layerPointToContainerPoint(pos),\n  \t\t    direction = this.options.direction,\n  \t\t    tooltipWidth = container.offsetWidth,\n  \t\t    tooltipHeight = container.offsetHeight,\n  \t\t    offset = toPoint(this.options.offset),\n  \t\t    anchor = this._getAnchor();\n\n  \t\tif (direction === 'top') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = tooltipHeight;\n  \t\t} else if (direction === 'bottom') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = 0;\n  \t\t} else if (direction === 'center') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (direction === 'right') {\n  \t\t\tsubX = 0;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (direction === 'left') {\n  \t\t\tsubX = tooltipWidth;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (tooltipPoint.x < centerPoint.x) {\n  \t\t\tdirection = 'right';\n  \t\t\tsubX = 0;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else {\n  \t\t\tdirection = 'left';\n  \t\t\tsubX = tooltipWidth + (offset.x + anchor.x) * 2;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t}\n\n  \t\tpos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n\n  \t\tremoveClass(container, 'leaflet-tooltip-right');\n  \t\tremoveClass(container, 'leaflet-tooltip-left');\n  \t\tremoveClass(container, 'leaflet-tooltip-top');\n  \t\tremoveClass(container, 'leaflet-tooltip-bottom');\n  \t\taddClass(container, 'leaflet-tooltip-' + direction);\n  \t\tsetPosition(container, pos);\n  \t},\n\n  \t_updatePosition: function () {\n  \t\tvar pos = this._map.latLngToLayerPoint(this._latlng);\n  \t\tthis._setPosition(pos);\n  \t},\n\n  \tsetOpacity: function (opacity) {\n  \t\tthis.options.opacity = opacity;\n\n  \t\tif (this._container) {\n  \t\t\tsetOpacity(this._container, opacity);\n  \t\t}\n  \t},\n\n  \t_animateZoom: function (e) {\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n  \t\tthis._setPosition(pos);\n  \t},\n\n  \t_getAnchor: function () {\n  \t\t// Where should we anchor the tooltip on the source layer?\n  \t\treturn toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n  \t}\n\n  });\n\n  // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n  var tooltip = function (options, source) {\n  \treturn new Tooltip(options, source);\n  };\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n\n  \t// @method openTooltip(tooltip: Tooltip): this\n  \t// Opens the specified tooltip.\n  \t// @alternative\n  \t// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n  \t// Creates a tooltip with the specified content and options and open it.\n  \topenTooltip: function (tooltip, latlng, options) {\n  \t\tthis._initOverlay(Tooltip, tooltip, latlng, options)\n  \t\t  .openOn(this);\n\n  \t\treturn this;\n  \t},\n\n  \t// @method closeTooltip(tooltip: Tooltip): this\n  \t// Closes the tooltip given as parameter.\n  \tcloseTooltip: function (tooltip) {\n  \t\ttooltip.close();\n  \t\treturn this;\n  \t}\n\n  });\n\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n\n  // @section Tooltip methods\n  Layer.include({\n\n  \t// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n  \t// Binds a tooltip to the layer with the passed `content` and sets up the\n  \t// necessary event listeners. If a `Function` is passed it will receive\n  \t// the layer as the first argument and should return a `String` or `HTMLElement`.\n  \tbindTooltip: function (content, options) {\n\n  \t\tif (this._tooltip && this.isTooltipOpen()) {\n  \t\t\tthis.unbindTooltip();\n  \t\t}\n\n  \t\tthis._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n  \t\tthis._initTooltipInteractions();\n\n  \t\tif (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n  \t\t\tthis.openTooltip();\n  \t\t}\n\n  \t\treturn this;\n  \t},\n\n  \t// @method unbindTooltip(): this\n  \t// Removes the tooltip previously bound with `bindTooltip`.\n  \tunbindTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._initTooltipInteractions(true);\n  \t\t\tthis.closeTooltip();\n  \t\t\tthis._tooltip = null;\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t_initTooltipInteractions: function (remove) {\n  \t\tif (!remove && this._tooltipHandlersAdded) { return; }\n  \t\tvar onOff = remove ? 'off' : 'on',\n  \t\t    events = {\n  \t\t\tremove: this.closeTooltip,\n  \t\t\tmove: this._moveTooltip\n  \t\t    };\n  \t\tif (!this._tooltip.options.permanent) {\n  \t\t\tevents.mouseover = this._openTooltip;\n  \t\t\tevents.mouseout = this.closeTooltip;\n  \t\t\tevents.click = this._openTooltip;\n  \t\t\tif (this._map) {\n  \t\t\t\tthis._addFocusListeners();\n  \t\t\t} else {\n  \t\t\t\tevents.add = this._addFocusListeners;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tevents.add = this._openTooltip;\n  \t\t}\n  \t\tif (this._tooltip.options.sticky) {\n  \t\t\tevents.mousemove = this._moveTooltip;\n  \t\t}\n  \t\tthis[onOff](events);\n  \t\tthis._tooltipHandlersAdded = !remove;\n  \t},\n\n  \t// @method openTooltip(latlng?: LatLng): this\n  \t// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n  \topenTooltip: function (latlng) {\n  \t\tif (this._tooltip) {\n  \t\t\tif (!(this instanceof FeatureGroup)) {\n  \t\t\t\tthis._tooltip._source = this;\n  \t\t\t}\n  \t\t\tif (this._tooltip._prepareOpen(latlng)) {\n  \t\t\t\t// open the tooltip on the map\n  \t\t\t\tthis._tooltip.openOn(this._map);\n\n  \t\t\t\tif (this.getElement) {\n  \t\t\t\t\tthis._setAriaDescribedByOnLayer(this);\n  \t\t\t\t} else if (this.eachLayer) {\n  \t\t\t\t\tthis.eachLayer(this._setAriaDescribedByOnLayer, this);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method closeTooltip(): this\n  \t// Closes the tooltip bound to this layer if it is open.\n  \tcloseTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\treturn this._tooltip.close();\n  \t\t}\n  \t},\n\n  \t// @method toggleTooltip(): this\n  \t// Opens or closes the tooltip bound to this layer depending on its current state.\n  \ttoggleTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._tooltip.toggle(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method isTooltipOpen(): boolean\n  \t// Returns `true` if the tooltip bound to this layer is currently open.\n  \tisTooltipOpen: function () {\n  \t\treturn this._tooltip.isOpen();\n  \t},\n\n  \t// @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n  \t// Sets the content of the tooltip bound to this layer.\n  \tsetTooltipContent: function (content) {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._tooltip.setContent(content);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getTooltip(): Tooltip\n  \t// Returns the tooltip bound to this layer.\n  \tgetTooltip: function () {\n  \t\treturn this._tooltip;\n  \t},\n\n  \t_addFocusListeners: function () {\n  \t\tif (this.getElement) {\n  \t\t\tthis._addFocusListenersOnLayer(this);\n  \t\t} else if (this.eachLayer) {\n  \t\t\tthis.eachLayer(this._addFocusListenersOnLayer, this);\n  \t\t}\n  \t},\n\n  \t_addFocusListenersOnLayer: function (layer) {\n  \t\tvar el = typeof layer.getElement === 'function' && layer.getElement();\n  \t\tif (el) {\n  \t\t\ton(el, 'focus', function () {\n  \t\t\t\tthis._tooltip._source = layer;\n  \t\t\t\tthis.openTooltip();\n  \t\t\t}, this);\n  \t\t\ton(el, 'blur', this.closeTooltip, this);\n  \t\t}\n  \t},\n\n  \t_setAriaDescribedByOnLayer: function (layer) {\n  \t\tvar el = typeof layer.getElement === 'function' && layer.getElement();\n  \t\tif (el) {\n  \t\t\tel.setAttribute('aria-describedby', this._tooltip._container.id);\n  \t\t}\n  \t},\n\n\n  \t_openTooltip: function (e) {\n  \t\tif (!this._tooltip || !this._map) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// If the map is moving, we will show the tooltip after it's done.\n  \t\tif (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {\n  \t\t\tthis._openOnceFlag = true;\n  \t\t\tvar that = this;\n  \t\t\tthis._map.once('moveend', function () {\n  \t\t\t\tthat._openOnceFlag = false;\n  \t\t\t\tthat._openTooltip(e);\n  \t\t\t});\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis._tooltip._source = e.layer || e.target;\n\n  \t\tthis.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n  \t},\n\n  \t_moveTooltip: function (e) {\n  \t\tvar latlng = e.latlng, containerPoint, layerPoint;\n  \t\tif (this._tooltip.options.sticky && e.originalEvent) {\n  \t\t\tcontainerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n  \t\t\tlayerPoint = this._map.containerPointToLayerPoint(containerPoint);\n  \t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\n  \t\t}\n  \t\tthis._tooltip.setLatLng(latlng);\n  \t}\n  });\n\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n  \toptions: {\n  \t\t// @section\n  \t\t// @aka DivIcon options\n  \t\ticonSize: [12, 12], // also can be set through CSS\n\n  \t\t// iconAnchor: (Point),\n  \t\t// popupAnchor: (Point),\n\n  \t\t// @option html: String|HTMLElement = ''\n  \t\t// Custom HTML code to put inside the div element, empty by default. Alternatively,\n  \t\t// an instance of `HTMLElement`.\n  \t\thtml: false,\n\n  \t\t// @option bgPos: Point = [0, 0]\n  \t\t// Optional relative position of the background, in pixels\n  \t\tbgPos: null,\n\n  \t\tclassName: 'leaflet-div-icon'\n  \t},\n\n  \tcreateIcon: function (oldIcon) {\n  \t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n  \t\t    options = this.options;\n\n  \t\tif (options.html instanceof Element) {\n  \t\t\tempty(div);\n  \t\t\tdiv.appendChild(options.html);\n  \t\t} else {\n  \t\t\tdiv.innerHTML = options.html !== false ? options.html : '';\n  \t\t}\n\n  \t\tif (options.bgPos) {\n  \t\t\tvar bgPos = toPoint(options.bgPos);\n  \t\t\tdiv.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';\n  \t\t}\n  \t\tthis._setIconStyles(div, 'icon');\n\n  \t\treturn div;\n  \t},\n\n  \tcreateShadow: function () {\n  \t\treturn null;\n  \t}\n  });\n\n  // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n  function divIcon(options) {\n  \treturn new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n\n  var GridLayer = Layer.extend({\n\n  \t// @section\n  \t// @aka GridLayer options\n  \toptions: {\n  \t\t// @option tileSize: Number|Point = 256\n  \t\t// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n  \t\ttileSize: 256,\n\n  \t\t// @option opacity: Number = 1.0\n  \t\t// Opacity of the tiles. Can be used in the `createTile()` function.\n  \t\topacity: 1,\n\n  \t\t// @option updateWhenIdle: Boolean = (depends)\n  \t\t// Load new tiles only when panning ends.\n  \t\t// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n  \t\t// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n  \t\t// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n  \t\tupdateWhenIdle: Browser.mobile,\n\n  \t\t// @option updateWhenZooming: Boolean = true\n  \t\t// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n  \t\tupdateWhenZooming: true,\n\n  \t\t// @option updateInterval: Number = 200\n  \t\t// Tiles will not update more than once every `updateInterval` milliseconds when panning.\n  \t\tupdateInterval: 200,\n\n  \t\t// @option zIndex: Number = 1\n  \t\t// The explicit zIndex of the tile layer.\n  \t\tzIndex: 1,\n\n  \t\t// @option bounds: LatLngBounds = undefined\n  \t\t// If set, tiles will only be loaded inside the set `LatLngBounds`.\n  \t\tbounds: null,\n\n  \t\t// @option minZoom: Number = 0\n  \t\t// The minimum zoom level down to which this layer will be displayed (inclusive).\n  \t\tminZoom: 0,\n\n  \t\t// @option maxZoom: Number = undefined\n  \t\t// The maximum zoom level up to which this layer will be displayed (inclusive).\n  \t\tmaxZoom: undefined,\n\n  \t\t// @option maxNativeZoom: Number = undefined\n  \t\t// Maximum zoom number the tile source has available. If it is specified,\n  \t\t// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n  \t\t// from `maxNativeZoom` level and auto-scaled.\n  \t\tmaxNativeZoom: undefined,\n\n  \t\t// @option minNativeZoom: Number = undefined\n  \t\t// Minimum zoom number the tile source has available. If it is specified,\n  \t\t// the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n  \t\t// from `minNativeZoom` level and auto-scaled.\n  \t\tminNativeZoom: undefined,\n\n  \t\t// @option noWrap: Boolean = false\n  \t\t// Whether the layer is wrapped around the antimeridian. If `true`, the\n  \t\t// GridLayer will only be displayed once at low zoom levels. Has no\n  \t\t// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n  \t\t// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n  \t\t// tiles outside the CRS limits.\n  \t\tnoWrap: false,\n\n  \t\t// @option pane: String = 'tilePane'\n  \t\t// `Map pane` where the grid layer will be added.\n  \t\tpane: 'tilePane',\n\n  \t\t// @option className: String = ''\n  \t\t// A custom class name to assign to the tile layer. Empty by default.\n  \t\tclassName: '',\n\n  \t\t// @option keepBuffer: Number = 2\n  \t\t// When panning the map, keep this many rows and columns of tiles before unloading them.\n  \t\tkeepBuffer: 2\n  \t},\n\n  \tinitialize: function (options) {\n  \t\tsetOptions(this, options);\n  \t},\n\n  \tonAdd: function () {\n  \t\tthis._initContainer();\n\n  \t\tthis._levels = {};\n  \t\tthis._tiles = {};\n\n  \t\tthis._resetView(); // implicit _update() call\n  \t},\n\n  \tbeforeAdd: function (map) {\n  \t\tmap._addZoomLimit(this);\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tthis._removeAllTiles();\n  \t\tremove(this._container);\n  \t\tmap._removeZoomLimit(this);\n  \t\tthis._container = null;\n  \t\tthis._tileZoom = undefined;\n  \t},\n\n  \t// @method bringToFront: this\n  \t// Brings the tile layer to the top of all tile layers.\n  \tbringToFront: function () {\n  \t\tif (this._map) {\n  \t\t\ttoFront(this._container);\n  \t\t\tthis._setAutoZIndex(Math.max);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToBack: this\n  \t// Brings the tile layer to the bottom of all tile layers.\n  \tbringToBack: function () {\n  \t\tif (this._map) {\n  \t\t\ttoBack(this._container);\n  \t\t\tthis._setAutoZIndex(Math.min);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getContainer: HTMLElement\n  \t// Returns the HTML element that contains the tiles for this layer.\n  \tgetContainer: function () {\n  \t\treturn this._container;\n  \t},\n\n  \t// @method setOpacity(opacity: Number): this\n  \t// Changes the [opacity](#gridlayer-opacity) of the grid layer.\n  \tsetOpacity: function (opacity) {\n  \t\tthis.options.opacity = opacity;\n  \t\tthis._updateOpacity();\n  \t\treturn this;\n  \t},\n\n  \t// @method setZIndex(zIndex: Number): this\n  \t// Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n  \tsetZIndex: function (zIndex) {\n  \t\tthis.options.zIndex = zIndex;\n  \t\tthis._updateZIndex();\n\n  \t\treturn this;\n  \t},\n\n  \t// @method isLoading: Boolean\n  \t// Returns `true` if any tile in the grid layer has not finished loading.\n  \tisLoading: function () {\n  \t\treturn this._loading;\n  \t},\n\n  \t// @method redraw: this\n  \t// Causes the layer to clear all the tiles and request them again.\n  \tredraw: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._removeAllTiles();\n  \t\t\tvar tileZoom = this._clampZoom(this._map.getZoom());\n  \t\t\tif (tileZoom !== this._tileZoom) {\n  \t\t\t\tthis._tileZoom = tileZoom;\n  \t\t\t\tthis._updateLevels();\n  \t\t\t}\n  \t\t\tthis._update();\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = {\n  \t\t\tviewprereset: this._invalidateAll,\n  \t\t\tviewreset: this._resetView,\n  \t\t\tzoom: this._resetView,\n  \t\t\tmoveend: this._onMoveEnd\n  \t\t};\n\n  \t\tif (!this.options.updateWhenIdle) {\n  \t\t\t// update tiles on move, but not more often than once per given interval\n  \t\t\tif (!this._onMove) {\n  \t\t\t\tthis._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n  \t\t\t}\n\n  \t\t\tevents.move = this._onMove;\n  \t\t}\n\n  \t\tif (this._zoomAnimated) {\n  \t\t\tevents.zoomanim = this._animateZoom;\n  \t\t}\n\n  \t\treturn events;\n  \t},\n\n  \t// @section Extension methods\n  \t// Layers extending `GridLayer` shall reimplement the following method.\n  \t// @method createTile(coords: Object, done?: Function): HTMLElement\n  \t// Called only internally, must be overridden by classes extending `GridLayer`.\n  \t// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n  \t// is specified, it must be called when the tile has finished loading and drawing.\n  \tcreateTile: function () {\n  \t\treturn document.createElement('div');\n  \t},\n\n  \t// @section\n  \t// @method getTileSize: Point\n  \t// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n  \tgetTileSize: function () {\n  \t\tvar s = this.options.tileSize;\n  \t\treturn s instanceof Point ? s : new Point(s, s);\n  \t},\n\n  \t_updateZIndex: function () {\n  \t\tif (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n  \t\t\tthis._container.style.zIndex = this.options.zIndex;\n  \t\t}\n  \t},\n\n  \t_setAutoZIndex: function (compare) {\n  \t\t// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n  \t\tvar layers = this.getPane().children,\n  \t\t    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n  \t\tfor (var i = 0, len = layers.length, zIndex; i < len; i++) {\n\n  \t\t\tzIndex = layers[i].style.zIndex;\n\n  \t\t\tif (layers[i] !== this._container && zIndex) {\n  \t\t\t\tedgeZIndex = compare(edgeZIndex, +zIndex);\n  \t\t\t}\n  \t\t}\n\n  \t\tif (isFinite(edgeZIndex)) {\n  \t\t\tthis.options.zIndex = edgeZIndex + compare(-1, 1);\n  \t\t\tthis._updateZIndex();\n  \t\t}\n  \t},\n\n  \t_updateOpacity: function () {\n  \t\tif (!this._map) { return; }\n\n  \t\t// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n  \t\tif (Browser.ielt9) { return; }\n\n  \t\tsetOpacity(this._container, this.options.opacity);\n\n  \t\tvar now = +new Date(),\n  \t\t    nextFrame = false,\n  \t\t    willPrune = false;\n\n  \t\tfor (var key in this._tiles) {\n  \t\t\tvar tile = this._tiles[key];\n  \t\t\tif (!tile.current || !tile.loaded) { continue; }\n\n  \t\t\tvar fade = Math.min(1, (now - tile.loaded) / 200);\n\n  \t\t\tsetOpacity(tile.el, fade);\n  \t\t\tif (fade < 1) {\n  \t\t\t\tnextFrame = true;\n  \t\t\t} else {\n  \t\t\t\tif (tile.active) {\n  \t\t\t\t\twillPrune = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tthis._onOpaqueTile(tile);\n  \t\t\t\t}\n  \t\t\t\ttile.active = true;\n  \t\t\t}\n  \t\t}\n\n  \t\tif (willPrune && !this._noPrune) { this._pruneTiles(); }\n\n  \t\tif (nextFrame) {\n  \t\t\tcancelAnimFrame(this._fadeFrame);\n  \t\t\tthis._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n  \t\t}\n  \t},\n\n  \t_onOpaqueTile: falseFn,\n\n  \t_initContainer: function () {\n  \t\tif (this._container) { return; }\n\n  \t\tthis._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n  \t\tthis._updateZIndex();\n\n  \t\tif (this.options.opacity < 1) {\n  \t\t\tthis._updateOpacity();\n  \t\t}\n\n  \t\tthis.getPane().appendChild(this._container);\n  \t},\n\n  \t_updateLevels: function () {\n\n  \t\tvar zoom = this._tileZoom,\n  \t\t    maxZoom = this.options.maxZoom;\n\n  \t\tif (zoom === undefined) { return undefined; }\n\n  \t\tfor (var z in this._levels) {\n  \t\t\tz = Number(z);\n  \t\t\tif (this._levels[z].el.children.length || z === zoom) {\n  \t\t\t\tthis._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n  \t\t\t\tthis._onUpdateLevel(z);\n  \t\t\t} else {\n  \t\t\t\tremove(this._levels[z].el);\n  \t\t\t\tthis._removeTilesAtZoom(z);\n  \t\t\t\tthis._onRemoveLevel(z);\n  \t\t\t\tdelete this._levels[z];\n  \t\t\t}\n  \t\t}\n\n  \t\tvar level = this._levels[zoom],\n  \t\t    map = this._map;\n\n  \t\tif (!level) {\n  \t\t\tlevel = this._levels[zoom] = {};\n\n  \t\t\tlevel.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n  \t\t\tlevel.el.style.zIndex = maxZoom;\n\n  \t\t\tlevel.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n  \t\t\tlevel.zoom = zoom;\n\n  \t\t\tthis._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n  \t\t\t// force the browser to consider the newly added element for transition\n  \t\t\tfalseFn(level.el.offsetWidth);\n\n  \t\t\tthis._onCreateLevel(level);\n  \t\t}\n\n  \t\tthis._level = level;\n\n  \t\treturn level;\n  \t},\n\n  \t_onUpdateLevel: falseFn,\n\n  \t_onRemoveLevel: falseFn,\n\n  \t_onCreateLevel: falseFn,\n\n  \t_pruneTiles: function () {\n  \t\tif (!this._map) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar key, tile;\n\n  \t\tvar zoom = this._map.getZoom();\n  \t\tif (zoom > this.options.maxZoom ||\n  \t\t\tzoom < this.options.minZoom) {\n  \t\t\tthis._removeAllTiles();\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\ttile = this._tiles[key];\n  \t\t\ttile.retain = tile.current;\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\ttile = this._tiles[key];\n  \t\t\tif (tile.current && !tile.active) {\n  \t\t\t\tvar coords = tile.coords;\n  \t\t\t\tif (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n  \t\t\t\t\tthis._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\tif (!this._tiles[key].retain) {\n  \t\t\t\tthis._removeTile(key);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_removeTilesAtZoom: function (zoom) {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tif (this._tiles[key].coords.z !== zoom) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tthis._removeTile(key);\n  \t\t}\n  \t},\n\n  \t_removeAllTiles: function () {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tthis._removeTile(key);\n  \t\t}\n  \t},\n\n  \t_invalidateAll: function () {\n  \t\tfor (var z in this._levels) {\n  \t\t\tremove(this._levels[z].el);\n  \t\t\tthis._onRemoveLevel(Number(z));\n  \t\t\tdelete this._levels[z];\n  \t\t}\n  \t\tthis._removeAllTiles();\n\n  \t\tthis._tileZoom = undefined;\n  \t},\n\n  \t_retainParent: function (x, y, z, minZoom) {\n  \t\tvar x2 = Math.floor(x / 2),\n  \t\t    y2 = Math.floor(y / 2),\n  \t\t    z2 = z - 1,\n  \t\t    coords2 = new Point(+x2, +y2);\n  \t\tcoords2.z = +z2;\n\n  \t\tvar key = this._tileCoordsToKey(coords2),\n  \t\t    tile = this._tiles[key];\n\n  \t\tif (tile && tile.active) {\n  \t\t\ttile.retain = true;\n  \t\t\treturn true;\n\n  \t\t} else if (tile && tile.loaded) {\n  \t\t\ttile.retain = true;\n  \t\t}\n\n  \t\tif (z2 > minZoom) {\n  \t\t\treturn this._retainParent(x2, y2, z2, minZoom);\n  \t\t}\n\n  \t\treturn false;\n  \t},\n\n  \t_retainChildren: function (x, y, z, maxZoom) {\n\n  \t\tfor (var i = 2 * x; i < 2 * x + 2; i++) {\n  \t\t\tfor (var j = 2 * y; j < 2 * y + 2; j++) {\n\n  \t\t\t\tvar coords = new Point(i, j);\n  \t\t\t\tcoords.z = z + 1;\n\n  \t\t\t\tvar key = this._tileCoordsToKey(coords),\n  \t\t\t\t    tile = this._tiles[key];\n\n  \t\t\t\tif (tile && tile.active) {\n  \t\t\t\t\ttile.retain = true;\n  \t\t\t\t\tcontinue;\n\n  \t\t\t\t} else if (tile && tile.loaded) {\n  \t\t\t\t\ttile.retain = true;\n  \t\t\t\t}\n\n  \t\t\t\tif (z + 1 < maxZoom) {\n  \t\t\t\t\tthis._retainChildren(i, j, z + 1, maxZoom);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_resetView: function (e) {\n  \t\tvar animating = e && (e.pinch || e.flyTo);\n  \t\tthis._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n  \t},\n\n  \t_animateZoom: function (e) {\n  \t\tthis._setView(e.center, e.zoom, true, e.noUpdate);\n  \t},\n\n  \t_clampZoom: function (zoom) {\n  \t\tvar options = this.options;\n\n  \t\tif (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n  \t\t\treturn options.minNativeZoom;\n  \t\t}\n\n  \t\tif (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n  \t\t\treturn options.maxNativeZoom;\n  \t\t}\n\n  \t\treturn zoom;\n  \t},\n\n  \t_setView: function (center, zoom, noPrune, noUpdate) {\n  \t\tvar tileZoom = Math.round(zoom);\n  \t\tif ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||\n  \t\t    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {\n  \t\t\ttileZoom = undefined;\n  \t\t} else {\n  \t\t\ttileZoom = this._clampZoom(tileZoom);\n  \t\t}\n\n  \t\tvar tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);\n\n  \t\tif (!noUpdate || tileZoomChanged) {\n\n  \t\t\tthis._tileZoom = tileZoom;\n\n  \t\t\tif (this._abortLoading) {\n  \t\t\t\tthis._abortLoading();\n  \t\t\t}\n\n  \t\t\tthis._updateLevels();\n  \t\t\tthis._resetGrid();\n\n  \t\t\tif (tileZoom !== undefined) {\n  \t\t\t\tthis._update(center);\n  \t\t\t}\n\n  \t\t\tif (!noPrune) {\n  \t\t\t\tthis._pruneTiles();\n  \t\t\t}\n\n  \t\t\t// Flag to prevent _updateOpacity from pruning tiles during\n  \t\t\t// a zoom anim or a pinch gesture\n  \t\t\tthis._noPrune = !!noPrune;\n  \t\t}\n\n  \t\tthis._setZoomTransforms(center, zoom);\n  \t},\n\n  \t_setZoomTransforms: function (center, zoom) {\n  \t\tfor (var i in this._levels) {\n  \t\t\tthis._setZoomTransform(this._levels[i], center, zoom);\n  \t\t}\n  \t},\n\n  \t_setZoomTransform: function (level, center, zoom) {\n  \t\tvar scale = this._map.getZoomScale(zoom, level.zoom),\n  \t\t    translate = level.origin.multiplyBy(scale)\n  \t\t        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n  \t\tif (Browser.any3d) {\n  \t\t\tsetTransform(level.el, translate, scale);\n  \t\t} else {\n  \t\t\tsetPosition(level.el, translate);\n  \t\t}\n  \t},\n\n  \t_resetGrid: function () {\n  \t\tvar map = this._map,\n  \t\t    crs = map.options.crs,\n  \t\t    tileSize = this._tileSize = this.getTileSize(),\n  \t\t    tileZoom = this._tileZoom;\n\n  \t\tvar bounds = this._map.getPixelWorldBounds(this._tileZoom);\n  \t\tif (bounds) {\n  \t\t\tthis._globalTileRange = this._pxBoundsToTileRange(bounds);\n  \t\t}\n\n  \t\tthis._wrapX = crs.wrapLng && !this.options.noWrap && [\n  \t\t\tMath.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),\n  \t\t\tMath.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)\n  \t\t];\n  \t\tthis._wrapY = crs.wrapLat && !this.options.noWrap && [\n  \t\t\tMath.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),\n  \t\t\tMath.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)\n  \t\t];\n  \t},\n\n  \t_onMoveEnd: function () {\n  \t\tif (!this._map || this._map._animatingZoom) { return; }\n\n  \t\tthis._update();\n  \t},\n\n  \t_getTiledPixelBounds: function (center) {\n  \t\tvar map = this._map,\n  \t\t    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n  \t\t    scale = map.getZoomScale(mapZoom, this._tileZoom),\n  \t\t    pixelCenter = map.project(center, this._tileZoom).floor(),\n  \t\t    halfSize = map.getSize().divideBy(scale * 2);\n\n  \t\treturn new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n  \t},\n\n  \t// Private method to load tiles in the grid's active zoom level according to map bounds\n  \t_update: function (center) {\n  \t\tvar map = this._map;\n  \t\tif (!map) { return; }\n  \t\tvar zoom = this._clampZoom(map.getZoom());\n\n  \t\tif (center === undefined) { center = map.getCenter(); }\n  \t\tif (this._tileZoom === undefined) { return; }\t// if out of minzoom/maxzoom\n\n  \t\tvar pixelBounds = this._getTiledPixelBounds(center),\n  \t\t    tileRange = this._pxBoundsToTileRange(pixelBounds),\n  \t\t    tileCenter = tileRange.getCenter(),\n  \t\t    queue = [],\n  \t\t    margin = this.options.keepBuffer,\n  \t\t    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),\n  \t\t                              tileRange.getTopRight().add([margin, -margin]));\n\n  \t\t// Sanity check: panic if the tile range contains Infinity somewhere.\n  \t\tif (!(isFinite(tileRange.min.x) &&\n  \t\t      isFinite(tileRange.min.y) &&\n  \t\t      isFinite(tileRange.max.x) &&\n  \t\t      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }\n\n  \t\tfor (var key in this._tiles) {\n  \t\t\tvar c = this._tiles[key].coords;\n  \t\t\tif (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n  \t\t\t\tthis._tiles[key].current = false;\n  \t\t\t}\n  \t\t}\n\n  \t\t// _update just loads more tiles. If the tile zoom level differs too much\n  \t\t// from the map's, let _setView reset levels and prune old tiles.\n  \t\tif (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }\n\n  \t\t// create a queue of coordinates to load tiles from\n  \t\tfor (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n  \t\t\tfor (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n  \t\t\t\tvar coords = new Point(i, j);\n  \t\t\t\tcoords.z = this._tileZoom;\n\n  \t\t\t\tif (!this._isValidTile(coords)) { continue; }\n\n  \t\t\t\tvar tile = this._tiles[this._tileCoordsToKey(coords)];\n  \t\t\t\tif (tile) {\n  \t\t\t\t\ttile.current = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tqueue.push(coords);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// sort tile queue to load tiles in order of their distance to center\n  \t\tqueue.sort(function (a, b) {\n  \t\t\treturn a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n  \t\t});\n\n  \t\tif (queue.length !== 0) {\n  \t\t\t// if it's the first batch of tiles to load\n  \t\t\tif (!this._loading) {\n  \t\t\t\tthis._loading = true;\n  \t\t\t\t// @event loading: Event\n  \t\t\t\t// Fired when the grid layer starts loading tiles.\n  \t\t\t\tthis.fire('loading');\n  \t\t\t}\n\n  \t\t\t// create DOM fragment to append tiles in one batch\n  \t\t\tvar fragment = document.createDocumentFragment();\n\n  \t\t\tfor (i = 0; i < queue.length; i++) {\n  \t\t\t\tthis._addTile(queue[i], fragment);\n  \t\t\t}\n\n  \t\t\tthis._level.el.appendChild(fragment);\n  \t\t}\n  \t},\n\n  \t_isValidTile: function (coords) {\n  \t\tvar crs = this._map.options.crs;\n\n  \t\tif (!crs.infinite) {\n  \t\t\t// don't load tile if it's out of bounds and not wrapped\n  \t\t\tvar bounds = this._globalTileRange;\n  \t\t\tif ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\n  \t\t\t    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }\n  \t\t}\n\n  \t\tif (!this.options.bounds) { return true; }\n\n  \t\t// don't load tile if it doesn't intersect the bounds in options\n  \t\tvar tileBounds = this._tileCoordsToBounds(coords);\n  \t\treturn toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n  \t},\n\n  \t_keyToBounds: function (key) {\n  \t\treturn this._tileCoordsToBounds(this._keyToTileCoords(key));\n  \t},\n\n  \t_tileCoordsToNwSe: function (coords) {\n  \t\tvar map = this._map,\n  \t\t    tileSize = this.getTileSize(),\n  \t\t    nwPoint = coords.scaleBy(tileSize),\n  \t\t    sePoint = nwPoint.add(tileSize),\n  \t\t    nw = map.unproject(nwPoint, coords.z),\n  \t\t    se = map.unproject(sePoint, coords.z);\n  \t\treturn [nw, se];\n  \t},\n\n  \t// converts tile coordinates to its geographical bounds\n  \t_tileCoordsToBounds: function (coords) {\n  \t\tvar bp = this._tileCoordsToNwSe(coords),\n  \t\t    bounds = new LatLngBounds(bp[0], bp[1]);\n\n  \t\tif (!this.options.noWrap) {\n  \t\t\tbounds = this._map.wrapLatLngBounds(bounds);\n  \t\t}\n  \t\treturn bounds;\n  \t},\n  \t// converts tile coordinates to key for the tile cache\n  \t_tileCoordsToKey: function (coords) {\n  \t\treturn coords.x + ':' + coords.y + ':' + coords.z;\n  \t},\n\n  \t// converts tile cache key to coordinates\n  \t_keyToTileCoords: function (key) {\n  \t\tvar k = key.split(':'),\n  \t\t    coords = new Point(+k[0], +k[1]);\n  \t\tcoords.z = +k[2];\n  \t\treturn coords;\n  \t},\n\n  \t_removeTile: function (key) {\n  \t\tvar tile = this._tiles[key];\n  \t\tif (!tile) { return; }\n\n  \t\tremove(tile.el);\n\n  \t\tdelete this._tiles[key];\n\n  \t\t// @event tileunload: TileEvent\n  \t\t// Fired when a tile is removed (e.g. when a tile goes off the screen).\n  \t\tthis.fire('tileunload', {\n  \t\t\ttile: tile.el,\n  \t\t\tcoords: this._keyToTileCoords(key)\n  \t\t});\n  \t},\n\n  \t_initTile: function (tile) {\n  \t\taddClass(tile, 'leaflet-tile');\n\n  \t\tvar tileSize = this.getTileSize();\n  \t\ttile.style.width = tileSize.x + 'px';\n  \t\ttile.style.height = tileSize.y + 'px';\n\n  \t\ttile.onselectstart = falseFn;\n  \t\ttile.onmousemove = falseFn;\n\n  \t\t// update opacity on tiles in IE7-8 because of filter inheritance problems\n  \t\tif (Browser.ielt9 && this.options.opacity < 1) {\n  \t\t\tsetOpacity(tile, this.options.opacity);\n  \t\t}\n  \t},\n\n  \t_addTile: function (coords, container) {\n  \t\tvar tilePos = this._getTilePos(coords),\n  \t\t    key = this._tileCoordsToKey(coords);\n\n  \t\tvar tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n  \t\tthis._initTile(tile);\n\n  \t\t// if createTile is defined with a second argument (\"done\" callback),\n  \t\t// we know that tile is async and will be ready later; otherwise\n  \t\tif (this.createTile.length < 2) {\n  \t\t\t// mark tile as ready, but delay one frame for opacity animation to happen\n  \t\t\trequestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n  \t\t}\n\n  \t\tsetPosition(tile, tilePos);\n\n  \t\t// save tile in cache\n  \t\tthis._tiles[key] = {\n  \t\t\tel: tile,\n  \t\t\tcoords: coords,\n  \t\t\tcurrent: true\n  \t\t};\n\n  \t\tcontainer.appendChild(tile);\n  \t\t// @event tileloadstart: TileEvent\n  \t\t// Fired when a tile is requested and starts loading.\n  \t\tthis.fire('tileloadstart', {\n  \t\t\ttile: tile,\n  \t\t\tcoords: coords\n  \t\t});\n  \t},\n\n  \t_tileReady: function (coords, err, tile) {\n  \t\tif (err) {\n  \t\t\t// @event tileerror: TileErrorEvent\n  \t\t\t// Fired when there is an error loading a tile.\n  \t\t\tthis.fire('tileerror', {\n  \t\t\t\terror: err,\n  \t\t\t\ttile: tile,\n  \t\t\t\tcoords: coords\n  \t\t\t});\n  \t\t}\n\n  \t\tvar key = this._tileCoordsToKey(coords);\n\n  \t\ttile = this._tiles[key];\n  \t\tif (!tile) { return; }\n\n  \t\ttile.loaded = +new Date();\n  \t\tif (this._map._fadeAnimated) {\n  \t\t\tsetOpacity(tile.el, 0);\n  \t\t\tcancelAnimFrame(this._fadeFrame);\n  \t\t\tthis._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n  \t\t} else {\n  \t\t\ttile.active = true;\n  \t\t\tthis._pruneTiles();\n  \t\t}\n\n  \t\tif (!err) {\n  \t\t\taddClass(tile.el, 'leaflet-tile-loaded');\n\n  \t\t\t// @event tileload: TileEvent\n  \t\t\t// Fired when a tile loads.\n  \t\t\tthis.fire('tileload', {\n  \t\t\t\ttile: tile.el,\n  \t\t\t\tcoords: coords\n  \t\t\t});\n  \t\t}\n\n  \t\tif (this._noTilesToLoad()) {\n  \t\t\tthis._loading = false;\n  \t\t\t// @event load: Event\n  \t\t\t// Fired when the grid layer loaded all visible tiles.\n  \t\t\tthis.fire('load');\n\n  \t\t\tif (Browser.ielt9 || !this._map._fadeAnimated) {\n  \t\t\t\trequestAnimFrame(this._pruneTiles, this);\n  \t\t\t} else {\n  \t\t\t\t// Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n  \t\t\t\t// to trigger a pruning.\n  \t\t\t\tsetTimeout(bind(this._pruneTiles, this), 250);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_getTilePos: function (coords) {\n  \t\treturn coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n  \t},\n\n  \t_wrapCoords: function (coords) {\n  \t\tvar newCoords = new Point(\n  \t\t\tthis._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,\n  \t\t\tthis._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n  \t\tnewCoords.z = coords.z;\n  \t\treturn newCoords;\n  \t},\n\n  \t_pxBoundsToTileRange: function (bounds) {\n  \t\tvar tileSize = this.getTileSize();\n  \t\treturn new Bounds(\n  \t\t\tbounds.min.unscaleBy(tileSize).floor(),\n  \t\t\tbounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n  \t},\n\n  \t_noTilesToLoad: function () {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tif (!this._tiles[key].loaded) { return false; }\n  \t\t}\n  \t\treturn true;\n  \t}\n  });\n\n  // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n  function gridLayer(options) {\n  \treturn new GridLayer(options);\n  }\n\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\r\n\r\n\r\n  var TileLayer = GridLayer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka TileLayer options\r\n  \toptions: {\r\n  \t\t// @option minZoom: Number = 0\r\n  \t\t// The minimum zoom level down to which this layer will be displayed (inclusive).\r\n  \t\tminZoom: 0,\r\n\r\n  \t\t// @option maxZoom: Number = 18\r\n  \t\t// The maximum zoom level up to which this layer will be displayed (inclusive).\r\n  \t\tmaxZoom: 18,\r\n\r\n  \t\t// @option subdomains: String|String[] = 'abc'\r\n  \t\t// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\r\n  \t\tsubdomains: 'abc',\r\n\r\n  \t\t// @option errorTileUrl: String = ''\r\n  \t\t// URL to the tile image to show in place of the tile that failed to load.\r\n  \t\terrorTileUrl: '',\r\n\r\n  \t\t// @option zoomOffset: Number = 0\r\n  \t\t// The zoom number used in tile URLs will be offset with this value.\r\n  \t\tzoomOffset: 0,\r\n\r\n  \t\t// @option tms: Boolean = false\r\n  \t\t// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\r\n  \t\ttms: false,\r\n\r\n  \t\t// @option zoomReverse: Boolean = false\r\n  \t\t// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\r\n  \t\tzoomReverse: false,\r\n\r\n  \t\t// @option detectRetina: Boolean = false\r\n  \t\t// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\r\n  \t\tdetectRetina: false,\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false,\r\n\r\n  \t\t// @option referrerPolicy: Boolean|String = false\r\n  \t\t// Whether the referrerPolicy attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\r\n  \t\t// This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\r\n  \t\t// (e.g. to validate an API token).\r\n  \t\t// Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\r\n  \t\treferrerPolicy: false\r\n  \t},\r\n\r\n  \tinitialize: function (url, options) {\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n  \t\tif (options.detectRetina && Browser.retina && options.maxZoom > 0) {\r\n\r\n  \t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\r\n  \t\t\tif (!options.zoomReverse) {\r\n  \t\t\t\toptions.zoomOffset++;\r\n  \t\t\t\toptions.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\r\n  \t\t\t} else {\r\n  \t\t\t\toptions.zoomOffset--;\r\n  \t\t\t\toptions.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\r\n  \t\t\t}\r\n\r\n  \t\t\toptions.minZoom = Math.max(0, options.minZoom);\r\n  \t\t} else if (!options.zoomReverse) {\r\n  \t\t\t// make sure maxZoom is gte minZoom\r\n  \t\t\toptions.maxZoom = Math.max(options.minZoom, options.maxZoom);\r\n  \t\t} else {\r\n  \t\t\t// make sure minZoom is lte maxZoom\r\n  \t\t\toptions.minZoom = Math.min(options.maxZoom, options.minZoom);\r\n  \t\t}\r\n\r\n  \t\tif (typeof options.subdomains === 'string') {\r\n  \t\t\toptions.subdomains = options.subdomains.split('');\r\n  \t\t}\r\n\r\n  \t\tthis.on('tileunload', this._onTileRemove);\r\n  \t},\r\n\r\n  \t// @method setUrl(url: String, noRedraw?: Boolean): this\r\n  \t// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\r\n  \t// If the URL does not change, the layer will not be redrawn unless\r\n  \t// the noRedraw parameter is set to false.\r\n  \tsetUrl: function (url, noRedraw) {\r\n  \t\tif (this._url === url && noRedraw === undefined) {\r\n  \t\t\tnoRedraw = true;\r\n  \t\t}\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\tif (!noRedraw) {\r\n  \t\t\tthis.redraw();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method createTile(coords: Object, done?: Function): HTMLElement\r\n  \t// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\r\n  \t// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\r\n  \t// callback is called when the tile has been loaded.\r\n  \tcreateTile: function (coords, done) {\r\n  \t\tvar tile = document.createElement('img');\r\n\r\n  \t\ton(tile, 'load', bind(this._tileOnLoad, this, done, tile));\r\n  \t\ton(tile, 'error', bind(this._tileOnError, this, done, tile));\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\ttile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\t// for this new option we follow the documented behavior\r\n  \t\t// more closely by only setting the property when string\r\n  \t\tif (typeof this.options.referrerPolicy === 'string') {\r\n  \t\t\ttile.referrerPolicy = this.options.referrerPolicy;\r\n  \t\t}\r\n\r\n  \t\t// The alt attribute is set to the empty string,\r\n  \t\t// allowing screen readers to ignore the decorative image tiles.\r\n  \t\t// https://www.w3.org/WAI/tutorials/images/decorative/\r\n  \t\t// https://www.w3.org/TR/html-aria/#el-img-empty-alt\r\n  \t\ttile.alt = '';\r\n\r\n  \t\ttile.src = this.getTileUrl(coords);\r\n\r\n  \t\treturn tile;\r\n  \t},\r\n\r\n  \t// @section Extension methods\r\n  \t// @uninheritable\r\n  \t// Layers extending `TileLayer` might reimplement the following method.\r\n  \t// @method getTileUrl(coords: Object): String\r\n  \t// Called only internally, returns the URL for a tile given its coordinates.\r\n  \t// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\r\n  \tgetTileUrl: function (coords) {\r\n  \t\tvar data = {\r\n  \t\t\tr: Browser.retina ? '@2x' : '',\r\n  \t\t\ts: this._getSubdomain(coords),\r\n  \t\t\tx: coords.x,\r\n  \t\t\ty: coords.y,\r\n  \t\t\tz: this._getZoomForUrl()\r\n  \t\t};\r\n  \t\tif (this._map && !this._map.options.crs.infinite) {\r\n  \t\t\tvar invertedY = this._globalTileRange.max.y - coords.y;\r\n  \t\t\tif (this.options.tms) {\r\n  \t\t\t\tdata['y'] = invertedY;\r\n  \t\t\t}\r\n  \t\t\tdata['-y'] = invertedY;\r\n  \t\t}\r\n\r\n  \t\treturn template(this._url, extend(data, this.options));\r\n  \t},\r\n\r\n  \t_tileOnLoad: function (done, tile) {\r\n  \t\t// For https://github.com/Leaflet/Leaflet/issues/3332\r\n  \t\tif (Browser.ielt9) {\r\n  \t\t\tsetTimeout(bind(done, this, null, tile), 0);\r\n  \t\t} else {\r\n  \t\t\tdone(null, tile);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_tileOnError: function (done, tile, e) {\r\n  \t\tvar errorUrl = this.options.errorTileUrl;\r\n  \t\tif (errorUrl && tile.getAttribute('src') !== errorUrl) {\r\n  \t\t\ttile.src = errorUrl;\r\n  \t\t}\r\n  \t\tdone(e, tile);\r\n  \t},\r\n\r\n  \t_onTileRemove: function (e) {\r\n  \t\te.tile.onload = null;\r\n  \t},\r\n\r\n  \t_getZoomForUrl: function () {\r\n  \t\tvar zoom = this._tileZoom,\r\n  \t\tmaxZoom = this.options.maxZoom,\r\n  \t\tzoomReverse = this.options.zoomReverse,\r\n  \t\tzoomOffset = this.options.zoomOffset;\r\n\r\n  \t\tif (zoomReverse) {\r\n  \t\t\tzoom = maxZoom - zoom;\r\n  \t\t}\r\n\r\n  \t\treturn zoom + zoomOffset;\r\n  \t},\r\n\r\n  \t_getSubdomain: function (tilePoint) {\r\n  \t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n  \t\treturn this.options.subdomains[index];\r\n  \t},\r\n\r\n  \t// stops loading all tiles in the background layer\r\n  \t_abortLoading: function () {\r\n  \t\tvar i, tile;\r\n  \t\tfor (i in this._tiles) {\r\n  \t\t\tif (this._tiles[i].coords.z !== this._tileZoom) {\r\n  \t\t\t\ttile = this._tiles[i].el;\r\n\r\n  \t\t\t\ttile.onload = falseFn;\r\n  \t\t\t\ttile.onerror = falseFn;\r\n\r\n  \t\t\t\tif (!tile.complete) {\r\n  \t\t\t\t\ttile.src = emptyImageUrl;\r\n  \t\t\t\t\tvar coords = this._tiles[i].coords;\r\n  \t\t\t\t\tremove(tile);\r\n  \t\t\t\t\tdelete this._tiles[i];\r\n  \t\t\t\t\t// @event tileabort: TileEvent\r\n  \t\t\t\t\t// Fired when a tile was loading but is now not wanted.\r\n  \t\t\t\t\tthis.fire('tileabort', {\r\n  \t\t\t\t\t\ttile: tile,\r\n  \t\t\t\t\t\tcoords: coords\r\n  \t\t\t\t\t});\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_removeTile: function (key) {\r\n  \t\tvar tile = this._tiles[key];\r\n  \t\tif (!tile) { return; }\r\n\r\n  \t\t// Cancels any pending http requests associated with the tile\r\n  \t\ttile.el.setAttribute('src', emptyImageUrl);\r\n\r\n  \t\treturn GridLayer.prototype._removeTile.call(this, key);\r\n  \t},\r\n\r\n  \t_tileReady: function (coords, err, tile) {\r\n  \t\tif (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\treturn GridLayer.prototype._tileReady.call(this, coords, err, tile);\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\r\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\r\n\r\n  function tileLayer(url, options) {\r\n  \treturn new TileLayer(url, options);\r\n  }\n\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data  2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\r\n\r\n  var TileLayerWMS = TileLayer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka TileLayer.WMS options\r\n  \t// If any custom options not documented here are used, they will be sent to the\r\n  \t// WMS server as extra parameters in each request URL. This can be useful for\r\n  \t// [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\r\n  \tdefaultWmsParams: {\r\n  \t\tservice: 'WMS',\r\n  \t\trequest: 'GetMap',\r\n\r\n  \t\t// @option layers: String = ''\r\n  \t\t// **(required)** Comma-separated list of WMS layers to show.\r\n  \t\tlayers: '',\r\n\r\n  \t\t// @option styles: String = ''\r\n  \t\t// Comma-separated list of WMS styles.\r\n  \t\tstyles: '',\r\n\r\n  \t\t// @option format: String = 'image/jpeg'\r\n  \t\t// WMS image format (use `'image/png'` for layers with transparency).\r\n  \t\tformat: 'image/jpeg',\r\n\r\n  \t\t// @option transparent: Boolean = false\r\n  \t\t// If `true`, the WMS service will return images with transparency.\r\n  \t\ttransparent: false,\r\n\r\n  \t\t// @option version: String = '1.1.1'\r\n  \t\t// Version of the WMS service to use\r\n  \t\tversion: '1.1.1'\r\n  \t},\r\n\r\n  \toptions: {\r\n  \t\t// @option crs: CRS = null\r\n  \t\t// Coordinate Reference System to use for the WMS requests, defaults to\r\n  \t\t// map CRS. Don't change this if you're not sure what it means.\r\n  \t\tcrs: null,\r\n\r\n  \t\t// @option uppercase: Boolean = false\r\n  \t\t// If `true`, WMS request parameter keys will be uppercase.\r\n  \t\tuppercase: false\r\n  \t},\r\n\r\n  \tinitialize: function (url, options) {\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\tvar wmsParams = extend({}, this.defaultWmsParams);\r\n\r\n  \t\t// all keys that are not TileLayer options go to WMS params\r\n  \t\tfor (var i in options) {\r\n  \t\t\tif (!(i in this.options)) {\r\n  \t\t\t\twmsParams[i] = options[i];\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\tvar realRetina = options.detectRetina && Browser.retina ? 2 : 1;\r\n  \t\tvar tileSize = this.getTileSize();\r\n  \t\twmsParams.width = tileSize.x * realRetina;\r\n  \t\twmsParams.height = tileSize.y * realRetina;\r\n\r\n  \t\tthis.wmsParams = wmsParams;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n\r\n  \t\tthis._crs = this.options.crs || map.options.crs;\r\n  \t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n  \t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n  \t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n  \t\tTileLayer.prototype.onAdd.call(this, map);\r\n  \t},\r\n\r\n  \tgetTileUrl: function (coords) {\r\n\r\n  \t\tvar tileBounds = this._tileCoordsToNwSe(coords),\r\n  \t\t    crs = this._crs,\r\n  \t\t    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\r\n  \t\t    min = bounds.min,\r\n  \t\t    max = bounds.max,\r\n  \t\t    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?\r\n  \t\t    [min.y, min.x, max.y, max.x] :\r\n  \t\t    [min.x, min.y, max.x, max.y]).join(','),\r\n  \t\t    url = TileLayer.prototype.getTileUrl.call(this, coords);\r\n  \t\treturn url +\r\n  \t\t\tgetParamString(this.wmsParams, url, this.options.uppercase) +\r\n  \t\t\t(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\r\n  \t},\r\n\r\n  \t// @method setParams(params: Object, noRedraw?: Boolean): this\r\n  \t// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\r\n  \tsetParams: function (params, noRedraw) {\r\n\r\n  \t\textend(this.wmsParams, params);\r\n\r\n  \t\tif (!noRedraw) {\r\n  \t\t\tthis.redraw();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\r\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\r\n  function tileLayerWMS(url, options) {\r\n  \treturn new TileLayerWMS(url, options);\r\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n\n  \t// @section\n  \t// @aka Renderer options\n  \toptions: {\n  \t\t// @option padding: Number = 0.1\n  \t\t// How much to extend the clip area around the map view (relative to its size)\n  \t\t// e.g. 0.1 would be 10% of map view in each direction\n  \t\tpadding: 0.1\n  \t},\n\n  \tinitialize: function (options) {\n  \t\tsetOptions(this, options);\n  \t\tstamp(this);\n  \t\tthis._layers = this._layers || {};\n  \t},\n\n  \tonAdd: function () {\n  \t\tif (!this._container) {\n  \t\t\tthis._initContainer(); // defined by renderer implementations\n\n  \t\t\t// always keep transform-origin as 0 0\n  \t\t\taddClass(this._container, 'leaflet-zoom-animated');\n  \t\t}\n\n  \t\tthis.getPane().appendChild(this._container);\n  \t\tthis._update();\n  \t\tthis.on('update', this._updatePaths, this);\n  \t},\n\n  \tonRemove: function () {\n  \t\tthis.off('update', this._updatePaths, this);\n  \t\tthis._destroyContainer();\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = {\n  \t\t\tviewreset: this._reset,\n  \t\t\tzoom: this._onZoom,\n  \t\t\tmoveend: this._update,\n  \t\t\tzoomend: this._onZoomEnd\n  \t\t};\n  \t\tif (this._zoomAnimated) {\n  \t\t\tevents.zoomanim = this._onAnimZoom;\n  \t\t}\n  \t\treturn events;\n  \t},\n\n  \t_onAnimZoom: function (ev) {\n  \t\tthis._updateTransform(ev.center, ev.zoom);\n  \t},\n\n  \t_onZoom: function () {\n  \t\tthis._updateTransform(this._map.getCenter(), this._map.getZoom());\n  \t},\n\n  \t_updateTransform: function (center, zoom) {\n  \t\tvar scale = this._map.getZoomScale(zoom, this._zoom),\n  \t\t    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n  \t\t    currentCenterPoint = this._map.project(this._center, zoom),\n\n  \t\t    topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint)\n  \t\t\t\t  .subtract(this._map._getNewPixelOrigin(center, zoom));\n\n  \t\tif (Browser.any3d) {\n  \t\t\tsetTransform(this._container, topLeftOffset, scale);\n  \t\t} else {\n  \t\t\tsetPosition(this._container, topLeftOffset);\n  \t\t}\n  \t},\n\n  \t_reset: function () {\n  \t\tthis._update();\n  \t\tthis._updateTransform(this._center, this._zoom);\n\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._reset();\n  \t\t}\n  \t},\n\n  \t_onZoomEnd: function () {\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._project();\n  \t\t}\n  \t},\n\n  \t_updatePaths: function () {\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._update();\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\t// Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n  \t\t// Subclasses are responsible of firing the 'update' event.\n  \t\tvar p = this.options.padding,\n  \t\t    size = this._map.getSize(),\n  \t\t    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n  \t\tthis._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n\n  \t\tthis._center = this._map.getCenter();\n  \t\tthis._zoom = this._map.getZoom();\n  \t}\n  });\n\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n\n  \t// @section\n  \t// @aka Canvas options\n  \toptions: {\n  \t\t// @option tolerance: Number = 0\n  \t\t// How much to extend the click tolerance around a path/object on the map.\n  \t\ttolerance: 0\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = Renderer.prototype.getEvents.call(this);\n  \t\tevents.viewprereset = this._onViewPreReset;\n  \t\treturn events;\n  \t},\n\n  \t_onViewPreReset: function () {\n  \t\t// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n  \t\tthis._postponeUpdatePaths = true;\n  \t},\n\n  \tonAdd: function () {\n  \t\tRenderer.prototype.onAdd.call(this);\n\n  \t\t// Redraw vectors since canvas is cleared upon removal,\n  \t\t// in case of removing the renderer itself from the map.\n  \t\tthis._draw();\n  \t},\n\n  \t_initContainer: function () {\n  \t\tvar container = this._container = document.createElement('canvas');\n\n  \t\ton(container, 'mousemove', this._onMouseMove, this);\n  \t\ton(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n  \t\ton(container, 'mouseout', this._handleMouseOut, this);\n  \t\tcontainer['_leaflet_disable_events'] = true;\n\n  \t\tthis._ctx = container.getContext('2d');\n  \t},\n\n  \t_destroyContainer: function () {\n  \t\tcancelAnimFrame(this._redrawRequest);\n  \t\tdelete this._ctx;\n  \t\tremove(this._container);\n  \t\toff(this._container);\n  \t\tdelete this._container;\n  \t},\n\n  \t_updatePaths: function () {\n  \t\tif (this._postponeUpdatePaths) { return; }\n\n  \t\tvar layer;\n  \t\tthis._redrawBounds = null;\n  \t\tfor (var id in this._layers) {\n  \t\t\tlayer = this._layers[id];\n  \t\t\tlayer._update();\n  \t\t}\n  \t\tthis._redraw();\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n  \t\tRenderer.prototype._update.call(this);\n\n  \t\tvar b = this._bounds,\n  \t\t    container = this._container,\n  \t\t    size = b.getSize(),\n  \t\t    m = Browser.retina ? 2 : 1;\n\n  \t\tsetPosition(container, b.min);\n\n  \t\t// set canvas size (also clearing it); use double size on retina\n  \t\tcontainer.width = m * size.x;\n  \t\tcontainer.height = m * size.y;\n  \t\tcontainer.style.width = size.x + 'px';\n  \t\tcontainer.style.height = size.y + 'px';\n\n  \t\tif (Browser.retina) {\n  \t\t\tthis._ctx.scale(2, 2);\n  \t\t}\n\n  \t\t// translate so we use the same path coordinates after canvas element moves\n  \t\tthis._ctx.translate(-b.min.x, -b.min.y);\n\n  \t\t// Tell paths to redraw themselves\n  \t\tthis.fire('update');\n  \t},\n\n  \t_reset: function () {\n  \t\tRenderer.prototype._reset.call(this);\n\n  \t\tif (this._postponeUpdatePaths) {\n  \t\t\tthis._postponeUpdatePaths = false;\n  \t\t\tthis._updatePaths();\n  \t\t}\n  \t},\n\n  \t_initPath: function (layer) {\n  \t\tthis._updateDashArray(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n\n  \t\tvar order = layer._order = {\n  \t\t\tlayer: layer,\n  \t\t\tprev: this._drawLast,\n  \t\t\tnext: null\n  \t\t};\n  \t\tif (this._drawLast) { this._drawLast.next = order; }\n  \t\tthis._drawLast = order;\n  \t\tthis._drawFirst = this._drawFirst || this._drawLast;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tvar order = layer._order;\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else {\n  \t\t\tthis._drawLast = prev;\n  \t\t}\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else {\n  \t\t\tthis._drawFirst = next;\n  \t\t}\n\n  \t\tdelete layer._order;\n\n  \t\tdelete this._layers[stamp(layer)];\n\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updatePath: function (layer) {\n  \t\t// Redraw the union of the layer's old pixel\n  \t\t// bounds and the new pixel bounds.\n  \t\tthis._extendRedrawBounds(layer);\n  \t\tlayer._project();\n  \t\tlayer._update();\n  \t\t// The redraw will extend the redraw bounds\n  \t\t// with the new pixel bounds.\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tthis._updateDashArray(layer);\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updateDashArray: function (layer) {\n  \t\tif (typeof layer.options.dashArray === 'string') {\n  \t\t\tvar parts = layer.options.dashArray.split(/[, ]+/),\n  \t\t\t    dashArray = [],\n  \t\t\t    dashValue,\n  \t\t\t    i;\n  \t\t\tfor (i = 0; i < parts.length; i++) {\n  \t\t\t\tdashValue = Number(parts[i]);\n  \t\t\t\t// Ignore dash array containing invalid lengths\n  \t\t\t\tif (isNaN(dashValue)) { return; }\n  \t\t\t\tdashArray.push(dashValue);\n  \t\t\t}\n  \t\t\tlayer.options._dashArray = dashArray;\n  \t\t} else {\n  \t\t\tlayer.options._dashArray = layer.options.dashArray;\n  \t\t}\n  \t},\n\n  \t_requestRedraw: function (layer) {\n  \t\tif (!this._map) { return; }\n\n  \t\tthis._extendRedrawBounds(layer);\n  \t\tthis._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n  \t},\n\n  \t_extendRedrawBounds: function (layer) {\n  \t\tif (layer._pxBounds) {\n  \t\t\tvar padding = (layer.options.weight || 0) + 1;\n  \t\t\tthis._redrawBounds = this._redrawBounds || new Bounds();\n  \t\t\tthis._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n  \t\t\tthis._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n  \t\t}\n  \t},\n\n  \t_redraw: function () {\n  \t\tthis._redrawRequest = null;\n\n  \t\tif (this._redrawBounds) {\n  \t\t\tthis._redrawBounds.min._floor();\n  \t\t\tthis._redrawBounds.max._ceil();\n  \t\t}\n\n  \t\tthis._clear(); // clear layers in redraw bounds\n  \t\tthis._draw(); // draw layers\n\n  \t\tthis._redrawBounds = null;\n  \t},\n\n  \t_clear: function () {\n  \t\tvar bounds = this._redrawBounds;\n  \t\tif (bounds) {\n  \t\t\tvar size = bounds.getSize();\n  \t\t\tthis._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n  \t\t} else {\n  \t\t\tthis._ctx.save();\n  \t\t\tthis._ctx.setTransform(1, 0, 0, 1, 0, 0);\n  \t\t\tthis._ctx.clearRect(0, 0, this._container.width, this._container.height);\n  \t\t\tthis._ctx.restore();\n  \t\t}\n  \t},\n\n  \t_draw: function () {\n  \t\tvar layer, bounds = this._redrawBounds;\n  \t\tthis._ctx.save();\n  \t\tif (bounds) {\n  \t\t\tvar size = bounds.getSize();\n  \t\t\tthis._ctx.beginPath();\n  \t\t\tthis._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n  \t\t\tthis._ctx.clip();\n  \t\t}\n\n  \t\tthis._drawing = true;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {\n  \t\t\t\tlayer._updatePath();\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._drawing = false;\n\n  \t\tthis._ctx.restore();  // Restore state before clipping.\n  \t},\n\n  \t_updatePoly: function (layer, closed) {\n  \t\tif (!this._drawing) { return; }\n\n  \t\tvar i, j, len2, p,\n  \t\t    parts = layer._parts,\n  \t\t    len = parts.length,\n  \t\t    ctx = this._ctx;\n\n  \t\tif (!len) { return; }\n\n  \t\tctx.beginPath();\n\n  \t\tfor (i = 0; i < len; i++) {\n  \t\t\tfor (j = 0, len2 = parts[i].length; j < len2; j++) {\n  \t\t\t\tp = parts[i][j];\n  \t\t\t\tctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n  \t\t\t}\n  \t\t\tif (closed) {\n  \t\t\t\tctx.closePath();\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._fillStroke(ctx, layer);\n\n  \t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n  \t},\n\n  \t_updateCircle: function (layer) {\n\n  \t\tif (!this._drawing || layer._empty()) { return; }\n\n  \t\tvar p = layer._point,\n  \t\t    ctx = this._ctx,\n  \t\t    r = Math.max(Math.round(layer._radius), 1),\n  \t\t    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n  \t\tif (s !== 1) {\n  \t\t\tctx.save();\n  \t\t\tctx.scale(1, s);\n  \t\t}\n\n  \t\tctx.beginPath();\n  \t\tctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n  \t\tif (s !== 1) {\n  \t\t\tctx.restore();\n  \t\t}\n\n  \t\tthis._fillStroke(ctx, layer);\n  \t},\n\n  \t_fillStroke: function (ctx, layer) {\n  \t\tvar options = layer.options;\n\n  \t\tif (options.fill) {\n  \t\t\tctx.globalAlpha = options.fillOpacity;\n  \t\t\tctx.fillStyle = options.fillColor || options.color;\n  \t\t\tctx.fill(options.fillRule || 'evenodd');\n  \t\t}\n\n  \t\tif (options.stroke && options.weight !== 0) {\n  \t\t\tif (ctx.setLineDash) {\n  \t\t\t\tctx.setLineDash(layer.options && layer.options._dashArray || []);\n  \t\t\t}\n  \t\t\tctx.globalAlpha = options.opacity;\n  \t\t\tctx.lineWidth = options.weight;\n  \t\t\tctx.strokeStyle = options.color;\n  \t\t\tctx.lineCap = options.lineCap;\n  \t\t\tctx.lineJoin = options.lineJoin;\n  \t\t\tctx.stroke();\n  \t\t}\n  \t},\n\n  \t// Canvas obviously doesn't have mouse events for individual drawn objects,\n  \t// so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n  \t_onClick: function (e) {\n  \t\tvar point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n  \t\t\t\tif (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {\n  \t\t\t\t\tclickedLayer = layer;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tthis._fireEvent(clickedLayer ? [clickedLayer] : false, e);\n  \t},\n\n  \t_onMouseMove: function (e) {\n  \t\tif (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }\n\n  \t\tvar point = this._map.mouseEventToLayerPoint(e);\n  \t\tthis._handleMouseHover(e, point);\n  \t},\n\n\n  \t_handleMouseOut: function (e) {\n  \t\tvar layer = this._hoveredLayer;\n  \t\tif (layer) {\n  \t\t\t// if we're leaving the layer, fire mouseout\n  \t\t\tremoveClass(this._container, 'leaflet-interactive');\n  \t\t\tthis._fireEvent([layer], e, 'mouseout');\n  \t\t\tthis._hoveredLayer = null;\n  \t\t\tthis._mouseHoverThrottled = false;\n  \t\t}\n  \t},\n\n  \t_handleMouseHover: function (e, point) {\n  \t\tif (this._mouseHoverThrottled) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar layer, candidateHoveredLayer;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n  \t\t\t\tcandidateHoveredLayer = layer;\n  \t\t\t}\n  \t\t}\n\n  \t\tif (candidateHoveredLayer !== this._hoveredLayer) {\n  \t\t\tthis._handleMouseOut(e);\n\n  \t\t\tif (candidateHoveredLayer) {\n  \t\t\t\taddClass(this._container, 'leaflet-interactive'); // change cursor\n  \t\t\t\tthis._fireEvent([candidateHoveredLayer], e, 'mouseover');\n  \t\t\t\tthis._hoveredLayer = candidateHoveredLayer;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);\n\n  \t\tthis._mouseHoverThrottled = true;\n  \t\tsetTimeout(bind(function () {\n  \t\t\tthis._mouseHoverThrottled = false;\n  \t\t}, this), 32);\n  \t},\n\n  \t_fireEvent: function (layers, e, type) {\n  \t\tthis._map._fireDOMEvent(e, type || e.type, layers);\n  \t},\n\n  \t_bringToFront: function (layer) {\n  \t\tvar order = layer._order;\n\n  \t\tif (!order) { return; }\n\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else {\n  \t\t\t// Already last\n  \t\t\treturn;\n  \t\t}\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else if (next) {\n  \t\t\t// Update first entry unless this is the\n  \t\t\t// single entry\n  \t\t\tthis._drawFirst = next;\n  \t\t}\n\n  \t\torder.prev = this._drawLast;\n  \t\tthis._drawLast.next = order;\n\n  \t\torder.next = null;\n  \t\tthis._drawLast = order;\n\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\tvar order = layer._order;\n\n  \t\tif (!order) { return; }\n\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else {\n  \t\t\t// Already first\n  \t\t\treturn;\n  \t\t}\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else if (prev) {\n  \t\t\t// Update last entry unless this is the\n  \t\t\t// single entry\n  \t\t\tthis._drawLast = prev;\n  \t\t}\n\n  \t\torder.prev = null;\n\n  \t\torder.next = this._drawFirst;\n  \t\tthis._drawFirst.prev = order;\n  \t\tthis._drawFirst = order;\n\n  \t\tthis._requestRedraw(layer);\n  \t}\n  });\n\n  // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n  function canvas(options) {\n  \treturn Browser.canvas ? new Canvas(options) : null;\n  }\n\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = (function () {\n  \ttry {\n  \t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n  \t\treturn function (name) {\n  \t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\n  \t\t};\n  \t} catch (e) {\n  \t\t// Do not return fn from catch block so `e` can be garbage collected\n  \t\t// See https://github.com/Leaflet/Leaflet/pull/7279\n  \t}\n  \treturn function (name) {\n  \t\treturn document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n  \t};\n  })();\n\n\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n  var vmlMixin = {\n\n  \t_initContainer: function () {\n  \t\tthis._container = create$1('div', 'leaflet-vml-container');\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom) { return; }\n  \t\tRenderer.prototype._update.call(this);\n  \t\tthis.fire('update');\n  \t},\n\n  \t_initPath: function (layer) {\n  \t\tvar container = layer._container = vmlCreate('shape');\n\n  \t\taddClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n\n  \t\tcontainer.coordsize = '1 1';\n\n  \t\tlayer._path = vmlCreate('path');\n  \t\tcontainer.appendChild(layer._path);\n\n  \t\tthis._updateStyle(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tvar container = layer._container;\n  \t\tthis._container.appendChild(container);\n\n  \t\tif (layer.options.interactive) {\n  \t\t\tlayer.addInteractiveTarget(container);\n  \t\t}\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tvar container = layer._container;\n  \t\tremove(container);\n  \t\tlayer.removeInteractiveTarget(container);\n  \t\tdelete this._layers[stamp(layer)];\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tvar stroke = layer._stroke,\n  \t\t    fill = layer._fill,\n  \t\t    options = layer.options,\n  \t\t    container = layer._container;\n\n  \t\tcontainer.stroked = !!options.stroke;\n  \t\tcontainer.filled = !!options.fill;\n\n  \t\tif (options.stroke) {\n  \t\t\tif (!stroke) {\n  \t\t\t\tstroke = layer._stroke = vmlCreate('stroke');\n  \t\t\t}\n  \t\t\tcontainer.appendChild(stroke);\n  \t\t\tstroke.weight = options.weight + 'px';\n  \t\t\tstroke.color = options.color;\n  \t\t\tstroke.opacity = options.opacity;\n\n  \t\t\tif (options.dashArray) {\n  \t\t\t\tstroke.dashStyle = isArray(options.dashArray) ?\n  \t\t\t\t    options.dashArray.join(' ') :\n  \t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\n  \t\t\t} else {\n  \t\t\t\tstroke.dashStyle = '';\n  \t\t\t}\n  \t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\n  \t\t\tstroke.joinstyle = options.lineJoin;\n\n  \t\t} else if (stroke) {\n  \t\t\tcontainer.removeChild(stroke);\n  \t\t\tlayer._stroke = null;\n  \t\t}\n\n  \t\tif (options.fill) {\n  \t\t\tif (!fill) {\n  \t\t\t\tfill = layer._fill = vmlCreate('fill');\n  \t\t\t}\n  \t\t\tcontainer.appendChild(fill);\n  \t\t\tfill.color = options.fillColor || options.color;\n  \t\t\tfill.opacity = options.fillOpacity;\n\n  \t\t} else if (fill) {\n  \t\t\tcontainer.removeChild(fill);\n  \t\t\tlayer._fill = null;\n  \t\t}\n  \t},\n\n  \t_updateCircle: function (layer) {\n  \t\tvar p = layer._point.round(),\n  \t\t    r = Math.round(layer._radius),\n  \t\t    r2 = Math.round(layer._radiusY || r);\n\n  \t\tthis._setPath(layer, layer._empty() ? 'M0 0' :\n  \t\t\t'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));\n  \t},\n\n  \t_setPath: function (layer, path) {\n  \t\tlayer._path.v = path;\n  \t},\n\n  \t_bringToFront: function (layer) {\n  \t\ttoFront(layer._container);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\ttoBack(layer._container);\n  \t}\n  };\n\n  var create = Browser.vml ? vmlCreate : svgCreate;\n\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n\n  \t_initContainer: function () {\n  \t\tthis._container = create('svg');\n\n  \t\t// makes it possible to click through svg root; we'll reset it back in individual paths\n  \t\tthis._container.setAttribute('pointer-events', 'none');\n\n  \t\tthis._rootGroup = create('g');\n  \t\tthis._container.appendChild(this._rootGroup);\n  \t},\n\n  \t_destroyContainer: function () {\n  \t\tremove(this._container);\n  \t\toff(this._container);\n  \t\tdelete this._container;\n  \t\tdelete this._rootGroup;\n  \t\tdelete this._svgSize;\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n  \t\tRenderer.prototype._update.call(this);\n\n  \t\tvar b = this._bounds,\n  \t\t    size = b.getSize(),\n  \t\t    container = this._container;\n\n  \t\t// set size of svg-container if changed\n  \t\tif (!this._svgSize || !this._svgSize.equals(size)) {\n  \t\t\tthis._svgSize = size;\n  \t\t\tcontainer.setAttribute('width', size.x);\n  \t\t\tcontainer.setAttribute('height', size.y);\n  \t\t}\n\n  \t\t// movement: update container viewBox so that we don't have to change coordinates of individual layers\n  \t\tsetPosition(container, b.min);\n  \t\tcontainer.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n\n  \t\tthis.fire('update');\n  \t},\n\n  \t// methods below are called by vector layers implementations\n\n  \t_initPath: function (layer) {\n  \t\tvar path = layer._path = create('path');\n\n  \t\t// @namespace Path\n  \t\t// @option className: String = null\n  \t\t// Custom class name set on an element. Only for SVG renderer.\n  \t\tif (layer.options.className) {\n  \t\t\taddClass(path, layer.options.className);\n  \t\t}\n\n  \t\tif (layer.options.interactive) {\n  \t\t\taddClass(path, 'leaflet-interactive');\n  \t\t}\n\n  \t\tthis._updateStyle(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tif (!this._rootGroup) { this._initContainer(); }\n  \t\tthis._rootGroup.appendChild(layer._path);\n  \t\tlayer.addInteractiveTarget(layer._path);\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tremove(layer._path);\n  \t\tlayer.removeInteractiveTarget(layer._path);\n  \t\tdelete this._layers[stamp(layer)];\n  \t},\n\n  \t_updatePath: function (layer) {\n  \t\tlayer._project();\n  \t\tlayer._update();\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tvar path = layer._path,\n  \t\t    options = layer.options;\n\n  \t\tif (!path) { return; }\n\n  \t\tif (options.stroke) {\n  \t\t\tpath.setAttribute('stroke', options.color);\n  \t\t\tpath.setAttribute('stroke-opacity', options.opacity);\n  \t\t\tpath.setAttribute('stroke-width', options.weight);\n  \t\t\tpath.setAttribute('stroke-linecap', options.lineCap);\n  \t\t\tpath.setAttribute('stroke-linejoin', options.lineJoin);\n\n  \t\t\tif (options.dashArray) {\n  \t\t\t\tpath.setAttribute('stroke-dasharray', options.dashArray);\n  \t\t\t} else {\n  \t\t\t\tpath.removeAttribute('stroke-dasharray');\n  \t\t\t}\n\n  \t\t\tif (options.dashOffset) {\n  \t\t\t\tpath.setAttribute('stroke-dashoffset', options.dashOffset);\n  \t\t\t} else {\n  \t\t\t\tpath.removeAttribute('stroke-dashoffset');\n  \t\t\t}\n  \t\t} else {\n  \t\t\tpath.setAttribute('stroke', 'none');\n  \t\t}\n\n  \t\tif (options.fill) {\n  \t\t\tpath.setAttribute('fill', options.fillColor || options.color);\n  \t\t\tpath.setAttribute('fill-opacity', options.fillOpacity);\n  \t\t\tpath.setAttribute('fill-rule', options.fillRule || 'evenodd');\n  \t\t} else {\n  \t\t\tpath.setAttribute('fill', 'none');\n  \t\t}\n  \t},\n\n  \t_updatePoly: function (layer, closed) {\n  \t\tthis._setPath(layer, pointsToPath(layer._parts, closed));\n  \t},\n\n  \t_updateCircle: function (layer) {\n  \t\tvar p = layer._point,\n  \t\t    r = Math.max(Math.round(layer._radius), 1),\n  \t\t    r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n  \t\t    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n  \t\t// drawing a circle with two half-arcs\n  \t\tvar d = layer._empty() ? 'M0 0' :\n  \t\t\t'M' + (p.x - r) + ',' + p.y +\n  \t\t\tarc + (r * 2) + ',0 ' +\n  \t\t\tarc + (-r * 2) + ',0 ';\n\n  \t\tthis._setPath(layer, d);\n  \t},\n\n  \t_setPath: function (layer, path) {\n  \t\tlayer._path.setAttribute('d', path);\n  \t},\n\n  \t// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n  \t_bringToFront: function (layer) {\n  \t\ttoFront(layer._path);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\ttoBack(layer._path);\n  \t}\n  });\n\n  if (Browser.vml) {\n  \tSVG.include(vmlMixin);\n  }\n\n  // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n  function svg(options) {\n  \treturn Browser.svg || Browser.vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n  \t// @namespace Map; @method getRenderer(layer: Path): Renderer\n  \t// Returns the instance of `Renderer` that should be used to render the given\n  \t// `Path`. It will ensure that the `renderer` options of the map and paths\n  \t// are respected, and that the renderers do exist on the map.\n  \tgetRenderer: function (layer) {\n  \t\t// @namespace Path; @option renderer: Renderer\n  \t\t// Use this specific instance of `Renderer` for this path. Takes\n  \t\t// precedence over the map's [default renderer](#map-renderer).\n  \t\tvar renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n  \t\tif (!renderer) {\n  \t\t\trenderer = this._renderer = this._createRenderer();\n  \t\t}\n\n  \t\tif (!this.hasLayer(renderer)) {\n  \t\t\tthis.addLayer(renderer);\n  \t\t}\n  \t\treturn renderer;\n  \t},\n\n  \t_getPaneRenderer: function (name) {\n  \t\tif (name === 'overlayPane' || name === undefined) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tvar renderer = this._paneRenderers[name];\n  \t\tif (renderer === undefined) {\n  \t\t\trenderer = this._createRenderer({pane: name});\n  \t\t\tthis._paneRenderers[name] = renderer;\n  \t\t}\n  \t\treturn renderer;\n  \t},\n\n  \t_createRenderer: function (options) {\n  \t\t// @namespace Map; @option preferCanvas: Boolean = false\n  \t\t// Whether `Path`s should be rendered on a `Canvas` renderer.\n  \t\t// By default, all `Path`s are rendered in a `SVG` renderer.\n  \t\treturn (this.options.preferCanvas && canvas(options)) || svg(options);\n  \t}\n  });\n\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n\n  var Rectangle = Polygon.extend({\n  \tinitialize: function (latLngBounds, options) {\n  \t\tPolygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n  \t},\n\n  \t// @method setBounds(latLngBounds: LatLngBounds): this\n  \t// Redraws the rectangle with the passed bounds.\n  \tsetBounds: function (latLngBounds) {\n  \t\treturn this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n  \t},\n\n  \t_boundsToLatLngs: function (latLngBounds) {\n  \t\tlatLngBounds = toLatLngBounds(latLngBounds);\n  \t\treturn [\n  \t\t\tlatLngBounds.getSouthWest(),\n  \t\t\tlatLngBounds.getNorthWest(),\n  \t\t\tlatLngBounds.getNorthEast(),\n  \t\t\tlatLngBounds.getSouthEast()\n  \t\t];\n  \t}\n  });\n\n\n  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n  function rectangle(latLngBounds, options) {\n  \treturn new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create;\n  SVG.pointsToPath = pointsToPath;\n\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @option boxZoom: Boolean = true\n  \t// Whether the map can be zoomed to a rectangular area specified by\n  \t// dragging the mouse while pressing the shift key.\n  \tboxZoom: true\n  });\n\n  var BoxZoom = Handler.extend({\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n  \t\tthis._container = map._container;\n  \t\tthis._pane = map._panes.overlayPane;\n  \t\tthis._resetStateTimeout = 0;\n  \t\tmap.on('unload', this._destroy, this);\n  \t},\n\n  \taddHooks: function () {\n  \t\ton(this._container, 'mousedown', this._onMouseDown, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._container, 'mousedown', this._onMouseDown, this);\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._moved;\n  \t},\n\n  \t_destroy: function () {\n  \t\tremove(this._pane);\n  \t\tdelete this._pane;\n  \t},\n\n  \t_resetState: function () {\n  \t\tthis._resetStateTimeout = 0;\n  \t\tthis._moved = false;\n  \t},\n\n  \t_clearDeferredResetState: function () {\n  \t\tif (this._resetStateTimeout !== 0) {\n  \t\t\tclearTimeout(this._resetStateTimeout);\n  \t\t\tthis._resetStateTimeout = 0;\n  \t\t}\n  \t},\n\n  \t_onMouseDown: function (e) {\n  \t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n  \t\t// Clear the deferred resetState if it hasn't executed yet, otherwise it\n  \t\t// will interrupt the interaction and orphan a box element in the container.\n  \t\tthis._clearDeferredResetState();\n  \t\tthis._resetState();\n\n  \t\tdisableTextSelection();\n  \t\tdisableImageDrag();\n\n  \t\tthis._startPoint = this._map.mouseEventToContainerPoint(e);\n\n  \t\ton(document, {\n  \t\t\tcontextmenu: stop,\n  \t\t\tmousemove: this._onMouseMove,\n  \t\t\tmouseup: this._onMouseUp,\n  \t\t\tkeydown: this._onKeyDown\n  \t\t}, this);\n  \t},\n\n  \t_onMouseMove: function (e) {\n  \t\tif (!this._moved) {\n  \t\t\tthis._moved = true;\n\n  \t\t\tthis._box = create$1('div', 'leaflet-zoom-box', this._container);\n  \t\t\taddClass(this._container, 'leaflet-crosshair');\n\n  \t\t\tthis._map.fire('boxzoomstart');\n  \t\t}\n\n  \t\tthis._point = this._map.mouseEventToContainerPoint(e);\n\n  \t\tvar bounds = new Bounds(this._point, this._startPoint),\n  \t\t    size = bounds.getSize();\n\n  \t\tsetPosition(this._box, bounds.min);\n\n  \t\tthis._box.style.width  = size.x + 'px';\n  \t\tthis._box.style.height = size.y + 'px';\n  \t},\n\n  \t_finish: function () {\n  \t\tif (this._moved) {\n  \t\t\tremove(this._box);\n  \t\t\tremoveClass(this._container, 'leaflet-crosshair');\n  \t\t}\n\n  \t\tenableTextSelection();\n  \t\tenableImageDrag();\n\n  \t\toff(document, {\n  \t\t\tcontextmenu: stop,\n  \t\t\tmousemove: this._onMouseMove,\n  \t\t\tmouseup: this._onMouseUp,\n  \t\t\tkeydown: this._onKeyDown\n  \t\t}, this);\n  \t},\n\n  \t_onMouseUp: function (e) {\n  \t\tif ((e.which !== 1) && (e.button !== 1)) { return; }\n\n  \t\tthis._finish();\n\n  \t\tif (!this._moved) { return; }\n  \t\t// Postpone to next JS tick so internal click event handling\n  \t\t// still see it as \"moved\".\n  \t\tthis._clearDeferredResetState();\n  \t\tthis._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n\n  \t\tvar bounds = new LatLngBounds(\n  \t\t        this._map.containerPointToLatLng(this._startPoint),\n  \t\t        this._map.containerPointToLatLng(this._point));\n\n  \t\tthis._map\n  \t\t\t.fitBounds(bounds)\n  \t\t\t.fire('boxzoomend', {boxZoomBounds: bounds});\n  \t},\n\n  \t_onKeyDown: function (e) {\n  \t\tif (e.keyCode === 27) {\n  \t\t\tthis._finish();\n  \t\t\tthis._clearDeferredResetState();\n  \t\t\tthis._resetState();\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n  \t// @option doubleClickZoom: Boolean|String = true\n  \t// Whether the map can be zoomed in by double clicking on it and\n  \t// zoomed out by double clicking while holding shift. If passed\n  \t// `'center'`, double-click zoom will zoom to the center of the\n  \t//  view regardless of where the mouse was.\n  \tdoubleClickZoom: true\n  });\n\n  var DoubleClickZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\tthis._map.on('dblclick', this._onDoubleClick, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._map.off('dblclick', this._onDoubleClick, this);\n  \t},\n\n  \t_onDoubleClick: function (e) {\n  \t\tvar map = this._map,\n  \t\t    oldZoom = map.getZoom(),\n  \t\t    delta = map.options.zoomDelta,\n  \t\t    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n  \t\tif (map.options.doubleClickZoom === 'center') {\n  \t\t\tmap.setZoom(zoom);\n  \t\t} else {\n  \t\t\tmap.setZoomAround(e.containerPoint, zoom);\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @option dragging: Boolean = true\n  \t// Whether the map is draggable with mouse/touch or not.\n  \tdragging: true,\n\n  \t// @section Panning Inertia Options\n  \t// @option inertia: Boolean = *\n  \t// If enabled, panning of the map will have an inertia effect where\n  \t// the map builds momentum while dragging and continues moving in\n  \t// the same direction for some time. Feels especially nice on touch\n  \t// devices. Enabled by default.\n  \tinertia: true,\n\n  \t// @option inertiaDeceleration: Number = 3000\n  \t// The rate with which the inertial movement slows down, in pixels/second.\n  \tinertiaDeceleration: 3400, // px/s^2\n\n  \t// @option inertiaMaxSpeed: Number = Infinity\n  \t// Max speed of the inertial movement, in pixels/second.\n  \tinertiaMaxSpeed: Infinity, // px/s\n\n  \t// @option easeLinearity: Number = 0.2\n  \teaseLinearity: 0.2,\n\n  \t// TODO refactor, move to CRS\n  \t// @option worldCopyJump: Boolean = false\n  \t// With this option enabled, the map tracks when you pan to another \"copy\"\n  \t// of the world and seamlessly jumps to the original one so that all overlays\n  \t// like markers and vector layers are still visible.\n  \tworldCopyJump: false,\n\n  \t// @option maxBoundsViscosity: Number = 0.0\n  \t// If `maxBounds` is set, this option will control how solid the bounds\n  \t// are when dragging the map around. The default value of `0.0` allows the\n  \t// user to drag outside the bounds at normal speed, higher values will\n  \t// slow down map dragging outside bounds, and `1.0` makes the bounds fully\n  \t// solid, preventing the user from dragging outside the bounds.\n  \tmaxBoundsViscosity: 0.0\n  });\n\n  var Drag = Handler.extend({\n  \taddHooks: function () {\n  \t\tif (!this._draggable) {\n  \t\t\tvar map = this._map;\n\n  \t\t\tthis._draggable = new Draggable(map._mapPane, map._container);\n\n  \t\t\tthis._draggable.on({\n  \t\t\t\tdragstart: this._onDragStart,\n  \t\t\t\tdrag: this._onDrag,\n  \t\t\t\tdragend: this._onDragEnd\n  \t\t\t}, this);\n\n  \t\t\tthis._draggable.on('predrag', this._onPreDragLimit, this);\n  \t\t\tif (map.options.worldCopyJump) {\n  \t\t\t\tthis._draggable.on('predrag', this._onPreDragWrap, this);\n  \t\t\t\tmap.on('zoomend', this._onZoomEnd, this);\n\n  \t\t\t\tmap.whenReady(this._onZoomEnd, this);\n  \t\t\t}\n  \t\t}\n  \t\taddClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n  \t\tthis._draggable.enable();\n  \t\tthis._positions = [];\n  \t\tthis._times = [];\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tremoveClass(this._map._container, 'leaflet-grab');\n  \t\tremoveClass(this._map._container, 'leaflet-touch-drag');\n  \t\tthis._draggable.disable();\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._draggable && this._draggable._moved;\n  \t},\n\n  \tmoving: function () {\n  \t\treturn this._draggable && this._draggable._moving;\n  \t},\n\n  \t_onDragStart: function () {\n  \t\tvar map = this._map;\n\n  \t\tmap._stop();\n  \t\tif (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n  \t\t\tvar bounds = toLatLngBounds(this._map.options.maxBounds);\n\n  \t\t\tthis._offsetLimit = toBounds(\n  \t\t\t\tthis._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),\n  \t\t\t\tthis._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)\n  \t\t\t\t\t.add(this._map.getSize()));\n\n  \t\t\tthis._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n  \t\t} else {\n  \t\t\tthis._offsetLimit = null;\n  \t\t}\n\n  \t\tmap\n  \t\t    .fire('movestart')\n  \t\t    .fire('dragstart');\n\n  \t\tif (map.options.inertia) {\n  \t\t\tthis._positions = [];\n  \t\t\tthis._times = [];\n  \t\t}\n  \t},\n\n  \t_onDrag: function (e) {\n  \t\tif (this._map.options.inertia) {\n  \t\t\tvar time = this._lastTime = +new Date(),\n  \t\t\t    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n  \t\t\tthis._positions.push(pos);\n  \t\t\tthis._times.push(time);\n\n  \t\t\tthis._prunePositions(time);\n  \t\t}\n\n  \t\tthis._map\n  \t\t    .fire('move', e)\n  \t\t    .fire('drag', e);\n  \t},\n\n  \t_prunePositions: function (time) {\n  \t\twhile (this._positions.length > 1 && time - this._times[0] > 50) {\n  \t\t\tthis._positions.shift();\n  \t\t\tthis._times.shift();\n  \t\t}\n  \t},\n\n  \t_onZoomEnd: function () {\n  \t\tvar pxCenter = this._map.getSize().divideBy(2),\n  \t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n  \t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n  \t\tthis._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n  \t},\n\n  \t_viscousLimit: function (value, threshold) {\n  \t\treturn value - (value - threshold) * this._viscosity;\n  \t},\n\n  \t_onPreDragLimit: function () {\n  \t\tif (!this._viscosity || !this._offsetLimit) { return; }\n\n  \t\tvar offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n  \t\tvar limit = this._offsetLimit;\n  \t\tif (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }\n  \t\tif (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }\n  \t\tif (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }\n  \t\tif (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }\n\n  \t\tthis._draggable._newPos = this._draggable._startPos.add(offset);\n  \t},\n\n  \t_onPreDragWrap: function () {\n  \t\t// TODO refactor to be able to adjust map pane position after zoom\n  \t\tvar worldWidth = this._worldWidth,\n  \t\t    halfWidth = Math.round(worldWidth / 2),\n  \t\t    dx = this._initialWorldOffset,\n  \t\t    x = this._draggable._newPos.x,\n  \t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n  \t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n  \t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n  \t\tthis._draggable._absPos = this._draggable._newPos.clone();\n  \t\tthis._draggable._newPos.x = newX;\n  \t},\n\n  \t_onDragEnd: function (e) {\n  \t\tvar map = this._map,\n  \t\t    options = map.options,\n\n  \t\t    noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n\n  \t\tmap.fire('dragend', e);\n\n  \t\tif (noInertia) {\n  \t\t\tmap.fire('moveend');\n\n  \t\t} else {\n  \t\t\tthis._prunePositions(+new Date());\n\n  \t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n  \t\t\t    duration = (this._lastTime - this._times[0]) / 1000,\n  \t\t\t    ease = options.easeLinearity,\n\n  \t\t\t    speedVector = direction.multiplyBy(ease / duration),\n  \t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n  \t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n  \t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n  \t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n  \t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n  \t\t\tif (!offset.x && !offset.y) {\n  \t\t\t\tmap.fire('moveend');\n\n  \t\t\t} else {\n  \t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n  \t\t\t\trequestAnimFrame(function () {\n  \t\t\t\t\tmap.panBy(offset, {\n  \t\t\t\t\t\tduration: decelerationDuration,\n  \t\t\t\t\t\teaseLinearity: ease,\n  \t\t\t\t\t\tnoMoveStart: true,\n  \t\t\t\t\t\tanimate: true\n  \t\t\t\t\t});\n  \t\t\t\t});\n  \t\t\t}\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n  Map.addInitHook('addHandler', 'dragging', Drag);\n\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Keyboard Navigation Options\n  Map.mergeOptions({\n  \t// @option keyboard: Boolean = true\n  \t// Makes the map focusable and allows users to navigate the map with keyboard\n  \t// arrows and `+`/`-` keys.\n  \tkeyboard: true,\n\n  \t// @option keyboardPanDelta: Number = 80\n  \t// Amount of pixels to pan when pressing an arrow key.\n  \tkeyboardPanDelta: 80\n  });\n\n  var Keyboard = Handler.extend({\n\n  \tkeyCodes: {\n  \t\tleft:    [37],\n  \t\tright:   [39],\n  \t\tdown:    [40],\n  \t\tup:      [38],\n  \t\tzoomIn:  [187, 107, 61, 171],\n  \t\tzoomOut: [189, 109, 54, 173]\n  \t},\n\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n\n  \t\tthis._setPanDelta(map.options.keyboardPanDelta);\n  \t\tthis._setZoomDelta(map.options.zoomDelta);\n  \t},\n\n  \taddHooks: function () {\n  \t\tvar container = this._map._container;\n\n  \t\t// make the container focusable by tabbing\n  \t\tif (container.tabIndex <= 0) {\n  \t\t\tcontainer.tabIndex = '0';\n  \t\t}\n\n  \t\ton(container, {\n  \t\t\tfocus: this._onFocus,\n  \t\t\tblur: this._onBlur,\n  \t\t\tmousedown: this._onMouseDown\n  \t\t}, this);\n\n  \t\tthis._map.on({\n  \t\t\tfocus: this._addHooks,\n  \t\t\tblur: this._removeHooks\n  \t\t}, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._removeHooks();\n\n  \t\toff(this._map._container, {\n  \t\t\tfocus: this._onFocus,\n  \t\t\tblur: this._onBlur,\n  \t\t\tmousedown: this._onMouseDown\n  \t\t}, this);\n\n  \t\tthis._map.off({\n  \t\t\tfocus: this._addHooks,\n  \t\t\tblur: this._removeHooks\n  \t\t}, this);\n  \t},\n\n  \t_onMouseDown: function () {\n  \t\tif (this._focused) { return; }\n\n  \t\tvar body = document.body,\n  \t\t    docEl = document.documentElement,\n  \t\t    top = body.scrollTop || docEl.scrollTop,\n  \t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n  \t\tthis._map._container.focus();\n\n  \t\twindow.scrollTo(left, top);\n  \t},\n\n  \t_onFocus: function () {\n  \t\tthis._focused = true;\n  \t\tthis._map.fire('focus');\n  \t},\n\n  \t_onBlur: function () {\n  \t\tthis._focused = false;\n  \t\tthis._map.fire('blur');\n  \t},\n\n  \t_setPanDelta: function (panDelta) {\n  \t\tvar keys = this._panKeys = {},\n  \t\t    codes = this.keyCodes,\n  \t\t    i, len;\n\n  \t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n  \t\t\tkeys[codes.left[i]] = [-1 * panDelta, 0];\n  \t\t}\n  \t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n  \t\t\tkeys[codes.right[i]] = [panDelta, 0];\n  \t\t}\n  \t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n  \t\t\tkeys[codes.down[i]] = [0, panDelta];\n  \t\t}\n  \t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n  \t\t\tkeys[codes.up[i]] = [0, -1 * panDelta];\n  \t\t}\n  \t},\n\n  \t_setZoomDelta: function (zoomDelta) {\n  \t\tvar keys = this._zoomKeys = {},\n  \t\t    codes = this.keyCodes,\n  \t\t    i, len;\n\n  \t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n  \t\t\tkeys[codes.zoomIn[i]] = zoomDelta;\n  \t\t}\n  \t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n  \t\t\tkeys[codes.zoomOut[i]] = -zoomDelta;\n  \t\t}\n  \t},\n\n  \t_addHooks: function () {\n  \t\ton(document, 'keydown', this._onKeyDown, this);\n  \t},\n\n  \t_removeHooks: function () {\n  \t\toff(document, 'keydown', this._onKeyDown, this);\n  \t},\n\n  \t_onKeyDown: function (e) {\n  \t\tif (e.altKey || e.ctrlKey || e.metaKey) { return; }\n\n  \t\tvar key = e.keyCode,\n  \t\t    map = this._map,\n  \t\t    offset;\n\n  \t\tif (key in this._panKeys) {\n  \t\t\tif (!map._panAnim || !map._panAnim._inProgress) {\n  \t\t\t\toffset = this._panKeys[key];\n  \t\t\t\tif (e.shiftKey) {\n  \t\t\t\t\toffset = toPoint(offset).multiplyBy(3);\n  \t\t\t\t}\n\n  \t\t\t\tif (map.options.maxBounds) {\n  \t\t\t\t\toffset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n  \t\t\t\t}\n\n  \t\t\t\tif (map.options.worldCopyJump) {\n  \t\t\t\t\tvar newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n  \t\t\t\t\tmap.panTo(newLatLng);\n  \t\t\t\t} else {\n  \t\t\t\t\tmap.panBy(offset);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (key in this._zoomKeys) {\n  \t\t\tmap.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n\n  \t\t} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n  \t\t\tmap.closePopup();\n\n  \t\t} else {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tstop(e);\n  \t}\n  });\n\n  // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Mouse wheel options\n  \t// @option scrollWheelZoom: Boolean|String = true\n  \t// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n  \t// it will zoom to the center of the view regardless of where the mouse was.\n  \tscrollWheelZoom: true,\n\n  \t// @option wheelDebounceTime: Number = 40\n  \t// Limits the rate at which a wheel can fire (in milliseconds). By default\n  \t// user can't zoom via wheel more often than once per 40 ms.\n  \twheelDebounceTime: 40,\n\n  \t// @option wheelPxPerZoomLevel: Number = 60\n  \t// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n  \t// mean a change of one full zoom level. Smaller values will make wheel-zooming\n  \t// faster (and vice versa).\n  \twheelPxPerZoomLevel: 60\n  });\n\n  var ScrollWheelZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\ton(this._map._container, 'wheel', this._onWheelScroll, this);\n\n  \t\tthis._delta = 0;\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._map._container, 'wheel', this._onWheelScroll, this);\n  \t},\n\n  \t_onWheelScroll: function (e) {\n  \t\tvar delta = getWheelDelta(e);\n\n  \t\tvar debounce = this._map.options.wheelDebounceTime;\n\n  \t\tthis._delta += delta;\n  \t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n  \t\tif (!this._startTime) {\n  \t\t\tthis._startTime = +new Date();\n  \t\t}\n\n  \t\tvar left = Math.max(debounce - (+new Date() - this._startTime), 0);\n\n  \t\tclearTimeout(this._timer);\n  \t\tthis._timer = setTimeout(bind(this._performZoom, this), left);\n\n  \t\tstop(e);\n  \t},\n\n  \t_performZoom: function () {\n  \t\tvar map = this._map,\n  \t\t    zoom = map.getZoom(),\n  \t\t    snap = this._map.options.zoomSnap || 0;\n\n  \t\tmap._stop(); // stop panning and fly animations if any\n\n  \t\t// map the delta with a sigmoid function to -4..4 range leaning on -1..1\n  \t\tvar d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n  \t\t    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n  \t\t    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n  \t\t    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n\n  \t\tthis._delta = 0;\n  \t\tthis._startTime = null;\n\n  \t\tif (!delta) { return; }\n\n  \t\tif (map.options.scrollWheelZoom === 'center') {\n  \t\t\tmap.setZoom(zoom + delta);\n  \t\t} else {\n  \t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n\n  /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */\n\n  var tapHoldDelay = 600;\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Touch interaction options\n  \t// @option tapHold: Boolean\n  \t// Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n  \ttapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n\n  \t// @option tapTolerance: Number = 15\n  \t// The max number of pixels a user can shift his finger during touch\n  \t// for it to be considered a valid tap.\n  \ttapTolerance: 15\n  });\n\n  var TapHold = Handler.extend({\n  \taddHooks: function () {\n  \t\ton(this._map._container, 'touchstart', this._onDown, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._map._container, 'touchstart', this._onDown, this);\n  \t},\n\n  \t_onDown: function (e) {\n  \t\tclearTimeout(this._holdTimeout);\n  \t\tif (e.touches.length !== 1) { return; }\n\n  \t\tvar first = e.touches[0];\n  \t\tthis._startPos = this._newPos = new Point(first.clientX, first.clientY);\n\n  \t\tthis._holdTimeout = setTimeout(bind(function () {\n  \t\t\tthis._cancel();\n  \t\t\tif (!this._isTapValid()) { return; }\n\n  \t\t\t// prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n  \t\t\ton(document, 'touchend', preventDefault);\n  \t\t\ton(document, 'touchend touchcancel', this._cancelClickPrevent);\n  \t\t\tthis._simulateEvent('contextmenu', first);\n  \t\t}, this), tapHoldDelay);\n\n  \t\ton(document, 'touchend touchcancel contextmenu', this._cancel, this);\n  \t\ton(document, 'touchmove', this._onMove, this);\n  \t},\n\n  \t_cancelClickPrevent: function cancelClickPrevent() {\n  \t\toff(document, 'touchend', preventDefault);\n  \t\toff(document, 'touchend touchcancel', cancelClickPrevent);\n  \t},\n\n  \t_cancel: function () {\n  \t\tclearTimeout(this._holdTimeout);\n  \t\toff(document, 'touchend touchcancel contextmenu', this._cancel, this);\n  \t\toff(document, 'touchmove', this._onMove, this);\n  \t},\n\n  \t_onMove: function (e) {\n  \t\tvar first = e.touches[0];\n  \t\tthis._newPos = new Point(first.clientX, first.clientY);\n  \t},\n\n  \t_isTapValid: function () {\n  \t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n  \t},\n\n  \t_simulateEvent: function (type, e) {\n  \t\tvar simulatedEvent = new MouseEvent(type, {\n  \t\t\tbubbles: true,\n  \t\t\tcancelable: true,\n  \t\t\tview: window,\n  \t\t\t// detail: 1,\n  \t\t\tscreenX: e.screenX,\n  \t\t\tscreenY: e.screenY,\n  \t\t\tclientX: e.clientX,\n  \t\t\tclientY: e.clientY,\n  \t\t\t// button: 2,\n  \t\t\t// buttons: 2\n  \t\t});\n\n  \t\tsimulatedEvent._simulated = true;\n\n  \t\te.target.dispatchEvent(simulatedEvent);\n  \t}\n  });\n\n  // @section Handlers\n  // @property tapHold: Handler\n  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n  Map.addInitHook('addHandler', 'tapHold', TapHold);\n\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Touch interaction options\n  \t// @option touchZoom: Boolean|String = *\n  \t// Whether the map can be zoomed by touch-dragging with two fingers. If\n  \t// passed `'center'`, it will zoom to the center of the view regardless of\n  \t// where the touch events (fingers) were. Enabled for touch-capable web\n  \t// browsers.\n  \ttouchZoom: Browser.touch,\n\n  \t// @option bounceAtZoomLimits: Boolean = true\n  \t// Set it to false if you don't want the map to zoom beyond min/max zoom\n  \t// and then bounce back when pinch-zooming.\n  \tbounceAtZoomLimits: true\n  });\n\n  var TouchZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\taddClass(this._map._container, 'leaflet-touch-zoom');\n  \t\ton(this._map._container, 'touchstart', this._onTouchStart, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tremoveClass(this._map._container, 'leaflet-touch-zoom');\n  \t\toff(this._map._container, 'touchstart', this._onTouchStart, this);\n  \t},\n\n  \t_onTouchStart: function (e) {\n  \t\tvar map = this._map;\n  \t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n  \t\tvar p1 = map.mouseEventToContainerPoint(e.touches[0]),\n  \t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]);\n\n  \t\tthis._centerPoint = map.getSize()._divideBy(2);\n  \t\tthis._startLatLng = map.containerPointToLatLng(this._centerPoint);\n  \t\tif (map.options.touchZoom !== 'center') {\n  \t\t\tthis._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n  \t\t}\n\n  \t\tthis._startDist = p1.distanceTo(p2);\n  \t\tthis._startZoom = map.getZoom();\n\n  \t\tthis._moved = false;\n  \t\tthis._zooming = true;\n\n  \t\tmap._stop();\n\n  \t\ton(document, 'touchmove', this._onTouchMove, this);\n  \t\ton(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n  \t\tpreventDefault(e);\n  \t},\n\n  \t_onTouchMove: function (e) {\n  \t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n  \t\tvar map = this._map,\n  \t\t    p1 = map.mouseEventToContainerPoint(e.touches[0]),\n  \t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]),\n  \t\t    scale = p1.distanceTo(p2) / this._startDist;\n\n  \t\tthis._zoom = map.getScaleZoom(scale, this._startZoom);\n\n  \t\tif (!map.options.bounceAtZoomLimits && (\n  \t\t\t(this._zoom < map.getMinZoom() && scale < 1) ||\n  \t\t\t(this._zoom > map.getMaxZoom() && scale > 1))) {\n  \t\t\tthis._zoom = map._limitZoom(this._zoom);\n  \t\t}\n\n  \t\tif (map.options.touchZoom === 'center') {\n  \t\t\tthis._center = this._startLatLng;\n  \t\t\tif (scale === 1) { return; }\n  \t\t} else {\n  \t\t\t// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n  \t\t\tvar delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n  \t\t\tif (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\n  \t\t\tthis._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n  \t\t}\n\n  \t\tif (!this._moved) {\n  \t\t\tmap._moveStart(true, false);\n  \t\t\tthis._moved = true;\n  \t\t}\n\n  \t\tcancelAnimFrame(this._animRequest);\n\n  \t\tvar moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false}, undefined);\n  \t\tthis._animRequest = requestAnimFrame(moveFn, this, true);\n\n  \t\tpreventDefault(e);\n  \t},\n\n  \t_onTouchEnd: function () {\n  \t\tif (!this._moved || !this._zooming) {\n  \t\t\tthis._zooming = false;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis._zooming = false;\n  \t\tcancelAnimFrame(this._animRequest);\n\n  \t\toff(document, 'touchmove', this._onTouchMove, this);\n  \t\toff(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n  \t\t// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n  \t\tif (this._map.options.zoomAnimation) {\n  \t\t\tthis._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n  \t\t} else {\n  \t\t\tthis._map._resetView(this._center, this._map._limitZoom(this._zoom));\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.TapHold = TapHold;\n  Map.TouchZoom = TouchZoom;\n\n  exports.Bounds = Bounds;\n  exports.Browser = Browser;\n  exports.CRS = CRS;\n  exports.Canvas = Canvas;\n  exports.Circle = Circle;\n  exports.CircleMarker = CircleMarker;\n  exports.Class = Class;\n  exports.Control = Control;\n  exports.DivIcon = DivIcon;\n  exports.DivOverlay = DivOverlay;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.Draggable = Draggable;\n  exports.Evented = Evented;\n  exports.FeatureGroup = FeatureGroup;\n  exports.GeoJSON = GeoJSON;\n  exports.GridLayer = GridLayer;\n  exports.Handler = Handler;\n  exports.Icon = Icon;\n  exports.ImageOverlay = ImageOverlay;\n  exports.LatLng = LatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.LineUtil = LineUtil;\n  exports.Map = Map;\n  exports.Marker = Marker;\n  exports.Mixin = Mixin;\n  exports.Path = Path;\n  exports.Point = Point;\n  exports.PolyUtil = PolyUtil;\n  exports.Polygon = Polygon;\n  exports.Polyline = Polyline;\n  exports.Popup = Popup;\n  exports.PosAnimation = PosAnimation;\n  exports.Projection = index;\n  exports.Rectangle = Rectangle;\n  exports.Renderer = Renderer;\n  exports.SVG = SVG;\n  exports.SVGOverlay = SVGOverlay;\n  exports.TileLayer = TileLayer;\n  exports.Tooltip = Tooltip;\n  exports.Transformation = Transformation;\n  exports.Util = Util;\n  exports.VideoOverlay = VideoOverlay;\n  exports.bind = bind;\n  exports.bounds = toBounds;\n  exports.canvas = canvas;\n  exports.circle = circle;\n  exports.circleMarker = circleMarker;\n  exports.control = control;\n  exports.divIcon = divIcon;\n  exports.extend = extend;\n  exports.featureGroup = featureGroup;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.gridLayer = gridLayer;\n  exports.icon = icon;\n  exports.imageOverlay = imageOverlay;\n  exports.latLng = toLatLng;\n  exports.latLngBounds = toLatLngBounds;\n  exports.layerGroup = layerGroup;\n  exports.map = createMap;\n  exports.marker = marker;\n  exports.point = toPoint;\n  exports.polygon = polygon;\n  exports.polyline = polyline;\n  exports.popup = popup;\n  exports.rectangle = rectangle;\n  exports.setOptions = setOptions;\n  exports.stamp = stamp;\n  exports.svg = svg;\n  exports.svgOverlay = svgOverlay;\n  exports.tileLayer = tileLayer;\n  exports.tooltip = tooltip;\n  exports.transformation = toTransformation;\n  exports.version = version;\n  exports.videoOverlay = videoOverlay;\n\n  var oldL = window.L;\n  exports.noConflict = function() {\n  \twindow.L = oldL;\n  \treturn this;\n  }\n  // Always export us to window global (see #2364)\n  window.L = exports;\n\n}));\n//# sourceMappingURL=leaflet-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ3dHO0FBQzFHLENBQUMsOEJBQThCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCLE9BQU8sc0NBQXNDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7O0FBRUgscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1Qzs7QUFFQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsc0JBQXNCLElBQUk7QUFDekUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxQkFBcUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxQkFBcUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxQkFBcUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxLQUFLLCtCQUErQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxLQUFLLCtCQUErQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZDQUE2QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxhQUFhO0FBQ2xELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsZUFBZTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUEyQztBQUN6RSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtB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QUVBLG1EQUFtRCxVQUFVO0FBQzdELGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDs7QUFFMUQ7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDs7QUFFQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsMkNBQTJDLHVCQUF1QjtBQUNsRSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9EQUFvRDs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0EsK0NBQStDOztBQUUvQzs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hELElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7O0FBRWxDO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanM/ZTExZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAcHJlc2VydmVcbiAqIExlYWZsZXQgMS45LjQsIGEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwcy4gaHR0cHM6Ly9sZWFmbGV0anMuY29tXG4gKiAoYykgMjAxMC0yMDIzIFZsYWRpbWlyIEFnYWZvbmtpbiwgKGMpIDIwMTAtMjAxMSBDbG91ZE1hZGVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmxlYWZsZXQgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdmVyc2lvbiA9IFwiMS45LjRcIjtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gICAqXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICovXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcbiAgXHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG4gIFx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcbiAgXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuICBcdFx0Zm9yIChpIGluIHNyYykge1xyXG4gIFx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICBcdHJldHVybiBkZXN0O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcbiAgdmFyIGNyZWF0ZSQyID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gIFx0ZnVuY3Rpb24gRigpIHt9XHJcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcbiAgXHRcdHJldHVybiBuZXcgRigpO1xyXG4gIFx0fTtcclxuICB9KSgpO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbiAgLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG4gIC8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gYmluZChmbiwgb2JqKSB7XHJcbiAgXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4gIFx0aWYgKGZuLmJpbmQpIHtcclxuICBcdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuICBcdH07XHJcbiAgfVxyXG5cclxuICAvLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuICAvLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG4gIHZhciBsYXN0SWQgPSAwO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ25pbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuICBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuICBcdGlmICghKCdfbGVhZmxldF9pZCcgaW4gb2JqKSkge1xyXG4gIFx0XHRvYmpbJ19sZWFmbGV0X2lkJ10gPSArK2xhc3RJZDtcclxuICBcdH1cclxuICBcdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcbiAgLy8gKHNvIHRoYXQgdGhlIGB0aGlzYCBrZXl3b3JkIHJlZmVycyB0byBgY29udGV4dGAgaW5zaWRlIGBmbmAncyBjb2RlKS4gVGhlIGZ1bmN0aW9uXHJcbiAgLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuICAvLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcbiAgLy8gZnVuY3Rpb24sIGZvbGxvd2VkIGJ5IGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gaW52b2tpbmcgdGhlIGJvdW5kIGZ1bmN0aW9uLlxyXG4gIC8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUsIGNvbnRleHQpIHtcclxuICBcdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuICBcdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyByZXNldCBsb2NrIGFuZCBjYWxsIGlmIHF1ZXVlZFxyXG4gIFx0XHRsb2NrID0gZmFsc2U7XHJcbiAgXHRcdGlmIChhcmdzKSB7XHJcbiAgXHRcdFx0d3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gIFx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuXHJcbiAgXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmIChsb2NrKSB7XHJcbiAgXHRcdFx0Ly8gY2FsbGVkIHRvbyBzb29uLCBxdWV1ZSB0byBjYWxsIGxhdGVyXHJcbiAgXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxyXG4gIFx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcbiAgXHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcbiAgXHRcdFx0bG9jayA9IHRydWU7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcblxyXG4gIFx0cmV0dXJuIHdyYXBwZXJGbjtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuICAvLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbiAgLy8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG4gIFx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG4gIFx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG4gIFx0ICAgIGQgPSBtYXggLSBtaW47XHJcbiAgXHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG4gIGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB3aXRoIHNwZWNpZmllZCBgcHJlY2lzaW9uYC5cclxuICAvLyBUaGUgZGVmYXVsdCBgcHJlY2lzaW9uYCB2YWx1ZSBpcyA2IGRlY2ltYWwgcGxhY2VzLlxyXG4gIC8vIGBmYWxzZWAgY2FuIGJlIHBhc3NlZCB0byBza2lwIGFueSBwcm9jZXNzaW5nIChjYW4gYmUgdXNlZnVsIHRvIGF2b2lkIHJvdW5kLW9mZiBlcnJvcnMpLlxyXG4gIGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIHByZWNpc2lvbikge1xyXG4gIFx0aWYgKHByZWNpc2lvbiA9PT0gZmFsc2UpIHsgcmV0dXJuIG51bTsgfVxyXG4gIFx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IDYgOiBwcmVjaXNpb24pO1xyXG4gIFx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0cmltKHN0cjogU3RyaW5nKTogU3RyaW5nXHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbiAgZnVuY3Rpb24gdHJpbShzdHIpIHtcclxuICBcdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyOiBTdHJpbmcpOiBTdHJpbmdbXVxyXG4gIC8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuICBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cikge1xyXG4gIFx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiBzZXRPcHRpb25zKG9iaiwgb3B0aW9ucykge1xyXG4gIFx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnb3B0aW9ucycpKSB7XHJcbiAgXHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBjcmVhdGUkMihvYmoub3B0aW9ucykgOiB7fTtcclxuICBcdH1cclxuICBcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG4gIFx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbiAgLy8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG4gIC8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuICAvLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4gIC8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuICBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuICBcdHZhciBwYXJhbXMgPSBbXTtcclxuICBcdGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuICBcdH1cclxuICBcdHJldHVybiAoKCFleGlzdGluZ1VybCB8fCBleGlzdGluZ1VybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRlbXBsYXRlUmUgPSAvXFx7ICooW1xcd18gLV0rKSAqXFx9L2c7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0ZW1wbGF0ZShzdHI6IFN0cmluZywgZGF0YTogT2JqZWN0KTogU3RyaW5nXHJcbiAgLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbiAgLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuICAvLyBgKCdIZWxsbyBmb28sIGJhcicpYC4gWW91IGNhbiBhbHNvIHNwZWNpZnkgZnVuY3Rpb25zIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3JcclxuICAvLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHIsIGRhdGEpIHtcclxuICBcdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuICBcdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuICBcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdmFsdWU7XHJcbiAgXHR9KTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcclxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LnByb3RvdHlwZS5pbmRleE9mXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxyXG4gIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuICBcdH1cclxuICBcdHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuICAvLyBEYXRhIFVSSSBzdHJpbmcgY29udGFpbmluZyBhIGJhc2U2NC1lbmNvZGVkIGVtcHR5IEdJRiBpbWFnZS5cclxuICAvLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuICAvLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbiAgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4gIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuICBmdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcbiAgXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxuICB9XHJcblxyXG4gIHZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4gIC8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuICBmdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuICBcdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcbiAgXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuICBcdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcbiAgXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuICB2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuICBcdFx0Z2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbiAgLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4gIC8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcbiAgLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4gIC8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuICAvLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuICBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuICBcdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuICBcdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGJpbmQoZm4sIGNvbnRleHQpKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG4gIC8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG4gIGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xyXG4gIFx0aWYgKGlkKSB7XHJcbiAgXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcbiAgXHR9XHJcbiAgfVxuXG4gIHZhciBVdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBjcmVhdGU6IGNyZWF0ZSQyLFxuICAgIGJpbmQ6IGJpbmQsXG4gICAgZ2V0IGxhc3RJZCAoKSB7IHJldHVybiBsYXN0SWQ7IH0sXG4gICAgc3RhbXA6IHN0YW1wLFxuICAgIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgICB3cmFwTnVtOiB3cmFwTnVtLFxuICAgIGZhbHNlRm46IGZhbHNlRm4sXG4gICAgZm9ybWF0TnVtOiBmb3JtYXROdW0sXG4gICAgdHJpbTogdHJpbSxcbiAgICBzcGxpdFdvcmRzOiBzcGxpdFdvcmRzLFxuICAgIHNldE9wdGlvbnM6IHNldE9wdGlvbnMsXG4gICAgZ2V0UGFyYW1TdHJpbmc6IGdldFBhcmFtU3RyaW5nLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgZW1wdHlJbWFnZVVybDogZW1wdHlJbWFnZVVybCxcbiAgICByZXF1ZXN0Rm46IHJlcXVlc3RGbixcbiAgICBjYW5jZWxGbjogY2FuY2VsRm4sXG4gICAgcmVxdWVzdEFuaW1GcmFtZTogcmVxdWVzdEFuaW1GcmFtZSxcbiAgICBjYW5jZWxBbmltRnJhbWU6IGNhbmNlbEFuaW1GcmFtZVxuICB9O1xuXG4gIC8vIEBjbGFzcyBDbGFzc1xyXG4gIC8vIEBha2EgTC5DbGFzc1xyXG5cclxuICAvLyBAc2VjdGlvblxyXG4gIC8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4gIC8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuICBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG4gIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuICBcdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbiAgXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuICBcdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG4gIFx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzKTtcclxuXHJcbiAgXHRcdC8vIGNhbGwgdGhlIGNvbnN0cnVjdG9yXHJcbiAgXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuICBcdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuICBcdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcbiAgXHR9O1xyXG5cclxuICBcdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuICBcdHZhciBwcm90byA9IGNyZWF0ZSQyKHBhcmVudFByb3RvKTtcclxuICBcdHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG4gIFx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG4gIFx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcbiAgXHRmb3IgKHZhciBpIGluIHRoaXMpIHtcclxuICBcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG4gIFx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG4gIFx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuICBcdFx0ZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuICBcdH1cclxuXHJcbiAgXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcbiAgXHRpZiAocHJvcHMuaW5jbHVkZXMpIHtcclxuICBcdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG4gIFx0XHRleHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuICBcdH1cclxuXHJcbiAgXHQvLyBtaXggZ2l2ZW4gcHJvcGVydGllcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuICBcdGV4dGVuZChwcm90bywgcHJvcHMpO1xyXG4gIFx0ZGVsZXRlIHByb3RvLnN0YXRpY3M7XHJcbiAgXHRkZWxldGUgcHJvdG8uaW5jbHVkZXM7XHJcblxyXG4gIFx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG4gIFx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuICBcdFx0cHJvdG8ub3B0aW9ucyA9IHBhcmVudFByb3RvLm9wdGlvbnMgPyBjcmVhdGUkMihwYXJlbnRQcm90by5vcHRpb25zKSA6IHt9O1xyXG4gIFx0XHRleHRlbmQocHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuICBcdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcbiAgXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcbiAgXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcblxyXG4gIFx0cmV0dXJuIE5ld0NsYXNzO1xyXG4gIH07XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuICBDbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgXHR2YXIgcGFyZW50T3B0aW9ucyA9IHRoaXMucHJvdG90eXBlLm9wdGlvbnM7XHJcbiAgXHRleHRlbmQodGhpcy5wcm90b3R5cGUsIHByb3BzKTtcclxuICBcdGlmIChwcm9wcy5vcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMucHJvdG90eXBlLm9wdGlvbnMgPSBwYXJlbnRPcHRpb25zO1xyXG4gIFx0XHR0aGlzLm1lcmdlT3B0aW9ucyhwcm9wcy5vcHRpb25zKTtcclxuICBcdH1cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uczogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG4gIENsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRleHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4gIC8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXHJcbiAgQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG4gIFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuICBcdHZhciBpbml0ID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzID0gdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyB8fCBbXTtcclxuICBcdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcbiAgXHQvKiBnbG9iYWwgTDogdHJ1ZSAqL1xyXG4gIFx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcbiAgXHRpbmNsdWRlcyA9IGlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuICBcdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG4gIFx0XHRcdFx0J3BsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuJywgbmV3IEVycm9yKCkuc3RhY2spO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEV2ZW50ZWRcclxuICAgKiBAYWthIEwuRXZlbnRlZFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICAgKiB9ICk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAgICpcclxuICAgKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEV2ZW50cyA9IHtcclxuICBcdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbiAgXHQgKi9cclxuICBcdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuICBcdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcbiAgXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcbiAgXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuIFRoaXMgaW5jbHVkZXMgaW1wbGljaXRseSBhdHRhY2hlZCBldmVudHMuXHJcbiAgXHQgKi9cclxuICBcdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0XHR2YXIgcmVtb3ZlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdGlmIChyZW1vdmVBbGwpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldKTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG4gIFx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIF9vbmNlKSB7XHJcbiAgXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG4gIFx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG4gIFx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuICBcdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9O1xyXG4gIFx0XHRpZiAoX29uY2UpIHtcclxuICBcdFx0XHRuZXdMaXN0ZW5lci5vbmNlID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG4gIFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcbiAgXHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKG5ld0xpc3RlbmVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcbiAgXHRcdHZhciBsaXN0ZW5lcnMsXHJcbiAgXHRcdCAgICBpLFxyXG4gIFx0XHQgICAgbGVuO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IC8vIHJlbW92ZSBhbGxcclxuICBcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuICBcdFx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcFxyXG4gIFx0XHRcdFx0Ly8gc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcbiAgXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gZmFsc2VGbjtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBsaXN0ZW5lciB0eXBlOiAnICsgdHlwZW9mIGZuKTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG4gIFx0XHR2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KTtcclxuICBcdFx0aWYgKGluZGV4ICE9PSBmYWxzZSkge1xyXG4gIFx0XHRcdHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpbmRleF07XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcbiAgXHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcbiAgXHRcdFx0XHRsaXN0ZW5lci5mbiA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuICBcdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGRhdGFcclxuICBcdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcbiAgXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG4gIFx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgZXZlbnQgPSBleHRlbmQoe30sIGRhdGEsIHtcclxuICBcdFx0XHR0eXBlOiB0eXBlLFxyXG4gIFx0XHRcdHRhcmdldDogdGhpcyxcclxuICBcdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuICBcdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuICBcdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuICBcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcbiAgXHRcdFx0XHRcdC8vIG9mZiBvdmVyd3JpdGVzIGwuZm4sIHNvIHdlIG5lZWQgdG8gY29weSBmbiB0byBhIHZhclxyXG4gIFx0XHRcdFx0XHR2YXIgZm4gPSBsLmZuO1xyXG4gIFx0XHRcdFx0XHRpZiAobC5vbmNlKSB7XHJcbiAgXHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgZm4sIGwuY3R4KTtcclxuICBcdFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0XHRmbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuICBcdFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG4gIFx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcbiAgXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgcHJvcGFnYXRlPzogQm9vbGVhbik6IEJvb2xlYW5cclxuICBcdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG4gIFx0Ly8gVGhlIHZlcmlmaWNhdGlvbiBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkLCBpdCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgcGFyZW50cyBoYXZlIHRoZSBsaXN0ZW5lciBhdHRhY2hlZCB0byBpdC5cclxuICBcdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCwgcHJvcGFnYXRlKSB7XHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ1wic3RyaW5nXCIgdHlwZSBhcmd1bWVudCBleHBlY3RlZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIGlucHV0IGBmbmAgdmFsdWUsIGJlY2F1c2Ugd2UgbmVlZCB0byB1c2UgaXQgZm9yIHByb3BhZ2F0aW9uXHJcbiAgXHRcdHZhciBfZm4gPSBmbjtcclxuICBcdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdHByb3BhZ2F0ZSA9ICEhZm47XHJcbiAgXHRcdFx0X2ZuID0gdW5kZWZpbmVkO1xyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHtcclxuICBcdFx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBfZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAocHJvcGFnYXRlKSB7XHJcbiAgXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG4gIFx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG4gIFx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHJldHVybnMgdGhlIGluZGV4IChudW1iZXIpIG9yIGZhbHNlXHJcbiAgXHRfbGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG4gIFx0XHRpZiAoIWZuKSB7XHJcbiAgXHRcdFx0cmV0dXJuICEhbGlzdGVuZXJzLmxlbmd0aDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuICBcdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcbiAgXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuICBcdFx0XHRcdHJldHVybiBpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG4gIFx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcbiAgXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuICBcdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcbiAgXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbiwgdHJ1ZSk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcbiAgXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQsIHRydWUpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuICBcdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuICBcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW3N0YW1wKG9iaildID0gb2JqO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG4gIFx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV07XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgZXh0ZW5kKHtcclxuICBcdFx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuICBcdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxyXG4gIFx0XHRcdH0sIGUpLCB0cnVlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4gIC8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbiAgRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4gIC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbiAgLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG4gIEV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuICAvLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbiAgRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4gIC8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbiAgRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuICAvLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuICAvLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbiAgRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG4gIHZhciBFdmVudGVkID0gQ2xhc3MuZXh0ZW5kKEV2ZW50cyk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgUG9pbnRcclxuICAgKiBAYWthIEwuUG9pbnRcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICAgKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuICBcdC8vIEBwcm9wZXJ0eSB4OiBOdW1iZXI7IFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuICBcdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuICBcdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuICBcdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxuICB9XHJcblxyXG4gIHZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuICBcdHJldHVybiB2ID4gMCA/IE1hdGguZmxvb3IodikgOiBNYXRoLmNlaWwodik7XHJcbiAgfTtcclxuXHJcbiAgUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuICBcdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG4gIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuICBcdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG4gIFx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuICBcdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuICBcdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuICBcdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG4gIFx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHRoaXMueCAvPSBudW07XHJcbiAgXHRcdHRoaXMueSAvPSBudW07XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0dGhpcy54ICo9IG51bTtcclxuICBcdFx0dGhpcy55ICo9IG51bTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG4gIFx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuICBcdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcbiAgXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcbiAgXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcbiAgXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuICBcdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuICBcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuICBcdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG4gIFx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcbiAgXHR0cnVuYzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcbiAgXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuICBcdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuICBcdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuICBcdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgY3VycmVudCBwb2ludCBjb29yZGluYXRlcyAoaW4gYWJzb2x1dGUgdmFsdWVzKS5cclxuICBcdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcbiAgXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAnUG9pbnQoJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbiAgLy8gQ3JlYXRlcyBhIFBvaW50IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy4gSWYgb3B0aW9uYWwgYHJvdW5kYCBpcyBzZXQgdG8gdHJ1ZSwgcm91bmRzIHRoZSBgeGAgYW5kIGB5YCB2YWx1ZXMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuICAvLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCwgeV1gIGluc3RlYWQuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbiAgLy8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cclxuICBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcbiAgXHRpZiAoeCBpbnN0YW5jZW9mIFBvaW50KSB7XHJcbiAgXHRcdHJldHVybiB4O1xyXG4gIFx0fVxyXG4gIFx0aWYgKGlzQXJyYXkoeCkpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuICBcdH1cclxuICBcdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG4gIFx0XHRyZXR1cm4geDtcclxuICBcdH1cclxuICBcdGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQm91bmRzXHJcbiAgICogQGFrYSBMLkJvdW5kc1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcDEgPSBMLnBvaW50KDEwLCAxMCksXHJcbiAgICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAgICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIEJvdW5kcy5wcm90b3R5cGUgPSB7XHJcbiAgXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIG1pbjIsIG1heDI7XHJcbiAgXHRcdGlmICghb2JqKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgUG9pbnQgfHwgdHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgJ3gnIGluIG9iaikge1xyXG4gIFx0XHRcdG1pbjIgPSBtYXgyID0gdG9Qb2ludChvYmopO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcbiAgXHRcdFx0bWluMiA9IG9iai5taW47XHJcbiAgXHRcdFx0bWF4MiA9IG9iai5tYXg7XHJcblxyXG4gIFx0XHRcdGlmICghbWluMiB8fCAhbWF4MikgeyByZXR1cm4gdGhpczsgfVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG4gIFx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcbiAgXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcbiAgXHRcdFx0dGhpcy5taW4gPSBtaW4yLmNsb25lKCk7XHJcbiAgXHRcdFx0dGhpcy5tYXggPSBtYXgyLmNsb25lKCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKG1pbjIueCwgdGhpcy5taW4ueCk7XHJcbiAgXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KG1heDIueCwgdGhpcy5tYXgueCk7XHJcbiAgXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKG1pbjIueSwgdGhpcy5taW4ueSk7XHJcbiAgXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KG1heDIueSwgdGhpcy5tYXgueSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcbiAgXHRcdHJldHVybiB0b1BvaW50KFxyXG4gIFx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG4gIFx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuICBcdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubWluOyAvLyBsZWZ0LCB0b3BcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1heGBdKCNib3VuZHMtbWF4KSkuXHJcbiAgXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuICBcdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuICBcdFx0XHRtaW4gPSBvYmoubWluO1xyXG4gIFx0XHRcdG1heCA9IG9iai5tYXg7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcbiAgXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuICBcdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG4gIFx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcbiAgXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcbiAgXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcbiAgXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuICBcdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuICBcdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcbiAgXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcbiAgXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuICBcdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcbiAgXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcbiAgXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG4gIFx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG4gIFx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IEJvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG4gIFx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuICBcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG4gIFx0XHRtYXggPSB0aGlzLm1heCxcclxuICBcdFx0aGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMobWluLnggLSBtYXgueCkgKiBidWZmZXJSYXRpbyxcclxuICBcdFx0d2lkdGhCdWZmZXIgPSBNYXRoLmFicyhtaW4ueSAtIG1heC55KSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHJcbiAgXHRcdHJldHVybiB0b0JvdW5kcyhcclxuICBcdFx0XHR0b1BvaW50KG1pbi54IC0gaGVpZ2h0QnVmZmVyLCBtaW4ueSAtIHdpZHRoQnVmZmVyKSxcclxuICBcdFx0XHR0b1BvaW50KG1heC54ICsgaGVpZ2h0QnVmZmVyLCBtYXgueSArIHdpZHRoQnVmZmVyKSk7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBib3VuZHMuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMubWluLmVxdWFscyhib3VuZHMuZ2V0VG9wTGVmdCgpKSAmJlxyXG4gIFx0XHRcdHRoaXMubWF4LmVxdWFscyhib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKSk7XHJcbiAgXHR9LFxyXG4gIH07XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbiAgLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29ybmVycyBjb29yZGluYXRlIHBhaXJzLlxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuICAvLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG4gIFx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IEJvdW5kcyhhLCBiKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAgICogQGFrYSBMLkxhdExuZ0JvdW5kc1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gICAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gICAqIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcC5maXRCb3VuZHMoW1xyXG4gICAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAgICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gICAqIF0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQ2F1dGlvbjogaWYgdGhlIGFyZWEgY3Jvc3NlcyB0aGUgYW50aW1lcmlkaWFuIChvZnRlbiBjb25mdXNlZCB3aXRoIHRoZSBJbnRlcm5hdGlvbmFsIERhdGUgTGluZSksIHlvdSBtdXN0IHNwZWNpZnkgY29ybmVycyBfb3V0c2lkZV8gdGhlIFstMTgwLCAxODBdIGRlZ3JlZXMgbG9uZ2l0dWRlIHJhbmdlLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIExhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG4gIFx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuICBcdHZhciBsYXRsbmdzID0gY29ybmVyMiA/IFtjb3JuZXIxLCBjb3JuZXIyXSA6IGNvcm5lcjE7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBMYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuICBcdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZykge1xyXG4gIFx0XHRcdHN3MiA9IG9iajtcclxuICBcdFx0XHRuZTIgPSBvYmo7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG4gIFx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuICBcdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuICBcdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG4gIFx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuICBcdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG4gIFx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcbiAgXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuICBcdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG4gIFx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcclxuICBcdFx0ICAgICAgICBuZXcgTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG4gIFx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG4gIFx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG4gIFx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubG5nICsgdGhpcy5fbm9ydGhFYXN0LmxuZykgLyAyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aFdlc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc291dGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuICBcdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIExhdExuZyB8fCAnbGF0JyBpbiBvYmopIHtcclxuICBcdFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9iaiA9IHRvTGF0TG5nQm91bmRzKG9iaik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG4gIFx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuICBcdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcbiAgXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuICBcdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcbiAgXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG4gIFx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcbiAgXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG4gIFx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuICBcdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuICBcdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcbiAgXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuICBcdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG4gIFx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIG1heE1hcmdpbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuICBcdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGNvcm5lcjE6IExhdExuZywgY29ybmVyMjogTGF0TG5nKVxyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbiAgZnVuY3Rpb24gdG9MYXRMbmdCb3VuZHMoYSwgYikge1xyXG4gIFx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxuICB9XG5cbiAgLyogQGNsYXNzIExhdExuZ1xyXG4gICAqIEBha2EgTC5MYXRMbmdcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCBhIGNlcnRhaW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gICAqIG1hcC5wYW5Ubyh7bG9uOiAzMCwgbGF0OiA1MH0pO1xyXG4gICAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gICAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcsIGFsdCkge1xyXG4gIFx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuICBcdH1cclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuICBcdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuICBcdHRoaXMubGF0ID0gK2xhdDtcclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuICBcdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcbiAgXHR0aGlzLmxuZyA9ICtsbmc7XHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcbiAgXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG4gIFx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIExhdExuZy5wcm90b3R5cGUgPSB7XHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYExhdExuZ2AgcG9pbnQgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcbiAgXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuXHJcbiAgXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuICBcdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMubG5nLCBwcmVjaXNpb24pICsgJyknO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgKGluIG1ldGVycykgdG8gdGhlIGdpdmVuIGBMYXRMbmdgIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIFtTcGhlcmljYWwgTGF3IG9mIENvc2luZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9sYXdfb2ZfY29zaW5lcykuXHJcbiAgXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuICBcdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG4gIFx0d3JhcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b0JvdW5kcyhzaXplSW5NZXRlcnM6IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuICBcdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcbiAgXHRcdHZhciBsYXRBY2N1cmFjeSA9IDE4MCAqIHNpemVJbk1ldGVycyAvIDQwMDc1MDE3LFxyXG4gIFx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcbiAgXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuICBcdFx0ICAgICAgICBbdGhpcy5sYXQgLSBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgLSBsbmdBY2N1cmFjeV0sXHJcbiAgXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbiAgLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuICAvLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG4gIGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuICBcdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0aWYgKGlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG4gIFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG4gIFx0XHRcdHJldHVybiBuZXcgTGF0TG5nKGFbMF0sIGFbMV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG4gIFx0fVxyXG4gIFx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5CYXNlXHJcbiAgICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAgICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICAgKiBjb29yZGluYXRlcyBpbiBvdGhlciB1bml0cyBmb3IgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuIFNlZVxyXG4gICAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwYXRpYWxfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gICAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICAgKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcclxuICAgKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgdmFyIENSUyA9IHtcclxuICBcdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIGdpdmVuIHpvb20uXHJcbiAgXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcbiAgXHRcdCAgICBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG4gIFx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcbiAgXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG4gIFx0cG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdCh1bnRyYW5zZm9ybWVkUG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gY29vcmRpbmF0ZXMgaW4gdW5pdHMgYWNjZXB0ZWQgZm9yXHJcbiAgXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBwcm9qZWN0ZWQgY29vcmRpbmF0ZSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIExhdExuZy5cclxuICBcdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHNjYWxlIHVzZWQgd2hlbiB0cmFuc2Zvcm1pbmcgcHJvamVjdGVkIGNvb3JkaW5hdGVzIGludG9cclxuICBcdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuICBcdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcbiAgXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHpvb20oc2NhbGU6IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcbiAgXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuICBcdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xyXG4gIFx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UHJvamVjdGVkQm91bmRzKHpvb206IE51bWJlcik6IEJvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG4gIFx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRpZiAodGhpcy5pbmZpbml0ZSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuICBcdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG4gIFx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICBtaW4gPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1pbiwgcyksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgY29kZTogU3RyaW5nXHJcbiAgXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuICBcdC8vXHJcbiAgXHQvLyBAcHJvcGVydHkgd3JhcExuZzogTnVtYmVyW11cclxuICBcdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuICBcdC8vIGdlb2dyYXBoaWNhbCBDUlNzLiBJZiBgdW5kZWZpbmVkYCwgdGhlIGxvbmdpdHVkZSBheGlzIGRvZXMgbm90IHdyYXAgYXJvdW5kLlxyXG4gIFx0Ly9cclxuICBcdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG4gIFx0Ly8gTGlrZSBgd3JhcExuZ2AsIGJ1dCBmb3IgdGhlIGxhdGl0dWRlICh2ZXJ0aWNhbCkgYXhpcy5cclxuXHJcbiAgXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG4gIFx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgaW5maW5pdGU6IEJvb2xlYW5cclxuICBcdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcbiAgXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcbiAgXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyB3cmFwTnVtKGxhdGxuZy5sbmcsIHRoaXMud3JhcExuZywgdHJ1ZSkgOiBsYXRsbmcubG5nLFxyXG4gIFx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gd3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdCxcclxuICBcdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcbiAgXHQvLyB0aGF0IGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHR2YXIgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcbiAgXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG4gIFx0XHQgICAgbG5nU2hpZnQgPSBjZW50ZXIubG5nIC0gbmV3Q2VudGVyLmxuZztcclxuXHJcbiAgXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG4gIFx0XHRcdHJldHVybiBib3VuZHM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuICBcdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG4gIFx0XHQgICAgbmV3U3cgPSBuZXcgTGF0TG5nKHN3LmxhdCAtIGxhdFNoaWZ0LCBzdy5sbmcgLSBsbmdTaGlmdCksXHJcbiAgXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcbiAgXHR9XHJcbiAgfTtcblxuICAvKlxuICAgKiBAbmFtZXNwYWNlIENSU1xuICAgKiBAY3JzIEwuQ1JTLkVhcnRoXG4gICAqXG4gICAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gICAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gICAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICAgKiBtZXRlcnMuXG4gICAqL1xuXG4gIHZhciBFYXJ0aCA9IGV4dGVuZCh7fSwgQ1JTLCB7XG4gIFx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cbiAgXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuICBcdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG4gIFx0Ly8gc2VlIGh0dHBzOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcbiAgXHRSOiA2MzcxMDAwLFxuXG4gIFx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuICBcdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG4gIFx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuICBcdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcbiAgXHRcdCAgICBzaW5ETGF0ID0gTWF0aC5zaW4oKGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQpICogcmFkIC8gMiksXG4gIFx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuICBcdFx0ICAgIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBzaW5ETG9uICogc2luRExvbixcbiAgXHRcdCAgICBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3JcclxuICAgKlxyXG4gICAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAgICogdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpc1xyXG4gICAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAgICovXHJcblxyXG4gIHZhciBlYXJ0aFJhZGl1cyA9IDYzNzgxMzc7XHJcblxyXG4gIHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcbiAgXHRSOiBlYXJ0aFJhZGl1cyxcclxuICBcdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG4gIFx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcbiAgXHRcdCAgICBzaW4gPSBNYXRoLnNpbihsYXQgKiBkKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcbiAgXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcbiAgXHRcdFx0dGhpcy5SICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIDIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuICBcdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcbiAgXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBkID0gZWFydGhSYWRpdXMgKiBNYXRoLlBJO1xyXG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuICBcdH0pKClcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXHJcbiAgICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjogYSBzZXQgb2YgY29lZmZpY2llbnRzIGBhYCwgYGJgLCBgY2AsIGBkYFxyXG4gICAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICAgKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gICAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAgICogXHRwMiA9IHRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShwKSwgLy8gIEwucG9pbnQoNywgOClcclxuICAgKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuXHJcbiAgLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbiAgLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcbiAgXHRpZiAoaXNBcnJheShhKSkge1xyXG4gIFx0XHQvLyB1c2UgYXJyYXkgcHJvcGVydGllc1xyXG4gIFx0XHR0aGlzLl9hID0gYVswXTtcclxuICBcdFx0dGhpcy5fYiA9IGFbMV07XHJcbiAgXHRcdHRoaXMuX2MgPSBhWzJdO1xyXG4gIFx0XHR0aGlzLl9kID0gYVszXTtcclxuICBcdFx0cmV0dXJuO1xyXG4gIFx0fVxyXG4gIFx0dGhpcy5fYSA9IGE7XHJcbiAgXHR0aGlzLl9iID0gYjtcclxuICBcdHRoaXMuX2MgPSBjO1xyXG4gIFx0dGhpcy5fZCA9IGQ7XHJcbiAgfVxyXG5cclxuICBUcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgXHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuICBcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuICBcdHRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcclxuICBcdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGRlc3RydWN0aXZlIHRyYW5zZm9ybSAoZmFzdGVyKVxyXG4gIFx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG4gIFx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcbiAgXHRcdHBvaW50LnggPSBzY2FsZSAqICh0aGlzLl9hICogcG9pbnQueCArIHRoaXMuX2IpO1xyXG4gIFx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuICBcdFx0cmV0dXJuIHBvaW50O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG4gIFx0Ly8gYnkgdGhlIGdpdmVuIHNjYWxlLiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG4gIFx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcbiAgXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuICBcdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGNvZWZmaWNpZW50czogQXJyYXkpOiBUcmFuc2Zvcm1hdGlvblxyXG4gIC8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbiAgLy8gYFthOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXJdYC5cclxuXHJcbiAgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gICAqXHJcbiAgICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAgICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAgICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gICAqL1xyXG5cclxuICB2YXIgRVBTRzM4NTcgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzozODU3JyxcclxuICBcdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuICBcdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG4gIFx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcbiAgXHR9KCkpXHJcbiAgfSk7XHJcblxyXG4gIHZhciBFUFNHOTAwOTEzID0gZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG4gIFx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG4gIH0pO1xuXG4gIC8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuICAvLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuXG4gIC8vIEBmdW5jdGlvbiBjcmVhdGUobmFtZTogU3RyaW5nKTogU1ZHRWxlbWVudFxuICAvLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbiAgLy8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cbiAgLy8gYW4gaW5zdGFuY2Ugb2YgW1NWR0xpbmVFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHTGluZUVsZW1lbnQpLlxuICBmdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuICBcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG4gIH1cblxuICAvLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbiAgLy8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuICAvLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG4gIGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG4gIFx0dmFyIHN0ciA9ICcnLFxuICBcdGksIGosIGxlbiwgbGVuMiwgcG9pbnRzLCBwO1xuXG4gIFx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG4gIFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICBcdFx0XHRwID0gcG9pbnRzW2pdO1xuICBcdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuICBcdFx0fVxuXG4gIFx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG4gIFx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuICBcdH1cblxuICBcdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG4gIFx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG4gIH1cblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gICAqIEBha2EgTC5Ccm93c2VyXHJcbiAgICpcclxuICAgKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gICAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuICAvLyBAcHJvcGVydHkgaWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIChub3QgRWRnZSkuXHJcbiAgdmFyIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbiAgLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG4gIHZhciBpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuICAvLyBAcHJvcGVydHkgZWRnZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgRWRnZSB3ZWIgYnJvd3Nlci5cclxuICB2YXIgZWRnZSA9ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuO1xyXG4gIC8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG4gIHZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbiAgLy8gKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG4gIHZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgYnJvd3NlcnMgcnVubmluZyBvbiBBbmRyb2lkIDIgb3IgQW5kcm9pZCAzLlxyXG4gIHZhciBhbmRyb2lkMjMgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAyJykgfHwgdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMycpO1xyXG5cclxuICAvKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbiAgdmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxyXG4gIC8vIEBwcm9wZXJ0eSBhbmRyb2lkU3RvY2s6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxuICB2YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbiAgdmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG4gIHZhciBjaHJvbWUgPSAhZWRnZSAmJiB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbiAgdmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuICAvLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxuICB2YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG4gIHZhciBwaGFudG9tID0gdXNlckFnZW50Q29udGFpbnMoJ3BoYW50b20nKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG4gIHZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuICB2YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuICAvLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gc3R5bGUpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQzZDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgbW9iaWxlV2Via2l0M2QgPSBtb2JpbGUgJiYgd2Via2l0M2Q7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuICB2YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuICAvLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cclxuICB2YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHRvdWNoTmF0aXZlOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbdG91Y2ggZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzKS5cclxuICAvLyAqKlRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbioqIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuICAvLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbiAgLy8gdG91Y2ggZXZlbnRzLlxyXG4gIHZhciB0b3VjaE5hdGl2ZSA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCAhIXdpbmRvdy5Ub3VjaEV2ZW50O1xyXG5cclxuICAvLyBAcHJvcGVydHkgdG91Y2g6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIGVpdGhlciBbdG91Y2hdKCNicm93c2VyLXRvdWNoKSBvciBbcG9pbnRlcl0oI2Jyb3dzZXItcG9pbnRlcikgZXZlbnRzLlxyXG4gIC8vIE5vdGU6IHBvaW50ZXIgZXZlbnRzIHdpbGwgYmUgcHJlZmVycmVkIChpZiBhdmFpbGFibGUpLCBhbmQgcHJvY2Vzc2VkIGZvciBhbGwgYHRvdWNoKmAgbGlzdGVuZXJzLlxyXG4gIHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAodG91Y2hOYXRpdmUgfHwgcG9pbnRlcik7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbiAgLy8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4gb3Igb24gYW55IHNjcmVlbiB3aGVuIGJyb3dzZXIncyBkaXNwbGF5IHpvb20gaXMgbW9yZSB0aGFuIDEwMCUuXHJcbiAgdmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHBhc3NpdmVFdmVudHM6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBwYXNzaXZlIGV2ZW50cy5cclxuICB2YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgXHR2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XHJcbiAgXHR0cnkge1xyXG4gIFx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcbiAgXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2V0dGVyLXJldHVyblxyXG4gIFx0XHRcdFx0c3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0pO1xyXG4gIFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBmYWxzZUZuLCBvcHRzKTtcclxuICBcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgZmFsc2VGbiwgb3B0cyk7XHJcbiAgXHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdC8vIEVycm9ycyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgc2luY2UgdGhpcyBpcyBvbmx5IGEgYnJvd3NlciBzdXBwb3J0IHRlc3QuXHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gc3VwcG9ydHNQYXNzaXZlT3B0aW9uO1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxyXG4gIHZhciBjYW52YXMkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG4gIH0oKSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBzdmc6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG4gIHZhciBzdmckMSA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBzdmdDcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xyXG5cclxuICB2YXIgaW5saW5lU3ZnID0gISFzdmckMSAmJiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIFx0ZGl2LmlubmVySFRNTCA9ICc8c3ZnLz4nO1xyXG4gIFx0cmV0dXJuIChkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkpID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG4gIH0pKCk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB2bWw6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbiAgdmFyIHZtbCA9ICFzdmckMSAmJiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0dHJ5IHtcclxuICBcdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIFx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcbiAgXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG4gIFx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XHJcblxyXG4gIFx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcbiAgXHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuICBcdH1cclxuICB9KCkpO1xyXG5cclxuXHJcbiAgLy8gQHByb3BlcnR5IG1hYzogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIE1hYyBwbGF0Zm9ybVxyXG4gIHZhciBtYWMgPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTWFjJykgPT09IDA7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBMaW51eCBwbGF0Zm9ybVxyXG4gIHZhciBsaW51eCA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdMaW51eCcpID09PSAwO1xyXG5cclxuICBmdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuICBcdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgdmFyIEJyb3dzZXIgPSB7XHJcbiAgXHRpZTogaWUsXHJcbiAgXHRpZWx0OTogaWVsdDksXHJcbiAgXHRlZGdlOiBlZGdlLFxyXG4gIFx0d2Via2l0OiB3ZWJraXQsXHJcbiAgXHRhbmRyb2lkOiBhbmRyb2lkLFxyXG4gIFx0YW5kcm9pZDIzOiBhbmRyb2lkMjMsXHJcbiAgXHRhbmRyb2lkU3RvY2s6IGFuZHJvaWRTdG9jayxcclxuICBcdG9wZXJhOiBvcGVyYSxcclxuICBcdGNocm9tZTogY2hyb21lLFxyXG4gIFx0Z2Vja286IGdlY2tvLFxyXG4gIFx0c2FmYXJpOiBzYWZhcmksXHJcbiAgXHRwaGFudG9tOiBwaGFudG9tLFxyXG4gIFx0b3BlcmExMjogb3BlcmExMixcclxuICBcdHdpbjogd2luLFxyXG4gIFx0aWUzZDogaWUzZCxcclxuICBcdHdlYmtpdDNkOiB3ZWJraXQzZCxcclxuICBcdGdlY2tvM2Q6IGdlY2tvM2QsXHJcbiAgXHRhbnkzZDogYW55M2QsXHJcbiAgXHRtb2JpbGU6IG1vYmlsZSxcclxuICBcdG1vYmlsZVdlYmtpdDogbW9iaWxlV2Via2l0LFxyXG4gIFx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZVdlYmtpdDNkLFxyXG4gIFx0bXNQb2ludGVyOiBtc1BvaW50ZXIsXHJcbiAgXHRwb2ludGVyOiBwb2ludGVyLFxyXG4gIFx0dG91Y2g6IHRvdWNoLFxyXG4gIFx0dG91Y2hOYXRpdmU6IHRvdWNoTmF0aXZlLFxyXG4gIFx0bW9iaWxlT3BlcmE6IG1vYmlsZU9wZXJhLFxyXG4gIFx0bW9iaWxlR2Vja286IG1vYmlsZUdlY2tvLFxyXG4gIFx0cmV0aW5hOiByZXRpbmEsXHJcbiAgXHRwYXNzaXZlRXZlbnRzOiBwYXNzaXZlRXZlbnRzLFxyXG4gIFx0Y2FudmFzOiBjYW52YXMkMSxcclxuICBcdHN2Zzogc3ZnJDEsXHJcbiAgXHR2bWw6IHZtbCxcclxuICBcdGlubGluZVN2ZzogaW5saW5lU3ZnLFxyXG4gIFx0bWFjOiBtYWMsXHJcbiAgXHRsaW51eDogbGludXhcclxuICB9O1xuXG4gIC8qXG4gICAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gICAqL1xuXG4gIHZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbiAgdmFyIFBPSU5URVJfVVAgPSAgICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xuICB2YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xuICB2YXIgcEV2ZW50ID0ge1xuICBcdHRvdWNoc3RhcnQgIDogUE9JTlRFUl9ET1dOLFxuICBcdHRvdWNobW92ZSAgIDogUE9JTlRFUl9NT1ZFLFxuICBcdHRvdWNoZW5kICAgIDogUE9JTlRFUl9VUCxcbiAgXHR0b3VjaGNhbmNlbCA6IFBPSU5URVJfQ0FOQ0VMXG4gIH07XG4gIHZhciBoYW5kbGUgPSB7XG4gIFx0dG91Y2hzdGFydCAgOiBfb25Qb2ludGVyU3RhcnQsXG4gIFx0dG91Y2htb3ZlICAgOiBfaGFuZGxlUG9pbnRlcixcbiAgXHR0b3VjaGVuZCAgICA6IF9oYW5kbGVQb2ludGVyLFxuICBcdHRvdWNoY2FuY2VsIDogX2hhbmRsZVBvaW50ZXJcbiAgfTtcbiAgdmFyIF9wb2ludGVycyA9IHt9O1xuICB2YXIgX3BvaW50ZXJEb2NMaXN0ZW5lciA9IGZhbHNlO1xuXG4gIC8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbiAgLy8gcmVmIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbiAgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuICBcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgXHRcdF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKTtcbiAgXHR9XG4gIFx0aWYgKCFoYW5kbGVbdHlwZV0pIHtcbiAgXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuICBcdFx0cmV0dXJuIGZhbHNlRm47XG4gIFx0fVxuICBcdGhhbmRsZXIgPSBoYW5kbGVbdHlwZV0uYmluZCh0aGlzLCBoYW5kbGVyKTtcbiAgXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcbiAgXHRyZXR1cm4gaGFuZGxlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcbiAgXHRpZiAoIXBFdmVudFt0eXBlXSkge1xuICBcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBldmVudCBzcGVjaWZpZWQ6JywgdHlwZSk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuICBcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcbiAgXHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyTW92ZShlKSB7XG4gIFx0aWYgKF9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcbiAgXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuICBcdGRlbGV0ZSBfcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpIHtcbiAgXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cbiAgXHRpZiAoIV9wb2ludGVyRG9jTGlzdGVuZXIpIHtcbiAgXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBfZ2xvYmFsUG9pbnRlckRvd24sIHRydWUpO1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIF9nbG9iYWxQb2ludGVyTW92ZSwgdHJ1ZSk7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cbiAgXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYW5kbGVQb2ludGVyKGhhbmRsZXIsIGUpIHtcbiAgXHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gKGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgJ21vdXNlJykpIHsgcmV0dXJuOyB9XG5cbiAgXHRlLnRvdWNoZXMgPSBbXTtcbiAgXHRmb3IgKHZhciBpIGluIF9wb2ludGVycykge1xuICBcdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcbiAgXHR9XG4gIFx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuICBcdGhhbmRsZXIoZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfb25Qb2ludGVyU3RhcnQoaGFuZGxlciwgZSkge1xuICBcdC8vIElFMTAgc3BlY2lmaWM6IE1zVG91Y2ggbmVlZHMgcHJldmVudERlZmF1bHQuIFNlZSAjMjAwMFxuICBcdGlmIChlLk1TUE9JTlRFUl9UWVBFX1RPVUNIICYmIGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0gpIHtcbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdH1cbiAgXHRfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gICAqXHJcbiAgICogTm90ZTogY3VycmVudGx5IG1vc3QgYnJvd3NlcnMgZmlyZSBuYXRpdmUgZGJsY2xpY2ssIHdpdGggb25seSBhIGZldyBleGNlcHRpb25zXHJcbiAgICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy83MDEyI2lzc3VlY29tbWVudC01OTUwODczODYpXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIG1ha2VEYmxjbGljayhldmVudCkge1xyXG4gIFx0Ly8gaW4gbW9kZXJuIGJyb3dzZXJzIGB0eXBlYCBjYW5ub3QgYmUganVzdCBvdmVycmlkZGVuOlxyXG4gIFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0dldHRlcl9vbmx5XHJcbiAgXHR2YXIgbmV3RXZlbnQgPSB7fSxcclxuICBcdCAgICBwcm9wLCBpO1xyXG4gIFx0Zm9yIChpIGluIGV2ZW50KSB7XHJcbiAgXHRcdHByb3AgPSBldmVudFtpXTtcclxuICBcdFx0bmV3RXZlbnRbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZChldmVudCkgOiBwcm9wO1xyXG4gIFx0fVxyXG4gIFx0ZXZlbnQgPSBuZXdFdmVudDtcclxuICBcdG5ld0V2ZW50LnR5cGUgPSAnZGJsY2xpY2snO1xyXG4gIFx0bmV3RXZlbnQuZGV0YWlsID0gMjtcclxuICBcdG5ld0V2ZW50LmlzVHJ1c3RlZCA9IGZhbHNlO1xyXG4gIFx0bmV3RXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7IC8vIGZvciBkZWJ1ZyBwdXJwb3Nlc1xyXG4gIFx0cmV0dXJuIG5ld0V2ZW50O1xyXG4gIH1cclxuXHJcbiAgdmFyIGRlbGF5ID0gMjAwO1xyXG4gIGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcikge1xyXG4gIFx0Ly8gTW9zdCBicm93c2VycyBoYW5kbGUgZG91YmxlIHRhcCBuYXRpdmVseVxyXG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcik7XHJcblxyXG4gIFx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIG5hdGl2ZSBkYmxjbGlja3MgZm9yIHRvdWNoIGV2ZW50cy5cclxuICBcdC8vIEl0IHNlZW1zIHRoYXQgaW4gYWxsIHN1Y2ggY2FzZXMgYGRldGFpbGAgcHJvcGVydHkgb2YgYGNsaWNrYCBldmVudCBpcyBhbHdheXMgYDFgLlxyXG4gIFx0Ly8gU28gaGVyZSB3ZSByZWx5IG9uIHRoYXQgZmFjdCB0byBhdm9pZCBleGNlc3NpdmUgJ2RibGNsaWNrJyBzaW11bGF0aW9uIHdoZW4gbm90IG5lZWRlZC5cclxuICBcdHZhciBsYXN0ID0gMCxcclxuICBcdCAgICBkZXRhaWw7XHJcbiAgXHRmdW5jdGlvbiBzaW1EYmxjbGljayhlKSB7XHJcbiAgXHRcdGlmIChlLmRldGFpbCAhPT0gMSkge1xyXG4gIFx0XHRcdGRldGFpbCA9IGUuZGV0YWlsOyAvLyBrZWVwIGluIHN5bmMgdG8gYXZvaWQgZmFsc2UgZGJsY2xpY2sgaW4gc29tZSBjYXNlc1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHxcclxuICBcdFx0XHQoZS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgIWUuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpKSB7XHJcblxyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gV2hlbiBjbGlja2luZyBvbiBhbiA8aW5wdXQ+LCB0aGUgYnJvd3NlciBnZW5lcmF0ZXMgYSBjbGljayBvbiBpdHNcclxuICBcdFx0Ly8gPGxhYmVsPiAoYW5kIHZpY2UgdmVyc2EpIHRyaWdnZXJpbmcgdHdvIGNsaWNrcyBpbiBxdWljayBzdWNjZXNzaW9uLlxyXG4gIFx0XHQvLyBUaGlzIGlnbm9yZXMgY2xpY2tzIG9uIGVsZW1lbnRzIHdoaWNoIGFyZSBhIGxhYmVsIHdpdGggYSAnZm9yJ1xyXG4gIFx0XHQvLyBhdHRyaWJ1dGUgKG9yIGNoaWxkcmVuIG9mIHN1Y2ggYSBsYWJlbCksIGJ1dCBub3QgY2hpbGRyZW4gb2ZcclxuICBcdFx0Ly8gYSA8aW5wdXQ+LlxyXG4gIFx0XHR2YXIgcGF0aCA9IGdldFByb3BhZ2F0aW9uUGF0aChlKTtcclxuICBcdFx0aWYgKHBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuICBcdFx0XHRyZXR1cm4gZWwgaW5zdGFuY2VvZiBIVE1MTGFiZWxFbGVtZW50ICYmIGVsLmF0dHJpYnV0ZXMuZm9yO1xyXG4gIFx0XHR9KSAmJlxyXG4gIFx0XHRcdCFwYXRoLnNvbWUoZnVuY3Rpb24gKGVsKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gKFxyXG4gIFx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHxcclxuICBcdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudFxyXG4gIFx0XHRcdFx0KTtcclxuICBcdFx0XHR9KVxyXG4gIFx0XHQpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBub3cgPSBEYXRlLm5vdygpO1xyXG4gIFx0XHRpZiAobm93IC0gbGFzdCA8PSBkZWxheSkge1xyXG4gIFx0XHRcdGRldGFpbCsrO1xyXG4gIFx0XHRcdGlmIChkZXRhaWwgPT09IDIpIHtcclxuICBcdFx0XHRcdGhhbmRsZXIobWFrZURibGNsaWNrKGUpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZGV0YWlsID0gMTtcclxuICBcdFx0fVxyXG4gIFx0XHRsYXN0ID0gbm93O1xyXG4gIFx0fVxyXG5cclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNpbURibGNsaWNrKTtcclxuXHJcbiAgXHRyZXR1cm4ge1xyXG4gIFx0XHRkYmxjbGljazogaGFuZGxlcixcclxuICBcdFx0c2ltRGJsY2xpY2s6IHNpbURibGNsaWNrXHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVycykge1xyXG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcnMuZGJsY2xpY2spO1xyXG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcnMuc2ltRGJsY2xpY2spO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gICAqXHJcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gICAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqXHJcbiAgICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gICAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICAgKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuICAvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuICB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcbiAgXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4gIC8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuICAvLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbiAgLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbiAgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuICBcdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbiAgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuICBcdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuICAvLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG4gIGZ1bmN0aW9uIGdldChpZCkge1xyXG4gIFx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4gIC8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuICBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuICBcdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuICBcdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcbiAgXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuICBcdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuICBcdH1cclxuICBcdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG4gIGZ1bmN0aW9uIGNyZWF0ZSQxKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcbiAgXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIFx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuICBcdGlmIChjb250YWluZXIpIHtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuICBcdH1cclxuICBcdHJldHVybiBlbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG4gIGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50KSB7XHJcbiAgXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuICBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG4gIFx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuICBcdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuICBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuICBcdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuICBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuICBcdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcbiAgXHR9XHJcbiAgXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG4gIFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHZhciBjbGFzc2VzID0gc3BsaXRXb3JkcyhuYW1lKTtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuICBcdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuICBcdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHNldENsYXNzKGVsLCB0cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuICBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuICBcdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4gIC8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuICBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG4gIFx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuICBcdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuICBcdGlmIChlbC5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xyXG4gIFx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4gIC8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4gIC8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuICBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG4gIFx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG4gIFx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcbiAgXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcbiAgXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcbiAgXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcbiAgXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG4gIFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcbiAgXHR0cnkge1xyXG4gIFx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcbiAgXHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG4gIFx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG4gIFx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcbiAgXHRpZiAoZmlsdGVyKSB7XHJcbiAgXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG4gIFx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuICAvLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbiAgLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuICAvLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuICBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG4gIFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbiAgLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuICAvLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbiAgLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcbiAgXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcbiAgXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuICBcdFx0KEJyb3dzZXIuaWUzZCA/XHJcbiAgXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG4gIFx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG4gIFx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuICAvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4gIC8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbiAgLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG4gIGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuICBcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG4gIFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuICBcdGlmIChCcm93c2VyLmFueTNkKSB7XHJcbiAgXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG4gIFx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4gIC8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuICBcdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG4gIFx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcbiAgXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbiAgLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4gIC8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuICAvLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4gIC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuICB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbiAgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbiAgdmFyIF91c2VyU2VsZWN0O1xyXG4gIGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuICBcdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRvbih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdH07XHJcbiAgXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRvZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHR9O1xyXG4gIH0gZWxzZSB7XHJcbiAgXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcbiAgXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuICBcdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcbiAgXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG4gIFx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuICBcdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG4gIFx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gIFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcbiAgXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbiAgLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4gIC8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcbiAgXHRvbih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuICBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcbiAgXHRvZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuICAvLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbiAgLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuICAvLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbiAgLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG4gIGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuICBcdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG4gIFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIFx0fVxyXG4gIFx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG4gIFx0cmVzdG9yZU91dGxpbmUoKTtcclxuICBcdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGU7XHJcbiAgXHRlbGVtZW50LnN0eWxlLm91dGxpbmVTdHlsZSA9ICdub25lJztcclxuICBcdG9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKVxyXG4gIC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbiAgZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKSB7XHJcbiAgXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuICBcdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSBfb3V0bGluZVN0eWxlO1xyXG4gIFx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gIFx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuICBcdG9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG4gIGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcbiAgXHRkbyB7XHJcbiAgXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuICBcdHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4gIC8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbiAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbiAgLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbiAgZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xyXG4gIFx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdHg6IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEsXHJcbiAgXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuICBcdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcbiAgXHR9O1xyXG4gIH1cblxuICB2YXIgRG9tVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgVFJBTlNGT1JNOiBUUkFOU0ZPUk0sXG4gICAgVFJBTlNJVElPTjogVFJBTlNJVElPTixcbiAgICBUUkFOU0lUSU9OX0VORDogVFJBTlNJVElPTl9FTkQsXG4gICAgZ2V0OiBnZXQsXG4gICAgZ2V0U3R5bGU6IGdldFN0eWxlLFxuICAgIGNyZWF0ZTogY3JlYXRlJDEsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgZW1wdHk6IGVtcHR5LFxuICAgIHRvRnJvbnQ6IHRvRnJvbnQsXG4gICAgdG9CYWNrOiB0b0JhY2ssXG4gICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG4gICAgc2V0Q2xhc3M6IHNldENsYXNzLFxuICAgIGdldENsYXNzOiBnZXRDbGFzcyxcbiAgICBzZXRPcGFjaXR5OiBzZXRPcGFjaXR5LFxuICAgIHRlc3RQcm9wOiB0ZXN0UHJvcCxcbiAgICBzZXRUcmFuc2Zvcm06IHNldFRyYW5zZm9ybSxcbiAgICBzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG4gICAgZ2V0UG9zaXRpb246IGdldFBvc2l0aW9uLFxuICAgIGdldCBkaXNhYmxlVGV4dFNlbGVjdGlvbiAoKSB7IHJldHVybiBkaXNhYmxlVGV4dFNlbGVjdGlvbjsgfSxcbiAgICBnZXQgZW5hYmxlVGV4dFNlbGVjdGlvbiAoKSB7IHJldHVybiBlbmFibGVUZXh0U2VsZWN0aW9uOyB9LFxuICAgIGRpc2FibGVJbWFnZURyYWc6IGRpc2FibGVJbWFnZURyYWcsXG4gICAgZW5hYmxlSW1hZ2VEcmFnOiBlbmFibGVJbWFnZURyYWcsXG4gICAgcHJldmVudE91dGxpbmU6IHByZXZlbnRPdXRsaW5lLFxuICAgIHJlc3RvcmVPdXRsaW5lOiByZXN0b3JlT3V0bGluZSxcbiAgICBnZXRTaXplZFBhcmVudE5vZGU6IGdldFNpemVkUGFyZW50Tm9kZSxcbiAgICBnZXRTY2FsZTogZ2V0U2NhbGVcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKi9cclxuXHJcbiAgLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuICAvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbiAgLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuICAvLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4gIC8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuICBmdW5jdGlvbiBvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRhZGRPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4gIC8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuICAvLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgb2YgZ2l2ZW4gdHlwZXMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIGZyb20gZ2l2ZW4gSFRNTEVsZW1lbnRcclxuICBmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gIFx0XHRiYXRjaFJlbW92ZShvYmopO1xyXG4gIFx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblxyXG4gIFx0fSBlbHNlIGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgXHRcdFx0YmF0Y2hSZW1vdmUob2JqLCBmdW5jdGlvbiAodHlwZSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIGluZGV4T2YodHlwZXMsIHR5cGUpICE9PSAtMTtcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiYXRjaFJlbW92ZShvYmosIGZpbHRlckZuKSB7XHJcbiAgXHRmb3IgKHZhciBpZCBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG4gIFx0XHR2YXIgdHlwZSA9IGlkLnNwbGl0KC9cXGQvKVswXTtcclxuICBcdFx0aWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbih0eXBlKSkge1xyXG4gIFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIG51bGwsIG51bGwsIGlkKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgdmFyIG1vdXNlU3Vic3QgPSB7XHJcbiAgXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuICBcdG1vdXNlbGVhdmU6ICdtb3VzZW91dCcsXHJcbiAgXHR3aGVlbDogISgnb253aGVlbCcgaW4gd2luZG93KSAmJiAnbW91c2V3aGVlbCdcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0dmFyIGlkID0gdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG4gIFx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuICBcdH07XHJcblxyXG4gIFx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG4gIFx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG4gIFx0XHRoYW5kbGVyID0gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG4gIFx0XHRoYW5kbGVyID0gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XHJcbiAgXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcbiAgXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9O1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb3JpZ2luYWxIYW5kbGVyLCBmYWxzZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG4gIFx0fVxyXG5cclxuICBcdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcbiAgXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQsIGlkKSB7XHJcbiAgXHRpZCA9IGlkIHx8IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpO1xyXG4gIFx0dmFyIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG4gIFx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG4gIFx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuICBcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuICBcdH1cclxuXHJcbiAgXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbiAgLy8gYGBganNcclxuICAvLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbiAgLy8gfSk7XHJcbiAgLy8gYGBgXHJcbiAgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcbiAgXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuICBcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICBcdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcbiAgXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuICBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuICBcdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RibGNsaWNrJ2AsIGAnY29udGV4dG1lbnUnYCxcclxuICAvLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbiAgZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuICBcdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2sgY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0ZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSA9IHRydWU7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4gIC8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuICAvLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4gIC8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuICBcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcbiAgXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICBcdH1cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuICBmdW5jdGlvbiBzdG9wKGUpIHtcclxuICBcdHByZXZlbnREZWZhdWx0KGUpO1xyXG4gIFx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0UHJvcGFnYXRpb25QYXRoKGV2OiBET01FdmVudCk6IEFycmF5XHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW2BFdmVudC5jb21wb3NlZFBhdGgoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudC9jb21wb3NlZFBhdGgpLlxyXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYEhUTUxFbGVtZW50YHMgdGhhdCB0aGUgZ2l2ZW4gRE9NIGV2ZW50XHJcbiAgLy8gc2hvdWxkIHByb3BhZ2F0ZSB0byAoaWYgbm90IHN0b3BwZWQpLlxyXG4gIGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldikge1xyXG4gIFx0aWYgKGV2LmNvbXBvc2VkUGF0aCkge1xyXG4gIFx0XHRyZXR1cm4gZXYuY29tcG9zZWRQYXRoKCk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIHBhdGggPSBbXTtcclxuICBcdHZhciBlbCA9IGV2LnRhcmdldDtcclxuXHJcbiAgXHR3aGlsZSAoZWwpIHtcclxuICBcdFx0cGF0aC5wdXNoKGVsKTtcclxuICBcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHBhdGg7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbiAgLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbiAgLy8gYGNvbnRhaW5lcmAgKGJvcmRlciBleGNsdWRlZCkgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuICBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG4gIFx0aWYgKCFjb250YWluZXIpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIHNjYWxlID0gZ2V0U2NhbGUoY29udGFpbmVyKSxcclxuICBcdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0Ly8gb2Zmc2V0LmxlZnQvdG9wIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSBjbGllbnRYL1kpLFxyXG4gIFx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuICBcdFx0KGUuY2xpZW50WCAtIG9mZnNldC5sZWZ0KSAvIHNjYWxlLnggLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuICBcdFx0KGUuY2xpZW50WSAtIG9mZnNldC50b3ApIC8gc2NhbGUueSAtIGNvbnRhaW5lci5jbGllbnRUb3BcclxuICBcdCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gIGV4Y2VwdCAsIFNhZmFyaSBhbmRcclxuICAvLyBXZSBuZWVkIGRvdWJsZSB0aGUgc2Nyb2xsIHBpeGVscyAoc2VlICM3NDAzIGFuZCAjNDUzOCkgZm9yIGFsbCBCcm93c2Vyc1xyXG4gIC8vIGV4Y2VwdCBPU1ggKE1hYykgLT4gM3gsIENocm9tZSBydW5uaW5nIG9uIExpbnV4IDF4XHJcblxyXG4gIHZhciB3aGVlbFB4RmFjdG9yID1cclxuICBcdChCcm93c2VyLmxpbnV4ICYmIEJyb3dzZXIuY2hyb21lKSA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuICBcdEJyb3dzZXIubWFjID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gKiAzIDpcclxuICBcdHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMCA/IDIgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcbiAgLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbiAgLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSB3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbiAgLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbiAgLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuICAvLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG4gIGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG4gIFx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuICBcdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcbiAgXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcbiAgXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG4gIFx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuICBcdCAgICAgICAwO1xyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbiAgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuICBcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuICBcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdHRyeSB7XHJcbiAgXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuICBcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGNhdGNoIChlcnIpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbiAgfVxuXG4gIHZhciBEb21FdmVudCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIHN0b3BQcm9wYWdhdGlvbjogc3RvcFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbixcbiAgICBwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXG4gICAgc3RvcDogc3RvcCxcbiAgICBnZXRQcm9wYWdhdGlvblBhdGg6IGdldFByb3BhZ2F0aW9uUGF0aCxcbiAgICBnZXRNb3VzZVBvc2l0aW9uOiBnZXRNb3VzZVBvc2l0aW9uLFxuICAgIGdldFdoZWVsRGVsdGE6IGdldFdoZWVsRGVsdGEsXG4gICAgaXNFeHRlcm5hbFRhcmdldDogaXNFeHRlcm5hbFRhcmdldCxcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgcmVtb3ZlTGlzdGVuZXI6IG9mZlxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAgICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxuICAgKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBteVBvc2l0aW9uTWFya2VyID0gTC5tYXJrZXIoWzQ4Ljg2NDcxNiwgMi4yOTQ2OTRdKS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiBteVBvc2l0aW9uTWFya2VyLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAqIFx0dmFyIHBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobXlQb3NpdGlvbk1hcmtlci5nZXRMYXRMbmcoKSk7XG4gICAqIFx0cG9zLnkgLT0gMjU7XG4gICAqIFx0dmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gICAqXG4gICAqIFx0Zngub25jZSgnZW5kJyxmdW5jdGlvbigpIHtcbiAgICogXHRcdHBvcy55ICs9IDI1O1xuICAgKiBcdFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC44KTtcbiAgICogXHR9KTtcbiAgICpcbiAgICogXHRmeC5ydW4obXlQb3NpdGlvbk1hcmtlci5faWNvbiwgcG9zLCAwLjMpO1xuICAgKiB9KTtcbiAgICpcbiAgICogYGBgXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gICAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqL1xuXG4gIHZhciBQb3NBbmltYXRpb24gPSBFdmVudGVkLmV4dGVuZCh7XG5cbiAgXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuICBcdC8vIFJ1biBhbiBhbmltYXRpb24gb2YgYSBnaXZlbiBlbGVtZW50IHRvIGEgbmV3IHBvc2l0aW9uLCBvcHRpb25hbGx5IHNldHRpbmdcbiAgXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcbiAgXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cHM6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG4gIFx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG4gIFx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHtcbiAgXHRcdHRoaXMuc3RvcCgpO1xuXG4gIFx0XHR0aGlzLl9lbCA9IGVsO1xuICBcdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG4gIFx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG4gIFx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cbiAgXHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24oZWwpO1xuICBcdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcbiAgXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gIFx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG4gIFx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cbiAgXHRcdHRoaXMuX2FuaW1hdGUoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzdG9wKClcbiAgXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9zdGVwKHRydWUpO1xuICBcdFx0dGhpcy5fY29tcGxldGUoKTtcbiAgXHR9LFxuXG4gIFx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIGFuaW1hdGlvbiBsb29wXG4gIFx0XHR0aGlzLl9hbmltSWQgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuICBcdFx0dGhpcy5fc3RlcCgpO1xuICBcdH0sXG5cbiAgXHRfc3RlcDogZnVuY3Rpb24gKHJvdW5kKSB7XG4gIFx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG4gIFx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cbiAgXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcbiAgXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcbiAgXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG4gIFx0XHRpZiAocm91bmQpIHtcbiAgXHRcdFx0cG9zLl9yb3VuZCgpO1xuICBcdFx0fVxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cbiAgXHRcdC8vIEBldmVudCBzdGVwOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuICBcdFx0dGhpcy5maXJlKCdzdGVwJyk7XG4gIFx0fSxcblxuICBcdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cbiAgXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cbiAgXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG4gIFx0fSxcblxuICBcdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuICBcdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIE1hcFxyXG4gICAqIEBha2EgTC5NYXBcclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gICAqXHJcbiAgICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAgICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICAgKiBcdHpvb206IDEzXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKi9cclxuXHJcbiAgdmFyIE1hcCA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBMLkNSUy5FUFNHMzg1N1xyXG4gIFx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcbiAgXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuICBcdFx0Y3JzOiBFUFNHMzg1NyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuICBcdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcbiAgXHRcdGNlbnRlcjogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuICBcdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG4gIFx0XHR6b29tOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuICBcdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG4gIFx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gIFx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9ICpcclxuICBcdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG4gIFx0XHQvLyB0aGUgaGlnaGVzdCBvZiB0aGVpciBgbWF4Wm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICBcdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG4gIFx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcbiAgXHRcdGxheWVyczogW10sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG4gIFx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcbiAgXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcbiAgXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG4gIFx0XHQvLyBbYHNldE1heEJvdW5kc2BdKCNtYXAtc2V0bWF4Ym91bmRzKSBtZXRob2QuXHJcbiAgXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcbiAgXHRcdC8vIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZHJhd2luZyB2ZWN0b3IgbGF5ZXJzIG9uIHRoZSBtYXAuIGBMLlNWR2BcclxuICBcdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcbiAgXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gQW5pbWF0aW9uIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuICBcdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG4gIFx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcbiAgXHRcdC8vIFdvbid0IGFuaW1hdGUgem9vbSBpZiB0aGUgem9vbSBkaWZmZXJlbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cclxuICBcdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG4gIFx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcbiAgXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcbiAgXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcbiAgXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG4gIFx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcbiAgXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcbiAgXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcbiAgXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcbiAgXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcbiAgXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuICBcdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcbiAgXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuICBcdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcbiAgXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG4gIFx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG4gIFx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG4gIFx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcbiAgXHRcdHpvb21EZWx0YTogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcbiAgXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcbiAgXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0Ly8gTWFrZSBzdXJlIHRvIGFzc2lnbiBpbnRlcm5hbCBmbGFncyBhdCB0aGUgYmVnaW5uaW5nLFxyXG4gIFx0XHQvLyB0byBhdm9pZCBpbmNvbnNpc3RlbnQgc3RhdGUgaW4gc29tZSBlZGdlIGNhc2VzLlxyXG4gIFx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuICBcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcbiAgXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG4gIFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG4gIFx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcbiAgXHRcdHRoaXMuX29uUmVzaXplID0gYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuICBcdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRWaWV3KHRvTGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIG9uIGJyb3dzZXJzIHdpdGhvdXQgaGFyZHdhcmUtYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnMgb3Igb2xkIEFuZHJvaWQvT3BlcmFcclxuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gVFJBTlNJVElPTiAmJiBCcm93c2VyLmFueTNkICYmICFCcm93c2VyLm1vYmlsZU9wZXJhICYmXHJcbiAgXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcbiAgXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG4gIFx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG4gIFx0XHRcdG9uKHRoaXMuX3Byb3h5LCBUUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuICBcdC8vIGFuaW1hdGlvbiBvcHRpb25zLlxyXG4gIFx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcbiAgXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKHRvTGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xyXG5cclxuICBcdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbSA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuICBcdFx0XHRcdG9wdGlvbnMucGFuID0gZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG4gIFx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcbiAgXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcbiAgXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcbiAgXHRcdFx0aWYgKG1vdmVkKSB7XHJcbiAgXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcbiAgXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuICBcdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSwgb3B0aW9ucy5wYW4gJiYgb3B0aW9ucy5wYW4ubm9Nb3ZlU3RhcnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG4gIFx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcbiAgXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG4gIFx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG4gIFx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcbiAgXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG4gIFx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG4gIFx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcbiAgXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG4gIFx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBcdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcbiAgXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG4gIFx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuICBcdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XHJcbiAgXHRcdFx0cmV0dXJuIHtcclxuICBcdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG4gIFx0XHRcdFx0em9vbTogem9vbVxyXG4gIFx0XHRcdH07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG4gIFx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcbiAgXHRcdFx0em9vbTogem9vbVxyXG4gIFx0XHR9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuICBcdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuICBcdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG4gIFx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuICBcdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG4gIFx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcbiAgXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG4gIFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcclxuICBcdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG4gIFx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG4gIFx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG4gIFx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHJcbiAgXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG4gIFx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG4gIFx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcbiAgXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcbiAgXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcbiAgXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuICBcdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG4gIFx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcbiAgXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG4gIFx0XHQgICAgcmhvID0gMS40MixcclxuICBcdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG4gIFx0XHRmdW5jdGlvbiByKGkpIHtcclxuICBcdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG4gIFx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG4gIFx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcbiAgXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG4gIFx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuICBcdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG4gIFx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcbiAgXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcbiAgXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuICBcdFx0XHRyZXR1cm4gbG9nO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuICBcdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuICBcdFx0dmFyIHIwID0gcigwKTtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuICBcdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuICBcdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuICBcdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuICBcdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcbiAgXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcbiAgXHRcdFx0aWYgKHQgPD0gMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRcdHRoaXMuX21vdmUoXHJcbiAgXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcbiAgXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcclxuICBcdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzXHJcbiAgXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcbiAgXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcbiAgXHRcdGZyYW1lLmNhbGwodGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcbiAgXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbiAgXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG4gIFx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5saXN0ZW5zKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSkge1xyXG4gIFx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcbiAgXHRcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IG51bGw7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcbiAgXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcbiAgXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG4gIFx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcbiAgXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogcGFkZGluZyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRoZSBtaW5pbXVtIGFtb3VudCB0byBtYWtlIHRoZSBgbGF0bG5nYCB2aXNpYmxlLiBVc2VcclxuICBcdC8vIHBhZGRpbmcgb3B0aW9ucyB0byBmaXQgdGhlIGRpc3BsYXkgdG8gbW9yZSByZXN0cmljdGVkIGJvdW5kcy5cclxuICBcdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG4gIFx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcbiAgXHRwYW5JbnNpZGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG4gIFx0XHQgICAgcGl4ZWxQb2ludCA9IHRoaXMucHJvamVjdChsYXRsbmcpLFxyXG4gIFx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pLFxyXG4gIFx0XHQgICAgcGFkZGVkU2l6ZSA9IHBhZGRlZEJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG4gIFx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG4gIFx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcbiAgXHRcdFx0dmFyIGNlbnRlck9mZnNldCA9IHBpeGVsUG9pbnQuc3VidHJhY3QocGFkZGVkQm91bmRzLmdldENlbnRlcigpKTtcclxuICBcdFx0XHR2YXIgb2Zmc2V0ID0gcGFkZGVkQm91bmRzLmV4dGVuZChwaXhlbFBvaW50KS5nZXRTaXplKCkuc3VidHJhY3QocGFkZGVkU2l6ZSk7XHJcbiAgXHRcdFx0cGl4ZWxDZW50ZXIueCArPSBjZW50ZXJPZmZzZXQueCA8IDAgPyAtb2Zmc2V0LnggOiBvZmZzZXQueDtcclxuICBcdFx0XHRwaXhlbENlbnRlci55ICs9IGNlbnRlck9mZnNldC55IDwgMCA/IC1vZmZzZXQueSA6IG9mZnNldC55O1xyXG4gIFx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QocGl4ZWxDZW50ZXIpLCBvcHRpb25zKTtcclxuICBcdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG4gIFx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcbiAgXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG4gIFx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcbiAgXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG4gIFx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcbiAgXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuICBcdC8vIHBhbiBieSBkZWZhdWx0LlxyXG4gIFx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gZXh0ZW5kKHtcclxuICBcdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuICBcdFx0XHRwYW46IHRydWVcclxuICBcdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuICBcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG4gIFx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcbiAgXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcbiAgXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuICBcdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcbiAgXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuICBcdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuICBcdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG4gIFx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuICBcdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcbiAgXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcbiAgXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuICBcdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcbiAgXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcbiAgXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcbiAgXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcbiAgXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gIFx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBleHRlbmQoe1xyXG4gIFx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG4gIFx0XHRcdHdhdGNoOiBmYWxzZVxyXG4gIFx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcbiAgXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuICBcdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcbiAgXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG4gIFx0XHR9LCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG4gIFx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG4gIFx0XHRcdFx0Y29kZTogMCxcclxuICBcdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuICBcdFx0XHR9KTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9uUmVzcG9uc2UgPSBiaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG4gIFx0XHQgICAgb25FcnJvciA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG4gIFx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcbiAgXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG4gIFx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcbiAgXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuICBcdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG4gIFx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcbiAgXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG4gIFx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG4gIFx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuICBcdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuICBcdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuICBcdFx0XHRjb2RlOiBjLFxyXG4gIFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcbiAgXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuICBcdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG4gIFx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG4gIFx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcbiAgXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuICBcdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuICBcdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG4gIFx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuICBcdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAgXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcbiAgXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICBcdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG4gIFx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHsgdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpOyB9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0cnkge1xyXG4gIFx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG4gIFx0XHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuICBcdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcbiAgXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcbiAgXHRcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IG51bGw7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG4gIFx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGk7XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX3BhbmVzID0gW107XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcmVuZGVyZXI7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcbiAgXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3JcclxuICBcdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuICBcdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuICBcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcbiAgXHRcdCAgICBwYW5lID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuICBcdFx0aWYgKG5hbWUpIHtcclxuICBcdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHBhbmU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXIuY2xvbmUoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgdmlld1xyXG4gIFx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuICBcdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuICBcdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG4gIFx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcbiAgXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4sIHBhZGRpbmc/OiBQb2ludCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuICBcdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuICBcdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuICBcdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG4gIFx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG4gIFx0XHRwYWRkaW5nID0gdG9Qb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcbiAgXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG4gIFx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcbiAgXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuICBcdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuICBcdFx0ICAgIGJvdW5kc1NpemUgPSB0b0JvdW5kcyh0aGlzLnByb2plY3Qoc2UsIHpvb20pLCB0aGlzLnByb2plY3QobncsIHpvb20pKS5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcbiAgXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcbiAgXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcbiAgXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcbiAgXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG4gIFx0XHRpZiAoc25hcCkge1xyXG4gIFx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuICBcdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuICBcdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuICBcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG4gIFx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG4gIFx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuICBcdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG4gIFx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcbiAgXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcbiAgXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuICBcdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcbiAgXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuICBcdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcbiAgXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcbiAgXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuICBcdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcbiAgXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcbiAgXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuICBcdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuICBcdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcbiAgXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG4gIFx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcbiAgXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG4gIFx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuICBcdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG4gIFx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcbiAgXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG4gIFx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcbiAgXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuICBcdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG4gIFx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcbiAgXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG4gIFx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcbiAgXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG4gIFx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcbiAgXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcbiAgXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuICBcdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcbiAgXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcbiAgXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG4gIFx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuICBcdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcbiAgXHQvLyBDUlMncyBib3VuZHMuXHJcbiAgXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuICBcdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG4gIFx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG4gIFx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuICBcdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcbiAgXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcbiAgXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcbiAgXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG4gIFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcbiAgXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcbiAgXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcbiAgXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuICBcdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcbiAgXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcbiAgXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuICBcdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcbiAgXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHJldHVybiBnZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcbiAgXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcbiAgXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGdldChpZCk7XHJcblxyXG4gIFx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcbiAgXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuICBcdFx0dGhpcy5fY29udGFpbmVySWQgPSBzdGFtcChjb250YWluZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuICBcdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgQnJvd3Nlci5hbnkzZDtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcbiAgXHRcdFx0KEJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuICBcdFx0XHQoQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuICBcdFx0XHQoQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcbiAgXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcbiAgXHRcdHZhciBwb3NpdGlvbiA9IGdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG4gIFx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcgJiYgcG9zaXRpb24gIT09ICdzdGlja3knKSB7XHJcbiAgXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuICBcdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb25cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuICBcdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcbiAgXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcbiAgXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcbiAgXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG4gIFx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcbiAgXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgR3JpZExheWVyYHMgYW5kIGBUaWxlTGF5ZXJgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciB2ZWN0b3JzIChgUGF0aGBzLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzKSwgYEltYWdlT3ZlcmxheWBzIGFuZCBgVmlkZW9PdmVybGF5YHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYFRvb2x0aXBgcy5cclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG4gIFx0XHRcdGFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG4gIFx0XHRcdGFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG4gIFx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcbiAgXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcbiAgXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuICBcdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuICBcdFx0dGhpc1xyXG4gIFx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBub01vdmVTdGFydClcclxuICBcdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG4gIFx0XHRcdC5fbW92ZUVuZCh6b29tQ2hhbmdlZCk7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG4gIFx0XHQvLyBvbiBtYXAgem9vbSBvciBsb2FkKS4gVmVyeSB1c2VmdWwgZm9yIGNyZWF0aW5nIGN1c3RvbSBvdmVybGF5cy5cclxuICBcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgaW5pdGlhbGl6ZWQgKHdoZW4gaXRzIGNlbnRlciBhbmQgem9vbSBhcmUgc2V0XHJcbiAgXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcbiAgXHRcdGlmIChsb2FkaW5nKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVTdGFydDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkLCBub01vdmVTdGFydCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuICBcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoIW5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEsIHN1cHJlc3NFdmVudCkge1xyXG4gIFx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcbiAgXHRcdH1cclxuICBcdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHJcbiAgXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG4gIFx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG4gIFx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XHJcblxyXG4gIFx0XHRpZiAoIXN1cHJlc3NFdmVudCkge1xyXG4gIFx0XHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCxcclxuICBcdFx0XHQvLyBpbmNsdWRpbmcgem9vbSBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcbiAgXHRcdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG4gIFx0XHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCxcclxuICBcdFx0XHQvLyBpbmNsdWRpbmcgcGFuIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuICBcdFx0fSBlbHNlIGlmIChkYXRhICYmIGRhdGEucGluY2gpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG4gIFx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nXHJcbiAgXHRcdC8vIChlLmcuIHVzZXIgc3RvcHBlZCBkcmFnZ2luZyB0aGUgbWFwIG9yIGFmdGVyIG5vbi1jZW50ZXJlZCB6b29tKS5cclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcbiAgXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG4gIFx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuICBcdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcbiAgXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuICBcdFx0dGhpcy5fdGFyZ2V0c1tzdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG4gIFx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyBvZmYgOiBvbjtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcbiAgXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuICBcdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG4gIFx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG4gIFx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHRoYXQgcHJvZHVjZXMgYSBjaGFyYWN0ZXIgdmFsdWUgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG4gIFx0XHQvLyBAZXZlbnQga2V5ZG93bjogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLiBVbmxpa2UgdGhlIGBrZXlwcmVzc2AgZXZlbnQsXHJcbiAgXHRcdC8vIHRoZSBga2V5ZG93bmAgZXZlbnQgaXMgZmlyZWQgZm9yIGtleXMgdGhhdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlIGFuZCBmb3Iga2V5c1xyXG4gIFx0XHQvLyB0aGF0IGRvIG5vdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlLlxyXG4gIFx0XHQvLyBAZXZlbnQga2V5dXA6IEtleWJvYXJkRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcbiAgXHRcdG9uT2ZmKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG4gIFx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXAnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcbiAgXHRcdFx0b25PZmYod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG4gIFx0XHRcdChyZW1vdmUgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcbiAgXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKFxyXG4gIFx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuICBcdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG4gIFx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuICBcdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHBzOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2ZpbmRFdmVudFRhcmdldHM6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XHJcbiAgXHRcdHZhciB0YXJnZXRzID0gW10sXHJcbiAgXHRcdCAgICB0YXJnZXQsXHJcbiAgXHRcdCAgICBpc0hvdmVyID0gdHlwZSA9PT0gJ21vdXNlb3V0JyB8fCB0eXBlID09PSAnbW91c2VvdmVyJyxcclxuICBcdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuICBcdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gIFx0XHR3aGlsZSAoc3JjKSB7XHJcbiAgXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tzdGFtcChzcmMpXTtcclxuICBcdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuICBcdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG4gIFx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG4gIFx0XHRcdFx0YnJlYWs7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHRcdGlmIChpc0hvdmVyICYmICFpc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuICBcdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG4gIFx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcbiAgXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgdGhpcy5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcbiAgXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGFyZ2V0cztcclxuICBcdH0sXHJcblxyXG4gIFx0X2lzQ2xpY2tEaXNhYmxlZDogZnVuY3Rpb24gKGVsKSB7XHJcbiAgXHRcdHdoaWxlIChlbCAmJiBlbCAhPT0gdGhpcy5fY29udGFpbmVyKSB7XHJcbiAgXHRcdFx0aWYgKGVsWydfbGVhZmxldF9kaXNhYmxlX2NsaWNrJ10pIHsgcmV0dXJuIHRydWU7IH1cclxuICBcdFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHR2YXIgZWwgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgZWxbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gfHwgZS50eXBlID09PSAnY2xpY2snICYmIHRoaXMuX2lzQ2xpY2tEaXNhYmxlZChlbCkpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuICBcdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcbiAgXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcbiAgXHRcdFx0cHJldmVudE91dGxpbmUoZWwpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3VzZUV2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXSxcclxuXHJcbiAgXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgY2FudmFzVGFyZ2V0cykge1xyXG5cclxuICBcdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG4gIFx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuICBcdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG4gIFx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcbiAgXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcbiAgXHRcdFx0dmFyIHN5bnRoID0gZXh0ZW5kKHt9LCBlKTtcclxuICBcdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuICBcdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIGNhbnZhc1RhcmdldHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcbiAgXHRcdHZhciB0YXJnZXRzID0gdGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKTtcclxuXHJcbiAgXHRcdGlmIChjYW52YXNUYXJnZXRzKSB7XHJcbiAgXHRcdFx0dmFyIGZpbHRlcmVkID0gW107IC8vIHBpY2sgb25seSB0YXJnZXRzIHdpdGggbGlzdGVuZXJzXHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYW52YXNUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0XHRpZiAoY2FudmFzVGFyZ2V0c1tpXS5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcbiAgXHRcdFx0XHRcdGZpbHRlcmVkLnB1c2goY2FudmFzVGFyZ2V0c1tpXSk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHRhcmdldHMgPSBmaWx0ZXJlZC5jb25jYXQodGFyZ2V0cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG4gIFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuICBcdFx0dmFyIGRhdGEgPSB7XHJcbiAgXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0aWYgKGUudHlwZSAhPT0gJ2tleXByZXNzJyAmJiBlLnR5cGUgIT09ICdrZXlkb3duJyAmJiBlLnR5cGUgIT09ICdrZXl1cCcpIHtcclxuICBcdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQuZ2V0TGF0TG5nICYmICghdGFyZ2V0Ll9yYWRpdXMgfHwgdGFyZ2V0Ll9yYWRpdXMgPD0gMTApO1xyXG4gIFx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcbiAgXHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcbiAgXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuICBcdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcbiAgXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG4gIFx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBpbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcbiAgXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuICBcdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG4gIFx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG4gIFx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcbiAgXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuICBcdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG4gIFx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuICBcdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcbiAgXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG4gIFx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiB0b0JvdW5kcyhbXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcbiAgXHRcdF0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuICBcdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuICBcdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG4gIFx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcbiAgXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG4gIFx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuICBcdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcbiAgXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG4gIFx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcbiAgXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG4gIFx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpIDw9IDEgJiYgTWF0aC5hYnMob2Zmc2V0LnkpIDw9IDEpIHtcclxuICBcdFx0XHRyZXR1cm4gY2VudGVyO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcbiAgXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG4gIFx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuICBcdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcbiAgXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuICBcdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSB0b0JvdW5kcyhcclxuICBcdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuICBcdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG4gIFx0XHQgICAgKSxcclxuICBcdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuICBcdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcbiAgXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcbiAgXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuICBcdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG4gIFx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG4gIFx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG4gIFx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG4gIFx0XHRpZiAoc25hcCkge1xyXG4gIFx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcbiAgXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuICBcdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuICBcdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcbiAgXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRydWU7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG4gIFx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcbiAgXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0XHR2YXIgcHJvcCA9IFRSQU5TRk9STSxcclxuICBcdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XHJcblxyXG4gIFx0XHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcclxuXHJcbiAgXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuICBcdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9LCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2Rlc3Ryb3lBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuICBcdFx0dGhpcy5vZmYoJ2xvYWQgbW92ZWVuZCcsIHRoaXMuX2FuaW1Nb3ZlRW5kLCB0aGlzKTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbU1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG4gIFx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG4gIFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XHJcbiAgXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcbiAgXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcbiAgXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRcdHRoaXNcclxuICBcdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCB8fCBmYWxzZSlcclxuICBcdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuICBcdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuICBcdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb20sXHJcbiAgXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG4gIFx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcbiAgXHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5fdGVtcEZpcmVab29tRXZlbnQ7XHJcblxyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgLy9cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2xcclxuICAgKiBAYWthIEwuQ29udHJvbFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICAgKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICAgKi9cclxuXHJcbiAgdmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbCBPcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuICBcdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuICBcdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuICBcdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICpcclxuICBcdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG4gIFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcbiAgXHQgKi9cclxuICBcdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG4gIFx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuICBcdFx0aWYgKG1hcCkge1xyXG4gIFx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgXHRcdGlmIChtYXApIHtcclxuICBcdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5yZW1vdmUoKTtcclxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuICBcdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuICBcdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuICBcdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuICBcdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcbiAgXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub2ZmKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIHZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxuICB9O1xyXG5cclxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gICAqIEB1bmluaGVyaXRhYmxlXHJcbiAgICpcclxuICAgKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAgICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAgICpcclxuICAgKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICAgKi9cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAgICovXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuICBcdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcbiAgXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gIFx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuICBcdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcbiAgXHRcdCAgICAgICAgICAgIGNyZWF0ZSQxKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuICBcdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuICBcdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG4gIFx0fVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGluaGVyaXRzIENvbnRyb2xcclxuICAgKlxyXG4gICAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICAgKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICAgKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogdmFyIG92ZXJsYXlzID0ge1xyXG4gICAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gICAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcclxuICAgKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAgICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIsIHRvdWNoLCBvciBrZXlib2FyZCBhY3RpdmF0aW9uLlxyXG4gIFx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG4gIFx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcbiAgXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcbiAgXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuICBcdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcbiAgXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcbiAgXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuICBcdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG4gIFx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcbiAgXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuICBcdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcbiAgXHRcdHRoaXMuX3ByZXZlbnRDbGljayA9IGZhbHNlO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG4gIFx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xyXG4gIFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcclxuICBcdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcbiAgXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG4gIFx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcbiAgXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuICBcdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG4gIFx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcbiAgXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuICBcdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKHN0YW1wKGxheWVyKSk7XHJcbiAgXHRcdGlmIChvYmopIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG4gIFx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcbiAgXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG4gIFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcbiAgXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcbiAgXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fc2VjdGlvbi5jbGllbnRIZWlnaHQpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuICBcdFx0XHR0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG4gIFx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG4gIFx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpLFxyXG4gIFx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcclxuXHJcbiAgXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuICBcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuICBcdFx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG4gIFx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb24gPSBjcmVhdGUkMSgnc2VjdGlvbicsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuICBcdFx0aWYgKGNvbGxhcHNlZCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcbiAgXHRcdFx0b24oY29udGFpbmVyLCB7XHJcbiAgXHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLl9leHBhbmRTYWZlbHksXHJcbiAgXHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IGNyZWF0ZSQxKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG4gIFx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcbiAgXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblxyXG4gIFx0XHRvbihsaW5rLCB7XHJcbiAgXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0XHRcdGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuX2V4cGFuZFNhZmVseSgpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH0sXHJcbiAgXHRcdFx0Ly8gQ2VydGFpbiBzY3JlZW4gcmVhZGVycyBpbnRlcmNlcHQgdGhlIGtleSBldmVudCBhbmQgaW5zdGVhZCBzZW5kIGEgY2xpY2sgZXZlbnRcclxuICBcdFx0XHRjbGljazogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0XHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG4gIFx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9LCB0aGlzKTtcclxuXHJcbiAgXHRcdGlmICghY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1iYXNlJywgc2VjdGlvbik7XHJcbiAgXHRcdHRoaXMuX3NlcGFyYXRvciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG4gIFx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIHNlY3Rpb24pO1xyXG5cclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHNlY3Rpb24pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIHN0YW1wKHRoaXMuX2xheWVyc1tpXS5sYXllcikgPT09IGlkKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzLnB1c2goe1xyXG4gIFx0XHRcdGxheWVyOiBsYXllcixcclxuICBcdFx0XHRuYW1lOiBuYW1lLFxyXG4gIFx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnMuc29ydChiaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnNvcnRGdW5jdGlvbihhLmxheWVyLCBiLmxheWVyLCBhLm5hbWUsIGIubmFtZSk7XHJcbiAgXHRcdFx0fSwgdGhpcykpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XHJcbiAgXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG4gIFx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0ZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG4gIFx0XHRlbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcbiAgXHRcdHZhciBiYXNlTGF5ZXJzUHJlc2VudCwgb3ZlcmxheXNQcmVzZW50LCBpLCBvYmosIGJhc2VMYXllcnNDb3VudCA9IDA7XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG4gIFx0XHRcdHRoaXMuX2FkZEl0ZW0ob2JqKTtcclxuICBcdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcbiAgXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcbiAgXHRcdFx0YmFzZUxheWVyc0NvdW50ICs9ICFvYmoub3ZlcmxheSA/IDEgOiAwO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5oaWRlU2luZ2xlQmFzZSkge1xyXG4gIFx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuICBcdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihzdGFtcChlLnRhcmdldCkpO1xyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG4gIFx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcbiAgXHRcdC8vIEBldmVudCBvdmVybGF5cmVtb3ZlOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcbiAgXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG4gIFx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ292ZXJsYXlhZGQnIDogJ292ZXJsYXlyZW1vdmUnKSA6XHJcbiAgXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuICBcdFx0aWYgKHR5cGUpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuZmlyZSh0eXBlLCBvYmopO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIElFNyBidWdzIG91dCBpZiB5b3UgY3JlYXRlIGEgcmFkaW8gZHluYW1pY2FsbHksIHNvIHlvdSBoYXZlIHRvIGRvIGl0IHRoaXMgaGFja3kgd2F5IChzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExOTA3OSlcclxuICBcdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG4gIFx0XHR2YXIgcmFkaW9IdG1sID0gJzxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIiBuYW1lPVwiJyArXHJcbiAgXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG4gIFx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIFx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcbiAgXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcbiAgXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcbiAgXHRcdCAgICBpbnB1dDtcclxuXHJcbiAgXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG4gIFx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICBcdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuICBcdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcbiAgXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzXycgKyBzdGFtcCh0aGlzKSwgY2hlY2tlZCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuICBcdFx0aW5wdXQubGF5ZXJJZCA9IHN0YW1wKG9iai5sYXllcik7XHJcblxyXG4gIFx0XHRvbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcbiAgXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gIFx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuICBcdFx0Ly8gSGVscHMgZnJvbSBwcmV2ZW50aW5nIGxheWVyIGNvbnRyb2wgZmxpY2tlciB3aGVuIGNoZWNrYm94ZXMgYXJlIGRpc2FibGVkXHJcbiAgXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuICBcdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHJcbiAgXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcbiAgXHRcdGhvbGRlci5hcHBlbmRDaGlsZChpbnB1dCk7XHJcbiAgXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcbiAgXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuICBcdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG4gIFx0XHRyZXR1cm4gbGFiZWw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gZXhwYW5kaW5nIHRoZSBjb250cm9sIG9uIG1vYmlsZSB3aXRoIGEgY2xpY2sgY2FuIGNhdXNlIGFkZGluZyBhIGxheWVyIC0gd2UgZG9uJ3Qgd2FudCB0aGlzXHJcbiAgXHRcdGlmICh0aGlzLl9wcmV2ZW50Q2xpY2spIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcbiAgXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcbiAgXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG4gIFx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcbiAgXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG4gIFx0XHQgICAgaW5wdXQsXHJcbiAgXHRcdCAgICBsYXllcixcclxuICBcdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gIFx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcbiAgXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuICBcdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZXhwYW5kU2FmZWx5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbjtcclxuICBcdFx0dGhpcy5fcHJldmVudENsaWNrID0gdHJ1ZTtcclxuICBcdFx0b24oc2VjdGlvbiwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcbiAgXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRcdG9mZihzZWN0aW9uLCAnY2xpY2snLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHRcdFx0dGhhdC5fcHJldmVudENsaWNrID0gZmFsc2U7XHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbiAgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICovXHJcblxyXG4gIHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+J1xyXG4gIFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcbiAgXHRcdHpvb21JblRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuICBcdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuICBcdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nXHJcbiAgXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcbiAgXHRcdHpvb21PdXRUZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiN4MjIxMjs8L3NwYW4+JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcbiAgXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG4gIFx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gIFx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuICBcdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG4gIFx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG4gIFx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcbiAgXHRcdHZhciBsaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcbiAgXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuICBcdFx0bGluay5ocmVmID0gJyMnO1xyXG4gIFx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG4gIFx0XHQvKlxyXG4gIFx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG4gIFx0XHQgKi9cclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGluaztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuICBcdFx0dGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbiAgLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuICAvLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0em9vbUNvbnRyb2w6IHRydWVcclxuICB9KTtcclxuXHJcbiAgTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuICBcdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuICBcdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuICBcdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuICBcdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuICBcdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcbiAgXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG4gIFx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG4gIHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gICAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gICAqIEBpbmhlcml0cyBDb250cm9sXG4gICAqXG4gICAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcbiAgXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuICBcdFx0bWF4V2lkdGg6IDEwMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cbiAgXHRcdG1ldHJpYzogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuICBcdFx0aW1wZXJpYWw6IHRydWVcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG4gIFx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cbiAgXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuICBcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICBcdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG4gIFx0XHRcdHRoaXMuX21TY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG4gIFx0XHR9XG4gIFx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuICBcdFx0XHR0aGlzLl9pU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG4gIFx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG4gIFx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuICBcdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuICBcdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG4gIFx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG4gIFx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuICBcdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG4gIFx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuICBcdH0sXG5cbiAgXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcbiAgXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuICBcdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuICBcdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG4gIFx0XHQgICAgZCA+PSA1ID8gNSA6XG4gIFx0XHQgICAgZCA+PSAzID8gMyA6XG4gIFx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cbiAgXHRcdHJldHVybiBwb3cxMCAqIGQ7XG4gIFx0fVxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciB1a3JhaW5pYW5GbGFnID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCI4XCIgdmlld0JveD1cIjAgMCAxMiA4XCIgY2xhc3M9XCJsZWFmbGV0LWF0dHJpYnV0aW9uLWZsYWdcIj48cGF0aCBmaWxsPVwiIzRDN0JFMVwiIGQ9XCJNMCAwaDEydjRIMHpcIi8+PHBhdGggZmlsbD1cIiNGRkQ1MDBcIiBkPVwiTTAgNGgxMnYzSDB6XCIvPjxwYXRoIGZpbGw9XCIjRTBCQzAwXCIgZD1cIk0wIDdoMTJ2MUgwelwiLz48L3N2Zz4nO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gICAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAgICogQGluaGVyaXRzIENvbnRyb2xcclxuICAgKlxyXG4gICAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nfGZhbHNlID0gJ0xlYWZsZXQnXHJcbiAgXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG4gIFx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cHM6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPicgKyAoQnJvd3Nlci5pbmxpbmVTdmcgPyB1a3JhaW5pYW5GbGFnICsgJyAnIDogJycpICsgJ0xlYWZsZXQ8L2E+J1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICBcdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG4gIFx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHRtYXAub24oJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9hZGRBdHRyaWJ1dGlvbiwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKGV2KSB7XHJcbiAgXHRcdGlmIChldi5sYXllci5nZXRBdHRyaWJ1dGlvbikge1xyXG4gIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0ZXYubGF5ZXIub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZ3xmYWxzZSk6IHRoaXNcclxuICBcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG4gIFx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCcmY29weTsgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnMnYCkuXHJcbiAgXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuICBcdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG4gIFx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuICBcdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG4gIFx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuICBcdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuICBcdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuICBcdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcbiAgXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuICBcdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj58PC9zcGFuPiAnKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXBcclxuICAvLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuICAvLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuICAvLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XHJcbiAgXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxuICB9KTtcclxuXHJcbiAgTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuICBcdGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB7XHJcbiAgXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbC5cclxuICB2YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zKTtcclxuICB9O1xuXG4gIENvbnRyb2wuTGF5ZXJzID0gTGF5ZXJzO1xuICBDb250cm9sLlpvb20gPSBab29tO1xuICBDb250cm9sLlNjYWxlID0gU2NhbGU7XG4gIENvbnRyb2wuQXR0cmlidXRpb24gPSBBdHRyaWJ1dGlvbjtcblxuICBjb250cm9sLmxheWVycyA9IGxheWVycztcbiAgY29udHJvbC56b29tID0gem9vbTtcbiAgY29udHJvbC5zY2FsZSA9IHNjYWxlO1xuICBjb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbiAgLypcbiAgXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuICBcdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuICAqL1xuXG4gIC8vIEBjbGFzcyBIYW5kbGVyXG4gIC8vIEBha2EgTC5IYW5kbGVyXG4gIC8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuICB2YXIgSGFuZGxlciA9IENsYXNzLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG4gIFx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuICBcdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gIFx0XHR0aGlzLmFkZEhvb2tzKCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcbiAgXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gIFx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGFuZGxlciBpcyBlbmFibGVkXG4gIFx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcbiAgXHR9XG5cbiAgXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICBcdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuICBcdC8vIEBtZXRob2QgYWRkSG9va3MoKVxuICBcdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG4gIFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZGlzYWJsZWQsIHNob3VsZCByZW1vdmUgdGhlIGV2ZW50IGhvb2tzIGFkZGVkIHByZXZpb3VzbHkuXG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIFRoZXJlIGlzIHN0YXRpYyBmdW5jdGlvbiB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkhhbmRsZXI6XG4gIC8vIEBmdW5jdGlvbiBhZGRUbyhtYXA6IE1hcCwgbmFtZTogU3RyaW5nKTogdGhpc1xuICAvLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICBIYW5kbGVyLmFkZFRvID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuICBcdG1hcC5hZGRIYW5kbGVyKG5hbWUsIHRoaXMpO1xuICBcdHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAgICogQGFrYSBMLkRyYWdnYWJsZVxyXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAgICpcclxuICAgKiBBIGNsYXNzIGZvciBtYWtpbmcgRE9NIGVsZW1lbnRzIGRyYWdnYWJsZSAoaW5jbHVkaW5nIHRvdWNoIHN1cHBvcnQpLlxyXG4gICAqIFVzZWQgaW50ZXJuYWxseSBmb3IgbWFwIGFuZCBtYXJrZXIgZHJhZ2dpbmcuIE9ubHkgd29ya3MgZm9yIGVsZW1lbnRzXHJcbiAgICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGVsZW1lbnRUb0RyYWcpO1xyXG4gICAqIGRyYWdnYWJsZS5lbmFibGUoKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIFNUQVJUID0gQnJvd3Nlci50b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJztcclxuXHJcbiAgdmFyIERyYWdnYWJsZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBzZWN0aW9uXHJcbiAgXHRcdC8vIEBha2EgRHJhZ2dhYmxlIG9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG4gIFx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG4gIFx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcbiAgXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBjb25zdHJ1Y3RvciBMLkRyYWdnYWJsZShlbDogSFRNTEVsZW1lbnQsIGRyYWdIYW5kbGU/OiBIVE1MRWxlbWVudCwgcHJldmVudE91dGxpbmU/OiBCb29sZWFuLCBvcHRpb25zPzogRHJhZ2dhYmxlIG9wdGlvbnMpXHJcbiAgXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuICBcdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcbiAgXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZW5hYmxlKClcclxuICBcdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuICBcdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdG9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuICBcdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcbiAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSBkcmFnZ2luZyB0aGlzIGRyYWdnYWJsZSxcclxuICBcdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcbiAgXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0dGhpcy5maW5pc2hEcmFnKHRydWUpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuICBcdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcbiAgXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG4gIFx0XHRpZiAoaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcclxuICBcdFx0XHQvLyBGaW5pc2ggZHJhZ2dpbmcgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCB0b3VjaFpvb21cclxuICBcdFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG4gIFx0XHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0aGlzOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG4gIFx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuICBcdFx0XHRwcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0ZGlzYWJsZUltYWdlRHJhZygpO1xyXG4gIFx0XHRkaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuICBcdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG4gIFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG4gIFx0XHQgICAgc2l6ZWRQYXJlbnQgPSBnZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG4gIFx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICBcdFx0Ly8gQ2FjaGUgdGhlIHNjYWxlLCBzbyB0aGF0IHdlIGNhbiBjb250aW51b3VzbHkgY29tcGVuc2F0ZSBmb3IgaXQgZHVyaW5nIGRyYWcgKF9vbk1vdmUpLlxyXG4gIFx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IGdldFNjYWxlKHNpemVkUGFyZW50KTtcclxuXHJcbiAgXHRcdHZhciBtb3VzZWV2ZW50ID0gZS50eXBlID09PSAnbW91c2Vkb3duJztcclxuICBcdFx0b24oZG9jdW1lbnQsIG1vdXNlZXZlbnQgPyAnbW91c2Vtb3ZlJyA6ICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG4gIFx0XHRvbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZXVwJyA6ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLl9zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcbiAgXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG4gIFx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgdGhlIHBhcmVudCBjb250YWluZXIncyBwb3NpdGlvbiwgYm9yZGVyIGFuZCBzY2FsZSBkbyBub3QgY2hhbmdlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRyYWcuXHJcbiAgXHRcdC8vIFRoZXJlZm9yZSB0aGVyZSBpcyBubyBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSBwb3NpdGlvbiBhbmQgYm9yZGVyICh0aGV5IGFyZSBlbGltaW5hdGVkIGJ5IHRoZSBzdWJ0cmFjdGlvbilcclxuICBcdFx0Ly8gYW5kIHdlIGNhbiB1c2UgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgdGhlIHNjYWxlLlxyXG4gIFx0XHRvZmZzZXQueCAvPSB0aGlzLl9wYXJlbnRTY2FsZS54O1xyXG4gIFx0XHRvZmZzZXQueSAvPSB0aGlzLl9wYXJlbnRTY2FsZS55O1xyXG5cclxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcbiAgXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuICBcdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblxyXG4gIFx0XHRcdGFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcbiAgXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcbiAgXHRcdFx0Ly8gaWYgbmVjZXNzYXJ5XHJcbiAgXHRcdFx0aWYgKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UgJiYgdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpIHtcclxuICBcdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuICBcdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcbiAgXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcbiAgXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uVXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuICBcdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcbiAgXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuICBcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGZpbmlzaERyYWc6IGZ1bmN0aW9uIChub0luZXJ0aWEpIHtcclxuICBcdFx0cmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuICBcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0b2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlIHRvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcbiAgXHRcdG9mZihkb2N1bWVudCwgJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHJcbiAgXHRcdGVuYWJsZUltYWdlRHJhZygpO1xyXG4gIFx0XHRlbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG4gIFx0XHR2YXIgZmlyZURyYWdlbmQgPSB0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3Zpbmc7XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuICBcdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICBcdFx0aWYgKGZpcmVEcmFnZW5kKSB7XHJcbiAgXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcbiAgXHRcdFx0XHRub0luZXJ0aWE6IG5vSW5lcnRpYSxcclxuICBcdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAgICovXHJcblxyXG4gIC8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAgICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdtYW4gYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXRoZXJsYW5kJUUyJTgwJTkzSG9kZ21hbl9hbGdvcml0aG0pKS5cclxuICAgKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gICAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICAgKiB0aGFuIHBvbHlsaW5lLCBzbyB0aGVyZSdzIGEgc2VwYXJhdGUgbWV0aG9kIGZvciBpdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHMsIGJvdW5kcywgcm91bmQpIHtcclxuICBcdHZhciBjbGlwcGVkUG9pbnRzLFxyXG4gIFx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG4gIFx0ICAgIGksIGosIGssXHJcbiAgXHQgICAgYSwgYixcclxuICBcdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG4gIFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdHBvaW50c1tpXS5fY29kZSA9IF9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuICBcdH1cclxuXHJcbiAgXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcbiAgXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcbiAgXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuICBcdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuICBcdFx0XHRhID0gcG9pbnRzW2ldO1xyXG4gIFx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG4gIFx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG4gIFx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG4gIFx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcbiAgXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuICBcdFx0XHRcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG4gIFx0XHRcdFx0XHRwLl9jb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuICBcdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKGEpO1xyXG5cclxuICBcdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuICBcdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcbiAgXHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdFx0XHRwLl9jb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuICBcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gcG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgLyogQGZ1bmN0aW9uIHBvbHlnb25DZW50ZXIobGF0bG5nczogTGF0TG5nW10sIGNyczogQ1JTKTogTGF0TG5nXHJcbiAgICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5Z29uLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBvbHlnb25DZW50ZXIobGF0bG5ncywgY3JzKSB7XHJcbiAgXHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXI7XHJcblxyXG4gIFx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuICBcdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuICBcdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGNlbnRyb2lkTGF0TG5nID0gdG9MYXRMbmcoWzAsIDBdKTtcclxuXHJcbiAgXHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0bG5ncyk7XHJcbiAgXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG4gIFx0Ly8gdGVzdHMgc2hvd2VkIHRoYXQgYmVsb3cgMTcwMCByb3VuZGluZyBlcnJvcnMgYXJlIGhhcHBlbmluZ1xyXG4gIFx0aWYgKGFyZWFCb3VuZHMgPCAxNzAwKSB7XHJcbiAgXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG4gIFx0XHRjZW50cm9pZExhdExuZyA9IGNlbnRyb2lkKGxhdGxuZ3MpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuICBcdHZhciBwb2ludHMgPSBbXTtcclxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcbiAgXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKFtsYXRsbmcubGF0IC0gY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmcubG5nIC0gY2VudHJvaWRMYXRMbmcubG5nXSkpKTtcclxuICBcdH1cclxuXHJcbiAgXHRhcmVhID0geCA9IHkgPSAwO1xyXG5cclxuICBcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtO1xyXG4gIFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuICBcdFx0cDEgPSBwb2ludHNbaV07XHJcbiAgXHRcdHAyID0gcG9pbnRzW2pdO1xyXG5cclxuICBcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XHJcbiAgXHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XHJcbiAgXHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XHJcbiAgXHRcdGFyZWEgKz0gZiAqIDM7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKGFyZWEgPT09IDApIHtcclxuICBcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXHJcbiAgXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBsYXRsbmdDZW50ZXIgPSBjcnMudW5wcm9qZWN0KHRvUG9pbnQoY2VudGVyKSk7XHJcbiAgXHRyZXR1cm4gdG9MYXRMbmcoW2xhdGxuZ0NlbnRlci5sYXQgKyBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZ0NlbnRlci5sbmcgKyBjZW50cm9pZExhdExuZy5sbmddKTtcclxuICB9XHJcblxyXG4gIC8qIEBmdW5jdGlvbiBjZW50cm9pZChsYXRsbmdzOiBMYXRMbmdbXSk6IExhdExuZ1xyXG4gICAqIFJldHVybnMgdGhlICdjZW50ZXIgb2YgbWFzcycgb2YgdGhlIHBhc3NlZCBMYXRMbmdzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGNvb3Jkcykge1xyXG4gIFx0dmFyIGxhdFN1bSA9IDA7XHJcbiAgXHR2YXIgbG5nU3VtID0gMDtcclxuICBcdHZhciBsZW4gPSAwO1xyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcbiAgXHRcdGxhdFN1bSArPSBsYXRsbmcubGF0O1xyXG4gIFx0XHRsbmdTdW0gKz0gbGF0bG5nLmxuZztcclxuICBcdFx0bGVuKys7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdG9MYXRMbmcoW2xhdFN1bSAvIGxlbiwgbG5nU3VtIC8gbGVuXSk7XHJcbiAgfVxuXG4gIHZhciBQb2x5VXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY2xpcFBvbHlnb246IGNsaXBQb2x5Z29uLFxuICAgIHBvbHlnb25DZW50ZXI6IHBvbHlnb25DZW50ZXIsXG4gICAgY2VudHJvaWQ6IGNlbnRyb2lkXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAgICovXHJcblxyXG4gIC8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4gIC8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4gIC8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbiAgLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuICAvLyBbUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbiAgLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4gIC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuICAvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4gIC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHBzOi8vbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanMvKS5cclxuICBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG4gIFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuICBcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcbiAgXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG4gIFx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbiAgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuICBcdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuICBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcbiAgXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbiAgfVxyXG5cclxuICAvLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbiAgZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuICBcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG4gIFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcbiAgXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG4gIFx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcbiAgXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG4gIFx0dmFyIGksXHJcbiAgXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcbiAgXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBuZXdQb2ludHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcbiAgXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuICBcdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG4gIFx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuICBcdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcbiAgXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuICBcdFx0XHRpbmRleCA9IGk7XHJcbiAgXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcbiAgXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcbiAgXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG4gIFx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG4gIGZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG4gIFx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG4gIFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG4gIFx0XHRcdHByZXYgPSBpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuICBcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuICB9XHJcblxyXG4gIHZhciBfbGFzdENvZGU7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4gIC8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuICAvLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbiAgLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4gIC8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbiAgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuICBcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuICBcdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG4gIFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG4gIFx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG4gIFx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuICBcdHdoaWxlICh0cnVlKSB7XHJcbiAgXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuICBcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuICBcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG4gIFx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gb3RoZXIgY2FzZXNcclxuICBcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG4gIFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcbiAgXHRcdFx0YSA9IHA7XHJcbiAgXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGIgPSBwO1xyXG4gIFx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG4gIFx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG4gIFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcbiAgXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdCAgICB4LCB5O1xyXG5cclxuICBcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWF4Lnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWluLnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG4gIFx0XHR4ID0gbWF4Lng7XHJcbiAgXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuICBcdFx0eCA9IG1pbi54O1xyXG4gIFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuICBcdHZhciBjb2RlID0gMDtcclxuXHJcbiAgXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuICBcdFx0Y29kZSB8PSAxO1xyXG4gIFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuICBcdFx0Y29kZSB8PSAyO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdGNvZGUgfD0gNDtcclxuICBcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG4gIFx0XHRjb2RlIHw9IDg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGNvZGU7XHJcbiAgfVxyXG5cclxuICAvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuICBmdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG4gIFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuICBcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG4gIGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG4gIFx0dmFyIHggPSBwMS54LFxyXG4gIFx0ICAgIHkgPSBwMS55LFxyXG4gIFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0geSxcclxuICBcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuICBcdCAgICB0O1xyXG5cclxuICBcdGlmIChkb3QgPiAwKSB7XHJcbiAgXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG4gIFx0XHRpZiAodCA+IDEpIHtcclxuICBcdFx0XHR4ID0gcDIueDtcclxuICBcdFx0XHR5ID0gcDIueTtcclxuICBcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG4gIFx0XHRcdHggKz0gZHggKiB0O1xyXG4gIFx0XHRcdHkgKz0gZHkgKiB0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0ZHggPSBwLnggLSB4O1xyXG4gIFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuICBcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxuICB9XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbiAgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuICBcdHJldHVybiAhaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcbiAgXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcbiAgXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyogQGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gICAqIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBhc3NlZCBMYXRMbmdzIChmaXJzdCByaW5nKSBmcm9tIGEgcG9seWxpbmUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcG9seWxpbmVDZW50ZXIobGF0bG5ncywgY3JzKSB7XHJcbiAgXHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sIGNlbnRlcjtcclxuXHJcbiAgXHRpZiAoIWxhdGxuZ3MgfHwgbGF0bG5ncy5sZW5ndGggPT09IDApIHtcclxuICBcdFx0dGhyb3cgbmV3IEVycm9yKCdsYXRsbmdzIG5vdCBwYXNzZWQnKTtcclxuICBcdH1cclxuXHJcbiAgXHRpZiAoIWlzRmxhdChsYXRsbmdzKSkge1xyXG4gIFx0XHRjb25zb2xlLndhcm4oJ2xhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZCcpO1xyXG4gIFx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgY2VudHJvaWRMYXRMbmcgPSB0b0xhdExuZyhbMCwgMF0pO1xyXG5cclxuICBcdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuICBcdHZhciBhcmVhQm91bmRzID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldFNvdXRoV2VzdCgpKSAqIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXROb3J0aFdlc3QoKSk7XHJcbiAgXHQvLyB0ZXN0cyBzaG93ZWQgdGhhdCBiZWxvdyAxNzAwIHJvdW5kaW5nIGVycm9ycyBhcmUgaGFwcGVuaW5nXHJcbiAgXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuICBcdFx0Ly8gZ2V0dGluZyBhIGluZXhhY3QgY2VudGVyLCB0byBtb3ZlIHRoZSBsYXRsbmdzIG5lYXIgdG8gWzAsIDBdIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXHJcbiAgXHRcdGNlbnRyb2lkTGF0TG5nID0gY2VudHJvaWQobGF0bG5ncyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGxlbiA9IGxhdGxuZ3MubGVuZ3RoO1xyXG4gIFx0dmFyIHBvaW50cyA9IFtdO1xyXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcclxuICBcdFx0cG9pbnRzLnB1c2goY3JzLnByb2plY3QodG9MYXRMbmcoW2xhdGxuZy5sYXQgLSBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZy5sbmcgLSBjZW50cm9pZExhdExuZy5sbmddKSkpO1xyXG4gIFx0fVxyXG5cclxuICBcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG4gIFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxyXG4gIFx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XHJcbiAgXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XHJcbiAgXHRcdFx0cDEgPSBwb2ludHNbaV07XHJcbiAgXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xyXG4gIFx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcclxuICBcdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XHJcblxyXG4gIFx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcclxuICBcdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xyXG4gIFx0XHRcdFx0Y2VudGVyID0gW1xyXG4gIFx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxyXG4gIFx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXHJcbiAgXHRcdFx0XHRdO1xyXG4gIFx0XHRcdFx0YnJlYWs7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGxhdGxuZ0NlbnRlciA9IGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuICBcdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG4gIH1cblxuICB2YXIgTGluZVV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHNpbXBsaWZ5OiBzaW1wbGlmeSxcbiAgICBwb2ludFRvU2VnbWVudERpc3RhbmNlOiBwb2ludFRvU2VnbWVudERpc3RhbmNlLFxuICAgIGNsb3Nlc3RQb2ludE9uU2VnbWVudDogY2xvc2VzdFBvaW50T25TZWdtZW50LFxuICAgIGNsaXBTZWdtZW50OiBjbGlwU2VnbWVudCxcbiAgICBfZ2V0RWRnZUludGVyc2VjdGlvbjogX2dldEVkZ2VJbnRlcnNlY3Rpb24sXG4gICAgX2dldEJpdENvZGU6IF9nZXRCaXRDb2RlLFxuICAgIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuICAgIGlzRmxhdDogaXNGbGF0LFxuICAgIF9mbGF0OiBfZmxhdCxcbiAgICBwb2x5bGluZUNlbnRlcjogcG9seWxpbmVDZW50ZXJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gICAqIEBzZWN0aW9uXHJcbiAgICogTGVhZmxldCBjb21lcyB3aXRoIGEgc2V0IG9mIGFscmVhZHkgZGVmaW5lZCBQcm9qZWN0aW9ucyBvdXQgb2YgdGhlIGJveDpcclxuICAgKlxyXG4gICAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICAgKlxyXG4gICAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gICAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAgICogbGF0aXR1ZGUuIEFsc28gc3VpdGFibGUgZm9yIGZsYXQgd29ybGRzLCBlLmcuIGdhbWUgbWFwcy4gVXNlZCBieSB0aGVcclxuICAgKiBgRVBTRzo0MzI2YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgTG9uTGF0ID0ge1xyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcsIGxhdGxuZy5sYXQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gICAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gICAqXHJcbiAgICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpcyBhbiBlbGxpcHNvaWQuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAgICovXHJcblxyXG4gIHZhciBNZXJjYXRvciA9IHtcclxuICBcdFI6IDYzNzgxMzcsXHJcbiAgXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcbiAgXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG4gIFx0XHQgICAgciA9IHRoaXMuUixcclxuICBcdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuICBcdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcbiAgXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG4gIFx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuICBcdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuICBcdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuICBcdFx0ICAgIHIgPSB0aGlzLlIsXHJcbiAgXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG4gIFx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuICBcdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuICBcdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuICBcdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuICBcdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuICBcdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuICBcdFx0XHRwaGkgKz0gZHBoaTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuICBcdH1cclxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAgICogQW4gb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgcHJvamVjdGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHdvcmxkIG9udG9cbiAgICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuXG4gICAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICAgKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gICAqIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XG4gICAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gICAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAgICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gICAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAgICogTm90ZSB0aGF0IHRoZSBwcm9qZWN0aW9uIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAgICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXG4gICAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxuXG4gICAqL1xuXG4gIHZhciBpbmRleCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgTG9uTGF0OiBMb25MYXQsXG4gICAgTWVyY2F0b3I6IE1lcmNhdG9yLFxuICAgIFNwaGVyaWNhbE1lcmNhdG9yOiBTcGhlcmljYWxNZXJjYXRvclxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAgICpcclxuICAgKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gICAqL1xyXG4gIHZhciBFUFNHMzM5NSA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG4gIFx0cHJvamVjdGlvbjogTWVyY2F0b3IsXHJcblxyXG4gIFx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTWVyY2F0b3IuUik7XHJcbiAgXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuICBcdH0oKSlcclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gICAqXHJcbiAgICogQSBjb21tb24gQ1JTIGFtb25nIEdJUyBlbnRodXNpYXN0cy4gVXNlcyBzaW1wbGUgRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24uXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gICAqIHdoaWNoIGlzIGEgYnJlYWtpbmcgY2hhbmdlIGZyb20gMC43LnggYmVoYXZpb3VyLiAgSWYgeW91IGFyZSB1c2luZyBhIGBUaWxlTGF5ZXJgXHJcbiAgICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gICAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICAgKiBvciAoLTE4MCwtOTApIGZvciBgVGlsZUxheWVyYHMgd2l0aCBbdGhlIGB0bXNgIG9wdGlvbl0oI3RpbGVsYXllci10bXMpIHNldC5cclxuICAgKi9cclxuXHJcbiAgdmFyIEVQU0c0MzI2ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG4gIFx0Y29kZTogJ0VQU0c6NDMyNicsXHJcbiAgXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcbiAgXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG4gIH0pO1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuU2ltcGxlXG4gICAqXG4gICAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICAgKiBNYXkgYmUgdXNlZCBmb3IgbWFwcyBvZiBmbGF0IHN1cmZhY2VzIChlLmcuIGdhbWUgbWFwcykuIE5vdGUgdGhhdCB0aGUgYHlgXG4gICAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICAgKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICAgKi9cblxuICB2YXIgU2ltcGxlID0gZXh0ZW5kKHt9LCBDUlMsIHtcbiAgXHRwcm9qZWN0aW9uOiBMb25MYXQsXG4gIFx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG4gIFx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG4gIFx0fSxcblxuICBcdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuICBcdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuICBcdH0sXG5cbiAgXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcbiAgXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG4gIFx0XHQgICAgZHkgPSBsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0O1xuXG4gIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgXHR9LFxuXG4gIFx0aW5maW5pdGU6IHRydWVcbiAgfSk7XG5cbiAgQ1JTLkVhcnRoID0gRWFydGg7XG4gIENSUy5FUFNHMzM5NSA9IEVQU0czMzk1O1xuICBDUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbiAgQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuICBDUlMuRVBTRzQzMjYgPSBFUFNHNDMyNjtcbiAgQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuICAvKlxuICAgKiBAY2xhc3MgTGF5ZXJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcbiAgICogQGFrYSBMLkxheWVyXG4gICAqIEBha2EgSUxheWVyXG4gICAqXG4gICAqIEEgc2V0IG9mIG1ldGhvZHMgZnJvbSB0aGUgTGF5ZXIgYmFzZSBjbGFzcyB0aGF0IGFsbCBMZWFmbGV0IGxheWVycyB1c2UuXG4gICAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxheWVyID0gTC5tYXJrZXIobGF0bG5nKS5hZGRUbyhtYXApO1xuICAgKiBsYXllci5hZGRUbyhtYXApO1xuICAgKiBsYXllci5yZW1vdmUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBldmVudCBhZGQ6IEV2ZW50XG4gICAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyBhZGRlZCB0byBhIG1hcFxuICAgKlxuICAgKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICAgKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgbWFwXG4gICAqL1xuXG5cbiAgdmFyIExheWVyID0gRXZlbnRlZC5leHRlbmQoe1xuXG4gIFx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG4gIFx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG4gIFx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG4gIFx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGUuZy4gXCLCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yc1wiLiBJdCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEgYW5kIGlzIG9mdGVuIGEgbGVnYWwgb2JsaWdhdGlvbiB0b3dhcmRzIGNvcHlyaWdodCBob2xkZXJzIGFuZCB0aWxlIHByb3ZpZGVycy5cbiAgXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG4gIFx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG4gIFx0fSxcblxuICBcdC8qIEBzZWN0aW9uXG4gIFx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gIFx0ICpcbiAgXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG4gIFx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcCBvciBsYXllciBncm91cC5cbiAgXHQgKi9cbiAgXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcbiAgXHQvL1xuICBcdC8vIEBhbHRlcm5hdGl2ZVxuICBcdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShncm91cDogTGF5ZXJHcm91cCk6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBgTGF5ZXJHcm91cGBcbiAgXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG4gIFx0XHRpZiAob2JqKSB7XG4gIFx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuICBcdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuICBcdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG4gIFx0fSxcblxuICBcdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcbiAgXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tzdGFtcCh0YXJnZXRFbCldID0gdGhpcztcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG4gIFx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV07XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG4gIFx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cbiAgXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcbiAgXHR9LFxuXG4gIFx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG4gIFx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuICBcdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG4gIFx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcbiAgXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG4gIFx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuICBcdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG4gIFx0XHRcdH0sIHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cbiAgXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG4gIFx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gICAqIEB1bmluaGVyaXRhYmxlXG4gICAqXG4gICAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAgICpcbiAgICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAgICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAgICpcbiAgICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAgICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAgICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICAgKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKlxuICAgKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAgICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gICAqL1xuXG5cbiAgLyogQG5hbWVzcGFjZSBNYXBcbiAgICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gICAqXG4gICAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICAgKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gICAqXG4gICAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICAgKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAgICpcbiAgICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICAgKi9cbiAgTWFwLmluY2x1ZGUoe1xuICBcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuICBcdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcbiAgXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcbiAgXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG4gIFx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cbiAgXHRcdGxheWVyLl9tYXBUb0FkZCA9IHRoaXM7XG5cbiAgXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcbiAgXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cbiAgXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG4gIFx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuICBcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuICBcdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcbiAgXHRcdH1cblxuICBcdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcbiAgXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRyZXR1cm4gc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycztcbiAgXHR9LFxuXG4gIFx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuICBcdCAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgbWFwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXG4gIFx0ICogYGBgXG4gIFx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG4gIFx0ICogICAgIGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcbiAgXHQgKiB9KTtcbiAgXHQgKiBgYGBcbiAgXHQgKi9cbiAgXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuICBcdFx0bGF5ZXJzID0gbGF5ZXJzID8gKGlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcbiAgXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcblxuICBcdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG4gIFx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcbiAgXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG4gIFx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cbiAgXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG4gIFx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcbiAgXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cbiAgXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcbiAgXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuICBcdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuICBcdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSk7XG4gIFx0XHR9XG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuICBcdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBMYXllckdyb3VwXHJcbiAgICogQGFrYSBMLkxheWVyR3JvdXBcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gICAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gICAqIHdlbGwuIEV4dGVuZHMgYExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAgICogXHQuYWRkTGF5ZXIocG9seWxpbmUpXHJcbiAgICogXHQuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuICBcdFx0dmFyIGksIGxlbjtcclxuXHJcbiAgXHRcdGlmIChsYXllcnMpIHtcclxuICBcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ3JvdXAuXHJcbiAgXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIoaWQ6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuICBcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG4gIFx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHR2YXIgbGF5ZXJJZCA9IHR5cGVvZiBsYXllciA9PT0gJ251bWJlcicgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcbiAgXHRcdHJldHVybiBsYXllcklkIGluIHRoaXMuX2xheWVycztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG4gIFx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuICBcdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuICBcdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuICBcdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcbiAgXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcbiAgXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuICBcdFx0ICAgIGksIGxheWVyO1xyXG5cclxuICBcdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuICBcdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuICBcdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG4gIFx0Ly8gYGBganNcclxuICBcdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG4gIFx0Ly8gfSk7XHJcbiAgXHQvLyBgYGBcclxuICBcdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuICBcdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuICBcdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG4gIFx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBsYXllcnMgPSBbXTtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcbiAgXHRcdHJldHVybiBsYXllcnM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG4gIFx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdHJldHVybiBzdGFtcChsYXllcik7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuICAvLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IExheWVyR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gICAqIEBha2EgTC5GZWF0dXJlR3JvdXBcclxuICAgKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gICAqXHJcbiAgICogRXh0ZW5kZWQgYExheWVyR3JvdXBgIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIGRvIHRoZSBzYW1lIHRoaW5nIHRvIGFsbCBpdHMgbWVtYmVyIGxheWVyczpcclxuICAgKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICAgKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAgICogaGFuZGxlciwgaXQgd2lsbCBoYW5kbGUgZXZlbnRzIGZyb20gYW55IG9mIHRoZSBsYXllcnMuIFRoaXMgaW5jbHVkZXMgbW91c2UgZXZlbnRzXHJcbiAgICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAgICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gICAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICAgKiBcdC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgYWxlcnQoJ0NsaWNrZWQgb24gYSBtZW1iZXIgb2YgdGhlIGdyb3VwIScpOyB9KVxyXG4gICAqIFx0LmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG4gIFx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG4gIFx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5yZW1vdmVMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGdpdmVuIHBhdGggb3B0aW9ucyB0byBlYWNoIGxheWVyIG9mIHRoZSBncm91cCB0aGF0IGhhcyBhIGBzZXRTdHlsZWAgbWV0aG9kLlxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG4gIFx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGJvdW5kcztcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuICAvLyBDcmVhdGUgYSBmZWF0dXJlIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzLCBvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIEljb25cclxuICAgKiBAYWthIEwuSWNvblxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBteUljb24gPSBMLmljb24oe1xyXG4gICAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gICAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gICAqICAgICBpY29uU2l6ZTogWzM4LCA5NV0sXHJcbiAgICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gICAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gICAqICAgICBzaGFkb3dVcmw6ICdteS1pY29uLXNoYWRvdy5wbmcnLFxyXG4gICAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gICAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICAgKiAgICAgc2hhZG93QW5jaG9yOiBbMjIsIDk0XVxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIGBMLkljb24uRGVmYXVsdGAgZXh0ZW5kcyBgTC5JY29uYCBhbmQgaXMgdGhlIGJsdWUgaWNvbiBMZWFmbGV0IHVzZXMgZm9yIG1hcmtlcnMgYnkgZGVmYXVsdC5cclxuICAgKlxyXG4gICAqL1xyXG5cclxuICB2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG4gIFx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuICBcdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuICBcdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHRvb2x0aXBBbmNob3I6IFBvaW50ID0gWzAsIDBdXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdG9vbHRpcHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuICBcdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcbiAgXHQgKi9cclxuXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvcHVwQW5jaG9yOiBbMCwgMF0sXHJcbiAgXHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuICBcdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcbiAgXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuICBcdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuICBcdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG4gIFx0XHRpZiAoIXNyYykge1xyXG4gIFx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcbiAgXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gaW1nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICBcdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG4gIFx0XHRcdHNpemVPcHRpb24gPSBbc2l6ZU9wdGlvbiwgc2l6ZU9wdGlvbl07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBzaXplID0gdG9Qb2ludChzaXplT3B0aW9uKSxcclxuICBcdFx0ICAgIGFuY2hvciA9IHRvUG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcbiAgXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG4gIFx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcbiAgXHRcdGlmIChhbmNob3IpIHtcclxuICBcdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuICBcdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHNpemUpIHtcclxuICBcdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuICBcdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG4gIFx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gIFx0XHRlbC5zcmMgPSBzcmM7XHJcbiAgXHRcdHJldHVybiBlbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgXHRcdHJldHVybiBCcm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbiAgZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXG4gICAqIEBtaW5pY2xhc3MgSWNvbi5EZWZhdWx0IChJY29uKVxuICAgKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gICAqIEBzZWN0aW9uXG4gICAqXG4gICAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gICAqIG5vIGljb24gaXMgc3BlY2lmaWVkLiBQb2ludHMgdG8gdGhlIGJsdWUgbWFya2VyIGltYWdlIGRpc3RyaWJ1dGVkIHdpdGggTGVhZmxldFxuICAgKiByZWxlYXNlcy5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IGljb24sIGp1c3QgY2hhbmdlIHRoZSBwcm9wZXJ0aWVzIG9mIGBMLkljb24uRGVmYXVsdC5wcm90b3R5cGUub3B0aW9uc2BcbiAgICogKHdoaWNoIGlzIGEgc2V0IG9mIGBJY29uIG9wdGlvbnNgKS5cbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gX2NvbXBsZXRlbHlfIHJlcGxhY2UgdGhlIGRlZmF1bHQgaWNvbiwgb3ZlcnJpZGUgdGhlXG4gICAqIGBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5pY29uYCB3aXRoIHlvdXIgb3duIGljb24gaW5zdGVhZC5cbiAgICovXG5cbiAgdmFyIEljb25EZWZhdWx0ID0gSWNvbi5leHRlbmQoe1xuXG4gIFx0b3B0aW9uczoge1xuICBcdFx0aWNvblVybDogICAgICAgJ21hcmtlci1pY29uLnBuZycsXG4gIFx0XHRpY29uUmV0aW5hVXJsOiAnbWFya2VyLWljb24tMngucG5nJyxcbiAgXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG4gIFx0XHRpY29uU2l6ZTogICAgWzI1LCA0MV0sXG4gIFx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG4gIFx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG4gIFx0XHR0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG4gIFx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cbiAgXHR9LFxuXG4gIFx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRpZiAodHlwZW9mIEljb25EZWZhdWx0LmltYWdlUGF0aCAhPT0gJ3N0cmluZycpIHtcdC8vIERlcHJlY2F0ZWQsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IG9ubHlcbiAgXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gQG9wdGlvbiBpbWFnZVBhdGg6IFN0cmluZ1xuICBcdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuICBcdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuICBcdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IHBhdGguXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG4gIFx0fSxcblxuICBcdF9zdHJpcFVybDogZnVuY3Rpb24gKHBhdGgpIHtcdC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIHVzZSBpbiB0ZXN0c1xuICBcdFx0dmFyIHN0cmlwID0gZnVuY3Rpb24gKHN0ciwgcmUsIGlkeCkge1xuICBcdFx0XHR2YXIgbWF0Y2ggPSByZS5leGVjKHN0cik7XG4gIFx0XHRcdHJldHVybiBtYXRjaCAmJiBtYXRjaFtpZHhdO1xuICBcdFx0fTtcbiAgXHRcdHBhdGggPSBzdHJpcChwYXRoLCAvXnVybFxcKChbJ1wiXSk/KC4rKVxcMVxcKSQvLCAyKTtcbiAgXHRcdHJldHVybiBwYXRoICYmIHN0cmlwKHBhdGgsIC9eKC4qKW1hcmtlci1pY29uXFwucG5nJC8sIDEpO1xuICBcdH0sXG5cbiAgXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbCA9IGNyZWF0ZSQxKCdkaXYnLCAgJ2xlYWZsZXQtZGVmYXVsdC1pY29uLXBhdGgnLCBkb2N1bWVudC5ib2R5KTtcbiAgXHRcdHZhciBwYXRoID0gZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcbiAgXHRcdCAgICAgICAgICAgZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kSW1hZ2UnKTtcdC8vIElFOFxuXG4gIFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgXHRcdHBhdGggPSB0aGlzLl9zdHJpcFVybChwYXRoKTtcbiAgXHRcdGlmIChwYXRoKSB7IHJldHVybiBwYXRoOyB9XG4gIFx0XHR2YXIgbGluayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZiQ9XCJsZWFmbGV0LmNzc1wiXScpO1xuICBcdFx0aWYgKCFsaW5rKSB7IHJldHVybiAnJzsgfVxuICBcdFx0cmV0dXJuIGxpbmsuaHJlZi5zdWJzdHJpbmcoMCwgbGluay5ocmVmLmxlbmd0aCAtICdsZWFmbGV0LmNzcycubGVuZ3RoIC0gMSk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gICAqL1xuXG5cbiAgLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAgICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAgICpcbiAgICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gICAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICAgKi9cblxuICB2YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG4gIFx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuICBcdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShpY29uLCBpY29uLCB0cnVlKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcbiAgXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuICBcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cbiAgXHRcdGFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuICBcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICBcdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG4gIFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHR9LCB0aGlzKS5kaXNhYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuICBcdFx0ICAgIG1hcCA9IG1hcmtlci5fbWFwLFxuICBcdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuICBcdFx0ICAgIHBhZGRpbmcgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxcbiAgXHRcdCAgICBpY29uUG9zID0gZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcbiAgXHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcbiAgXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuICBcdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuICBcdFx0XHRib3VuZHMubWluLl9zdWJ0cmFjdChvcmlnaW4pLmFkZChwYWRkaW5nKSxcbiAgXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuICBcdFx0KTtcblxuICBcdFx0aWYgKCFwYW5Cb3VuZHMuY29udGFpbnMoaWNvblBvcykpIHtcbiAgXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuICBcdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuICBcdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWF4LngpIC8gKGJvdW5kcy5tYXgueCAtIHBhbkJvdW5kcy5tYXgueCkgLVxuICBcdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cbiAgXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cbiAgXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1pbi55KSAvIChib3VuZHMubWluLnkgLSBwYW5Cb3VuZHMubWluLnkpXG4gIFx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cbiAgXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5fYWRkKG1vdmVtZW50KTtcbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuICBcdFx0XHRzZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcbiAgXHRcdFx0dGhpcy5fb25EcmFnKGUpO1xuXG4gIFx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcbiAgXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG4gIFx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG4gIFx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cbiAgXHRcdC8vIFdoZW4gdXNpbmcgRVM2IGltcG9ydHMgaXQgY291bGQgbm90IGJlIHNldCB3aGVuIGBQb3B1cGAgd2FzIG5vdCBpbXBvcnRlZCBhcyB3ZWxsXG4gIFx0XHR0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCAmJiB0aGlzLl9tYXJrZXIuY2xvc2VQb3B1cCgpO1xuXG4gIFx0XHR0aGlzLl9tYXJrZXJcbiAgXHRcdFx0LmZpcmUoJ21vdmVzdGFydCcpXG4gIFx0XHRcdC5maXJlKCdkcmFnc3RhcnQnKTtcbiAgXHR9LFxuXG4gIFx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuKSB7XG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcbiAgXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcbiAgXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcbiAgXHRcdCAgICBpY29uUG9zID0gZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcbiAgXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cbiAgXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cbiAgXHRcdGlmIChzaGFkb3cpIHtcbiAgXHRcdFx0c2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcbiAgXHRcdH1cblxuICBcdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG4gIFx0XHRlLmxhdGxuZyA9IGxhdGxuZztcbiAgXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG4gIFx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cbiAgXHRcdG1hcmtlclxuICBcdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcbiAgXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG4gIFx0XHQgY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXG4gIFx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuICBcdFx0ZGVsZXRlIHRoaXMuX29sZExhdExuZztcbiAgXHRcdHRoaXMuX21hcmtlclxuICBcdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcbiAgXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTWFya2VyXHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICogQGFrYSBMLk1hcmtlclxyXG4gICAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgTWFya2VyIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG4gIFx0XHQvLyBJY29uIGluc3RhbmNlIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBtYXJrZXIuXHJcbiAgXHRcdC8vIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi5cclxuICBcdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG4gIFx0XHRpY29uOiBuZXcgSWNvbkRlZmF1bHQoKSxcclxuXHJcbiAgXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuICBcdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcbiAgXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcbiAgXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG4gIFx0XHR0aXRsZTogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJ01hcmtlcidcclxuICBcdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZS5cclxuICBcdFx0Ly8gW1VzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2FjY2Vzc2liaWxpdHkvI21hcmtlcnMtbXVzdC1iZS1sYWJlbGxlZCkuXHJcbiAgXHRcdGFsdDogJ01hcmtlcicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuICBcdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuICBcdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuICBcdFx0b3BhY2l0eTogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuICBcdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuICBcdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcbiAgXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNoYWRvd1BhbmU6IFN0cmluZyA9ICdzaGFkb3dQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIHNoYWRvdyB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRzaGFkb3dQYW5lOiAnc2hhZG93UGFuZScsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG4gIFx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5PbkZvY3VzOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGVuIGB0cnVlYCwgdGhlIG1hcCB3aWxsIHBhbiB3aGVuZXZlciB0aGUgbWFya2VyIGlzIGZvY3VzZWQgKHZpYVxyXG4gIFx0XHQvLyBlLmcuIHByZXNzaW5nIGB0YWJgIG9uIHRoZSBrZXlib2FyZCkgdG8gZW5zdXJlIHRoZSBtYXJrZXIgaXNcclxuICBcdFx0Ly8gdmlzaWJsZSB3aXRoaW4gdGhlIG1hcCdzIGJvdW5kc1xyXG4gIFx0XHRhdXRvUGFuT25Gb2N1czogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGRyYWdnYWJsZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcbiAgXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHBhbiB0aGUgbWFwIHdoZW4gZHJhZ2dpbmcgdGhpcyBtYXJrZXIgbmVhciBpdHMgZWRnZSBvciBub3QuXHJcbiAgXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1MCwgNTApXHJcbiAgXHRcdC8vIERpc3RhbmNlIChpbiBwaXhlbHMgdG8gdGhlIGxlZnQvcmlnaHQgYW5kIHRvIHRoZSB0b3AvYm90dG9tKSBvZiB0aGVcclxuICBcdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZzogWzUwLCA1MF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5TcGVlZDogTnVtYmVyID0gMTBcclxuICBcdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcbiAgXHRcdGF1dG9QYW5TcGVlZDogMTBcclxuICBcdH0sXHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqXHJcbiAgXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcbiAgXHQgKi9cclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcbiAgXHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcbiAgXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcbiAgXHRcdFx0dGhpcy5kcmFnZ2luZy5yZW1vdmVIb29rcygpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcbiAgXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHtcclxuICBcdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcbiAgXHRcdH07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG4gIFx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuICBcdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0SWNvbjogSWNvblxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG4gIFx0Z2V0SWNvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb247XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcbiAgXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuICBcdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuICBcdH0sXHJcblxyXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuICBcdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcbiAgXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcbiAgXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuICBcdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuICBcdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcbiAgXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG4gIFx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuICBcdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG4gIFx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG4gIFx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuICBcdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG4gIFx0XHRcdGljb24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcbiAgXHRcdFx0dGhpcy5vbih7XHJcbiAgXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuICBcdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcbiAgXHRcdFx0b24oaWNvbiwgJ2ZvY3VzJywgdGhpcy5fcGFuT25Gb2N1cywgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcbiAgXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG4gIFx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuICBcdFx0XHRhZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG4gIFx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcbiAgXHRcdH1cclxuXHJcblxyXG4gIFx0XHRpZiAoYWRkSWNvbikge1xyXG4gIFx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG4gIFx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG4gIFx0XHRcdHRoaXMuZ2V0UGFuZShvcHRpb25zLnNoYWRvd1BhbmUpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG4gIFx0XHRcdHRoaXMub2ZmKHtcclxuICBcdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG4gIFx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuICBcdFx0XHRvZmYodGhpcy5faWNvbiwgJ2ZvY3VzJywgdGhpcy5fcGFuT25Gb2N1cywgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9pY29uKTtcclxuICBcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcbiAgXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fc2hhZG93KTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3pJbmRleCA9IHBvcy55ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcclxuXHJcbiAgXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpLnJvdW5kKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJbnRlcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuICBcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcbiAgXHRcdGlmIChNYXJrZXJEcmFnKSB7XHJcbiAgXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcbiAgXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICBcdFx0XHRcdGRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpO1xyXG4gIFx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IE1hcmtlckRyYWcodGhpcyk7XHJcblxyXG4gIFx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuICBcdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3Bhbk9uRm9jdXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuICBcdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgaWNvbk9wdHMgPSB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zO1xyXG4gIFx0XHR2YXIgc2l6ZSA9IGljb25PcHRzLmljb25TaXplID8gdG9Qb2ludChpY29uT3B0cy5pY29uU2l6ZSkgOiB0b1BvaW50KDAsIDApO1xyXG4gIFx0XHR2YXIgYW5jaG9yID0gaWNvbk9wdHMuaWNvbkFuY2hvciA/IHRvUG9pbnQoaWNvbk9wdHMuaWNvbkFuY2hvcikgOiB0b1BvaW50KDAsIDApO1xyXG5cclxuICBcdFx0bWFwLnBhbkluc2lkZSh0aGlzLl9sYXRsbmcsIHtcclxuICBcdFx0XHRwYWRkaW5nVG9wTGVmdDogYW5jaG9yLFxyXG4gIFx0XHRcdHBhZGRpbmdCb3R0b21SaWdodDogc2l6ZS5zdWJ0cmFjdChhbmNob3IpXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3I7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3I7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuICAvLyBAZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG4gIGZ1bmN0aW9uIG1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBQYXRoXG4gICAqIEBha2EgTC5QYXRoXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICAgKlxuICAgKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAgICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gICAqL1xuXG4gIHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcbiAgXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuICBcdFx0c3Ryb2tlOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcbiAgXHRcdC8vIFN0cm9rZSBjb2xvclxuICBcdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuICBcdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcbiAgXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcbiAgXHRcdHdlaWdodDogMyxcblxuICBcdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcbiAgXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG4gIFx0XHRvcGFjaXR5OiAxLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG4gIFx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG4gIFx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuICBcdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cbiAgXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG4gIFx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG4gIFx0XHRkYXNoQXJyYXk6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICBcdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuICBcdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuICBcdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuICBcdFx0ZmlsbDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG4gIFx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG4gIFx0XHRmaWxsQ29sb3I6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuICBcdFx0Ly8gRmlsbCBvcGFjaXR5LlxuICBcdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuICBcdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG4gIFx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuICBcdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuICBcdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuICBcdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuICBcdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcbiAgXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgcGF0aCB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxuICBcdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG4gIFx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG4gIFx0fSxcblxuICBcdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG4gIFx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG4gIFx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcbiAgXHRcdHRoaXMuX3Jlc2V0KCk7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG4gIFx0Ly8gUmVkcmF3cyB0aGUgbGF5ZXIuIFNvbWV0aW1lcyB1c2VmdWwgYWZ0ZXIgeW91IGNoYW5nZWQgdGhlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHBhdGggdXNlcy5cbiAgXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuICBcdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG4gIFx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcbiAgXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSAmJiBzdHlsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsICd3ZWlnaHQnKSkge1xuICBcdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcbiAgXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHBhdGggbGF5ZXJzLlxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcbiAgXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuICBcdFx0dGhpcy5fcHJvamVjdCgpO1xuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcbiAgXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgK1xuICBcdFx0ICAodGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2UgfHwgMCk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gICAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAgICogQGluaGVyaXRzIFBhdGhcbiAgICpcbiAgICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICAgKi9cblxuICB2YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0ZmlsbDogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG4gIFx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuICBcdFx0cmFkaXVzOiAxMFxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cbiAgXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuICBcdFx0dGhpcy5yZWRyYXcoKTtcblxuICBcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuICBcdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuICBcdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gIFx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuICBcdH0sXG5cbiAgXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG4gIFx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG4gIFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG4gIFx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG4gIFx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG4gIFx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcbiAgXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG4gIFx0fVxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBtYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gIGZ1bmN0aW9uIGNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIENpcmNsZVxuICAgKiBAYWthIEwuQ2lyY2xlXG4gICAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gICAqXG4gICAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcbiAgXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG4gIFx0XHRcdG9wdGlvbnMgPSBleHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcbiAgXHRcdH1cbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG4gIFx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG4gIFx0XHQvLyBAc2VjdGlvblxuICBcdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuICBcdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cbiAgXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG4gIFx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG4gIFx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuICBcdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuICBcdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuICBcdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcbiAgXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcbiAgXHR9LFxuXG4gIFx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuICBcdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG4gIFx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG4gIFx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuICBcdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG4gIFx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG4gIFx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG4gIFx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG4gIFx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuICBcdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuICBcdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cbiAgXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG4gIFx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG4gIFx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG4gIFx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcbiAgXHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuICBcdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3RcbiAgLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4gIC8vIEBhbHRlcm5hdGl2ZVxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbiAgLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbiAgLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG4gIGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IENpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIFBvbHlsaW5lXG4gICAqIEBha2EgTC5Qb2x5bGluZVxuICAgKiBAaW5oZXJpdHMgUGF0aFxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICAgKiBcdFszNy43NywgLTEyMi40M10sXG4gICAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gICAqIF07XG4gICAqXG4gICAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAgICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gICAqIFx0IFszNy43NywgLTEyMi40M10sXG4gICAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gICAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAgICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICAgKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gICAqIF07XG4gICAqIGBgYFxuICAgKi9cblxuXG4gIHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuICBcdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuICBcdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuICBcdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cbiAgXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG4gIFx0XHRub0NsaXA6IGZhbHNlXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG4gIFx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuICBcdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG4gIFx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG4gIFx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG4gIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgcG9pbnQgY2xvc2VzdCB0byBgcGAgb24gdGhlIFBvbHlsaW5lLlxuICBcdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuICBcdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG4gIFx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuICBcdFx0ICAgIGNsb3Nlc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG4gIFx0XHQgICAgcDEsIHAyO1xuXG4gIFx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICBcdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcbiAgXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuICBcdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cbiAgXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuICBcdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRpZiAobWluUG9pbnQpIHtcbiAgXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIG1pblBvaW50O1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHBvbHlsaW5lQ2VudGVyKHRoaXMuX2RlZmF1bHRTaGFwZSgpLCB0aGlzLl9tYXAub3B0aW9ucy5jcnMpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcbiAgXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYWRkTGF0TG5nKGxhdGxuZzogTGF0TG5nLCBsYXRsbmdzPzogTGF0TG5nW10pOiB0aGlzXG4gIFx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuICBcdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG4gIFx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuICBcdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICBcdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG4gIFx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuICBcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG4gIFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG4gIFx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG4gIFx0fSxcblxuICBcdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBpc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcbiAgXHR9LFxuXG4gIFx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuICBcdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBbXSxcbiAgXHRcdCAgICBmbGF0ID0gaXNGbGF0KGxhdGxuZ3MpO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRpZiAoZmxhdCkge1xuICBcdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuICBcdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH0sXG5cbiAgXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuICBcdFx0dGhpcy5fcmluZ3MgPSBbXTtcbiAgXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cbiAgXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuICBcdFx0XHR0aGlzLl9yYXdQeEJvdW5kcyA9IHB4Qm91bmRzO1xuICBcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuICBcdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cbiAgXHRcdGlmICghdGhpcy5fcmF3UHhCb3VuZHMpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHMoW1xuICBcdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QocCksXG4gIFx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1heC5hZGQocClcbiAgXHRcdF0pO1xuICBcdH0sXG5cbiAgXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcbiAgXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuICBcdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuICBcdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuICBcdFx0ICAgIGksIHJpbmc7XG5cbiAgXHRcdGlmIChmbGF0KSB7XG4gIFx0XHRcdHJpbmcgPSBbXTtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG4gIFx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG4gIFx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG4gIFx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcbiAgXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcbiAgXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuICBcdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuICBcdFx0XHRcdHNlZ21lbnQgPSBjbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cbiAgXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuICBcdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG4gIFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuICBcdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcbiAgXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcbiAgXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG4gIFx0XHRcdFx0XHRrKys7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2VcbiAgXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuICBcdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwYXJ0c1tpXSA9IHNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuICBcdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuICBcdH0sXG5cbiAgXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG4gIFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcbiAgXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG4gIFx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIFx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcbiAgXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuICBcdFx0XHRcdGlmIChwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuICAvLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbiAgLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbiAgLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG4gIGZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuICBQb2x5bGluZS5fZmxhdCA9IF9mbGF0O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBQb2x5Z29uXG4gICAqIEBha2EgTC5Qb2x5Z29uXG4gICAqIEBpbmhlcml0cyBQb2x5bGluZVxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gICAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICAgKlxuICAgKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gICAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAgICogICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICAgKiBdO1xuICAgKiBgYGBcbiAgICpcbiAgICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICAgKiAgICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gICAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICAgKiAgIF0sXG4gICAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICAgKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gICAqICAgXVxuICAgKiBdO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFBvbHlnb24gPSBQb2x5bGluZS5leHRlbmQoe1xuXG4gIFx0b3B0aW9uczoge1xuICBcdFx0ZmlsbDogdHJ1ZVxuICBcdH0sXG5cbiAgXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgUG9seWdvbi5cbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcG9seWdvbkNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcbiAgXHR9LFxuXG4gIFx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcbiAgXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG4gIFx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG4gIFx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuICBcdFx0XHRyZXN1bHQucG9wKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH0sXG5cbiAgXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuICBcdFx0aWYgKGlzRmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuICBcdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG4gIFx0fSxcblxuICBcdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuICBcdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuICBcdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cbiAgXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcbiAgXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG4gIFx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcbiAgXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0Y2xpcHBlZCA9IGNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuICBcdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcbiAgXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuICBcdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuICBcdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuICBcdFx0XHRcdHAxID0gcGFydFtqXTtcbiAgXHRcdFx0XHRwMiA9IHBhcnRba107XG5cbiAgXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICBcdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG4gIFx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuICBcdH1cblxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4gIGZ1bmN0aW9uIHBvbHlnb24obGF0bG5ncywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEdlb0pTT05cclxuICAgKiBAYWthIEwuR2VvSlNPTlxyXG4gICAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICAgKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAgICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICAgKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICAgKiBcdH1cclxuICAgKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gICAqIH0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG4gIFx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuICBcdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcbiAgXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG4gIFx0ICogXHRyZXR1cm4ge31cclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuICBcdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG4gIFx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuICBcdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBtYXJrZXJzSW5oZXJpdE9wdGlvbnM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG4gIFx0ICovXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuICBcdFx0aWYgKGdlb2pzb24pIHtcclxuICBcdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG4gIFx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuICBcdFx0dmFyIGZlYXR1cmVzID0gaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG4gIFx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuICBcdFx0aWYgKGZlYXR1cmVzKSB7XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG4gIFx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG4gIFx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG4gIFx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuICBcdFx0aWYgKCFsYXllcikge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG4gIFx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcbiAgXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcbiAgXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG4gIFx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG4gIFx0Ly8gSWYgYGxheWVyYCBpcyBvbWl0dGVkLCB0aGUgc3R5bGUgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IGxheWVyIGlzIHJlc2V0LlxyXG4gIFx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuICBcdFx0bGF5ZXIub3B0aW9ucyA9IGV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG4gIFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG4gIFx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuICBcdFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuICAvLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuICAvLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbiAgLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbiAgLy8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbiAgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG4gIFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG4gIFx0ICAgIGxheWVycyA9IFtdLFxyXG4gIFx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcbiAgXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG4gIFx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuICBcdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG4gIFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdH1cclxuXHJcbiAgXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuICBcdGNhc2UgJ1BvaW50JzpcclxuICBcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcbiAgXHRcdHJldHVybiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdNdWx0aVBvaW50JzpcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcbiAgXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG4gIFx0Y2FzZSAnTGluZVN0cmluZyc6XHJcbiAgXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG4gIFx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnUG9seWdvbic6XHJcbiAgXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG4gIFx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIGdlb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuICBcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG4gIFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG4gIFx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcbiAgXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRcdGlmIChnZW9MYXllcikge1xyXG4gIFx0XHRcdFx0bGF5ZXJzLnB1c2goZ2VvTGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHR2YXIgZmVhdHVyZUxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb21ldHJ5LmZlYXR1cmVzW2ldLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdFx0aWYgKGZlYXR1cmVMYXllcikge1xyXG4gIFx0XHRcdFx0bGF5ZXJzLnB1c2goZmVhdHVyZUxheWVyKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcbiAgXHRkZWZhdWx0OlxyXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllckZuLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcbiAgXHRcdHBvaW50VG9MYXllckZuKGdlb2pzb24sIGxhdGxuZykgOlxyXG4gIFx0XHRuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlcnNJbmhlcml0T3B0aW9ucyAmJiBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuICAvLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuICBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHMpIHtcclxuICBcdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuICAvLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbiAgLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4gIC8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuICBcdHZhciBsYXRsbmdzID0gW107XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG4gIFx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuICBcdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuICBcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGxhdGxuZ3M7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nOiBMYXRMbmcsIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbiAgLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcbiAgXHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcbiAgXHRcdFtmb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcbiAgXHRcdFtmb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbildO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbiwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuICAvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4gIC8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcbiAgXHR2YXIgY29vcmRzID0gW107XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0Ly8gQ2hlY2sgZm9yIGZsYXQgYXJyYXlzIHJlcXVpcmVkIHRvIGVuc3VyZSB1bmJhbGFuY2VkIGFycmF5cyBhcmUgY29ycmVjdGx5IGNvbnZlcnRlZCBpbiByZWN1cnNpb25cclxuICBcdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcbiAgXHRcdFx0bGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIGlzRmxhdChsYXRsbmdzW2ldKSA/IDAgOiBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuICBcdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuICBcdH1cclxuXHJcbiAgXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XHJcbiAgXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXS5zbGljZSgpKTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gY29vcmRzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuICBcdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuICBcdFx0ZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG4gIFx0XHRhc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuICBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG4gIFx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG4gIFx0XHRyZXR1cm4gZ2VvanNvbjtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4ge1xyXG4gIFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcbiAgXHRcdHByb3BlcnRpZXM6IHt9LFxyXG4gIFx0XHRnZW9tZXRyeTogZ2VvanNvblxyXG4gIFx0fTtcclxuICB9XHJcblxyXG4gIHZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogJ1BvaW50JyxcclxuICBcdFx0XHRjb29yZGluYXRlczogbGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSwgcHJlY2lzaW9uKVxyXG4gIFx0XHR9KTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4gIC8vIEBzZWN0aW9uIE90aGVyIG1ldGhvZHNcclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbiAgTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbiAgQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG4gIENpcmNsZU1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG4gIFBvbHlsaW5lLmluY2x1ZGUoe1xyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHZhciBtdWx0aSA9ICFpc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG4gIFx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMSA6IDAsIGZhbHNlLCBwcmVjaXNpb24pO1xyXG5cclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG4gIFx0XHR9KTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG4gIFBvbHlnb24uaW5jbHVkZSh7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIGhvbGVzID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuICBcdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIWlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcbiAgXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcbiAgXHRcdGlmICghaG9sZXMpIHtcclxuICBcdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG4gIFx0XHR9KTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG4gIExheWVyR3JvdXAuaW5jbHVkZSh7XHJcbiAgXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgXHQvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICBcdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgRmVhdHVyZUNvbGxlY3Rpb25gLCBgR2VvbWV0cnlDb2xsZWN0aW9uYCwgb3IgYE11bHRpUG9pbnRgKS5cclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cclxuICBcdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuICBcdFx0aWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludChwcmVjaXNpb24pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcclxuICBcdFx0ICAgIGpzb25zID0gW107XHJcblxyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcbiAgXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xyXG4gIFx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcbiAgXHRcdFx0XHRcdGpzb25zLnB1c2goanNvbi5nZW9tZXRyeSk7XHJcbiAgXHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuICBcdFx0XHRcdFx0Ly8gU3F1YXNoIG5lc3RlZCBmZWF0dXJlIGNvbGxlY3Rpb25zXHJcbiAgXHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuICBcdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuICBcdFx0XHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xyXG4gIFx0XHRcdFx0XHR9XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG4gIFx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG4gIFx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHtcclxuICBcdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG4gIFx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG4gIFx0XHR9O1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuICAvLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4gIC8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4gIC8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG4gIHZhciBnZW9Kc29uID0gZ2VvSlNPTjtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICAgKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGltYWdlVXJsID0gJ2h0dHBzOi8vbWFwcy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICAgKiBcdGltYWdlQm91bmRzID0gW1s0MC43MTIyMTYsIC03NC4yMjY1NV0sIFs0MC43NzM5NDEsIC03NC4xMjU0NF1dO1xyXG4gICAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuICBcdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcbiAgXHRcdG9wYWNpdHk6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcbiAgXHRcdGFsdDogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuICBcdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW1hZ2UuXHJcbiAgXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gVVJMIHRvIHRoZSBvdmVybGF5IGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIG92ZXJsYXkgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuICBcdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcbiAgXHRcdC8vIFRoZSBleHBsaWNpdCBbekluZGV4XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleCkgb2YgdGhlIG92ZXJsYXkgbGF5ZXIuXHJcbiAgXHRcdHpJbmRleDogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgaW1hZ2UuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcbiAgXHRcdGNsYXNzTmFtZTogJydcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcbiAgXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuICBcdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuICBcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR0aGlzLl9yZXNldCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmUodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcbiAgXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcbiAgXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGVPcHRzKSB7XHJcbiAgXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG4gIFx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG4gIFx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBVcGRhdGUgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG4gIFx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBldmVudHMgPSB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleCh2YWx1ZTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG4gIFx0c2V0WkluZGV4OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHZhbHVlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG4gIFx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG4gIFx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBjcmVhdGUkMSgnaW1nJyk7XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhpbWcsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3MoaW1nLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuICBcdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xyXG4gIFx0XHRpbWcub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG4gIFx0XHRpbWcub25sb2FkID0gYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcbiAgXHRcdGltZy5vbmVycm9yID0gYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuICBcdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy56SW5kZXgpIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG4gIFx0XHRcdHRoaXMuX3VybCA9IGltZy5zcmM7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpbWcuc3JjID0gdGhpcy5fdXJsO1xyXG4gIFx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHModGhpcy5fYm91bmRzLCBlLnpvb20sIGUuY2VudGVyKS5taW47XHJcblxyXG4gIFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcbiAgXHRcdCAgICBib3VuZHMgPSBuZXcgQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG4gIFx0XHRzZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG4gIFx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG4gIFx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRzZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfb3ZlcmxheU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gQGV2ZW50IGVycm9yOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuICBcdFx0dGhpcy5maXJlKCdlcnJvcicpO1xyXG5cclxuICBcdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDtcclxuICBcdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuICBcdFx0XHR0aGlzLl91cmwgPSBlcnJvclVybDtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSBlcnJvclVybDtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgSW1hZ2VPdmVybGF5LlxyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0Q2VudGVyKCk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuICAvLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbiAgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAgICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gICAqXHJcbiAgICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICAgKiBIVE1MNSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICAgKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAgICogTC52aWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIFZpZGVvT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcbiAgXHRcdC8vIE9uIHNvbWUgYnJvd3NlcnMgYXV0b3BsYXkgd2lsbCBvbmx5IHdvcmsgd2l0aCBgbXV0ZWQ6IHRydWVgXHJcbiAgXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG4gIFx0XHRsb29wOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZWVwQXNwZWN0UmF0aW86IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgc2F2ZSBhc3BlY3QgcmF0aW8gYWZ0ZXIgdGhlIHByb2plY3Rpb24uXHJcbiAgXHRcdC8vIFJlbGV2YW50IGZvciBzdXBwb3J0ZWQgYnJvd3NlcnMuIFNlZSBbYnJvd3NlciBjb21wYXRpYmlsaXR5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdClcclxuICBcdFx0a2VlcEFzcGVjdFJhdGlvOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtdXRlZDogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBvbiBtdXRlIHdoZW4gbG9hZGVkLlxyXG4gIFx0XHRtdXRlZDogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBsYXlzSW5saW5lOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBNb2JpbGUgYnJvd3NlcnMgd2lsbCBwbGF5IHRoZSB2aWRlbyByaWdodCB3aGVyZSBpdCBpcyBpbnN0ZWFkIG9mIG9wZW4gaXQgdXAgaW4gZnVsbHNjcmVlbiBtb2RlLlxyXG4gIFx0XHRwbGF5c0lubGluZTogdHJ1ZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ1ZJREVPJztcclxuICBcdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogY3JlYXRlJDEoJ3ZpZGVvJyk7XHJcblxyXG4gIFx0XHRhZGRDbGFzcyh2aWQsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3ModmlkLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3ModmlkLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuICBcdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xyXG4gIFx0XHR2aWQub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZGVvIGhhcyBmaW5pc2hlZCBsb2FkaW5nIHRoZSBmaXJzdCBmcmFtZVxyXG4gIFx0XHR2aWQub25sb2FkZWRkYXRhID0gYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblxyXG4gIFx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcbiAgXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuICBcdFx0XHR2YXIgc291cmNlcyA9IFtdO1xyXG4gIFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuICBcdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghaXNBcnJheSh0aGlzLl91cmwpKSB7IHRoaXMuX3VybCA9IFt0aGlzLl91cmxdOyB9XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5rZWVwQXNwZWN0UmF0aW8gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZpZC5zdHlsZSwgJ29iamVjdEZpdCcpKSB7XHJcbiAgXHRcdFx0dmlkLnN0eWxlWydvYmplY3RGaXQnXSA9ICdmaWxsJztcclxuICBcdFx0fVxyXG4gIFx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuICBcdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG4gIFx0XHR2aWQubXV0ZWQgPSAhIXRoaXMub3B0aW9ucy5tdXRlZDtcclxuICBcdFx0dmlkLnBsYXlzSW5saW5lID0gISF0aGlzLm9wdGlvbnMucGxheXNJbmxpbmU7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIHNvdXJjZSA9IGNyZWF0ZSQxKCdzb3VyY2UnKTtcclxuICBcdFx0XHRzb3VyY2Uuc3JjID0gdGhpcy5fdXJsW2ldO1xyXG4gIFx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTFZpZGVvRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MVmlkZW9FbGVtZW50KVxyXG4gIFx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnZpZGVvT3ZlcmxheSh2aWRlbzogU3RyaW5nfEFycmF5fEhUTUxWaWRlb0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogVmlkZW9PdmVybGF5IG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIHZpZGVvIChvciBhcnJheSBvZiBVUkxzLCBvciBldmVuIGEgdmlkZW8gZWxlbWVudCkgYW5kIHRoZVxyXG4gIC8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbiAgZnVuY3Rpb24gdmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHT3ZlcmxheVxuICAgKiBAYWthIEwuU1ZHT3ZlcmxheVxuICAgKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XG4gICAqXG4gICAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gICAqXG4gICAqIEFuIFNWRyBvdmVybGF5IHVzZXMgdGhlIFtgPHN2Zz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdmcpIGVsZW1lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gICAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XG4gICAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAgICogc3ZnRWxlbWVudC5pbm5lckhUTUwgPSAnPHJlY3Qgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMDBcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOnJlZFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMTIzXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgc3R5bGU9XCJmaWxsOiMwMDEzZmZcIi8+JztcbiAgICogdmFyIHN2Z0VsZW1lbnRCb3VuZHMgPSBbIFsgMzIsIC0xMzAgXSwgWyAxMywgLTEwMCBdIF07XG4gICAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNWR092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuICBcdFx0YWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG4gIFx0XHRlbC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgXHRcdGVsLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcbiAgXHR9XG5cbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogU1ZHRWxlbWVudFxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuICBcdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIGFuIFNWRyBlbGVtZW50IGFuZCB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxuICAvLyBBIHZpZXdCb3ggYXR0cmlidXRlIGlzIHJlcXVpcmVkIG9uIHRoZSBTVkcgZWxlbWVudCB0byB6b29tIGluIGFuZCBvdXQgcHJvcGVybHkuXG5cbiAgZnVuY3Rpb24gc3ZnT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTVkdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqIEBha2EgTC5EaXZPdmVybGF5XHJcbiAgICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBvdmVybGF5cyBsaWtlIHBsdWdpbnMuXHJcbiAgICovXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIHRydWUsIHRoZSBwb3B1cC90b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBtb3VzZSBldmVudHMuXHJcbiAgXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXHJcbiAgXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIG92ZXJsYXkgcG9zaXRpb24uXHJcbiAgXHRcdG9mZnNldDogWzAsIDBdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgb3ZlcmxheS5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0cGFuZTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24gPSAnJ1xyXG4gIFx0XHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkgd2hpbGUgaW5pdGlhbGl6aW5nLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmVcclxuICBcdFx0Ly8gcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcbiAgXHRcdGNvbnRlbnQ6ICcnXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuICBcdFx0aWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMgaW5zdGFuY2VvZiBMYXRMbmcgfHwgaXNBcnJheShvcHRpb25zKSkpIHtcclxuICBcdFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhvcHRpb25zKTtcclxuICBcdFx0XHRzZXRPcHRpb25zKHRoaXMsIHNvdXJjZSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jb250ZW50KSB7XHJcbiAgXHRcdFx0dGhpcy5fY29udGVudCA9IHRoaXMub3B0aW9ucy5jb250ZW50O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgb3ZlcmxheSB0byB0aGUgbWFwLlxyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5vcGVuUG9wdXAocG9wdXApYC9gLm9wZW5Ub29sdGlwKHRvb2x0aXApYC5cclxuICBcdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuICBcdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHtcclxuICBcdFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xvc2UoKTogdGhpc1xyXG4gIFx0Ly8gQ2xvc2VzIHRoZSBvdmVybGF5LlxyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5jbG9zZVBvcHVwKHBvcHVwKWAvYC5jbG9zZVRvb2x0aXAodG9vbHRpcClgXHJcbiAgXHQvLyBhbmQgYGxheWVyLmNsb3NlUG9wdXAoKWAvYC5jbG9zZVRvb2x0aXAoKWAuXHJcbiAgXHRjbG9zZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZShsYXllcj86IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBvdmVybGF5IGJvdW5kIHRvIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuICBcdC8vIEFyZ3VtZW50IG1heSBiZSBvbWl0dGVkIG9ubHkgZm9yIG92ZXJsYXkgYm91bmQgdG8gbGF5ZXIuXHJcbiAgXHQvLyBBbHRlcm5hdGl2ZSB0byBgbGF5ZXIudG9nZ2xlUG9wdXAoKWAvYC50b2dnbGVUb29sdGlwKClgLlxyXG4gIFx0dG9nZ2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gIFx0XHRcdFx0dGhpcy5fc291cmNlID0gbGF5ZXI7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdGxheWVyID0gdGhpcy5fc291cmNlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHR0aGlzLl9wcmVwYXJlT3BlbigpO1xyXG5cclxuICBcdFx0XHQvLyBvcGVuIHRoZSBvdmVybGF5IG9uIHRoZSBtYXBcclxuICBcdFx0XHR0aGlzLm9wZW5PbihsYXllci5fbWFwKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG4gIFx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG4gIFx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZChyZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuICBcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgdGhlIG92ZXJsYXkuXHJcbiAgXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgd2hlcmUgdGhlIG92ZXJsYXkgd2lsbCBvcGVuLlxyXG4gIFx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG4gIFx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgb3ZlcmxheS5cclxuICBcdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBvdmVybGF5LiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc291cmNlIGxheWVyIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cclxuICBcdC8vIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBvdmVybGF5LlxyXG4gIFx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICBcdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcbiAgXHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBjb250YWluZXIgb2YgdGhlIG92ZXJsYXkuXHJcbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdXBkYXRlOiBudWxsXHJcbiAgXHQvLyBVcGRhdGVzIHRoZSBvdmVybGF5IGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIG92ZXJsYXkgYWZ0ZXIgc29tZXRoaW5nIGluc2lkZSBjaGFuZ2VkLCBlLmcuIGltYWdlIGxvYWRlZC5cclxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcbiAgXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IHtcclxuICBcdFx0XHR6b29tOiB0aGlzLl91cGRhdGVQb3NpdGlvbixcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGV2ZW50cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIHdoZW4gdGhlIG92ZXJsYXkgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG4gIFx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhIXRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IGluIGZyb250IG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSB0byB0aGUgYmFjayBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBwcmVwYXJlIGJvdW5kIG92ZXJsYXkgdG8gb3BlbjogdXBkYXRlIGxhdGxuZyBwb3MgLyBjb250ZW50IHNvdXJjZSAoZm9yIEZlYXR1cmVHcm91cClcclxuICBcdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgc291cmNlID0gdGhpcy5fc291cmNlO1xyXG4gIFx0XHRpZiAoIXNvdXJjZS5fbWFwKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG4gIFx0XHRcdHNvdXJjZSA9IG51bGw7XHJcbiAgXHRcdFx0dmFyIGxheWVycyA9IHRoaXMuX3NvdXJjZS5fbGF5ZXJzO1xyXG4gIFx0XHRcdGZvciAodmFyIGlkIGluIGxheWVycykge1xyXG4gIFx0XHRcdFx0aWYgKGxheWVyc1tpZF0uX21hcCkge1xyXG4gIFx0XHRcdFx0XHRzb3VyY2UgPSBsYXllcnNbaWRdO1xyXG4gIFx0XHRcdFx0XHRicmVhaztcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKCFzb3VyY2UpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIFVuYWJsZSB0byBnZXQgc291cmNlIGxheWVyLlxyXG5cclxuICBcdFx0XHQvLyBzZXQgb3ZlcmxheSBzb3VyY2UgdG8gdGhpcyBsYXllclxyXG4gIFx0XHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFsYXRsbmcpIHtcclxuICBcdFx0XHRpZiAoc291cmNlLmdldENlbnRlcikge1xyXG4gIFx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldENlbnRlcigpO1xyXG4gIFx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldExhdExuZykge1xyXG4gIFx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldExhdExuZygpO1xyXG4gIFx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldEJvdW5kcykge1xyXG4gIFx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHQvLyB1cGRhdGUgdGhlIG92ZXJsYXkgKGNvbnRlbnQsIGxheW91dCwgZXRjLi4uKVxyXG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG4gIFx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gIFx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuICBcdFx0Ly8gQHNlY3Rpb24gRGl2T3ZlcmxheSBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IGNvbnRlbnR1cGRhdGU6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkgaXMgdXBkYXRlZFxyXG4gIFx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgYm90dG9tID0gdGhpcy5fY29udGFpbmVyQm90dG9tID0gLW9mZnNldC55LFxyXG4gIFx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG4gIFx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIG92ZXJsYXkgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIFswLCAwXTtcclxuICBcdH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIE1hcC5pbmNsdWRlKHtcclxuICBcdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgY29udGVudCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciBvdmVybGF5ID0gY29udGVudDtcclxuICBcdFx0aWYgKCEob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykpIHtcclxuICBcdFx0XHRvdmVybGF5ID0gbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zKS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChsYXRsbmcpIHtcclxuICBcdFx0XHRvdmVybGF5LnNldExhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBvdmVybGF5O1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgTGF5ZXIuaW5jbHVkZSh7XHJcbiAgXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIG9sZCwgY29udGVudCwgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcbiAgXHRcdGlmIChvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSB7XHJcbiAgXHRcdFx0c2V0T3B0aW9ucyhvdmVybGF5LCBvcHRpb25zKTtcclxuICBcdFx0XHRvdmVybGF5Ll9zb3VyY2UgPSB0aGlzO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG92ZXJsYXkgPSAob2xkICYmICFvcHRpb25zKSA/IG9sZCA6IG5ldyBPdmVybGF5Q2xhc3Mob3B0aW9ucywgdGhpcyk7XHJcbiAgXHRcdFx0b3ZlcmxheS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBvdmVybGF5O1xyXG4gIFx0fVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIFBvcHVwXHJcbiAgICogQGluaGVyaXRzIERpdk92ZXJsYXlcclxuICAgKiBAYWthIEwuUG9wdXBcclxuICAgKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAgICogb3BlbiBwb3B1cHMgd2hpbGUgbWFraW5nIHN1cmUgdGhhdCBvbmx5IG9uZSBwb3B1cCBpcyBvcGVuIGF0IG9uZSB0aW1lXHJcbiAgICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAgICogYGBgXHJcbiAgICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAgICpcclxuICAgKiBBIHBvcHVwIGNhbiBiZSBhbHNvIHN0YW5kYWxvbmU6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwb3B1cCA9IEwucG9wdXAoKVxyXG4gICAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAgICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAgICogXHQub3Blbk9uKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICogb3JcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwb3B1cCA9IEwucG9wdXAobGF0bG5nLCB7Y29udGVudDogJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gICAqIFx0Lm9wZW5PbihtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4gIHZhciBQb3B1cCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0cGFuZTogJ3BvcHVwUGFuZScsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG4gIFx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi5cclxuICBcdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuICBcdFx0Ly8gTWF4IHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG4gIFx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuICBcdFx0Ly8gTWluIHdpZHRoIG9mIHRoZSBwb3B1cCwgaW4gcGl4ZWxzLlxyXG4gIFx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG4gIFx0XHQvLyBJZiBzZXQsIGNyZWF0ZXMgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0XHJcbiAgXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcbiAgXHRcdC8vIFRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBjYW4gYmUgc3R5bGVkIHVzaW5nIHRoZVxyXG4gIFx0XHQvLyBgbGVhZmxldC1wb3B1cC1zY3JvbGxlZGAgQ1NTIGNsYXNzIHNlbGVjdG9yLlxyXG4gIFx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuICBcdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcbiAgXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuICBcdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG4gIFx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcbiAgXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcbiAgXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuICBcdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICBcdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG4gIFx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuICBcdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuICBcdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcbiAgXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS5cclxuICBcdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHJcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG4gIFx0XHRcdG1hcC5yZW1vdmVMYXllcihtYXAuX3BvcHVwKTtcclxuICBcdFx0fVxyXG4gIFx0XHRtYXAuX3BvcHVwID0gdGhpcztcclxuXHJcbiAgXHRcdHJldHVybiBEaXZPdmVybGF5LnByb3RvdHlwZS5vcGVuT24uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG4gIFx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuICBcdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcbiAgXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JyxcclxuICBcdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG4gIFx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG4gIFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcbiAgXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ2NvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcbiAgXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl90aXAgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG4gIFx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gY3JlYXRlJDEoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpOyAvLyBvdmVycmlkZXMgdGhlIGltcGxpY2l0IHJvbGU9bGluayBvZiA8YT4gZWxlbWVudHMgIzczOTlcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2xvc2UgcG9wdXAnKTtcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjMjE1Ozwvc3Bhbj4nO1xyXG5cclxuICBcdFx0XHRvbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChldik7XHJcbiAgXHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcbiAgXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcbiAgXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcbiAgXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcbiAgXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICBcdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuICBcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcbiAgXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG4gIFx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG4gIFx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcbiAgXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG4gIFx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuICBcdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG4gIFx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG4gIFx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcbiAgXHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuICBcdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkgeyB0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpOyB9XHJcblxyXG4gIFx0XHQvLyBXZSBjYW4gZW5kbGVzc2x5IHJlY3Vyc2UgaWYga2VlcEluVmlldyBpcyBzZXQgYW5kIHRoZSB2aWV3IHJlc2V0cy5cclxuICBcdFx0Ly8gTGV0J3MgZ3VhcmQgYWdhaW5zdCB0aGF0IGJ5IGV4aXRpbmcgZWFybHkgaWYgd2UncmUgcmVzcG9uZGluZyB0byBvdXIgb3duIGF1dG9wYW4uXHJcbiAgXHRcdGlmICh0aGlzLl9hdXRvcGFubmluZykge1xyXG4gIFx0XHRcdHRoaXMuX2F1dG9wYW5uaW5nID0gZmFsc2U7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG4gIFx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG4gIFx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuICBcdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcbiAgXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcbiAgXHRcdGxheWVyUG9zLl9hZGQoZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuICBcdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcbiAgXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcbiAgXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBkeCA9IDAsXHJcbiAgXHRcdCAgICBkeSA9IDA7XHJcblxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcbiAgXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG4gIFx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuICBcdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcbiAgXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuICBcdFx0aWYgKGR4IHx8IGR5KSB7XHJcbiAgXHRcdFx0Ly8gVHJhY2sgdGhhdCB3ZSdyZSBhdXRvcGFubmluZywgYXMgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlLXJhbiBvbiBtb3ZlZW5kXHJcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IHRydWU7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHRtYXBcclxuICBcdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcbiAgXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb3B1cChsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXHJcbiAgdmFyIHBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG4gIFx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKiBAbmFtZXNwYWNlIE1hcFxyXG4gICAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICAgKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gICAqIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHBvcHVwcyB0byBjbG9zZSB3aGVuIHVzZXIgY2xpY2tzIHRoZSBtYXAuXHJcbiAgICovXHJcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XHJcbiAgXHRjbG9zZVBvcHVwT25DbGljazogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXBcclxuICAvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG4gIFx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCBwb3B1cCB3aGlsZSBjbG9zaW5nIHRoZSBwcmV2aW91c2x5IG9wZW5lZCAodG8gbWFrZSBzdXJlIG9ubHkgb25lIGlzIG9wZW5lZCBhdCBvbmUgdGltZSBmb3IgdXNhYmlsaXR5KS5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBDcmVhdGVzIGEgcG9wdXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW5zIGl0IGluIHRoZSBnaXZlbiBwb2ludCBvbiBhIG1hcC5cclxuICBcdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5faW5pdE92ZXJsYXkoUG9wdXAsIHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpXHJcbiAgXHRcdCAgLm9wZW5Pbih0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAocG9wdXA/OiBQb3B1cCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG4gIFx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcbiAgXHRcdHBvcHVwID0gYXJndW1lbnRzLmxlbmd0aCA/IHBvcHVwIDogdGhpcy5fcG9wdXA7XHJcbiAgXHRcdGlmIChwb3B1cCkge1xyXG4gIFx0XHRcdHBvcHVwLmNsb3NlKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBMYXllclxyXG4gICAqIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHMgZXhhbXBsZVxyXG4gICAqXHJcbiAgICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gICAqIGxheWVyLm9wZW5Qb3B1cCgpO1xyXG4gICAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gICAqL1xyXG5cclxuICAvLyBAc2VjdGlvbiBQb3B1cCBtZXRob2RzXHJcbiAgTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIEJpbmRzIGEgcG9wdXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXHJcbiAgXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG4gIFx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcbiAgXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX3BvcHVwID0gdGhpcy5faW5pdE92ZXJsYXkoUG9wdXAsIHRoaXMuX3BvcHVwLCBjb250ZW50LCBvcHRpb25zKTtcclxuICBcdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcclxuICBcdFx0XHR0aGlzLm9uKHtcclxuICBcdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcbiAgXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuICBcdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG4gIFx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kUG9wdXBgLlxyXG4gIFx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5vZmYoe1xyXG4gIFx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuICBcdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG4gIFx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcbiAgXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuICBcdFx0XHR9KTtcclxuICBcdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSBmYWxzZTtcclxuICBcdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuICBcdC8vIE9wZW5zIHRoZSBib3VuZCBwb3B1cCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXHJcbiAgXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkpIHtcclxuICBcdFx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSB0aGlzO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAodGhpcy5fcG9wdXAuX3ByZXBhcmVPcGVuKGxhdGxuZyB8fCB0aGlzLl9sYXRsbmcpKSB7XHJcbiAgXHRcdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXHJcbiAgXHRcdFx0XHR0aGlzLl9wb3B1cC5vcGVuT24odGhpcy5fbWFwKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xvc2VQb3B1cCgpOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuICBcdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAuY2xvc2UoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGVQb3B1cCgpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG4gIFx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAudG9nZ2xlKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG4gIFx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFBvcHVwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8UG9wdXApOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG4gIFx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG4gIFx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8ICF0aGlzLl9tYXApIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuICBcdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcclxuICBcdFx0c3RvcChlKTtcclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXAuX3NvdXJjZSA9PT0gdGFyZ2V0ICYmICEodGFyZ2V0IGluc3RhbmNlb2YgUGF0aCkpIHtcclxuICBcdFx0XHQvLyB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcbiAgXHRcdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG4gIFx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXRsbmcpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRhcmdldDtcclxuICBcdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZVBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25LZXlQcmVzczogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG4gIFx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBUb29sdGlwXG4gICAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gICAqIEBha2EgTC5Ub29sdGlwXG4gICAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgdG9vbHRpcCB0byBtYXJrZXI6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICAgKiBgYGBcbiAgICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFRvb2x0aXBgIG1ldGhvZC5cbiAgICpcbiAgICogQSB0b29sdGlwIGNhbiBiZSBhbHNvIHN0YW5kYWxvbmU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciB0b29sdGlwID0gTC50b29sdGlwKClcbiAgICogXHQuc2V0TGF0TG5nKGxhdGxuZylcbiAgICogXHQuc2V0Q29udGVudCgnSGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgdG9vbHRpcC4nKVxuICAgKiBcdC5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICogb3JcbiAgICogYGBganNcbiAgICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAobGF0bG5nLCB7Y29udGVudDogJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJ30pXG4gICAqIFx0LmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKlxuICAgKlxuICAgKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAgICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldHRpbmc6XG4gICAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICAgKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICAgKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICAgKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gICAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICAgKi9cblxuXG4gIC8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuICB2YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0b29sdGlwUGFuZSdcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cbiAgXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDApXG4gIFx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG4gIFx0XHRvZmZzZXQ6IFswLCAwXSxcblxuICBcdFx0Ly8gQG9wdGlvbiBkaXJlY3Rpb246IFN0cmluZyA9ICdhdXRvJ1xuICBcdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcbiAgXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cbiAgXHRcdC8vIGBhdXRvYCB3aWxsIGR5bmFtaWNhbGx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcbiAgXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG4gIFx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuICBcdFx0cGVybWFuZW50OiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuICBcdFx0c3RpY2t5OiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcbiAgXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG4gIFx0XHRvcGFjaXR5OiAwLjlcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG4gIFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuICBcdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuICBcdFx0XHR0aGlzLmFkZEV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuICBcdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcbiAgXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuICBcdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgXHRcdFx0dGhpcy5yZW1vdmVFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLnBlcm1hbmVudCkge1xuICBcdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLmNsb3NlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuICBcdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cbiAgXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSk7XG5cbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xuICBcdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCAnbGVhZmxldC10b29sdGlwLScgKyBzdGFtcCh0aGlzKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIFx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHZhciBzdWJYLCBzdWJZLFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG4gIFx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuICBcdFx0ICAgIHRvb2x0aXBQb2ludCA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChwb3MpLFxuICBcdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG4gIFx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuICBcdFx0ICAgIHRvb2x0aXBIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuICBcdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cbiAgXHRcdGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodDtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IDA7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gIFx0XHRcdHN1YlggPSAwO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGg7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSBpZiAodG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG4gIFx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gIFx0XHRcdHN1YlggPSAwO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggKyAob2Zmc2V0LnggKyBhbmNob3IueCkgKiAyO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9XG5cbiAgXHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHN1YlgsIHN1YlksIHRydWUpKS5hZGQob2Zmc2V0KS5hZGQoYW5jaG9yKTtcblxuICBcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuICBcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXRvcCcpO1xuICBcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuICBcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBwb3MpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG4gIFx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuICBcdH0sXG5cbiAgXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG4gIFx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuICBcdH0sXG5cbiAgXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG4gIFx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuICBcdH1cblxuICB9KTtcblxuICAvLyBAbmFtZXNwYWNlIFRvb2x0aXBcbiAgLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBgVG9vbHRpcGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG4gIC8vIEBhbHRlcm5hdGl2ZVxuICAvLyBAZmFjdG9yeSBMLnRvb2x0aXAobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBvcGVuIGFuZCBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbi5cbiAgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIFx0cmV0dXJuIG5ldyBUb29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG4gIH07XG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICBNYXAuaW5jbHVkZSh7XG5cbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCB0b29sdGlwLlxuICBcdC8vIEBhbHRlcm5hdGl2ZVxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBDcmVhdGVzIGEgdG9vbHRpcCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbiBpdC5cbiAgXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuICBcdFx0dGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKVxuICBcdFx0ICAub3Blbk9uKHRoaXMpO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcbiAgXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuICBcdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcbiAgXHRcdHRvb2x0aXAuY2xvc2UoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH1cblxuICB9KTtcblxuICAvKlxuICAgKiBAbmFtZXNwYWNlIExheWVyXG4gICAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gICAqXG4gICAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gICAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gICAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICAgKiBgYGBcbiAgICovXG5cbiAgLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG4gIExheWVyLmluY2x1ZGUoe1xuXG4gIFx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG4gIFx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcbiAgXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cbiAgXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5pc1Rvb2x0aXBPcGVuKCkpIHtcbiAgXHRcdFx0dGhpcy51bmJpbmRUb29sdGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3Rvb2x0aXAgPSB0aGlzLl9pbml0T3ZlcmxheShUb29sdGlwLCB0aGlzLl90b29sdGlwLCBjb250ZW50LCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcbiAgXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuICBcdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuICBcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuICBcdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcbiAgXHRcdGlmICghcmVtb3ZlICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuICBcdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuICBcdFx0ICAgIGV2ZW50cyA9IHtcbiAgXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcbiAgXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcbiAgXHRcdCAgICB9O1xuICBcdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG4gIFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuICBcdFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnMoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRldmVudHMuYWRkID0gdGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnM7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcbiAgXHRcdH1cbiAgXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG4gIFx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuICBcdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSkge1xuICBcdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IHRoaXM7XG4gIFx0XHRcdH1cbiAgXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX3ByZXBhcmVPcGVuKGxhdGxuZykpIHtcbiAgXHRcdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcbiAgXHRcdFx0XHR0aGlzLl90b29sdGlwLm9wZW5Pbih0aGlzLl9tYXApO1xuXG4gIFx0XHRcdFx0aWYgKHRoaXMuZ2V0RWxlbWVudCkge1xuICBcdFx0XHRcdFx0dGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcih0aGlzKTtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZWFjaExheWVyKSB7XG4gIFx0XHRcdFx0XHR0aGlzLmVhY2hMYXllcih0aGlzLl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyLCB0aGlzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCgpOiB0aGlzXG4gIFx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cbiAgXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLl90b29sdGlwLmNsb3NlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG4gIFx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuICBcdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAudG9nZ2xlKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNUb29sdGlwT3BlbigpOiBib29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cbiAgXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG4gIFx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG4gIFx0Z2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG4gIFx0fSxcblxuICBcdF9hZGRGb2N1c0xpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuZ2V0RWxlbWVudCkge1xuICBcdFx0XHR0aGlzLl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIodGhpcyk7XG4gIFx0XHR9IGVsc2UgaWYgKHRoaXMuZWFjaExheWVyKSB7XG4gIFx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllciwgdGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGVsID0gdHlwZW9mIGxheWVyLmdldEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgbGF5ZXIuZ2V0RWxlbWVudCgpO1xuICBcdFx0aWYgKGVsKSB7XG4gIFx0XHRcdG9uKGVsLCAnZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG4gIFx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuICBcdFx0XHR9LCB0aGlzKTtcbiAgXHRcdFx0b24oZWwsICdibHVyJywgdGhpcy5jbG9zZVRvb2x0aXAsIHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgZWwgPSB0eXBlb2YgbGF5ZXIuZ2V0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXllci5nZXRFbGVtZW50KCk7XG4gIFx0XHRpZiAoZWwpIHtcbiAgXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLmlkKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG5cbiAgXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElmIHRoZSBtYXAgaXMgbW92aW5nLCB3ZSB3aWxsIHNob3cgdGhlIHRvb2x0aXAgYWZ0ZXIgaXQncyBkb25lLlxuICBcdFx0aWYgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgJiYgIXRoaXMuX29wZW5PbmNlRmxhZykge1xuICBcdFx0XHR0aGlzLl9vcGVuT25jZUZsYWcgPSB0cnVlO1xuICBcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG4gIFx0XHRcdHRoaXMuX21hcC5vbmNlKCdtb3ZlZW5kJywgZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHRoYXQuX29wZW5PbmNlRmxhZyA9IGZhbHNlO1xuICBcdFx0XHRcdHRoYXQuX29wZW5Ub29sdGlwKGUpO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG4gIFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG4gIFx0fSxcblxuICBcdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcbiAgXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG4gIFx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIERpdkljb25cbiAgICogQGFrYSBMLkRpdkljb25cbiAgICogQGluaGVyaXRzIEljb25cbiAgICpcbiAgICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAgICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gICAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gICAqXG4gICAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gICAqL1xuXG4gIHZhciBEaXZJY29uID0gSWNvbi5leHRlbmQoe1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBzZWN0aW9uXG4gIFx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuICBcdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuICBcdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcbiAgXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZ3xIVE1MRWxlbWVudCA9ICcnXG4gIFx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuICBcdFx0Ly8gYW4gaW5zdGFuY2Ugb2YgYEhUTUxFbGVtZW50YC5cbiAgXHRcdGh0bWw6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuICBcdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuICBcdFx0YmdQb3M6IG51bGwsXG5cbiAgXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG4gIFx0fSxcblxuICBcdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG4gIFx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0aWYgKG9wdGlvbnMuaHRtbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgXHRcdFx0ZW1wdHkoZGl2KTtcbiAgXHRcdFx0ZGl2LmFwcGVuZENoaWxkKG9wdGlvbnMuaHRtbCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuICBcdFx0XHR2YXIgYmdQb3MgPSB0b1BvaW50KG9wdGlvbnMuYmdQb3MpO1xuICBcdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuICBcdFx0cmV0dXJuIGRpdjtcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xuICB9XG5cbiAgSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5cbiAgLypcbiAgICogQGNsYXNzIEdyaWRMYXllclxuICAgKiBAaW5oZXJpdHMgTGF5ZXJcbiAgICogQGFrYSBMLkdyaWRMYXllclxuICAgKlxuICAgKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gICAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAgICpcbiAgICpcbiAgICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gICAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICAgKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAgICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAgICpcbiAgICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gICAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gICAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAgICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAgICpcbiAgICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICAgKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAgICogICAgICAgICByZXR1cm4gdGlsZTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gICAqICAgICAgICAgdmFyIGVycm9yO1xuICAgKlxuICAgKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAgICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAgICpcbiAgICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gICAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gICAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAgICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAgICpcbiAgICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gICAqICAgICAgICAgfSwgMTAwMCk7XG4gICAqXG4gICAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHNlY3Rpb25cbiAgICovXG5cblxuICB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuICBcdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuICBcdFx0dGlsZVNpemU6IDI1NixcblxuICBcdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcbiAgXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG4gIFx0XHRvcGFjaXR5OiAxLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG4gIFx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuICBcdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cbiAgXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG4gIFx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuICBcdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG4gIFx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG4gIFx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuICBcdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcbiAgXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG4gIFx0XHR6SW5kZXg6IDEsXG5cbiAgXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcbiAgXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cbiAgXHRcdGJvdW5kczogbnVsbCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG4gIFx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cbiAgXHRcdG1pblpvb206IDAsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG4gIFx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG4gIFx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuICBcdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuICBcdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuICBcdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuICBcdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuICBcdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuICBcdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuICBcdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcbiAgXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG4gIFx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuICBcdFx0bm9XcmFwOiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG4gIFx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcbiAgXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuICBcdFx0Y2xhc3NOYW1lOiAnJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG4gIFx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG4gIFx0XHRrZWVwQnVmZmVyOiAyXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG4gIFx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcbiAgXHRcdHRoaXMuX3RpbGVzID0ge307XG5cbiAgXHRcdHRoaXMuX3Jlc2V0VmlldygpOyAvLyBpbXBsaWNpdCBfdXBkYXRlKCkgY2FsbFxuICBcdH0sXG5cbiAgXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICBcdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG4gIFx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cbiAgXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuICBcdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuICBcdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0XHR2YXIgdGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGhpcy5fbWFwLmdldFpvb20oKSk7XG4gIFx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pIHtcbiAgXHRcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuICBcdFx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IHtcbiAgXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0VmlldyxcbiAgXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuICBcdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcbiAgXHRcdH07XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG4gIFx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuICBcdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuICBcdFx0XHRcdHRoaXMuX29uTW92ZSA9IHRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICBcdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cbiAgXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG4gIFx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuICBcdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuICBcdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuICBcdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG4gIFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG4gIFx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuICBcdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG4gIFx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcbiAgXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcbiAgXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICBcdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuICBcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuICBcdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuICBcdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuICBcdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuICBcdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG4gIFx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG4gIFx0XHRcdGlmIChmYWRlIDwgMSkge1xuICBcdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG4gIFx0XHRpZiAobmV4dEZyYW1lKSB7XG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuICBcdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25PcGFxdWVUaWxlOiBmYWxzZUZuLFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuICBcdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuICBcdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHogPSBOdW1iZXIoeik7XG4gIFx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcbiAgXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcbiAgXHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuICBcdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuICBcdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG4gIFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gIFx0XHRpZiAoIWxldmVsKSB7XG4gIFx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cbiAgXHRcdFx0bGV2ZWwuZWwgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuICBcdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcbiAgXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cbiAgXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuICBcdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuICBcdFx0XHRmYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuICBcdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuICBcdFx0cmV0dXJuIGxldmVsO1xuICBcdH0sXG5cbiAgXHRfb25VcGRhdGVMZXZlbDogZmFsc2VGbixcblxuICBcdF9vblJlbW92ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X29uQ3JlYXRlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIga2V5LCB0aWxlO1xuXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gIFx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG4gIFx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuICBcdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcbiAgXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcbiAgXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG4gIFx0XHRcdFx0Y29udGludWU7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHRyZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcbiAgXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIoeikpO1xuICBcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuICBcdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG4gIFx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcbiAgXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuICBcdFx0ICAgIHoyID0geiAtIDEsXG4gIFx0XHQgICAgY29vcmRzMiA9IG5ldyBQb2ludCgreDIsICt5Mik7XG4gIFx0XHRjb29yZHMyLnogPSArejI7XG5cbiAgXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG4gIFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh6MiA+IG1pblpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH0sXG5cbiAgXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cbiAgXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG4gIFx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuICBcdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cbiAgXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG4gIFx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG4gIFx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG4gIFx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gIFx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuICBcdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG4gIFx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuICBcdH0sXG5cbiAgXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB6b29tO1xuICBcdH0sXG5cbiAgXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcbiAgXHRcdHZhciB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG4gIFx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcbiAgXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuICBcdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRpbGVab29tKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuICBcdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuICBcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG4gIFx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcbiAgXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuICBcdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuICBcdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFub1BydW5lKSB7XG4gIFx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcbiAgXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG4gIFx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG4gIFx0fSxcblxuICBcdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcbiAgXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcbiAgXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuICBcdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcbiAgXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICBcdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG4gIFx0XHRpZiAoYm91bmRzKSB7XG4gIFx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG4gIFx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSxcbiAgXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcbiAgXHRcdF07XG4gIFx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcbiAgXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuICBcdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuICBcdFx0XTtcbiAgXHR9LFxuXG4gIFx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShtYXBab29tLCB0aGlzLl90aWxlWm9vbSksXG4gIFx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuICBcdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuICBcdH0sXG5cbiAgXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuICBcdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX2NsYW1wWm9vbShtYXAuZ2V0Wm9vbSgpKTtcblxuICBcdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuICBcdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cbiAgXHRcdHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcbiAgXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcbiAgXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuICBcdFx0ICAgIHF1ZXVlID0gW10sXG4gIFx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG4gIFx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcbiAgXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG4gIFx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cbiAgXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcbiAgXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueSkgJiZcbiAgXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcbiAgXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG4gIFx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcbiAgXHRcdFx0XHR0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG4gIFx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuICBcdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cbiAgXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuICBcdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuICBcdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG4gIFx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcbiAgXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG4gIFx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcbiAgXHRcdFx0XHRpZiAodGlsZSkge1xuICBcdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcbiAgXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gIFx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcbiAgXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG4gIFx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG4gIFx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG4gIFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuICBcdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cbiAgXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG4gIFx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG4gIFx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG4gIFx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG4gIFx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuICBcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuICBcdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcbiAgXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcbiAgXHR9LFxuXG4gIFx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcbiAgXHR9LFxuXG4gIFx0X3RpbGVDb29yZHNUb053U2U6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG4gIFx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcbiAgXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuICBcdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG4gIFx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcbiAgXHRcdHJldHVybiBbbncsIHNlXTtcbiAgXHR9LFxuXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICBcdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcbiAgXHRcdCAgICBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKGJwWzBdLCBicFsxXSk7XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuICBcdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIGJvdW5kcztcbiAgXHR9LFxuICBcdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuICBcdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG4gIFx0fSxcblxuICBcdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG4gIFx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuICBcdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcbiAgXHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcbiAgXHRcdGNvb3Jkcy56ID0gK2tbMl07XG4gIFx0XHRyZXR1cm4gY29vcmRzO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuICBcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG4gIFx0XHRyZW1vdmUodGlsZS5lbCk7XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG4gIFx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuICBcdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuICBcdFx0XHR0aWxlOiB0aWxlLmVsLFxuICBcdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuICBcdFx0YWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG4gIFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gIFx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG4gIFx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG4gIFx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICBcdFx0dGlsZS5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG5cbiAgXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcbiAgXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuICBcdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gIFx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuICBcdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cbiAgXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG4gIFx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG4gIFx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcbiAgXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cbiAgXHRcdFx0cmVxdWVzdEFuaW1GcmFtZShiaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG4gIFx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcbiAgXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG4gIFx0XHRcdGVsOiB0aWxlLFxuICBcdFx0XHRjb29yZHM6IGNvb3JkcyxcbiAgXHRcdFx0Y3VycmVudDogdHJ1ZVxuICBcdFx0fTtcblxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuICBcdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cbiAgXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcbiAgXHRcdFx0dGlsZTogdGlsZSxcbiAgXHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcbiAgXHRcdGlmIChlcnIpIHtcbiAgXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cbiAgXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG4gIFx0XHRcdFx0ZXJyb3I6IGVycixcbiAgXHRcdFx0XHR0aWxlOiB0aWxlLFxuICBcdFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cbiAgXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuICBcdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG4gIFx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuICBcdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuICBcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghZXJyKSB7XG4gIFx0XHRcdGFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cbiAgXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG4gIFx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG4gIFx0XHRcdFx0dGlsZTogdGlsZS5lbCxcbiAgXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuICBcdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gIFx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cbiAgXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cbiAgXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG4gIFx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG4gIFx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG4gIFx0XHRcdFx0c2V0VGltZW91dChiaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuICBcdH0sXG5cbiAgXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcbiAgXHRcdFx0dGhpcy5fd3JhcFggPyB3cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcbiAgXHRcdFx0dGhpcy5fd3JhcFkgPyB3cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG4gIFx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuICBcdFx0cmV0dXJuIG5ld0Nvb3JkcztcbiAgXHR9LFxuXG4gIFx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKFxuICBcdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcbiAgXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcbiAgXHR9LFxuXG4gIFx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGdyaWRMYXllcihvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICAgKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAgICogQGFrYSBMLlRpbGVMYXllclxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwudGlsZUxheWVyKCdodHRwczovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnfSkuYWRkVG8obWFwKTtcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogJ2h0dHBzOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICAgKlxyXG4gICAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICB2YXIgVGlsZUxheWVyID0gR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG4gIFx0XHRtaW5ab29tOiAwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG4gIFx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcbiAgXHRcdG1heFpvb206IDE4LFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG4gIFx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICBcdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuICBcdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG4gIFx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG4gIFx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuICBcdFx0dG1zOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcbiAgXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcbiAgXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJlZmVycmVyUG9saWN5OiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLlxyXG4gIFx0XHQvLyBUaGlzIG1heSBiZSBuZWVkZWQgaWYgeW91ciBtYXAncyByZW5kZXJpbmcgY29udGV4dCBoYXMgYSBzdHJpY3QgZGVmYXVsdCBidXQgeW91ciB0aWxlIHByb3ZpZGVyIGV4cGVjdHMgYSB2YWxpZCByZWZlcnJlclxyXG4gIFx0XHQvLyAoZS5nLiB0byB2YWxpZGF0ZSBhbiBBUEkgdG9rZW4pLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbSFRNTEltYWdlRWxlbWVudC5yZWZlcnJlclBvbGljeV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQvcmVmZXJyZXJQb2xpY3kpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRyZWZlcnJlclBvbGljeTogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcbiAgXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG4gIFx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcbiAgXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuICBcdFx0XHRcdG9wdGlvbnMubWF4Wm9vbSA9IE1hdGgubWF4KG9wdGlvbnMubWluWm9vbSwgb3B0aW9ucy5tYXhab29tIC0gMSk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCBvcHRpb25zLm1pblpvb20gKyAxKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcbiAgXHRcdH0gZWxzZSBpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuICBcdFx0XHQvLyBtYWtlIHN1cmUgbWF4Wm9vbSBpcyBndGUgbWluWm9vbVxyXG4gIFx0XHRcdG9wdGlvbnMubWF4Wm9vbSA9IE1hdGgubWF4KG9wdGlvbnMubWluWm9vbSwgb3B0aW9ucy5tYXhab29tKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyBtYWtlIHN1cmUgbWluWm9vbSBpcyBsdGUgbWF4Wm9vbVxyXG4gIFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcbiAgXHQvLyBJZiB0aGUgVVJMIGRvZXMgbm90IGNoYW5nZSwgdGhlIGxheWVyIHdpbGwgbm90IGJlIHJlZHJhd24gdW5sZXNzXHJcbiAgXHQvLyB0aGUgbm9SZWRyYXcgcGFyYW1ldGVyIGlzIHNldCB0byBmYWxzZS5cclxuICBcdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuICBcdFx0aWYgKHRoaXMuX3VybCA9PT0gdXJsICYmIG5vUmVkcmF3ID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHRub1JlZHJhdyA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdGlmICghbm9SZWRyYXcpIHtcclxuICBcdFx0XHR0aGlzLnJlZHJhdygpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcbiAgXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcbiAgXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcbiAgXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcbiAgXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG4gIFx0XHRvbih0aWxlLCAnbG9hZCcsIGJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG4gIFx0XHRvbih0aWxlLCAnZXJyb3InLCBiaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuICBcdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGZvciB0aGlzIG5ldyBvcHRpb24gd2UgZm9sbG93IHRoZSBkb2N1bWVudGVkIGJlaGF2aW9yXHJcbiAgXHRcdC8vIG1vcmUgY2xvc2VseSBieSBvbmx5IHNldHRpbmcgdGhlIHByb3BlcnR5IHdoZW4gc3RyaW5nXHJcbiAgXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5ID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdHRpbGUucmVmZXJyZXJQb2xpY3kgPSB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3k7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIFRoZSBhbHQgYXR0cmlidXRlIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nLFxyXG4gIFx0XHQvLyBhbGxvd2luZyBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhlIGRlY29yYXRpdmUgaW1hZ2UgdGlsZXMuXHJcbiAgXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvdHV0b3JpYWxzL2ltYWdlcy9kZWNvcmF0aXZlL1xyXG4gIFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hcmlhLyNlbC1pbWctZW1wdHktYWx0XHJcbiAgXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG4gIFx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRpbGU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAgXHQvLyBAdW5pbmhlcml0YWJsZVxyXG4gIFx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuICBcdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG4gIFx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcbiAgXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcbiAgXHRcdHZhciBkYXRhID0ge1xyXG4gIFx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuICBcdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuICBcdFx0XHR4OiBjb29yZHMueCxcclxuICBcdFx0XHR5OiBjb29yZHMueSxcclxuICBcdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuICBcdFx0fTtcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcbiAgXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcbiAgXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0ZW1wbGF0ZSh0aGlzLl91cmwsIGV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcbiAgXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcbiAgXHRcdFx0c2V0VGltZW91dChiaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuICBcdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuICBcdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuICBcdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGRvbmUoZSwgdGlsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG4gIFx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcbiAgXHRcdHpvb21SZXZlcnNlID0gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlLFxyXG4gIFx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG4gIFx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuICBcdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG4gIFx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuICBcdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGksIHRpbGU7XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuICBcdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcbiAgXHRcdFx0XHR0aWxlLm9ubG9hZCA9IGZhbHNlRm47XHJcbiAgXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBmYWxzZUZuO1xyXG5cclxuICBcdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG4gIFx0XHRcdFx0XHR0aWxlLnNyYyA9IGVtcHR5SW1hZ2VVcmw7XHJcbiAgXHRcdFx0XHRcdHZhciBjb29yZHMgPSB0aGlzLl90aWxlc1tpXS5jb29yZHM7XHJcbiAgXHRcdFx0XHRcdHJlbW92ZSh0aWxlKTtcclxuICBcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG4gIFx0XHRcdFx0XHQvLyBAZXZlbnQgdGlsZWFib3J0OiBUaWxlRXZlbnRcclxuICBcdFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgd2FzIGxvYWRpbmcgYnV0IGlzIG5vdyBub3Qgd2FudGVkLlxyXG4gIFx0XHRcdFx0XHR0aGlzLmZpcmUoJ3RpbGVhYm9ydCcsIHtcclxuICBcdFx0XHRcdFx0XHR0aWxlOiB0aWxlLFxyXG4gIFx0XHRcdFx0XHRcdGNvb3JkczogY29vcmRzXHJcbiAgXHRcdFx0XHRcdH0pO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xyXG4gIFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdC8vIENhbmNlbHMgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHRpbGVcclxuICBcdFx0dGlsZS5lbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGVtcHR5SW1hZ2VVcmwpO1xyXG5cclxuICBcdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZVRpbGUuY2FsbCh0aGlzLCBrZXkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgKHRpbGUgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSBlbXB0eUltYWdlVXJsKSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuICBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAgICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gICAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAgICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAgICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAgICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gICAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG4gIFx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG4gIFx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuICBcdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwczovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG4gIFx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG4gIFx0XHRzZXJ2aWNlOiAnV01TJyxcclxuICBcdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG4gIFx0XHRsYXllcnM6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcbiAgXHRcdHN0eWxlczogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcbiAgXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG4gIFx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcbiAgXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG4gIFx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuICBcdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcbiAgXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcbiAgXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG4gIFx0XHRjcnM6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcbiAgXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcbiAgXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG4gIFx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG4gIFx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dmFyIHJlYWxSZXRpbmEgPSBvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xyXG4gIFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcbiAgXHRcdHdtc1BhcmFtcy53aWR0aCA9IHRpbGVTaXplLnggKiByZWFsUmV0aW5hO1xyXG4gIFx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG4gIFx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcbiAgXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG4gIFx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcbiAgXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG4gIFx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuICBcdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcbiAgXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxyXG4gIFx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG4gIFx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuICBcdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuICBcdFx0ICAgIFttaW4ueSwgbWluLngsIG1heC55LCBtYXgueF0gOlxyXG4gIFx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG4gIFx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuICBcdFx0cmV0dXJuIHVybCArXHJcbiAgXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG4gIFx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG4gIFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuICBcdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuICBcdFx0aWYgKCFub1JlZHJhdykge1xyXG4gIFx0XHRcdHRoaXMucmVkcmF3KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpO1xyXG4gIH1cblxuICBUaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xuICB0aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBSZW5kZXJlclxuICAgKiBAaW5oZXJpdHMgTGF5ZXJcbiAgICogQGFrYSBMLlJlbmRlcmVyXG4gICAqXG4gICAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gICAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICAgKlxuICAgKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gICAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICAgKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gICAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICAgKlxuICAgKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAgICpcbiAgICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAgICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAgICogaXRzIG1hcCBoYXMgbW92ZWRcbiAgICovXG5cbiAgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuICBcdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG4gIFx0XHRwYWRkaW5nOiAwLjFcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHRzdGFtcCh0aGlzKTtcbiAgXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gIFx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuICBcdFx0XHQvLyBhbHdheXMga2VlcCB0cmFuc2Zvcm0tb3JpZ2luIGFzIDAgMFxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0dGhpcy5vbigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcbiAgXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0ge1xuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuICBcdFx0XHR6b29tOiB0aGlzLl9vblpvb20sXG4gIFx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcbiAgXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG4gIFx0XHR9O1xuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X29uQW5pbVpvb206IGZ1bmN0aW9uIChldikge1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG4gIFx0fSxcblxuICBcdF9vblpvb206IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcbiAgXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXG4gIFx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQoY3VycmVudENlbnRlclBvaW50KVxuICBcdFx0XHRcdCAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSk7XG5cbiAgXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG4gIFx0XHRcdHNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fY2VudGVyLCB0aGlzLl96b29tKTtcblxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3VwZGF0ZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcbiAgXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG4gIFx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuICBcdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG4gIFx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKG1pbiwgbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKSkucm91bmQoKSk7XG5cbiAgXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIENhbnZhc1xuICAgKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAgICogQGFrYSBMLkNhbnZhc1xuICAgKlxuICAgKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICAgKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICAgKlxuICAgKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cHM6Ly9jYW5pdXNlLmNvbS9jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gICAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAgICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICAgKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICAgKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgQ2FudmFzIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuICBcdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGljayB0b2xlcmFuY2UgYXJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcC5cbiAgXHRcdHRvbGVyYW5jZTogMFxuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG4gIFx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG4gIFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG4gIFx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG4gIFx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuICBcdFx0dGhpcy5fZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gIFx0XHRvbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG4gIFx0XHRvbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICBcdFx0b24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG4gIFx0XHRjb250YWluZXJbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gPSB0cnVlO1xuXG4gIFx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jdHg7XG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGxheWVyO1xuICBcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG4gIFx0XHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3JlZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICBcdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcbiAgXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cbiAgXHRcdC8vIHNldCBjYW52YXMgc2l6ZSAoYWxzbyBjbGVhcmluZyBpdCk7IHVzZSBkb3VibGUgc2l6ZSBvbiByZXRpbmFcbiAgXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG4gIFx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcbiAgXHRcdGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG4gIFx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuICBcdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG4gIFx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG4gIFx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cbiAgXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcbiAgXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG4gIFx0fSxcblxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG4gIFx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykge1xuICBcdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblxuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuICBcdFx0XHRsYXllcjogbGF5ZXIsXG4gIFx0XHRcdHByZXY6IHRoaXMuX2RyYXdMYXN0LFxuICBcdFx0XHRuZXh0OiBudWxsXG4gIFx0XHR9O1xuICBcdFx0aWYgKHRoaXMuX2RyYXdMYXN0KSB7IHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjsgfVxuICBcdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcbiAgXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcbiAgXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuICBcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcbiAgXHRcdH1cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuICBcdFx0fVxuXG4gIFx0XHRkZWxldGUgbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuICBcdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cbiAgXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG4gIFx0XHRsYXllci5fcHJvamVjdCgpO1xuICBcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuICBcdFx0Ly8gVGhlIHJlZHJhdyB3aWxsIGV4dGVuZCB0aGUgcmVkcmF3IGJvdW5kc1xuICBcdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICh0eXBlb2YgbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkgPT09ICdzdHJpbmcnKSB7XG4gIFx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuICBcdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG4gIFx0XHRcdCAgICBkYXNoVmFsdWUsXG4gIFx0XHRcdCAgICBpO1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgXHRcdFx0XHRkYXNoVmFsdWUgPSBOdW1iZXIocGFydHNbaV0pO1xuICBcdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG4gIFx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG4gIFx0XHRcdFx0ZGFzaEFycmF5LnB1c2goZGFzaFZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG4gIFx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKGxheWVyLl9weEJvdW5kcykge1xuICBcdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cbiAgXHRcdGlmICh0aGlzLl9yZWRyYXdCb3VuZHMpIHtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuICBcdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG4gIFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuICBcdH0sXG5cbiAgXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG4gIFx0XHRpZiAoYm91bmRzKSB7XG4gIFx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuICBcdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG4gIFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcbiAgXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cbiAgXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG4gIFx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG4gIFx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcbiAgXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcblxuICBcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcbiAgXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGksIGosIGxlbjIsIHAsXG4gIFx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG4gIFx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuICBcdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuICBcdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG4gIFx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0aWYgKGNsb3NlZCkge1xuICBcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG4gIFx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cbiAgXHRcdGlmICghdGhpcy5fZHJhd2luZyB8fCBsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG4gIFx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuICBcdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcbiAgXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cbiAgXHRcdGlmIChzICE9PSAxKSB7XG4gIFx0XHRcdGN0eC5zYXZlKCk7XG4gIFx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcbiAgXHRcdH1cblxuICBcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuICBcdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cbiAgXHRcdGlmIChzICE9PSAxKSB7XG4gIFx0XHRcdGN0eC5yZXN0b3JlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG4gIFx0fSxcblxuICBcdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuICBcdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG4gIFx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuICBcdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuICBcdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG4gIFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG4gIFx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcbiAgXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG4gIFx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG4gIFx0XHRcdGN0eC5zdHJva2UoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG4gIFx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cbiAgXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgXHRcdFx0XHRpZiAoIShlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAncHJlY2xpY2snKSB8fCAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcbiAgXHRcdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0dGhpcy5fZmlyZUV2ZW50KGNsaWNrZWRMYXllciA/IFtjbGlja2VkTGF5ZXJdIDogZmFsc2UsIGUpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcbiAgXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuICBcdH0sXG5cblxuICBcdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcbiAgXHRcdGlmIChsYXllcikge1xuICBcdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG4gIFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcbiAgXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcbiAgXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG4gIFx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcbiAgXHRcdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSk7XG5cbiAgXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuICBcdFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuICBcdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuICBcdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maXJlRXZlbnQodGhpcy5faG92ZXJlZExheWVyID8gW3RoaXMuX2hvdmVyZWRMYXllcl0gOiBmYWxzZSwgZSk7XG5cbiAgXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuICBcdFx0c2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuICBcdFx0fSwgdGhpcyksIDMyKTtcbiAgXHR9LFxuXG4gIFx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuICBcdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBBbHJlYWR5IGxhc3RcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0aWYgKHByZXYpIHtcbiAgXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcbiAgXHRcdH0gZWxzZSBpZiAobmV4dCkge1xuICBcdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG4gIFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuICBcdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuICBcdFx0fVxuXG4gIFx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG4gIFx0XHR0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7XG5cbiAgXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuICBcdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cbiAgXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcbiAgXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuICBcdFx0aWYgKHByZXYpIHtcbiAgXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIEFscmVhZHkgZmlyc3RcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcbiAgXHRcdH0gZWxzZSBpZiAocHJldikge1xuICBcdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcbiAgXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG4gIFx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcbiAgXHRcdH1cblxuICBcdFx0b3JkZXIucHJldiA9IG51bGw7XG5cbiAgXHRcdG9yZGVyLm5leHQgPSB0aGlzLl9kcmF3Rmlyc3Q7XG4gIFx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5jYW52YXMob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgZnVuY3Rpb24gY2FudmFzKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbiAgfVxuXG4gIC8qXG4gICAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gICAqL1xuXG5cbiAgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIFx0dHJ5IHtcbiAgXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcbiAgXHRcdH07XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0Ly8gRG8gbm90IHJldHVybiBmbiBmcm9tIGNhdGNoIGJsb2NrIHNvIGBlYCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L3B1bGwvNzI3OVxuICBcdH1cbiAgXHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcbiAgXHR9O1xuICB9KSgpO1xuXG5cbiAgLypcbiAgICogQGNsYXNzIFNWR1xuICAgKlxuICAgKlxuICAgKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICAgKi9cblxuICAvLyBtaXhpbiB0byByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuICB2YXIgdm1sTWl4aW4gPSB7XG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG4gIFx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cbiAgXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICBcdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcbiAgXHRcdHJlbW92ZShjb250YWluZXIpO1xuICBcdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuICBcdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcbiAgXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcbiAgXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG4gIFx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG4gIFx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuICBcdFx0XHRpZiAoIXN0cm9rZSkge1xuICBcdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuICBcdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuICBcdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICBcdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcbiAgXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuICBcdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuICBcdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuICBcdFx0XHR9XG4gIFx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG4gIFx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG4gIFx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuICBcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcbiAgXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcbiAgXHRcdFx0aWYgKCFmaWxsKSB7XG4gIFx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuICBcdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuICBcdFx0fSBlbHNlIGlmIChmaWxsKSB7XG4gIFx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcbiAgXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG4gIFx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG4gIFx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG4gIFx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcbiAgXHR9LFxuXG4gIFx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuICBcdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcbiAgXHR9LFxuXG4gIFx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvQmFjayhsYXllci5fY29udGFpbmVyKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICogQGluaGVyaXRzIFJlbmRlcmVyXG4gICAqIEBha2EgTC5TVkdcbiAgICpcbiAgICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAgICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAgICpcbiAgICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vc3ZnKSwgU1ZHIGlzIG5vdFxuICAgKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICAgKlxuICAgKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICAgKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICAgKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gICAqIHRoaXMgY2FzZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAgICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAgICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cbiAgXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuICBcdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG4gIFx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuICBcdH0sXG5cbiAgXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIFx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gIFx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcbiAgXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG4gIFx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcbiAgXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcbiAgXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG4gIFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcbiAgXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG4gIFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcbiAgXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cbiAgXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG4gIFx0fSxcblxuICBcdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUoJ3BhdGgnKTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cbiAgXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuICBcdFx0XHRhZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG4gIFx0XHRcdGFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuICBcdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcbiAgXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0cmVtb3ZlKGxheWVyLl9wYXRoKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0bGF5ZXIuX3Byb2plY3QoKTtcbiAgXHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cbiAgXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuICBcdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG4gIFx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuICBcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG4gIFx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcbiAgXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuICBcdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcbiAgXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuICBcdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuICBcdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3NcbiAgXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuICBcdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuICBcdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcbiAgXHR9LFxuXG4gIFx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuICBcdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG4gIFx0fSxcblxuICBcdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9Gcm9udChsYXllci5fcGF0aCk7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX3BhdGgpO1xuICBcdH1cbiAgfSk7XG5cbiAgaWYgKEJyb3dzZXIudm1sKSB7XG4gIFx0U1ZHLmluY2x1ZGUodm1sTWl4aW4pO1xuICB9XG5cbiAgLy8gQG5hbWVzcGFjZSBTVkdcbiAgLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgZnVuY3Rpb24gc3ZnKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gQnJvd3Nlci5zdmcgfHwgQnJvd3Nlci52bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbiAgfVxuXG4gIE1hcC5pbmNsdWRlKHtcbiAgXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cbiAgXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuICBcdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cbiAgXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG4gIFx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG4gIFx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cbiAgXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG4gIFx0XHRpZiAoIXJlbmRlcmVyKSB7XG4gIFx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG4gIFx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHJlbmRlcmVyO1xuICBcdH0sXG5cbiAgXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcbiAgXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoe3BhbmU6IG5hbWV9KTtcbiAgXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHJlbmRlcmVyO1xuICBcdH0sXG5cbiAgXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKG9wdGlvbnMpKSB8fCBzdmcob3B0aW9ucyk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICAgKi9cblxuICAvKlxuICAgKiBAY2xhc3MgUmVjdGFuZ2xlXG4gICAqIEBha2EgTC5SZWN0YW5nbGVcbiAgICogQGluaGVyaXRzIFBvbHlnb25cbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gICAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gICAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICogYGBgXG4gICAqXG4gICAqL1xuXG5cbiAgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG4gIFx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcbiAgXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcbiAgXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuICBcdH0sXG5cbiAgXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG4gIFx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuICBcdFx0cmV0dXJuIFtcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG4gIFx0XHRdO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4gIGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgU1ZHLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgU1ZHLnBvaW50c1RvUGF0aCA9IHBvaW50c1RvUGF0aDtcblxuICBHZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbiAgR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuICBHZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyA9IGNvb3Jkc1RvTGF0TG5ncztcbiAgR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuICBHZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3JkcztcbiAgR2VvSlNPTi5nZXRGZWF0dXJlID0gZ2V0RmVhdHVyZTtcbiAgR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAgICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcbiAgXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cbiAgXHRib3hab29tOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuICBcdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG4gIFx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZSh0aGlzLl9wYW5lKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuICBcdH0sXG5cbiAgXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcbiAgXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcbiAgXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG4gIFx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG4gIFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG4gIFx0XHRkaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICBcdFx0ZGlzYWJsZUltYWdlRHJhZygpO1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHRvbihkb2N1bWVudCwge1xuICBcdFx0XHRjb250ZXh0bWVudTogc3RvcCxcbiAgXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuICBcdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuICBcdFx0XHR0aGlzLl9ib3ggPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG4gIFx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cbiAgXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcbiAgXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuICBcdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG4gIFx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcbiAgXHR9LFxuXG4gIFx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21vdmVkKSB7XG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9ib3gpO1xuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuICBcdFx0fVxuXG4gIFx0XHRlbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gIFx0XHRlbmFibGVJbWFnZURyYWcoKTtcblxuICBcdFx0b2ZmKGRvY3VtZW50LCB7XG4gIFx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuICBcdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuICBcdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG4gIFx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuICBcdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG4gIFx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuICBcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuICBcdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG4gIFx0XHR0aGlzLl9tYXBcbiAgXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG4gIFx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuICBcdH0sXG5cbiAgXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgXHRcdFx0dGhpcy5fZmluaXNoKCk7XG4gIFx0XHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4gIC8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuICBcdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuICBcdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuICBcdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cbiAgXHRkb3VibGVDbGlja1pvb206IHRydWVcbiAgfSk7XG5cbiAgdmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuICBcdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvL1xuICAvLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbiAgLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuICAvLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbiAgLy9cbiAgLy8gYGBganNcbiAgLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4gIC8vIGBgYFxuICAvL1xuICAvLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4gIC8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBEb3VibGVDbGlja1pvb20pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuICBcdGRyYWdnaW5nOiB0cnVlLFxuXG4gIFx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG4gIFx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuICBcdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG4gIFx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuICBcdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgXHRpbmVydGlhOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG4gIFx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuICBcdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG4gIFx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cbiAgXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cbiAgXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuICBcdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuICBcdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG4gIFx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2VcbiAgXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG4gIFx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcbiAgXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG4gIFx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cbiAgXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG4gIFx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcbiAgXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuICBcdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcbiAgXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuICBcdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuICBcdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG4gIH0pO1xuXG4gIHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuICBcdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcbiAgXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICBcdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdFx0fSwgdGhpcyk7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuICBcdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuICBcdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuICBcdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cbiAgXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuICBcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG4gIFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG4gIFx0fSxcblxuICBcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0bWFwLl9zdG9wKCk7XG4gIFx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuICBcdFx0XHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHModGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuICBcdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuICBcdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldFNvdXRoRWFzdCgpKS5tdWx0aXBseUJ5KC0xKVxuICBcdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cbiAgXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRtYXBcbiAgXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0JylcbiAgXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuICBcdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcbiAgXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuICBcdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG4gIFx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cbiAgXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX21hcFxuICBcdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcbiAgXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuICBcdH0sXG5cbiAgXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG4gIFx0XHR3aGlsZSAodGhpcy5fcG9zaXRpb25zLmxlbmd0aCA+IDEgJiYgdGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcbiAgXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG4gIFx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG4gIFx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuICBcdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcbiAgXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuICBcdH0sXG5cbiAgXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuICBcdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcbiAgXHR9LFxuXG4gIFx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuICBcdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG4gIFx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG4gIFx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG4gIFx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG4gIFx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcbiAgXHR9LFxuXG4gIFx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuICBcdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuICBcdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuICBcdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuICBcdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuICBcdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG4gIFx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcbiAgXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cbiAgXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IGUubm9JbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cbiAgXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cbiAgXHRcdGlmIChub0luZXJ0aWEpIHtcbiAgXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG4gIFx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG4gIFx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG4gIFx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG4gIFx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG4gIFx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuICBcdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcbiAgXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG4gIFx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcbiAgXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cbiAgXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcbiAgXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcbiAgXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuICBcdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuICBcdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcbiAgXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICAvLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcblxuICAvKlxuICAgKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcbiAgXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cbiAgXHRrZXlib2FyZDogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcbiAgXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cbiAgXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxuICB9KTtcblxuICB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cbiAgXHRrZXlDb2Rlczoge1xuICBcdFx0bGVmdDogICAgWzM3XSxcbiAgXHRcdHJpZ2h0OiAgIFszOV0sXG4gIFx0XHRkb3duOiAgICBbNDBdLFxuICBcdFx0dXA6ICAgICAgWzM4XSxcbiAgXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG4gIFx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuICBcdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG4gIFx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuICBcdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG4gIFx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcbiAgXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuICBcdFx0fVxuXG4gIFx0XHRvbihjb250YWluZXIsIHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcbiAgXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuICBcdFx0fSwgdGhpcyk7XG5cbiAgXHRcdHRoaXMuX21hcC5vbih7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3NcbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG4gIFx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cbiAgXHRcdH0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9tYXAub2ZmKHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG4gIFx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG4gIFx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG4gIFx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcbiAgXHR9LFxuXG4gIFx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG4gIFx0fSxcblxuICBcdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG4gIFx0fSxcblxuICBcdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG4gIFx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcbiAgXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG4gIFx0XHQgICAgaSwgbGVuO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcbiAgXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcbiAgXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG4gIFx0XHQgICAgaSwgbGVuO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG9mZnNldDtcblxuICBcdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG4gIFx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcbiAgXHRcdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG4gIFx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcbiAgXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcbiAgXHRcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQodG9Qb2ludChvZmZzZXQpLCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG4gIFx0XHRcdFx0XHR2YXIgbmV3TGF0TG5nID0gbWFwLndyYXBMYXRMbmcobWFwLnVucHJvamVjdChtYXAucHJvamVjdChtYXAuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSk7XG4gIFx0XHRcdFx0XHRtYXAucGFuVG8obmV3TGF0TG5nKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuICBcdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcbiAgXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRzdG9wKGUpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4gIC8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBNb3VzZSB3aGVlbCBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG4gIFx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuICBcdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG4gIFx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcbiAgXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cbiAgXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cbiAgXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG4gIFx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuICBcdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcbiAgXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cbiAgXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxuICB9KTtcblxuICB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cbiAgXHRcdHRoaXMuX2RlbHRhID0gMDtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGRlbHRhID0gZ2V0V2hlZWxEZWx0YShlKTtcblxuICBcdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cbiAgXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuICBcdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuICBcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBcdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuICBcdFx0c3RvcChlKTtcbiAgXHR9LFxuXG4gIFx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuICBcdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG4gIFx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG4gIFx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuICBcdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuICBcdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuICBcdFx0dGhpcy5fZGVsdGEgPSAwO1xuICBcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuICBcdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbiAgLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG5cbiAgLypcbiAgICogTC5NYXAuVGFwSG9sZCBpcyB1c2VkIHRvIHNpbXVsYXRlIGBjb250ZXh0bWVudWAgZXZlbnQgb24gbG9uZyBob2xkLFxuICAgKiB3aGljaCBvdGhlcndpc2UgaXMgbm90IGZpcmVkIGJ5IG1vYmlsZSBTYWZhcmkuXG4gICAqL1xuXG4gIHZhciB0YXBIb2xkRGVsYXkgPSA2MDA7XG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiB0YXBIb2xkOiBCb29sZWFuXG4gIFx0Ly8gRW5hYmxlcyBzaW11bGF0aW9uIG9mIGBjb250ZXh0bWVudWAgZXZlbnQsIGRlZmF1bHQgaXMgYHRydWVgIGZvciBtb2JpbGUgU2FmYXJpLlxuICBcdHRhcEhvbGQ6IEJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5zYWZhcmkgJiYgQnJvd3Nlci5tb2JpbGUsXG5cbiAgXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcbiAgXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuICBcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuICBcdHRhcFRvbGVyYW5jZTogMTVcbiAgfSk7XG5cbiAgdmFyIFRhcEhvbGQgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG4gIFx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuICBcdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cbiAgXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5fY2FuY2VsKCk7XG4gIFx0XHRcdGlmICghdGhpcy5faXNUYXBWYWxpZCgpKSB7IHJldHVybjsgfVxuXG4gIFx0XHRcdC8vIHByZXZlbnQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBodHRwczovL3czYy5naXRodWIuaW8vdG91Y2gtZXZlbnRzLyNtb3VzZS1ldmVudHNcbiAgXHRcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHByZXZlbnREZWZhdWx0KTtcbiAgXHRcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX2NhbmNlbENsaWNrUHJldmVudCk7XG4gIFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuICBcdFx0fSwgdGhpcyksIHRhcEhvbGREZWxheSk7XG5cbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfY2FuY2VsQ2xpY2tQcmV2ZW50OiBmdW5jdGlvbiBjYW5jZWxDbGlja1ByZXZlbnQoKSB7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHByZXZlbnREZWZhdWx0KTtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgY2FuY2VsQ2xpY2tQcmV2ZW50KTtcbiAgXHR9LFxuXG4gIFx0X2NhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG4gIFx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG4gIFx0fSxcblxuICBcdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcbiAgXHR9LFxuXG4gIFx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gIFx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCB7XG4gIFx0XHRcdGJ1YmJsZXM6IHRydWUsXG4gIFx0XHRcdGNhbmNlbGFibGU6IHRydWUsXG4gIFx0XHRcdHZpZXc6IHdpbmRvdyxcbiAgXHRcdFx0Ly8gZGV0YWlsOiAxLFxuICBcdFx0XHRzY3JlZW5YOiBlLnNjcmVlblgsXG4gIFx0XHRcdHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgXHRcdFx0Y2xpZW50WDogZS5jbGllbnRYLFxuICBcdFx0XHRjbGllbnRZOiBlLmNsaWVudFksXG4gIFx0XHRcdC8vIGJ1dHRvbjogMixcbiAgXHRcdFx0Ly8gYnV0dG9uczogMlxuICBcdFx0fSk7XG5cbiAgXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXG4gIFx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0YXBIb2xkOiBIYW5kbGVyXG4gIC8vIExvbmcgdGFwIGhhbmRsZXIgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCAodXNlZnVsIGluIG1vYmlsZSBTYWZhcmkpLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwSG9sZCcsIFRhcEhvbGQpO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcbiAgXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuICBcdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG4gIFx0Ly8gYnJvd3NlcnMuXG4gIFx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoLFxuXG4gIFx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG4gIFx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuICBcdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxuICB9KTtcblxuICB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuICBcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIFx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcbiAgXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG4gIFx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuICBcdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG4gIFx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuICBcdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcbiAgXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG4gIFx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuICBcdFx0bWFwLl9zdG9wKCk7XG5cbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcbiAgXHR9LFxuXG4gIFx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuICBcdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG4gIFx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuICBcdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cbiAgXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcbiAgXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcbiAgXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG4gIFx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG4gIFx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuICBcdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcbiAgXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cbiAgXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG4gIFx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG4gIFx0XHR2YXIgbW92ZUZuID0gYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0sIHVuZGVmaW5lZCk7XG4gIFx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG4gIFx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbiAgLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcblxuICBNYXAuQm94Wm9vbSA9IEJveFpvb207XG4gIE1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG4gIE1hcC5EcmFnID0gRHJhZztcbiAgTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG4gIE1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG4gIE1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbiAgTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuICBleHBvcnRzLkJvdW5kcyA9IEJvdW5kcztcbiAgZXhwb3J0cy5Ccm93c2VyID0gQnJvd3NlcjtcbiAgZXhwb3J0cy5DUlMgPSBDUlM7XG4gIGV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuICBleHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiAgZXhwb3J0cy5DaXJjbGVNYXJrZXIgPSBDaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbiAgZXhwb3J0cy5Db250cm9sID0gQ29udHJvbDtcbiAgZXhwb3J0cy5EaXZJY29uID0gRGl2SWNvbjtcbiAgZXhwb3J0cy5EaXZPdmVybGF5ID0gRGl2T3ZlcmxheTtcbiAgZXhwb3J0cy5Eb21FdmVudCA9IERvbUV2ZW50O1xuICBleHBvcnRzLkRvbVV0aWwgPSBEb21VdGlsO1xuICBleHBvcnRzLkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcbiAgZXhwb3J0cy5FdmVudGVkID0gRXZlbnRlZDtcbiAgZXhwb3J0cy5GZWF0dXJlR3JvdXAgPSBGZWF0dXJlR3JvdXA7XG4gIGV4cG9ydHMuR2VvSlNPTiA9IEdlb0pTT047XG4gIGV4cG9ydHMuR3JpZExheWVyID0gR3JpZExheWVyO1xuICBleHBvcnRzLkhhbmRsZXIgPSBIYW5kbGVyO1xuICBleHBvcnRzLkljb24gPSBJY29uO1xuICBleHBvcnRzLkltYWdlT3ZlcmxheSA9IEltYWdlT3ZlcmxheTtcbiAgZXhwb3J0cy5MYXRMbmcgPSBMYXRMbmc7XG4gIGV4cG9ydHMuTGF0TG5nQm91bmRzID0gTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLkxheWVyID0gTGF5ZXI7XG4gIGV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG4gIGV4cG9ydHMuTGluZVV0aWwgPSBMaW5lVXRpbDtcbiAgZXhwb3J0cy5NYXAgPSBNYXA7XG4gIGV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuICBleHBvcnRzLk1peGluID0gTWl4aW47XG4gIGV4cG9ydHMuUGF0aCA9IFBhdGg7XG4gIGV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbiAgZXhwb3J0cy5Qb2x5VXRpbCA9IFBvbHlVdGlsO1xuICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuICBleHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG4gIGV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcbiAgZXhwb3J0cy5Qb3NBbmltYXRpb24gPSBQb3NBbmltYXRpb247XG4gIGV4cG9ydHMuUHJvamVjdGlvbiA9IGluZGV4O1xuICBleHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICBleHBvcnRzLlNWRyA9IFNWRztcbiAgZXhwb3J0cy5TVkdPdmVybGF5ID0gU1ZHT3ZlcmxheTtcbiAgZXhwb3J0cy5UaWxlTGF5ZXIgPSBUaWxlTGF5ZXI7XG4gIGV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG4gIGV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy5VdGlsID0gVXRpbDtcbiAgZXhwb3J0cy5WaWRlb092ZXJsYXkgPSBWaWRlb092ZXJsYXk7XG4gIGV4cG9ydHMuYmluZCA9IGJpbmQ7XG4gIGV4cG9ydHMuYm91bmRzID0gdG9Cb3VuZHM7XG4gIGV4cG9ydHMuY2FudmFzID0gY2FudmFzO1xuICBleHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcbiAgZXhwb3J0cy5jaXJjbGVNYXJrZXIgPSBjaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuY29udHJvbCA9IGNvbnRyb2w7XG4gIGV4cG9ydHMuZGl2SWNvbiA9IGRpdkljb247XG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuICBleHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcbiAgZXhwb3J0cy5nZW9KU09OID0gZ2VvSlNPTjtcbiAgZXhwb3J0cy5nZW9Kc29uID0gZ2VvSnNvbjtcbiAgZXhwb3J0cy5ncmlkTGF5ZXIgPSBncmlkTGF5ZXI7XG4gIGV4cG9ydHMuaWNvbiA9IGljb247XG4gIGV4cG9ydHMuaW1hZ2VPdmVybGF5ID0gaW1hZ2VPdmVybGF5O1xuICBleHBvcnRzLmxhdExuZyA9IHRvTGF0TG5nO1xuICBleHBvcnRzLmxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLmxheWVyR3JvdXAgPSBsYXllckdyb3VwO1xuICBleHBvcnRzLm1hcCA9IGNyZWF0ZU1hcDtcbiAgZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XG4gIGV4cG9ydHMucG9pbnQgPSB0b1BvaW50O1xuICBleHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xuICBleHBvcnRzLnBvbHlsaW5lID0gcG9seWxpbmU7XG4gIGV4cG9ydHMucG9wdXAgPSBwb3B1cDtcbiAgZXhwb3J0cy5yZWN0YW5nbGUgPSByZWN0YW5nbGU7XG4gIGV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG4gIGV4cG9ydHMuc3RhbXAgPSBzdGFtcDtcbiAgZXhwb3J0cy5zdmcgPSBzdmc7XG4gIGV4cG9ydHMuc3ZnT3ZlcmxheSA9IHN2Z092ZXJsYXk7XG4gIGV4cG9ydHMudGlsZUxheWVyID0gdGlsZUxheWVyO1xuICBleHBvcnRzLnRvb2x0aXAgPSB0b29sdGlwO1xuICBleHBvcnRzLnRyYW5zZm9ybWF0aW9uID0gdG9UcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgZXhwb3J0cy52aWRlb092ZXJsYXkgPSB2aWRlb092ZXJsYXk7XG5cbiAgdmFyIG9sZEwgPSB3aW5kb3cuTDtcbiAgZXhwb3J0cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gIFx0d2luZG93LkwgPSBvbGRMO1xuICBcdHJldHVybiB0aGlzO1xuICB9XG4gIC8vIEFsd2F5cyBleHBvcnQgdXMgdG8gd2luZG93IGdsb2JhbCAoc2VlICMyMzY0KVxuICB3aW5kb3cuTCA9IGV4cG9ydHM7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQtc3JjLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/leaflet-src.js\n");

/***/ }),

/***/ "./node_modules/micromodal/dist/micromodal.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/micromodal/dist/micromodal.es.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction e(e,t){for(var o=0;o<t.length;o++){var n=t[o];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function t(e){return function(e){if(Array.isArray(e))return o(e)}(e)||function(e){if(\"undefined\"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if(\"string\"==typeof e)return o(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);\"Object\"===n&&e.constructor&&(n=e.constructor.name);if(\"Map\"===n||\"Set\"===n)return Array.from(e);if(\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return o(e,t)}(e)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var o=0,n=new Array(t);o<t;o++)n[o]=e[o];return n}var n,i,a,r,s,l=(n=[\"a[href]\",\"area[href]\",'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])',\"select:not([disabled]):not([aria-hidden])\",\"textarea:not([disabled]):not([aria-hidden])\",\"button:not([disabled]):not([aria-hidden])\",\"iframe\",\"object\",\"embed\",\"[contenteditable]\",'[tabindex]:not([tabindex^=\"-\"])'],i=function(){function o(e){var n=e.targetModal,i=e.triggers,a=void 0===i?[]:i,r=e.onShow,s=void 0===r?function(){}:r,l=e.onClose,c=void 0===l?function(){}:l,d=e.openTrigger,u=void 0===d?\"data-micromodal-trigger\":d,f=e.closeTrigger,h=void 0===f?\"data-micromodal-close\":f,v=e.openClass,g=void 0===v?\"is-open\":v,m=e.disableScroll,b=void 0!==m&&m,y=e.disableFocus,p=void 0!==y&&y,w=e.awaitCloseAnimation,E=void 0!==w&&w,k=e.awaitOpenAnimation,M=void 0!==k&&k,A=e.debugMode,C=void 0!==A&&A;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,o),this.modal=document.getElementById(n),this.config={debugMode:C,disableScroll:b,openTrigger:u,closeTrigger:h,openClass:g,onShow:s,onClose:c,awaitCloseAnimation:E,awaitOpenAnimation:M,disableFocus:p},a.length>0&&this.registerTriggers.apply(this,t(a)),this.onClick=this.onClick.bind(this),this.onKeydown=this.onKeydown.bind(this)}var i,a,r;return i=o,(a=[{key:\"registerTriggers\",value:function(){for(var e=this,t=arguments.length,o=new Array(t),n=0;n<t;n++)o[n]=arguments[n];o.filter(Boolean).forEach((function(t){t.addEventListener(\"click\",(function(t){return e.showModal(t)}))}))}},{key:\"showModal\",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(this.activeElement=document.activeElement,this.modal.setAttribute(\"aria-hidden\",\"false\"),this.modal.classList.add(this.config.openClass),this.scrollBehaviour(\"disable\"),this.addEventListeners(),this.config.awaitOpenAnimation){var o=function t(){e.modal.removeEventListener(\"animationend\",t,!1),e.setFocusToFirstNode()};this.modal.addEventListener(\"animationend\",o,!1)}else this.setFocusToFirstNode();this.config.onShow(this.modal,this.activeElement,t)}},{key:\"closeModal\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=this.modal;if(this.modal.setAttribute(\"aria-hidden\",\"true\"),this.removeEventListeners(),this.scrollBehaviour(\"enable\"),this.activeElement&&this.activeElement.focus&&this.activeElement.focus(),this.config.onClose(this.modal,this.activeElement,e),this.config.awaitCloseAnimation){var o=this.config.openClass;this.modal.addEventListener(\"animationend\",(function e(){t.classList.remove(o),t.removeEventListener(\"animationend\",e,!1)}),!1)}else t.classList.remove(this.config.openClass)}},{key:\"closeModalById\",value:function(e){this.modal=document.getElementById(e),this.modal&&this.closeModal()}},{key:\"scrollBehaviour\",value:function(e){if(this.config.disableScroll){var t=document.querySelector(\"body\");switch(e){case\"enable\":Object.assign(t.style,{overflow:\"\"});break;case\"disable\":Object.assign(t.style,{overflow:\"hidden\"})}}}},{key:\"addEventListeners\",value:function(){this.modal.addEventListener(\"touchstart\",this.onClick),this.modal.addEventListener(\"click\",this.onClick),document.addEventListener(\"keydown\",this.onKeydown)}},{key:\"removeEventListeners\",value:function(){this.modal.removeEventListener(\"touchstart\",this.onClick),this.modal.removeEventListener(\"click\",this.onClick),document.removeEventListener(\"keydown\",this.onKeydown)}},{key:\"onClick\",value:function(e){(e.target.hasAttribute(this.config.closeTrigger)||e.target.parentNode.hasAttribute(this.config.closeTrigger))&&(e.preventDefault(),e.stopPropagation(),this.closeModal(e))}},{key:\"onKeydown\",value:function(e){27===e.keyCode&&this.closeModal(e),9===e.keyCode&&this.retainFocus(e)}},{key:\"getFocusableNodes\",value:function(){var e=this.modal.querySelectorAll(n);return Array.apply(void 0,t(e))}},{key:\"setFocusToFirstNode\",value:function(){var e=this;if(!this.config.disableFocus){var t=this.getFocusableNodes();if(0!==t.length){var o=t.filter((function(t){return!t.hasAttribute(e.config.closeTrigger)}));o.length>0&&o[0].focus(),0===o.length&&t[0].focus()}}}},{key:\"retainFocus\",value:function(e){var t=this.getFocusableNodes();if(0!==t.length)if(t=t.filter((function(e){return null!==e.offsetParent})),this.modal.contains(document.activeElement)){var o=t.indexOf(document.activeElement);e.shiftKey&&0===o&&(t[t.length-1].focus(),e.preventDefault()),!e.shiftKey&&t.length>0&&o===t.length-1&&(t[0].focus(),e.preventDefault())}else t[0].focus()}}])&&e(i.prototype,a),r&&e(i,r),o}(),a=null,r=function(e){if(!document.getElementById(e))return console.warn(\"MicroModal: Seems like you have missed %c'\".concat(e,\"'\"),\"background-color: #f8f9fa;color: #50596c;font-weight: bold;\",\"ID somewhere in your code. Refer example below to resolve it.\"),console.warn(\"%cExample:\",\"background-color: #f8f9fa;color: #50596c;font-weight: bold;\",'<div class=\"modal\" id=\"'.concat(e,'\"></div>')),!1},s=function(e,t){if(function(e){e.length<=0&&(console.warn(\"MicroModal: Please specify at least one %c'micromodal-trigger'\",\"background-color: #f8f9fa;color: #50596c;font-weight: bold;\",\"data attribute.\"),console.warn(\"%cExample:\",\"background-color: #f8f9fa;color: #50596c;font-weight: bold;\",'<a href=\"#\" data-micromodal-trigger=\"my-modal\"></a>'))}(e),!t)return!0;for(var o in t)r(o);return!0},{init:function(e){var o=Object.assign({},{openTrigger:\"data-micromodal-trigger\"},e),n=t(document.querySelectorAll(\"[\".concat(o.openTrigger,\"]\"))),r=function(e,t){var o=[];return e.forEach((function(e){var n=e.attributes[t].value;void 0===o[n]&&(o[n]=[]),o[n].push(e)})),o}(n,o.openTrigger);if(!0!==o.debugMode||!1!==s(n,r))for(var l in r){var c=r[l];o.targetModal=l,o.triggers=t(c),a=new i(o)}},show:function(e,t){var o=t||{};o.targetModal=e,!0===o.debugMode&&!1===r(e)||(a&&a.removeEventListeners(),(a=new i(o)).showModal())},close:function(e){e?a.closeModalById(e):a.closeModal()}});\"undefined\"!=typeof window&&(window.MicroModal=l);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (l);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWljcm9tb2RhbC9kaXN0L21pY3JvbW9kYWwuZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGdCQUFnQixZQUFZLFdBQVcsS0FBSyxXQUFXLCtHQUErRyxjQUFjLG1CQUFtQixnQ0FBZ0MsaUJBQWlCLGlGQUFpRixtQkFBbUIsYUFBYSxvQ0FBb0Msb0RBQW9ELG9EQUFvRCw2Q0FBNkMscUZBQXFGLGdCQUFnQiw0SkFBNEosR0FBRyxnQkFBZ0Isb0NBQW9DLDJCQUEyQixJQUFJLGNBQWMsU0FBUywrVUFBK1UsY0FBYyx1RkFBdUYsd0NBQXdDLDJVQUEyVSxlQUFlLDhFQUE4RSw0REFBNEQsa0pBQWtKLGtJQUFrSSxVQUFVLGdCQUFnQix3Q0FBd0MscURBQXFELElBQUksc0JBQXNCLHVDQUF1Qyx3Q0FBd0Msc0JBQXNCLEdBQUcsSUFBSSxFQUFFLGlDQUFpQyx5RUFBeUUscU9BQXFPLG1CQUFtQiwwRUFBMEUsaURBQWlELGdDQUFnQyxxREFBcUQsRUFBRSxrQ0FBa0MsK0VBQStFLDJRQUEyUSw0QkFBNEIseURBQXlELGlFQUFpRSxNQUFNLGdEQUFnRCxFQUFFLHVDQUF1QyxxRUFBcUUsRUFBRSx3Q0FBd0MsOEJBQThCLHFDQUFxQyxVQUFVLG9DQUFvQyxZQUFZLEVBQUUsTUFBTSxxQ0FBcUMsa0JBQWtCLEtBQUssRUFBRSx5Q0FBeUMsOEpBQThKLEVBQUUsNENBQTRDLHVLQUF1SyxFQUFFLGdDQUFnQyw0S0FBNEssRUFBRSxrQ0FBa0MsdUVBQXVFLEVBQUUseUNBQXlDLHFDQUFxQyxpQ0FBaUMsRUFBRSwyQ0FBMkMsV0FBVyw4QkFBOEIsK0JBQStCLGlCQUFpQiw0QkFBNEIsNkNBQTZDLEdBQUcsdURBQXVELEVBQUUsb0NBQW9DLCtCQUErQiwyQ0FBMkMsNkJBQTZCLGdEQUFnRCx3Q0FBd0MseUlBQXlJLG1CQUFtQixpQ0FBaUMsd0JBQXdCLDBJQUEwSSxlQUFlLGtCQUFrQix3SEFBd0gsZUFBZSxrQkFBa0IscURBQXFELGlCQUFpQixlQUFlLHdIQUF3SCxlQUFlLGtCQUFrQiwwRUFBMEUsZUFBZSxrQkFBa0IsMERBQTBELGdCQUFnQixvQkFBb0IsU0FBUyxFQUFFLGlCQUFpQixzQkFBc0IsRUFBRSxzQ0FBc0Msa0ZBQWtGLFNBQVMsOEJBQThCLDRCQUE0QixzQ0FBc0MsS0FBSyxrQkFBa0IsaURBQWlELFdBQVcsNENBQTRDLG9CQUFvQixZQUFZLG9HQUFvRyxtQkFBbUIsc0NBQXNDLEVBQUUsa0RBQWtELGlFQUFlLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL25vZGVfbW9kdWxlcy9taWNyb21vZGFsL2Rpc3QvbWljcm9tb2RhbC5lcy5qcz9hMWI3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIG49dFtvXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fWZ1bmN0aW9uIHQoZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIG8oZSl9KGUpfHxmdW5jdGlvbihlKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIG8oZSx0KTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSk7XCJPYmplY3RcIj09PW4mJmUuY29uc3RydWN0b3ImJihuPWUuY29uc3RydWN0b3IubmFtZSk7aWYoXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uKXJldHVybiBBcnJheS5mcm9tKGUpO2lmKFwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSlyZXR1cm4gbyhlLHQpfShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBvKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBvPTAsbj1uZXcgQXJyYXkodCk7bzx0O28rKyluW29dPWVbb107cmV0dXJuIG59dmFyIG4saSxhLHIscyxsPShuPVtcImFbaHJlZl1cIixcImFyZWFbaHJlZl1cIiwnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdHlwZT1cImhpZGRlblwiXSk6bm90KFthcmlhLWhpZGRlbl0pJyxcInNlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsXCJ0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsXCJidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbYXJpYS1oaWRkZW5dKVwiLFwiaWZyYW1lXCIsXCJvYmplY3RcIixcImVtYmVkXCIsXCJbY29udGVudGVkaXRhYmxlXVwiLCdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSknXSxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyhlKXt2YXIgbj1lLnRhcmdldE1vZGFsLGk9ZS50cmlnZ2VycyxhPXZvaWQgMD09PWk/W106aSxyPWUub25TaG93LHM9dm9pZCAwPT09cj9mdW5jdGlvbigpe306cixsPWUub25DbG9zZSxjPXZvaWQgMD09PWw/ZnVuY3Rpb24oKXt9OmwsZD1lLm9wZW5UcmlnZ2VyLHU9dm9pZCAwPT09ZD9cImRhdGEtbWljcm9tb2RhbC10cmlnZ2VyXCI6ZCxmPWUuY2xvc2VUcmlnZ2VyLGg9dm9pZCAwPT09Zj9cImRhdGEtbWljcm9tb2RhbC1jbG9zZVwiOmYsdj1lLm9wZW5DbGFzcyxnPXZvaWQgMD09PXY/XCJpcy1vcGVuXCI6dixtPWUuZGlzYWJsZVNjcm9sbCxiPXZvaWQgMCE9PW0mJm0seT1lLmRpc2FibGVGb2N1cyxwPXZvaWQgMCE9PXkmJnksdz1lLmF3YWl0Q2xvc2VBbmltYXRpb24sRT12b2lkIDAhPT13JiZ3LGs9ZS5hd2FpdE9wZW5BbmltYXRpb24sTT12b2lkIDAhPT1rJiZrLEE9ZS5kZWJ1Z01vZGUsQz12b2lkIDAhPT1BJiZBOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbyksdGhpcy5tb2RhbD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChuKSx0aGlzLmNvbmZpZz17ZGVidWdNb2RlOkMsZGlzYWJsZVNjcm9sbDpiLG9wZW5UcmlnZ2VyOnUsY2xvc2VUcmlnZ2VyOmgsb3BlbkNsYXNzOmcsb25TaG93OnMsb25DbG9zZTpjLGF3YWl0Q2xvc2VBbmltYXRpb246RSxhd2FpdE9wZW5BbmltYXRpb246TSxkaXNhYmxlRm9jdXM6cH0sYS5sZW5ndGg+MCYmdGhpcy5yZWdpc3RlclRyaWdnZXJzLmFwcGx5KHRoaXMsdChhKSksdGhpcy5vbkNsaWNrPXRoaXMub25DbGljay5iaW5kKHRoaXMpLHRoaXMub25LZXlkb3duPXRoaXMub25LZXlkb3duLmJpbmQodGhpcyl9dmFyIGksYSxyO3JldHVybiBpPW8sKGE9W3trZXk6XCJyZWdpc3RlclRyaWdnZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGgsbz1uZXcgQXJyYXkodCksbj0wO248dDtuKyspb1tuXT1hcmd1bWVudHNbbl07by5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGUuc2hvd01vZGFsKHQpfSkpfSkpfX0se2tleTpcInNob3dNb2RhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpudWxsO2lmKHRoaXMuYWN0aXZlRWxlbWVudD1kb2N1bWVudC5hY3RpdmVFbGVtZW50LHRoaXMubW9kYWwuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcImZhbHNlXCIpLHRoaXMubW9kYWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5vcGVuQ2xhc3MpLHRoaXMuc2Nyb2xsQmVoYXZpb3VyKFwiZGlzYWJsZVwiKSx0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCksdGhpcy5jb25maWcuYXdhaXRPcGVuQW5pbWF0aW9uKXt2YXIgbz1mdW5jdGlvbiB0KCl7ZS5tb2RhbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsdCwhMSksZS5zZXRGb2N1c1RvRmlyc3ROb2RlKCl9O3RoaXMubW9kYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLG8sITEpfWVsc2UgdGhpcy5zZXRGb2N1c1RvRmlyc3ROb2RlKCk7dGhpcy5jb25maWcub25TaG93KHRoaXMubW9kYWwsdGhpcy5hY3RpdmVFbGVtZW50LHQpfX0se2tleTpcImNsb3NlTW9kYWxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpudWxsLHQ9dGhpcy5tb2RhbDtpZih0aGlzLm1vZGFsLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSx0aGlzLnNjcm9sbEJlaGF2aW91cihcImVuYWJsZVwiKSx0aGlzLmFjdGl2ZUVsZW1lbnQmJnRoaXMuYWN0aXZlRWxlbWVudC5mb2N1cyYmdGhpcy5hY3RpdmVFbGVtZW50LmZvY3VzKCksdGhpcy5jb25maWcub25DbG9zZSh0aGlzLm1vZGFsLHRoaXMuYWN0aXZlRWxlbWVudCxlKSx0aGlzLmNvbmZpZy5hd2FpdENsb3NlQW5pbWF0aW9uKXt2YXIgbz10aGlzLmNvbmZpZy5vcGVuQ2xhc3M7dGhpcy5tb2RhbC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsKGZ1bmN0aW9uIGUoKXt0LmNsYXNzTGlzdC5yZW1vdmUobyksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsZSwhMSl9KSwhMSl9ZWxzZSB0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcub3BlbkNsYXNzKX19LHtrZXk6XCJjbG9zZU1vZGFsQnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMubW9kYWw9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSksdGhpcy5tb2RhbCYmdGhpcy5jbG9zZU1vZGFsKCl9fSx7a2V5Olwic2Nyb2xsQmVoYXZpb3VyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYodGhpcy5jb25maWcuZGlzYWJsZVNjcm9sbCl7dmFyIHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJvZHlcIik7c3dpdGNoKGUpe2Nhc2VcImVuYWJsZVwiOk9iamVjdC5hc3NpZ24odC5zdHlsZSx7b3ZlcmZsb3c6XCJcIn0pO2JyZWFrO2Nhc2VcImRpc2FibGVcIjpPYmplY3QuYXNzaWduKHQuc3R5bGUse292ZXJmbG93OlwiaGlkZGVuXCJ9KX19fX0se2tleTpcImFkZEV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5vbkNsaWNrKSx0aGlzLm1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMub25DbGljayksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLm9uS2V5ZG93bil9fSx7a2V5OlwicmVtb3ZlRXZlbnRMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLm9uQ2xpY2spLHRoaXMubW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5vbkNsaWNrKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMub25LZXlkb3duKX19LHtrZXk6XCJvbkNsaWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSl7KGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZSh0aGlzLmNvbmZpZy5jbG9zZVRyaWdnZXIpfHxlLnRhcmdldC5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSh0aGlzLmNvbmZpZy5jbG9zZVRyaWdnZXIpKSYmKGUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLHRoaXMuY2xvc2VNb2RhbChlKSl9fSx7a2V5Olwib25LZXlkb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7Mjc9PT1lLmtleUNvZGUmJnRoaXMuY2xvc2VNb2RhbChlKSw5PT09ZS5rZXlDb2RlJiZ0aGlzLnJldGFpbkZvY3VzKGUpfX0se2tleTpcImdldEZvY3VzYWJsZU5vZGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm1vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwobik7cmV0dXJuIEFycmF5LmFwcGx5KHZvaWQgMCx0KGUpKX19LHtrZXk6XCJzZXRGb2N1c1RvRmlyc3ROb2RlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKCF0aGlzLmNvbmZpZy5kaXNhYmxlRm9jdXMpe3ZhciB0PXRoaXMuZ2V0Rm9jdXNhYmxlTm9kZXMoKTtpZigwIT09dC5sZW5ndGgpe3ZhciBvPXQuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hdC5oYXNBdHRyaWJ1dGUoZS5jb25maWcuY2xvc2VUcmlnZ2VyKX0pKTtvLmxlbmd0aD4wJiZvWzBdLmZvY3VzKCksMD09PW8ubGVuZ3RoJiZ0WzBdLmZvY3VzKCl9fX19LHtrZXk6XCJyZXRhaW5Gb2N1c1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0Rm9jdXNhYmxlTm9kZXMoKTtpZigwIT09dC5sZW5ndGgpaWYodD10LmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1lLm9mZnNldFBhcmVudH0pKSx0aGlzLm1vZGFsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKXt2YXIgbz10LmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7ZS5zaGlmdEtleSYmMD09PW8mJih0W3QubGVuZ3RoLTFdLmZvY3VzKCksZS5wcmV2ZW50RGVmYXVsdCgpKSwhZS5zaGlmdEtleSYmdC5sZW5ndGg+MCYmbz09PXQubGVuZ3RoLTEmJih0WzBdLmZvY3VzKCksZS5wcmV2ZW50RGVmYXVsdCgpKX1lbHNlIHRbMF0uZm9jdXMoKX19XSkmJmUoaS5wcm90b3R5cGUsYSksciYmZShpLHIpLG99KCksYT1udWxsLHI9ZnVuY3Rpb24oZSl7aWYoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpKXJldHVybiBjb25zb2xlLndhcm4oXCJNaWNyb01vZGFsOiDinZdTZWVtcyBsaWtlIHlvdSBoYXZlIG1pc3NlZCAlYydcIi5jb25jYXQoZSxcIidcIiksXCJiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOWZhO2NvbG9yOiAjNTA1OTZjO2ZvbnQtd2VpZ2h0OiBib2xkO1wiLFwiSUQgc29tZXdoZXJlIGluIHlvdXIgY29kZS4gUmVmZXIgZXhhbXBsZSBiZWxvdyB0byByZXNvbHZlIGl0LlwiKSxjb25zb2xlLndhcm4oXCIlY0V4YW1wbGU6XCIsXCJiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOWZhO2NvbG9yOiAjNTA1OTZjO2ZvbnQtd2VpZ2h0OiBib2xkO1wiLCc8ZGl2IGNsYXNzPVwibW9kYWxcIiBpZD1cIicuY29uY2F0KGUsJ1wiPjwvZGl2PicpKSwhMX0scz1mdW5jdGlvbihlLHQpe2lmKGZ1bmN0aW9uKGUpe2UubGVuZ3RoPD0wJiYoY29uc29sZS53YXJuKFwiTWljcm9Nb2RhbDog4p2XUGxlYXNlIHNwZWNpZnkgYXQgbGVhc3Qgb25lICVjJ21pY3JvbW9kYWwtdHJpZ2dlcidcIixcImJhY2tncm91bmQtY29sb3I6ICNmOGY5ZmE7Y29sb3I6ICM1MDU5NmM7Zm9udC13ZWlnaHQ6IGJvbGQ7XCIsXCJkYXRhIGF0dHJpYnV0ZS5cIiksY29uc29sZS53YXJuKFwiJWNFeGFtcGxlOlwiLFwiYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjlmYTtjb2xvcjogIzUwNTk2Yztmb250LXdlaWdodDogYm9sZDtcIiwnPGEgaHJlZj1cIiNcIiBkYXRhLW1pY3JvbW9kYWwtdHJpZ2dlcj1cIm15LW1vZGFsXCI+PC9hPicpKX0oZSksIXQpcmV0dXJuITA7Zm9yKHZhciBvIGluIHQpcihvKTtyZXR1cm4hMH0se2luaXQ6ZnVuY3Rpb24oZSl7dmFyIG89T2JqZWN0LmFzc2lnbih7fSx7b3BlblRyaWdnZXI6XCJkYXRhLW1pY3JvbW9kYWwtdHJpZ2dlclwifSxlKSxuPXQoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQoby5vcGVuVHJpZ2dlcixcIl1cIikpKSxyPWZ1bmN0aW9uKGUsdCl7dmFyIG89W107cmV0dXJuIGUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5hdHRyaWJ1dGVzW3RdLnZhbHVlO3ZvaWQgMD09PW9bbl0mJihvW25dPVtdKSxvW25dLnB1c2goZSl9KSksb30obixvLm9wZW5UcmlnZ2VyKTtpZighMCE9PW8uZGVidWdNb2RlfHwhMSE9PXMobixyKSlmb3IodmFyIGwgaW4gcil7dmFyIGM9cltsXTtvLnRhcmdldE1vZGFsPWwsby50cmlnZ2Vycz10KGMpLGE9bmV3IGkobyl9fSxzaG93OmZ1bmN0aW9uKGUsdCl7dmFyIG89dHx8e307by50YXJnZXRNb2RhbD1lLCEwPT09by5kZWJ1Z01vZGUmJiExPT09cihlKXx8KGEmJmEucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSwoYT1uZXcgaShvKSkuc2hvd01vZGFsKCkpfSxjbG9zZTpmdW5jdGlvbihlKXtlP2EuY2xvc2VNb2RhbEJ5SWQoZSk6YS5jbG9zZU1vZGFsKCl9fSk7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5NaWNyb01vZGFsPWwpO2V4cG9ydCBkZWZhdWx0IGw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/micromodal/dist/micromodal.es.js\n");

/***/ }),

/***/ "./src/scss/app.scss":
/*!***************************!*\
  !*** ./src/scss/app.scss ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2Nzcy9hcHAuc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9zcmMvc2Nzcy9hcHAuc2Nzcz82MjllIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scss/app.scss\n");

/***/ }),

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);\n      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));\n  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));\n  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));\n  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';\n          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));\n          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUIsK0RBQVc7QUFDOUIsd0JBQXdCLG9FQUFnQjtBQUN4QyxzQkFBc0IsaUVBQWE7QUFDbkMsZUFBZSwyREFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNB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O0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdURBQUc7QUFDekMscUNBQXFDLHVEQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVEQUFHO0FBQ3hCLHFCQUFxQix1REFBRztBQUN4QixxQkFBcUIsdURBQUc7QUFDeEIscUJBQXFCLHVEQUFHO0FBQ3hCO0FBQ0EsaUZBQWlGLHVEQUFHO0FBQ3BGLFVBQVU7QUFDVixtRkFBbUYsdURBQUc7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcz81OTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoLFxuICAgIGhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0XG4gIH0gOiByZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBvZmZzZXRTY2FsZSA9IChhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkpID8gKGF3YWl0IChwbGF0Zm9ybS5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgYm90dG9tOiAoZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSAvIG9mZnNldFNjYWxlLnksXG4gICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtaWRkbGV3YXJlRGF0YVxuICAgIH0gPSBzdGF0ZTtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZS5cbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50LFxuICAgICAgcGFkZGluZyA9IDBcbiAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpIHx8IHt9O1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzWUF4aXMgPSBheGlzID09PSAneSc7XG4gICAgY29uc3QgbWluUHJvcCA9IGlzWUF4aXMgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gaXNZQXhpcyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBjbGllbnRQcm9wID0gaXNZQXhpcyA/ICdjbGllbnRIZWlnaHQnIDogJ2NsaWVudFdpZHRoJztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGFycm93T2Zmc2V0UGFyZW50W2NsaWVudFByb3BdIDogMDtcblxuICAgIC8vIERPTSBwbGF0Zm9ybSBjYW4gcmV0dXJuIGB3aW5kb3dgIGFzIHRoZSBgb2Zmc2V0UGFyZW50YC5cbiAgICBpZiAoIWNsaWVudFNpemUgfHwgIShhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoYXJyb3dPZmZzZXRQYXJlbnQpKSkpIHtcbiAgICAgIGNsaWVudFNpemUgPSBlbGVtZW50cy5mbG9hdGluZ1tjbGllbnRQcm9wXSB8fCByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAgIC8vIElmIHRoZSBwYWRkaW5nIGlzIGxhcmdlIGVub3VnaCB0aGF0IGl0IGNhdXNlcyB0aGUgYXJyb3cgdG8gbm8gbG9uZ2VyIGJlXG4gICAgLy8gY2VudGVyZWQsIG1vZGlmeSB0aGUgcGFkZGluZyBzbyB0aGF0IGl0IGlzIGNlbnRlcmVkLlxuICAgIGNvbnN0IGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiAtIDE7XG4gICAgY29uc3QgbWluUGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21pblByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWF4UHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzLlxuICAgIGNvbnN0IG1pbiQxID0gbWluUGFkZGluZztcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBtYXhQYWRkaW5nO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gY2xhbXAobWluJDEsIGNlbnRlciwgbWF4KTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhlIGFycm93J3MgcGFkZGluZyBjYXVzZXMgaXQgdG9cbiAgICAvLyB0byBwb2ludCB0byBub3RoaW5nIGZvciBhbiBhbGlnbmVkIHBsYWNlbWVudCwgYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCBpdHNlbGYuIFRvIGVuc3VyZSBgc2hpZnQoKWAgY29udGludWVzIHRvIHRha2UgYWN0aW9uLFxuICAgIC8vIGEgc2luZ2xlIHJlc2V0IGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgaXMgdHJ1ZS5cbiAgICBjb25zdCBzaG91bGRBZGRPZmZzZXQgPSAhbWlkZGxld2FyZURhdGEuYXJyb3cgJiYgZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT0gbnVsbCAmJiBjZW50ZXIgIT09IG9mZnNldCAmJiByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSAvIDIgLSAoY2VudGVyIDwgbWluJDEgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZykgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiQxID8gY2VudGVyIC0gbWluJDEgOiBjZW50ZXIgLSBtYXggOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSArIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0IC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgICAuLi4oc2hvdWxkQWRkT2Zmc2V0ICYmIHtcbiAgICAgICAgICBhbGlnbm1lbnRPZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNldDogc2hvdWxkQWRkT2Zmc2V0XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykge1xuICBjb25zdCBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50ID0gYWxpZ25tZW50ID8gWy4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCksIC4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT09IGFsaWdubWVudCldIDogYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRTaWRlKHBsYWNlbWVudCkgPT09IHBsYWNlbWVudCk7XG4gIHJldHVybiBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50LmZpbHRlcihwbGFjZW1lbnQgPT4ge1xuICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50IHx8IChhdXRvQWxpZ25tZW50ID8gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSAhPT0gcGxhY2VtZW50IDogZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX3BsYWNlbWVudHNUaGF0Rml0T25FO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyxcbiAgICAgICAgYXV0b0FsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMkMSA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBwbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXhdO1xuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlnbm1lbnRTaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzJDFbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1swXV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzFdXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICAgIC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2suXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UgPSBhbGxPdmVyZmxvd3MubWFwKGQgPT4ge1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQoZC5wbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gW2QucGxhY2VtZW50LCBhbGlnbm1lbnQgJiYgY3Jvc3NBeGlzID9cbiAgICAgICAgLy8gQ2hlY2sgYWxvbmcgdGhlIG1haW5BeGlzIGFuZCBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBkLm92ZXJmbG93cy5zbGljZSgwLCAyKS5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiwgMCkgOlxuICAgICAgICAvLyBDaGVjayBvbmx5IHRoZSBtYWluQXhpcy5cbiAgICAgICAgZC5vdmVyZmxvd3NbMF0sIGQub3ZlcmZsb3dzXTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSA9IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZS5maWx0ZXIoZCA9PiBkWzJdLnNsaWNlKDAsXG4gICAgICAvLyBBbGlnbmVkIHBsYWNlbWVudHMgc2hvdWxkIG5vdCBjaGVjayB0aGVpciBvcHBvc2l0ZSBjcm9zc0F4aXNcbiAgICAgIC8vIHNpZGUuXG4gICAgICBnZXRBbGlnbm1lbnQoZFswXSkgPyAyIDogMykuZXZlcnkodiA9PiB2IDw9IDApKTtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gKChfcGxhY2VtZW50c1RoYXRGaXRPbkUgPSBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1RoYXRGaXRPbkVbMF0pIHx8IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZVswXVswXTtcbiAgICAgIGlmIChyZXNldFBsYWNlbWVudCAhPT0gcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZsaXAnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWUsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gJ2Jlc3RGaXQnLFxuICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gJ25vbmUnLFxuICAgICAgICBmbGlwQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gICAgICAvLyBJZiBhIHJlc2V0IGJ5IHRoZSBhcnJvdyB3YXMgY2F1c2VkIGR1ZSB0byBhbiBhbGlnbm1lbnQgb2Zmc2V0IGJlaW5nXG4gICAgICAvLyBhZGRlZCwgd2Ugc2hvdWxkIHNraXAgYW55IGxvZ2ljIG5vdyBzaW5jZSBgZmxpcCgpYCBoYXMgYWxyZWFkeSBkb25lIGl0c1xuICAgICAgLy8gd29yay5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjU0OSNpc3N1ZWNvbW1lbnQtMTcxOTYwMTY0M1xuICAgICAgaWYgKChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsU2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhpbml0aWFsUGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09ICdub25lJztcbiAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyMiA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSAneSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50LFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgY29uc3QgbWFpbkF4aXNNdWx0aSA9IFsnbGVmdCcsICd0b3AnXS5pbmNsdWRlcyhzaWRlKSA/IC0xIDogMTtcbiAgY29uc3QgY3Jvc3NBeGlzTXVsdGkgPSBydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgY29uc3QgcmF3VmFsdWUgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZS5tYWluQXhpcyB8fCAwLFxuICAgIGNyb3NzQXhpczogcmF3VmFsdWUuY3Jvc3NBeGlzIHx8IDAsXG4gICAgYWxpZ25tZW50QXhpczogcmF3VmFsdWUuYWxpZ25tZW50QXhpc1xuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5LFxuICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfc3RhdGUkbWlkZGxld2FyZURhdGEsIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gbWluKGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IG1pbih3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV0sIG1heGltdW1DbGlwcGluZ1dpZHRoKTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEuZW5hYmxlZC54KSB7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEyLmVuYWJsZWQueSkge1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ \"./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ \"./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\n\nfunction getCssDimensions(element) {\n  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;\n  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\nfunction getVisualOffsets(element) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);\n    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);\n      currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    }\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);\n  const body = element.ownerDocument.body;\n  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === 'rtl') {\n    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));\n  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {\n    return false;\n  }\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed';\n  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)) {\n    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);\n    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);\n    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  let htmlX = 0;\n  let htmlY = 0;\n  if (documentElement && !isOffsetParentAnElement && !isFixed) {\n    const htmlRect = documentElement.getBoundingClientRect();\n    htmlY = htmlRect.top + scroll.scrollTop;\n    htmlX = htmlRect.left + scroll.scrollLeft -\n    // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect);\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlX;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlY;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {\n    return win;\n  }\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n    while (svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {\n    return win;\n  }\n  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);\n    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));\n    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));\n    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeVQ7QUFDL087QUFDa1A7QUFDOVA7O0FBRTlEO0FBQ0EsY0FBYyx3RUFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUVBQWE7QUFDakM7QUFDQTtBQUNBLHlCQUF5Qix5REFBSywyQkFBMkIseURBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlFQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxPQUFPLHFFQUFhO0FBQ3BCLFdBQVcsZ0VBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGVBQWUseURBQUs7QUFDcEIsZUFBZSx5REFBSzs7QUFFcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsZ0VBQVk7QUFDM0M7QUFDQSxjQUFjLGlFQUFTO0FBQ3ZCLE9BQU8sZ0VBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGlFQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0VBQVk7QUFDMUI7QUFDQTtBQUNBLFVBQVUsaUVBQVM7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwySEFBMkgsZ0VBQVk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBUztBQUN6QixzQ0FBc0MsaUVBQVMsaUJBQWlCLGlFQUFTO0FBQ3pFO0FBQ0Esd0JBQXdCLHVFQUFlO0FBQ3ZD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQWdCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVE7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQU87O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQU07O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQU07O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFNOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBTzs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVE7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBWTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQWlCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTRJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbWFyY2VsLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20ubWpzP2M0MTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCwgZGV0ZWN0T3ZlcmZsb3cgYXMgZGV0ZWN0T3ZlcmZsb3ckMSwgb2Zmc2V0IGFzIG9mZnNldCQxLCBhdXRvUGxhY2VtZW50IGFzIGF1dG9QbGFjZW1lbnQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgZmxpcCBhcyBmbGlwJDEsIHNpemUgYXMgc2l6ZSQxLCBoaWRlIGFzIGhpZGUkMSwgYXJyb3cgYXMgYXJyb3ckMSwgaW5saW5lIGFzIGlubGluZSQxLCBsaW1pdFNoaWZ0IGFzIGxpbWl0U2hpZnQkMSwgY29tcHV0ZVBvc2l0aW9uIGFzIGNvbXB1dGVQb3NpdGlvbiQxIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuaW1wb3J0IHsgcm91bmQsIGNyZWF0ZUNvb3JkcywgbWF4LCBtaW4sIGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGlzSFRNTEVsZW1lbnQsIGlzRWxlbWVudCwgZ2V0V2luZG93LCBpc1dlYktpdCwgZ2V0RnJhbWVFbGVtZW50LCBnZXREb2N1bWVudEVsZW1lbnQsIGlzVG9wTGF5ZXIsIGdldE5vZGVOYW1lLCBpc092ZXJmbG93RWxlbWVudCwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNDb250YWluaW5nQmxvY2ssIGlzVGFibGVFbGVtZW50LCBnZXRDb250YWluaW5nQmxvY2sgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmV4cG9ydCB7IGdldE92ZXJmbG93QW5jZXN0b3JzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAvLyBJbiB0ZXN0aW5nIGVudmlyb25tZW50cywgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgYXJlIGVtcHR5XG4gIC8vIHN0cmluZ3MgZm9yIFNWRyBlbGVtZW50cywgcmV0dXJuaW5nIE5hTi4gRmFsbGJhY2sgdG8gYDBgIGluIHRoaXMgY2FzZS5cbiAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdChjc3Mud2lkdGgpIHx8IDA7XG4gIGxldCBoZWlnaHQgPSBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGhhc09mZnNldCA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IG9mZnNldFdpZHRoID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRXaWR0aCA6IHdpZHRoO1xuICBjb25zdCBvZmZzZXRIZWlnaHQgPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldEhlaWdodCA6IGhlaWdodDtcbiAgY29uc3Qgc2hvdWxkRmFsbGJhY2sgPSByb3VuZCh3aWR0aCkgIT09IG9mZnNldFdpZHRoIHx8IHJvdW5kKGhlaWdodCkgIT09IG9mZnNldEhlaWdodDtcbiAgaWYgKHNob3VsZEZhbGxiYWNrKSB7XG4gICAgd2lkdGggPSBvZmZzZXRXaWR0aDtcbiAgICBoZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJDogc2hvdWxkRmFsbGJhY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW53cmFwRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAhaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGlmICghaXNIVE1MRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgIHJldHVybiBjcmVhdGVDb29yZHMoMSk7XG4gIH1cbiAgY29uc3QgcmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhkb21FbGVtZW50KTtcbiAgbGV0IHggPSAoJCA/IHJvdW5kKHJlY3Qud2lkdGgpIDogcmVjdC53aWR0aCkgLyB3aWR0aDtcbiAgbGV0IHkgPSAoJCA/IHJvdW5kKHJlY3QuaGVpZ2h0KSA6IHJlY3QuaGVpZ2h0KSAvIGhlaWdodDtcblxuICAvLyAwLCBOYU4sIG9yIEluZmluaXR5IHNob3VsZCBhbHdheXMgZmFsbGJhY2sgdG8gMS5cblxuICBpZiAoIXggfHwgIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHggPSAxO1xuICB9XG4gIGlmICgheSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgeSA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuY29uc3Qgbm9PZmZzZXRzID0gLyojX19QVVJFX18qL2NyZWF0ZUNvb3JkcygwKTtcbmZ1bmN0aW9uIGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmICghaXNXZWJLaXQoKSB8fCAhd2luLnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIG5vT2Zmc2V0cztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxuICAgIHk6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZWxlbWVudCwgaXNGaXhlZCwgZmxvYXRpbmdPZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWZsb2F0aW5nT2Zmc2V0UGFyZW50IHx8IGlzRml4ZWQgJiYgZmxvYXRpbmdPZmZzZXRQYXJlbnQgIT09IGdldFdpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZDtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGlmIChpbmNsdWRlU2NhbGUpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCB2aXN1YWxPZmZzZXRzID0gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50LCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkgPyBnZXRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDApO1xuICBsZXQgeCA9IChjbGllbnRSZWN0LmxlZnQgKyB2aXN1YWxPZmZzZXRzLngpIC8gc2NhbGUueDtcbiAgbGV0IHkgPSAoY2xpZW50UmVjdC50b3AgKyB2aXN1YWxPZmZzZXRzLnkpIC8gc2NhbGUueTtcbiAgbGV0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlLng7XG4gIGxldCBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlLnk7XG4gIGlmIChkb21FbGVtZW50KSB7XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbUVsZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldFdpbiA9IG9mZnNldFBhcmVudCAmJiBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSA/IGdldFdpbmRvdyhvZmZzZXRQYXJlbnQpIDogb2Zmc2V0UGFyZW50O1xuICAgIGxldCBjdXJyZW50V2luID0gd2luO1xuICAgIGxldCBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIHdoaWxlIChjdXJyZW50SUZyYW1lICYmIG9mZnNldFBhcmVudCAmJiBvZmZzZXRXaW4gIT09IGN1cnJlbnRXaW4pIHtcbiAgICAgIGNvbnN0IGlmcmFtZVNjYWxlID0gZ2V0U2NhbGUoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBpZnJhbWVSZWN0ID0gY3VycmVudElGcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBsZWZ0ID0gaWZyYW1lUmVjdC5sZWZ0ICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50TGVmdCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdMZWZ0KSkgKiBpZnJhbWVTY2FsZS54O1xuICAgICAgY29uc3QgdG9wID0gaWZyYW1lUmVjdC50b3AgKyAoY3VycmVudElGcmFtZS5jbGllbnRUb3AgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nVG9wKSkgKiBpZnJhbWVTY2FsZS55O1xuICAgICAgeCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgeSAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgd2lkdGggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIGhlaWdodCAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgeCArPSBsZWZ0O1xuICAgICAgeSArPSB0b3A7XG4gICAgICBjdXJyZW50V2luID0gZ2V0V2luZG93KGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3Qoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogZmFsc2U7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG4vLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4vLyBpbmNvcnJlY3QgZm9yIFJUTC5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCwgcmVjdCkge1xuICBjb25zdCBsZWZ0U2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGxlZnRTY3JvbGw7XG4gIH1cbiAgcmV0dXJuIHJlY3QubGVmdCArIGxlZnRTY3JvbGw7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIC4uLmNsaXBwaW5nQW5jZXN0b3IsXG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBpc1RvcExheWVyKGVsZW1lbnQpID8gW10gOiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIC8vIElmIHRoZSA8Ym9keT4gc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgKGUuZy4gUlRMIHN5c3RlbXMpLiBVc2VcbiAgICAgIC8vIEZpcmVmb3ggd2l0aCBsYXlvdXQuc2Nyb2xsYmFyLnNpZGUgPSAzIGluIGFib3V0OmNvbmZpZyB0byB0ZXN0IHRoaXMuXG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGxldCBodG1sWCA9IDA7XG4gIGxldCBodG1sWSA9IDA7XG4gIGlmIChkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgY29uc3QgaHRtbFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaHRtbFkgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICAgIGh0bWxYID0gaHRtbFJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC1cbiAgICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhci5cbiAgICBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCwgaHRtbFJlY3QpO1xuICB9XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCAtIGh0bWxYO1xuICBjb25zdCB5ID0gcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55IC0gaHRtbFk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAvLyBGaXJlZm94IHJldHVybnMgdGhlIDxodG1sPiBlbGVtZW50IGFzIHRoZSBvZmZzZXRQYXJlbnQgaWYgaXQncyBub24tc3RhdGljLFxuICAvLyB3aGlsZSBDaHJvbWUgYW5kIFNhZmFyaSByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LiBUaGUgPGJvZHk+IGVsZW1lbnQgbXVzdFxuICAvLyBiZSB1c2VkIHRvIHBlcmZvcm0gdGhlIGNvcnJlY3QgY2FsY3VsYXRpb25zIGV2ZW4gaWYgdGhlIDxodG1sPiBlbGVtZW50IGlzXG4gIC8vIG5vbi1zdGF0aWMuXG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZmxvYXRpbmdEaW1lbnNpb25zLmhlaWdodFxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgKF9pbyA9IGlvKSA9PSBudWxsIHx8IF9pby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIG9uTW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zZXRUb3AgPSBmbG9vcih0b3ApO1xuICAgIGNvbnN0IGluc2V0UmlnaHQgPSBmbG9vcihyb290LmNsaWVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCkpO1xuICAgIGNvbnN0IGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSk7XG4gICAgY29uc3QgaW5zZXRMZWZ0ID0gZmxvb3IobGVmdCk7XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IC1pbnNldFRvcCArIFwicHggXCIgKyAtaW5zZXRSaWdodCArIFwicHggXCIgKyAtaW5zZXRCb3R0b20gKyBcInB4IFwiICsgLWluc2V0TGVmdCArIFwicHhcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbWF4KDAsIG1pbigxLCB0aHJlc2hvbGQpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgaXNGaXJzdFVwZGF0ZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF0aW8pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGNsaXBwZWQsIHRoZSByYXRpbyBpcyAwLiBUaHJvdHRsZSB0aGUgcmVmcmVzaFxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiB1cGRhdGVzLlxuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaChmYWxzZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBhIGBkb2N1bWVudGAgYXMgdGhlIHJvb3QgYW5kIHdpbGwgdGhyb3cgYW5cbiAgICAvLyBlcnJvci5cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IHJvb3Qub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAobmV4dFJlZlJlY3QueCAhPT0gcHJldlJlZlJlY3QueCB8fCBuZXh0UmVmUmVjdC55ICE9PSBwcmV2UmVmUmVjdC55IHx8IG5leHRSZWZSZWN0LndpZHRoICE9PSBwcmV2UmVmUmVjdC53aWR0aCB8fCBuZXh0UmVmUmVjdC5oZWlnaHQgIT09IHByZXZSZWZSZWN0LmhlaWdodCkpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX3Jlc2l6ZU9ic2VydmVyMjtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICBjbGVhbnVwSW8gPT0gbnVsbCB8fCBjbGVhbnVwSW8oKTtcbiAgICAoX3Jlc2l6ZU9ic2VydmVyMiA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlcjIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmNvbnN0IGRldGVjdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3ckMTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gYXV0b1BsYWNlbWVudCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBzaGlmdCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZsaXAkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gc2l6ZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGhpZGUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBhcnJvdyQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBpbmxpbmUkMTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGxpbWl0U2hpZnQkMTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isTopLayer: () => (/* binding */ isTopLayer),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcz84ODFjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGhhc1dpbmRvdygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8vIE1vY2tlZCBub2RlcyBpbiB0ZXN0aW5nIGVudmlyb25tZW50cyBtYXkgbm90IGJlIGluc3RhbmNlcyBvZiBOb2RlLiBCeVxuICAvLyByZXR1cm5pbmcgYCNkb2N1bWVudGAgYW4gaW5maW5pdGUgbG9vcCB3b24ndCBvY2N1ci5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMzE3XG4gIHJldHVybiAnI2RvY3VtZW50Jztcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCB8fCAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gKF9yZWYgPSAoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSB8fCB0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSAmJiAhWydpbmxpbmUnLCAnY29udGVudHMnXS5pbmNsdWRlcyhkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBpc1RvcExheWVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsnOnBvcG92ZXItb3BlbicsICc6bW9kYWwnXS5zb21lKHNlbGVjdG9yID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50T3JDc3MpIHtcbiAgY29uc3Qgd2Via2l0ID0gaXNXZWJLaXQoKTtcbiAgY29uc3QgY3NzID0gaXNFbGVtZW50KGVsZW1lbnRPckNzcykgPyBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnRPckNzcykgOiBlbGVtZW50T3JDc3M7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgcmV0dXJuIGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gJ25vcm1hbCcgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmJhY2tkcm9wRmlsdGVyID8gY3NzLmJhY2tkcm9wRmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXS5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNUb3BMYXllcihjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIGlmICh0eXBlb2YgQ1NTID09PSAndW5kZWZpbmVkJyB8fCAhQ1NTLnN1cHBvcnRzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBDU1Muc3VwcG9ydHMoJy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyJywgJ25vbmUnKTtcbn1cbmZ1bmN0aW9uIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQod2luKTtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKGZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQod2luKSB7XG4gIHJldHVybiB3aW4ucGFyZW50ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih3aW4ucGFyZW50KSA/IHdpbi5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBnZXRDb250YWluaW5nQmxvY2ssIGdldERvY3VtZW50RWxlbWVudCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNUb3BMYXllciwgaXNXZWJLaXQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5VyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW1hcmNlbC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanM/MWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICBsZWZ0OiB4LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5leHBvcnQgeyBhbGlnbm1lbnRzLCBjbGFtcCwgY3JlYXRlQ29vcmRzLCBldmFsdWF0ZSwgZXhwYW5kUGFkZGluZ09iamVjdCwgZmxvb3IsIGdldEFsaWdubWVudCwgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldEF4aXNMZW5ndGgsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlQXhpcywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldFBhZGRpbmdPYmplY3QsIGdldFNpZGUsIGdldFNpZGVBeGlzLCBtYXgsIG1pbiwgcGxhY2VtZW50cywgcmVjdFRvQ2xpZW50UmVjdCwgcm91bmQsIHNpZGVzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ }),

/***/ "./node_modules/@glidejs/glide/dist/glide.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@glidejs/glide/dist/glide.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Glide)\n/* harmony export */ });\n/*!\n * Glide.js v3.6.2\n * (c) 2013-2024 Jdrzej Chaubek (https://github.com/jedrzejchalubek/)\n * Released under the MIT License.\n */\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nvar defaults = {\n  /**\n   * Type of the movement.\n   *\n   * Available types:\n   * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.\n   * `carousel` - Changes slides without starting over when it reaches the first or last slide.\n   *\n   * @type {String}\n   */\n  type: 'slider',\n\n  /**\n   * Start at specific slide number defined with zero-based index.\n   *\n   * @type {Number}\n   */\n  startAt: 0,\n\n  /**\n   * A number of slides visible on the single viewport.\n   *\n   * @type {Number}\n   */\n  perView: 1,\n\n  /**\n   * Focus currently active slide at a specified position in the track.\n   *\n   * Available inputs:\n   * `center` - Current slide will be always focused at the center of a track.\n   * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.\n   *\n   * @type {String|Number}\n   */\n  focusAt: 0,\n\n  /**\n   * A size of the gap added between slides.\n   *\n   * @type {Number}\n   */\n  gap: 10,\n\n  /**\n   * Change slides after a specified interval. Use `false` for turning off autoplay.\n   *\n   * @type {Number|Boolean}\n   */\n  autoplay: false,\n\n  /**\n   * Stop autoplay on mouseover event.\n   *\n   * @type {Boolean}\n   */\n  hoverpause: true,\n\n  /**\n   * Allow for changing slides with left and right keyboard arrows.\n   *\n   * @type {Boolean}\n   */\n  keyboard: true,\n\n  /**\n   * Stop running `perView` number of slides from the end. Use this\n   * option if you don't want to have an empty space after\n   * a slider. Works only with `slider` type and a\n   * non-centered `focusAt` setting.\n   *\n   * @type {Boolean}\n   */\n  bound: false,\n\n  /**\n   * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.\n   *\n   * @type {Number|Boolean}\n   */\n  swipeThreshold: 80,\n\n  /**\n   * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.\n   *\n   * @type {Number|Boolean}\n   */\n  dragThreshold: 120,\n\n  /**\n   * A number of slides moved on single swipe.\n   *\n   * Available types:\n   * `` - Moves slider by one slide per swipe\n   * `|` - Moves slider between views per swipe (number of slides defined in `perView` options)\n   *\n   * @type {String}\n   */\n  perSwipe: '',\n\n  /**\n   * Moving distance ratio of the slides on a swiping and dragging.\n   *\n   * @type {Number}\n   */\n  touchRatio: 0.5,\n\n  /**\n   * Angle required to activate slides moving on swiping or dragging.\n   *\n   * @type {Number}\n   */\n  touchAngle: 45,\n\n  /**\n   * Duration of the animation in milliseconds.\n   *\n   * @type {Number}\n   */\n  animationDuration: 400,\n\n  /**\n   * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.\n   *\n   * @type {Boolean}\n   */\n  rewind: true,\n\n  /**\n   * Duration of the rewinding animation of the `slider` type in milliseconds.\n   *\n   * @type {Number}\n   */\n  rewindDuration: 800,\n\n  /**\n   * Easing function for the animation.\n   *\n   * @type {String}\n   */\n  animationTimingFunc: 'cubic-bezier(.165, .840, .440, 1)',\n\n  /**\n   * Wait for the animation to finish until the next user input can be processed\n   *\n   * @type {boolean}\n   */\n  waitForTransition: true,\n\n  /**\n   * Throttle costly events at most once per every wait milliseconds.\n   *\n   * @type {Number}\n   */\n  throttle: 10,\n\n  /**\n   * Moving direction mode.\n   *\n   * Available inputs:\n   * - 'ltr' - left to right movement,\n   * - 'rtl' - right to left movement.\n   *\n   * @type {String}\n   */\n  direction: 'ltr',\n\n  /**\n   * The distance value of the next and previous viewports which\n   * have to peek in the current view. Accepts number and\n   * pixels as a string. Left and right peeking can be\n   * set up separately with a directions object.\n   *\n   * For example:\n   * `100` - Peek 100px on the both sides.\n   * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.\n   *\n   * @type {Number|String|Object}\n   */\n  peek: 0,\n\n  /**\n   * Defines how many clones of current viewport will be generated.\n   *\n   * @type {Number}\n   */\n  cloningRatio: 1,\n\n  /**\n   * Collection of options applied at specified media breakpoints.\n   * For example: display two slides per view under 800px.\n   * `{\n   *   '800px': {\n   *     perView: 2\n   *   }\n   * }`\n   */\n  breakpoints: {},\n\n  /**\n   * Collection of internally used HTML classes.\n   *\n   * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object\n   * @type {Object}\n   */\n  classes: {\n    swipeable: 'glide--swipeable',\n    dragging: 'glide--dragging',\n    direction: {\n      ltr: 'glide--ltr',\n      rtl: 'glide--rtl'\n    },\n    type: {\n      slider: 'glide--slider',\n      carousel: 'glide--carousel'\n    },\n    slide: {\n      clone: 'glide__slide--clone',\n      active: 'glide__slide--active'\n    },\n    arrow: {\n      disabled: 'glide__arrow--disabled'\n    },\n    nav: {\n      active: 'glide__bullet--active'\n    }\n  }\n};\n\n/**\n * Outputs warning message to the bowser console.\n *\n * @param  {String} msg\n * @return {Void}\n */\nfunction warn(msg) {\n  console.error(\"[Glide warn]: \".concat(msg));\n}\n\n/**\n * Converts value entered as number\n * or string to integer value.\n *\n * @param {String} value\n * @returns {Number}\n */\nfunction toInt(value) {\n  return parseInt(value);\n}\n/**\n * Converts value entered as number\n * or string to flat value.\n *\n * @param {String} value\n * @returns {Number}\n */\n\nfunction toFloat(value) {\n  return parseFloat(value);\n}\n/**\n * Indicates whether the specified value is a string.\n *\n * @param  {*}   value\n * @return {Boolean}\n */\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n/**\n * Indicates whether the specified value is an object.\n *\n * @param  {*} value\n * @return {Boolean}\n *\n * @see https://github.com/jashkenas/underscore\n */\n\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return type === 'function' || type === 'object' && !!value; // eslint-disable-line no-mixed-operators\n}\n/**\n * Indicates whether the specified value is a function.\n *\n * @param  {*} value\n * @return {Boolean}\n */\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * Indicates whether the specified value is undefined.\n *\n * @param  {*} value\n * @return {Boolean}\n */\n\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\n/**\n * Indicates whether the specified value is an array.\n *\n * @param  {*} value\n * @return {Boolean}\n */\n\nfunction isArray(value) {\n  return value.constructor === Array;\n}\n\n/**\n * Creates and initializes specified collection of extensions.\n * Each extension receives access to instance of glide and rest of components.\n *\n * @param {Object} glide\n * @param {Object} extensions\n *\n * @returns {Object}\n */\n\nfunction mount(glide, extensions, events) {\n  var components = {};\n\n  for (var name in extensions) {\n    if (isFunction(extensions[name])) {\n      components[name] = extensions[name](glide, components, events);\n    } else {\n      warn('Extension must be a function');\n    }\n  }\n\n  for (var _name in components) {\n    if (isFunction(components[_name].mount)) {\n      components[_name].mount();\n    }\n  }\n\n  return components;\n}\n\n/**\n * Defines getter and setter property on the specified object.\n *\n * @param  {Object} obj         Object where property has to be defined.\n * @param  {String} prop        Name of the defined property.\n * @param  {Object} definition  Get and set definitions for the property.\n * @return {Void}\n */\nfunction define(obj, prop, definition) {\n  Object.defineProperty(obj, prop, definition);\n}\n/**\n * Sorts aphabetically object keys.\n *\n * @param  {Object} obj\n * @return {Object}\n */\n\nfunction sortKeys(obj) {\n  return Object.keys(obj).sort().reduce(function (r, k) {\n    r[k] = obj[k];\n    return r[k], r;\n  }, {});\n}\n/**\n * Merges passed settings object with default options.\n *\n * @param  {Object} defaults\n * @param  {Object} settings\n * @return {Object}\n */\n\nfunction mergeOptions(defaults, settings) {\n  var options = Object.assign({}, defaults, settings); // `Object.assign` do not deeply merge objects, so we\n  // have to do it manually for every nested object\n  // in options. Although it does not look smart,\n  // it's smaller and faster than some fancy\n  // merging deep-merge algorithm script.\n\n  if (settings.hasOwnProperty('classes')) {\n    options.classes = Object.assign({}, defaults.classes, settings.classes);\n    var properties = ['direction', 'type', 'slide', 'arrow', 'nav'];\n    properties.forEach(function (property) {\n      if (settings.classes.hasOwnProperty(property)) {\n        options.classes[property] = _objectSpread2(_objectSpread2({}, defaults.classes[property]), settings.classes[property]);\n      }\n    });\n  }\n\n  if (settings.hasOwnProperty('breakpoints')) {\n    options.breakpoints = Object.assign({}, defaults.breakpoints, settings.breakpoints);\n  }\n\n  return options;\n}\n\nvar EventsBus = /*#__PURE__*/function () {\n  /**\n   * Construct a EventBus instance.\n   *\n   * @param {Object} events\n   */\n  function EventsBus() {\n    var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EventsBus);\n\n    this.events = events;\n    this.hop = events.hasOwnProperty;\n  }\n  /**\n   * Adds listener to the specifed event.\n   *\n   * @param {String|Array} event\n   * @param {Function} handler\n   */\n\n\n  _createClass(EventsBus, [{\n    key: \"on\",\n    value: function on(event, handler) {\n      if (isArray(event)) {\n        for (var i = 0; i < event.length; i++) {\n          this.on(event[i], handler);\n        }\n\n        return;\n      } // Create the event's object if not yet created\n\n\n      if (!this.hop.call(this.events, event)) {\n        this.events[event] = [];\n      } // Add the handler to queue\n\n\n      var index = this.events[event].push(handler) - 1; // Provide handle back for removal of event\n\n      return {\n        remove: function remove() {\n          delete this.events[event][index];\n        }\n      };\n    }\n    /**\n     * Runs registered handlers for specified event.\n     *\n     * @param {String|Array} event\n     * @param {Object=} context\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(event, context) {\n      if (isArray(event)) {\n        for (var i = 0; i < event.length; i++) {\n          this.emit(event[i], context);\n        }\n\n        return;\n      } // If the event doesn't exist, or there's no handlers in queue, just leave\n\n\n      if (!this.hop.call(this.events, event)) {\n        return;\n      } // Cycle through events queue, fire!\n\n\n      this.events[event].forEach(function (item) {\n        item(context || {});\n      });\n    }\n  }]);\n\n  return EventsBus;\n}();\n\nvar Glide$1 = /*#__PURE__*/function () {\n  /**\r\n   * Construct glide.\r\n   *\r\n   * @param  {String} selector\r\n   * @param  {Object} options\r\n   */\n  function Glide(selector) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Glide);\n\n    this._c = {};\n    this._t = [];\n    this._e = new EventsBus();\n    this.disabled = false;\n    this.selector = selector;\n    this.settings = mergeOptions(defaults, options);\n    this.index = this.settings.startAt;\n  }\n  /**\r\n   * Initializes glide.\r\n   *\r\n   * @param {Object} extensions Collection of extensions to initialize.\r\n   * @return {Glide}\r\n   */\n\n\n  _createClass(Glide, [{\n    key: \"mount\",\n    value: function mount$1() {\n      var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._e.emit('mount.before');\n\n      if (isObject(extensions)) {\n        this._c = mount(this, extensions, this._e);\n      } else {\n        warn('You need to provide a object on `mount()`');\n      }\n\n      this._e.emit('mount.after');\n\n      return this;\n    }\n    /**\r\n     * Collects an instance `translate` transformers.\r\n     *\r\n     * @param  {Array} transformers Collection of transformers.\r\n     * @return {Void}\r\n     */\n\n  }, {\n    key: \"mutate\",\n    value: function mutate() {\n      var transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (isArray(transformers)) {\n        this._t = transformers;\n      } else {\n        warn('You need to provide a array on `mutate()`');\n      }\n\n      return this;\n    }\n    /**\r\n     * Updates glide with specified settings.\r\n     *\r\n     * @param {Object} settings\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.settings = mergeOptions(this.settings, settings);\n\n      if (settings.hasOwnProperty('startAt')) {\n        this.index = settings.startAt;\n      }\n\n      this._e.emit('update');\n\n      return this;\n    }\n    /**\r\n     * Change slide with specified pattern. A pattern must be in the special format:\r\n     * `>` - Move one forward\r\n     * `<` - Move one backward\r\n     * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)\r\n     * `>>` - Rewinds to end (last slide)\r\n     * `<<` - Rewinds to start (first slide)\r\n     * `|>` - Move one viewport forward\r\n     * `|<` - Move one viewport backward\r\n     *\r\n     * @param {String} pattern\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"go\",\n    value: function go(pattern) {\n      this._c.Run.make(pattern);\n\n      return this;\n    }\n    /**\r\n     * Move track by specified distance.\r\n     *\r\n     * @param {String} distance\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(distance) {\n      this._c.Transition.disable();\n\n      this._c.Move.make(distance);\n\n      return this;\n    }\n    /**\r\n     * Destroy instance and revert all changes done by this._c.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._e.emit('destroy');\n\n      return this;\n    }\n    /**\r\n     * Start instance autoplaying.\r\n     *\r\n     * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (interval) {\n        this.settings.autoplay = interval;\n      }\n\n      this._e.emit('play');\n\n      return this;\n    }\n    /**\r\n     * Stop instance autoplaying.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._e.emit('pause');\n\n      return this;\n    }\n    /**\r\n     * Sets glide into a idle status.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.disabled = true;\n      return this;\n    }\n    /**\r\n     * Sets glide into a active status.\r\n     *\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.disabled = false;\n      return this;\n    }\n    /**\r\n     * Adds cuutom event listener with handler.\r\n     *\r\n     * @param  {String|Array} event\r\n     * @param  {Function} handler\r\n     * @return {Glide}\r\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, handler) {\n      this._e.on(event, handler);\n\n      return this;\n    }\n    /**\r\n     * Checks if glide is a precised type.\r\n     *\r\n     * @param  {String} name\r\n     * @return {Boolean}\r\n     */\n\n  }, {\n    key: \"isType\",\n    value: function isType(name) {\n      return this.settings.type === name;\n    }\n    /**\r\n     * Gets value of the core options.\r\n     *\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"settings\",\n    get: function get() {\n      return this._o;\n    }\n    /**\r\n     * Sets value of the core options.\r\n     *\r\n     * @param  {Object} o\r\n     * @return {Void}\r\n     */\n    ,\n    set: function set(o) {\n      if (isObject(o)) {\n        this._o = o;\n      } else {\n        warn('Options must be an `object` instance.');\n      }\n    }\n    /**\r\n     * Gets current index of the slider.\r\n     *\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this._i;\n    }\n    /**\r\n     * Sets current index a slider.\r\n     *\r\n     * @return {Object}\r\n     */\n    ,\n    set: function set(i) {\n      this._i = toInt(i);\n    }\n    /**\r\n     * Gets type name of the slider.\r\n     *\r\n     * @return {String}\r\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.settings.type;\n    }\n    /**\r\n     * Gets value of the idle status.\r\n     *\r\n     * @return {Boolean}\r\n     */\n\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this._d;\n    }\n    /**\r\n     * Sets value of the idle status.\r\n     *\r\n     * @return {Boolean}\r\n     */\n    ,\n    set: function set(status) {\n      this._d = !!status;\n    }\n  }]);\n\n  return Glide;\n}();\n\nfunction Run (Glide, Components, Events) {\n  var Run = {\n    /**\n     * Initializes autorunning of the glide.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this._o = false;\n    },\n\n    /**\n     * Makes glides running based on the passed moving schema.\n     *\n     * @param {String} move\n     */\n    make: function make(move) {\n      var _this = this;\n\n      if (!Glide.disabled) {\n        !Glide.settings.waitForTransition || Glide.disable();\n        this.move = move;\n        Events.emit('run.before', this.move);\n        this.calculate();\n        Events.emit('run', this.move);\n        Components.Transition.after(function () {\n          if (_this.isStart()) {\n            Events.emit('run.start', _this.move);\n          }\n\n          if (_this.isEnd()) {\n            Events.emit('run.end', _this.move);\n          }\n\n          if (_this.isOffset()) {\n            _this._o = false;\n            Events.emit('run.offset', _this.move);\n          }\n\n          Events.emit('run.after', _this.move);\n          Glide.enable();\n        });\n      }\n    },\n\n    /**\n     * Calculates current index based on defined move.\n     *\n     * @return {Number|Undefined}\n     */\n    calculate: function calculate() {\n      var move = this.move,\n          length = this.length;\n      var steps = move.steps,\n          direction = move.direction; // By default assume that size of view is equal to one slide\n\n      var viewSize = 1; // While direction is `=` we want jump to\n      // a specified index described in steps.\n\n      if (direction === '=') {\n        // Check if bound is true, \n        // as we want to avoid whitespaces.\n        if (Glide.settings.bound && toInt(steps) > length) {\n          Glide.index = length;\n          return;\n        }\n\n        Glide.index = steps;\n        return;\n      } // When pattern is equal to `>>` we want\n      // fast forward to the last slide.\n\n\n      if (direction === '>' && steps === '>') {\n        Glide.index = length;\n        return;\n      } // When pattern is equal to `<<` we want\n      // fast forward to the first slide.\n\n\n      if (direction === '<' && steps === '<') {\n        Glide.index = 0;\n        return;\n      } // pagination movement\n\n\n      if (direction === '|') {\n        viewSize = Glide.settings.perView || 1;\n      } // we are moving forward\n\n\n      if (direction === '>' || direction === '|' && steps === '>') {\n        var index = calculateForwardIndex(viewSize);\n\n        if (index > length) {\n          this._o = true;\n        }\n\n        Glide.index = normalizeForwardIndex(index, viewSize);\n        return;\n      } // we are moving backward\n\n\n      if (direction === '<' || direction === '|' && steps === '<') {\n        var _index = calculateBackwardIndex(viewSize);\n\n        if (_index < 0) {\n          this._o = true;\n        }\n\n        Glide.index = normalizeBackwardIndex(_index, viewSize);\n        return;\n      }\n\n      warn(\"Invalid direction pattern [\".concat(direction).concat(steps, \"] has been used\"));\n    },\n\n    /**\n     * Checks if we are on the first slide.\n     *\n     * @return {Boolean}\n     */\n    isStart: function isStart() {\n      return Glide.index <= 0;\n    },\n\n    /**\n     * Checks if we are on the last slide.\n     *\n     * @return {Boolean}\n     */\n    isEnd: function isEnd() {\n      return Glide.index >= this.length;\n    },\n\n    /**\n     * Checks if we are making a offset run.\n     *\n     * @param {String} direction\n     * @return {Boolean}\n     */\n    isOffset: function isOffset() {\n      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n      if (!direction) {\n        return this._o;\n      }\n\n      if (!this._o) {\n        return false;\n      } // did we view to the right?\n\n\n      if (direction === '|>') {\n        return this.move.direction === '|' && this.move.steps === '>';\n      } // did we view to the left?\n\n\n      if (direction === '|<') {\n        return this.move.direction === '|' && this.move.steps === '<';\n      }\n\n      return this.move.direction === direction;\n    },\n\n    /**\n     * Checks if bound mode is active\n     *\n     * @return {Boolean}\n     */\n    isBound: function isBound() {\n      return Glide.isType('slider') && Glide.settings.focusAt !== 'center' && Glide.settings.bound;\n    }\n  };\n  /**\n   * Returns index value to move forward/to the right\n   *\n   * @param viewSize\n   * @returns {Number}\n   */\n\n  function calculateForwardIndex(viewSize) {\n    var index = Glide.index;\n\n    if (Glide.isType('carousel')) {\n      return index + viewSize;\n    }\n\n    return index + (viewSize - index % viewSize);\n  }\n  /**\n   * Normalizes the given forward index based on glide settings, preventing it to exceed certain boundaries\n   *\n   * @param index\n   * @param length\n   * @param viewSize\n   * @returns {Number}\n   */\n\n\n  function normalizeForwardIndex(index, viewSize) {\n    var length = Run.length;\n\n    if (index <= length) {\n      return index;\n    }\n\n    if (Glide.isType('carousel')) {\n      return index - (length + 1);\n    }\n\n    if (Glide.settings.rewind) {\n      // bound does funny things with the length, therefor we have to be certain\n      // that we are on the last possible index value given by bound\n      if (Run.isBound() && !Run.isEnd()) {\n        return length;\n      }\n\n      return 0;\n    }\n\n    if (Run.isBound()) {\n      return length;\n    }\n\n    return Math.floor(length / viewSize) * viewSize;\n  }\n  /**\n   * Calculates index value to move backward/to the left\n   *\n   * @param viewSize\n   * @returns {Number}\n   */\n\n\n  function calculateBackwardIndex(viewSize) {\n    var index = Glide.index;\n\n    if (Glide.isType('carousel')) {\n      return index - viewSize;\n    } // ensure our back navigation results in the same index as a forward navigation\n    // to experience a homogeneous paging\n\n\n    var view = Math.ceil(index / viewSize);\n    return (view - 1) * viewSize;\n  }\n  /**\n   * Normalizes the given backward index based on glide settings, preventing it to exceed certain boundaries\n   *\n   * @param index\n   * @param length\n   * @param viewSize\n   * @returns {*}\n   */\n\n\n  function normalizeBackwardIndex(index, viewSize) {\n    var length = Run.length;\n\n    if (index >= 0) {\n      return index;\n    }\n\n    if (Glide.isType('carousel')) {\n      return index + (length + 1);\n    }\n\n    if (Glide.settings.rewind) {\n      // bound does funny things with the length, therefor we have to be certain\n      // that we are on first possible index value before we to rewind to the length given by bound\n      if (Run.isBound() && Run.isStart()) {\n        return length;\n      }\n\n      return Math.floor(length / viewSize) * viewSize;\n    }\n\n    return 0;\n  }\n\n  define(Run, 'move', {\n    /**\n     * Gets value of the move schema.\n     *\n     * @returns {Object}\n     */\n    get: function get() {\n      return this._m;\n    },\n\n    /**\n     * Sets value of the move schema.\n     *\n     * @returns {Object}\n     */\n    set: function set(value) {\n      var step = value.substr(1);\n      this._m = {\n        direction: value.substr(0, 1),\n        steps: step ? toInt(step) ? toInt(step) : step : 0\n      };\n    }\n  });\n  define(Run, 'length', {\n    /**\n     * Gets value of the running distance based\n     * on zero-indexing number of slides.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var settings = Glide.settings;\n      var length = Components.Html.slides.length; // If the `bound` option is active, a maximum running distance should be\n      // reduced by `perView` and `focusAt` settings. Running distance\n      // should end before creating an empty space after instance.\n\n      if (this.isBound()) {\n        return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);\n      }\n\n      return length - 1;\n    }\n  });\n  define(Run, 'offset', {\n    /**\n     * Gets status of the offsetting flag.\n     *\n     * @return {Boolean}\n     */\n    get: function get() {\n      return this._o;\n    }\n  });\n  return Run;\n}\n\n/**\n * Returns a current time.\n *\n * @return {Number}\n */\nfunction now() {\n  return new Date().getTime();\n}\n\n/**\n * Returns a function, that, when invoked, will only be triggered\n * at most once during a given window of time.\n *\n * @param {Function} func\n * @param {Number} wait\n * @param {Object=} options\n * @return {Function}\n *\n * @see https://github.com/jashkenas/underscore\n */\n\nfunction throttle(func, wait) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout, context, args, result;\n  var previous = 0;\n\n  var later = function later() {\n    previous = options.leading === false ? 0 : now();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  var throttled = function throttled() {\n    var at = now();\n    if (!previous && options.leading === false) previous = at;\n    var remaining = wait - (at - previous);\n    context = this;\n    args = arguments;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = at;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n\n  throttled.cancel = function () {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = context = args = null;\n  };\n\n  return throttled;\n}\n\nvar MARGIN_TYPE = {\n  ltr: ['marginLeft', 'marginRight'],\n  rtl: ['marginRight', 'marginLeft']\n};\nfunction Gaps (Glide, Components, Events) {\n  var Gaps = {\n    /**\n     * Applies gaps between slides. First and last\n     * slides do not receive it's edge margins.\n     *\n     * @param {HTMLCollection} slides\n     * @return {Void}\n     */\n    apply: function apply(slides) {\n      for (var i = 0, len = slides.length; i < len; i++) {\n        var style = slides[i].style;\n        var direction = Components.Direction.value;\n\n        if (i !== 0) {\n          style[MARGIN_TYPE[direction][0]] = \"\".concat(this.value / 2, \"px\");\n        } else {\n          style[MARGIN_TYPE[direction][0]] = '';\n        }\n\n        if (i !== slides.length - 1) {\n          style[MARGIN_TYPE[direction][1]] = \"\".concat(this.value / 2, \"px\");\n        } else {\n          style[MARGIN_TYPE[direction][1]] = '';\n        }\n      }\n    },\n\n    /**\n     * Removes gaps from the slides.\n     *\n     * @param {HTMLCollection} slides\n     * @returns {Void}\n    */\n    remove: function remove(slides) {\n      for (var i = 0, len = slides.length; i < len; i++) {\n        var style = slides[i].style;\n        style.marginLeft = '';\n        style.marginRight = '';\n      }\n    }\n  };\n  define(Gaps, 'value', {\n    /**\n     * Gets value of the gap.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      return toInt(Glide.settings.gap);\n    }\n  });\n  define(Gaps, 'grow', {\n    /**\n     * Gets additional dimensions value caused by gaps.\n     * Used to increase width of the slides wrapper.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      return Gaps.value * Components.Sizes.length;\n    }\n  });\n  define(Gaps, 'reductor', {\n    /**\n     * Gets reduction value caused by gaps.\n     * Used to subtract width of the slides.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      var perView = Glide.settings.perView;\n      return Gaps.value * (perView - 1) / perView;\n    }\n  });\n  /**\n   * Apply calculated gaps:\n   * - after building, so slides (including clones) will receive proper margins\n   * - on updating via API, to recalculate gaps with new options\n   */\n\n  Events.on(['build.after', 'update'], throttle(function () {\n    Gaps.apply(Components.Html.wrapper.children);\n  }, 30));\n  /**\n   * Remove gaps:\n   * - on destroying to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Gaps.remove(Components.Html.wrapper.children);\n  });\n  return Gaps;\n}\n\n/**\n * Finds siblings nodes of the passed node.\n *\n * @param  {Element} node\n * @return {Array}\n */\nfunction siblings(node) {\n  if (node && node.parentNode) {\n    var n = node.parentNode.firstChild;\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== node) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  }\n\n  return [];\n}\n/**\n * Coerces a NodeList to an Array.\n *\n * @param  {NodeList} nodeList\n * @return {Array}\n */\n\nfunction toArray(nodeList) {\n  return Array.prototype.slice.call(nodeList);\n}\n\nvar TRACK_SELECTOR = '[data-glide-el=\"track\"]';\nfunction Html (Glide, Components, Events) {\n  var Html = {\n    /**\n     * Setup slider HTML nodes.\n     *\n     * @param {Glide} glide\n     */\n    mount: function mount() {\n      this.root = Glide.selector;\n      this.track = this.root.querySelector(TRACK_SELECTOR);\n      this.collectSlides();\n    },\n\n    /**\n     * Collect slides\n     */\n    collectSlides: function collectSlides() {\n      this.slides = toArray(this.wrapper.children).filter(function (slide) {\n        return !slide.classList.contains(Glide.settings.classes.slide.clone);\n      });\n    }\n  };\n  define(Html, 'root', {\n    /**\n     * Gets node of the glide main element.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Html._r;\n    },\n\n    /**\n     * Sets node of the glide main element.\n     *\n     * @return {Object}\n     */\n    set: function set(r) {\n      if (isString(r)) {\n        r = document.querySelector(r);\n      }\n\n      if (r !== null) {\n        Html._r = r;\n      } else {\n        warn('Root element must be a existing Html node');\n      }\n    }\n  });\n  define(Html, 'track', {\n    /**\n     * Gets node of the glide track with slides.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Html._t;\n    },\n\n    /**\n     * Sets node of the glide track with slides.\n     *\n     * @return {Object}\n     */\n    set: function set(t) {\n      Html._t = t;\n    }\n  });\n  define(Html, 'wrapper', {\n    /**\n     * Gets node of the slides wrapper.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Html.track.children[0];\n    }\n  });\n  /**\n   * Add/remove/reorder dynamic slides\n   */\n\n  Events.on('update', function () {\n    Html.collectSlides();\n  });\n  return Html;\n}\n\nfunction Peek (Glide, Components, Events) {\n  var Peek = {\n    /**\n     * Setups how much to peek based on settings.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.value = Glide.settings.peek;\n    }\n  };\n  define(Peek, 'value', {\n    /**\n     * Gets value of the peek.\n     *\n     * @returns {Number|Object}\n     */\n    get: function get() {\n      return Peek._v;\n    },\n\n    /**\n     * Sets value of the peek.\n     *\n     * @param {Number|Object} value\n     * @return {Void}\n     */\n    set: function set(value) {\n      if (isObject(value)) {\n        value.before = toInt(value.before);\n        value.after = toInt(value.after);\n      } else {\n        value = toInt(value);\n      }\n\n      Peek._v = value;\n    }\n  });\n  define(Peek, 'reductor', {\n    /**\n     * Gets reduction value caused by peek.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      var value = Peek.value;\n      var perView = Glide.settings.perView;\n\n      if (isObject(value)) {\n        return value.before / perView + value.after / perView;\n      }\n\n      return value * 2 / perView;\n    }\n  });\n  /**\n   * Recalculate peeking sizes on:\n   * - when resizing window to update to proper percents\n   */\n\n  Events.on(['resize', 'update'], function () {\n    Peek.mount();\n  });\n  return Peek;\n}\n\nfunction Move (Glide, Components, Events) {\n  var Move = {\n    /**\n     * Constructs move component.\n     *\n     * @returns {Void}\n     */\n    mount: function mount() {\n      this._o = 0;\n    },\n\n    /**\n     * Calculates a movement value based on passed offset and currently active index.\n     *\n     * @param  {Number} offset\n     * @return {Void}\n     */\n    make: function make() {\n      var _this = this;\n\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.offset = offset;\n      Events.emit('move', {\n        movement: this.value\n      });\n      Components.Transition.after(function () {\n        Events.emit('move.after', {\n          movement: _this.value\n        });\n      });\n    }\n  };\n  define(Move, 'offset', {\n    /**\n     * Gets an offset value used to modify current translate.\n     *\n     * @return {Object}\n     */\n    get: function get() {\n      return Move._o;\n    },\n\n    /**\n     * Sets an offset value used to modify current translate.\n     *\n     * @return {Object}\n     */\n    set: function set(value) {\n      Move._o = !isUndefined(value) ? toInt(value) : 0;\n    }\n  });\n  define(Move, 'translate', {\n    /**\n     * Gets a raw movement value.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Components.Sizes.slideWidth * Glide.index;\n    }\n  });\n  define(Move, 'value', {\n    /**\n     * Gets an actual movement value corrected by offset.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var offset = this.offset;\n      var translate = this.translate;\n\n      if (Components.Direction.is('rtl')) {\n        return translate + offset;\n      }\n\n      return translate - offset;\n    }\n  });\n  /**\n   * Make movement to proper slide on:\n   * - before build, so glide will start at `startAt` index\n   * - on each standard run to move to newly calculated index\n   */\n\n  Events.on(['build.before', 'run'], function () {\n    Move.make();\n  });\n  return Move;\n}\n\nfunction Sizes (Glide, Components, Events) {\n  var Sizes = {\n    /**\n     * Setups dimensions of slides.\n     *\n     * @return {Void}\n     */\n    setupSlides: function setupSlides() {\n      var width = \"\".concat(this.slideWidth, \"px\");\n      var slides = Components.Html.slides;\n\n      for (var i = 0; i < slides.length; i++) {\n        slides[i].style.width = width;\n      }\n    },\n\n    /**\n     * Setups dimensions of slides wrapper.\n     *\n     * @return {Void}\n     */\n    setupWrapper: function setupWrapper() {\n      Components.Html.wrapper.style.width = \"\".concat(this.wrapperSize, \"px\");\n    },\n\n    /**\n     * Removes applied styles from HTML elements.\n     *\n     * @returns {Void}\n     */\n    remove: function remove() {\n      var slides = Components.Html.slides;\n\n      for (var i = 0; i < slides.length; i++) {\n        slides[i].style.width = '';\n      }\n\n      Components.Html.wrapper.style.width = '';\n    }\n  };\n  define(Sizes, 'length', {\n    /**\n     * Gets count number of the slides.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Components.Html.slides.length;\n    }\n  });\n  define(Sizes, 'width', {\n    /**\n     * Gets width value of the slider (visible area).\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Components.Html.track.offsetWidth;\n    }\n  });\n  define(Sizes, 'wrapperSize', {\n    /**\n     * Gets size of the slides wrapper.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Sizes.slideWidth * Sizes.length + Components.Gaps.grow + Components.Clones.grow;\n    }\n  });\n  define(Sizes, 'slideWidth', {\n    /**\n     * Gets width value of a single slide.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return Sizes.width / Glide.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;\n    }\n  });\n  /**\n   * Apply calculated glide's dimensions:\n   * - before building, so other dimensions (e.g. translate) will be calculated propertly\n   * - when resizing window to recalculate sildes dimensions\n   * - on updating via API, to calculate dimensions based on new options\n   */\n\n  Events.on(['build.before', 'resize', 'update'], function () {\n    Sizes.setupSlides();\n    Sizes.setupWrapper();\n  });\n  /**\n   * Remove calculated glide's dimensions:\n   * - on destoting to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Sizes.remove();\n  });\n  return Sizes;\n}\n\nfunction Build (Glide, Components, Events) {\n  var Build = {\n    /**\n     * Init glide building. Adds classes, sets\n     * dimensions and setups initial state.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      Events.emit('build.before');\n      this.typeClass();\n      this.activeClass();\n      Events.emit('build.after');\n    },\n\n    /**\n     * Adds `type` class to the glide element.\n     *\n     * @return {Void}\n     */\n    typeClass: function typeClass() {\n      Components.Html.root.classList.add(Glide.settings.classes.type[Glide.settings.type]);\n    },\n\n    /**\n     * Sets active class to current slide.\n     *\n     * @return {Void}\n     */\n    activeClass: function activeClass() {\n      var classes = Glide.settings.classes;\n      var slide = Components.Html.slides[Glide.index];\n\n      if (slide) {\n        slide.classList.add(classes.slide.active);\n        siblings(slide).forEach(function (sibling) {\n          sibling.classList.remove(classes.slide.active);\n        });\n      }\n    },\n\n    /**\n     * Removes HTML classes applied at building.\n     *\n     * @return {Void}\n     */\n    removeClasses: function removeClasses() {\n      var _Glide$settings$class = Glide.settings.classes,\n          type = _Glide$settings$class.type,\n          slide = _Glide$settings$class.slide;\n      Components.Html.root.classList.remove(type[Glide.settings.type]);\n      Components.Html.slides.forEach(function (sibling) {\n        sibling.classList.remove(slide.active);\n      });\n    }\n  };\n  /**\n   * Clear building classes:\n   * - on destroying to bring HTML to its initial state\n   * - on updating to remove classes before remounting component\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Build.removeClasses();\n  });\n  /**\n   * Remount component:\n   * - on resizing of the window to calculate new dimensions\n   * - on updating settings via API\n   */\n\n  Events.on(['resize', 'update'], function () {\n    Build.mount();\n  });\n  /**\n   * Swap active class of current slide:\n   * - after each move to the new index\n   */\n\n  Events.on('move.after', function () {\n    Build.activeClass();\n  });\n  return Build;\n}\n\nfunction Clones (Glide, Components, Events) {\n  var Clones = {\n    /**\n     * Create pattern map and collect slides to be cloned.\n     */\n    mount: function mount() {\n      this.items = [];\n\n      if (Glide.isType('carousel')) {\n        this.items = this.collect();\n      }\n    },\n\n    /**\n     * Collect clones with pattern.\n     *\n     * @return {[]}\n     */\n    collect: function collect() {\n      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var slides = Components.Html.slides;\n      var _Glide$settings = Glide.settings,\n          perView = _Glide$settings.perView,\n          classes = _Glide$settings.classes,\n          cloningRatio = _Glide$settings.cloningRatio;\n\n      if (slides.length > 0) {\n        var peekIncrementer = +!!Glide.settings.peek;\n        var cloneCount = perView + peekIncrementer + Math.round(perView / 2);\n        var append = slides.slice(0, cloneCount).reverse();\n        var prepend = slides.slice(cloneCount * -1);\n\n        for (var r = 0; r < Math.max(cloningRatio, Math.floor(perView / slides.length)); r++) {\n          for (var i = 0; i < append.length; i++) {\n            var clone = append[i].cloneNode(true);\n            clone.classList.add(classes.slide.clone);\n            items.push(clone);\n          }\n\n          for (var _i = 0; _i < prepend.length; _i++) {\n            var _clone = prepend[_i].cloneNode(true);\n\n            _clone.classList.add(classes.slide.clone);\n\n            items.unshift(_clone);\n          }\n        }\n      }\n\n      return items;\n    },\n\n    /**\n     * Append cloned slides with generated pattern.\n     *\n     * @return {Void}\n     */\n    append: function append() {\n      var items = this.items;\n      var _Components$Html = Components.Html,\n          wrapper = _Components$Html.wrapper,\n          slides = _Components$Html.slides;\n      var half = Math.floor(items.length / 2);\n      var prepend = items.slice(0, half).reverse();\n      var append = items.slice(half * -1).reverse();\n      var width = \"\".concat(Components.Sizes.slideWidth, \"px\");\n\n      for (var i = 0; i < append.length; i++) {\n        wrapper.appendChild(append[i]);\n      }\n\n      for (var _i2 = 0; _i2 < prepend.length; _i2++) {\n        wrapper.insertBefore(prepend[_i2], slides[0]);\n      }\n\n      for (var _i3 = 0; _i3 < items.length; _i3++) {\n        items[_i3].style.width = width;\n      }\n    },\n\n    /**\n     * Remove all cloned slides.\n     *\n     * @return {Void}\n     */\n    remove: function remove() {\n      var items = this.items;\n\n      for (var i = 0; i < items.length; i++) {\n        Components.Html.wrapper.removeChild(items[i]);\n      }\n    }\n  };\n  define(Clones, 'grow', {\n    /**\n     * Gets additional dimensions value caused by clones.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones.items.length;\n    }\n  });\n  /**\n   * Append additional slide's clones:\n   * - while glide's type is `carousel`\n   */\n\n  Events.on('update', function () {\n    Clones.remove();\n    Clones.mount();\n    Clones.append();\n  });\n  /**\n   * Append additional slide's clones:\n   * - while glide's type is `carousel`\n   */\n\n  Events.on('build.before', function () {\n    if (Glide.isType('carousel')) {\n      Clones.append();\n    }\n  });\n  /**\n   * Remove clones HTMLElements:\n   * - on destroying, to bring HTML to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Clones.remove();\n  });\n  return Clones;\n}\n\nvar EventsBinder = /*#__PURE__*/function () {\n  /**\n   * Construct a EventsBinder instance.\n   */\n  function EventsBinder() {\n    var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EventsBinder);\n\n    this.listeners = listeners;\n  }\n  /**\n   * Adds events listeners to arrows HTML elements.\n   *\n   * @param  {String|Array} events\n   * @param  {Element|Window|Document} el\n   * @param  {Function} closure\n   * @param  {Boolean|Object} capture\n   * @return {Void}\n   */\n\n\n  _createClass(EventsBinder, [{\n    key: \"on\",\n    value: function on(events, el, closure) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (isString(events)) {\n        events = [events];\n      }\n\n      for (var i = 0; i < events.length; i++) {\n        this.listeners[events[i]] = closure;\n        el.addEventListener(events[i], this.listeners[events[i]], capture);\n      }\n    }\n    /**\n     * Removes event listeners from arrows HTML elements.\n     *\n     * @param  {String|Array} events\n     * @param  {Element|Window|Document} el\n     * @param  {Boolean|Object} capture\n     * @return {Void}\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(events, el) {\n      var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (isString(events)) {\n        events = [events];\n      }\n\n      for (var i = 0; i < events.length; i++) {\n        el.removeEventListener(events[i], this.listeners[events[i]], capture);\n      }\n    }\n    /**\n     * Destroy collected listeners.\n     *\n     * @returns {Void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      delete this.listeners;\n    }\n  }]);\n\n  return EventsBinder;\n}();\n\nfunction Resize (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Resize = {\n    /**\n     * Initializes window bindings.\n     */\n    mount: function mount() {\n      this.bind();\n    },\n\n    /**\n     * Binds `rezsize` listener to the window.\n     * It's a costly event, so we are debouncing it.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('resize', window, throttle(function () {\n        Events.emit('resize');\n      }, Glide.settings.throttle));\n    },\n\n    /**\n     * Unbinds listeners from the window.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('resize', window);\n    }\n  };\n  /**\n   * Remove bindings from window:\n   * - on destroying, to remove added EventListener\n   */\n\n  Events.on('destroy', function () {\n    Resize.unbind();\n    Binder.destroy();\n  });\n  return Resize;\n}\n\nvar VALID_DIRECTIONS = ['ltr', 'rtl'];\nvar FLIPED_MOVEMENTS = {\n  '>': '<',\n  '<': '>',\n  '=': '='\n};\nfunction Direction (Glide, Components, Events) {\n  var Direction = {\n    /**\n     * Setups gap value based on settings.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.value = Glide.settings.direction;\n    },\n\n    /**\n     * Resolves pattern based on direction value\n     *\n     * @param {String} pattern\n     * @returns {String}\n     */\n    resolve: function resolve(pattern) {\n      var token = pattern.slice(0, 1);\n\n      if (this.is('rtl')) {\n        return pattern.split(token).join(FLIPED_MOVEMENTS[token]);\n      }\n\n      return pattern;\n    },\n\n    /**\n     * Checks value of direction mode.\n     *\n     * @param {String} direction\n     * @returns {Boolean}\n     */\n    is: function is(direction) {\n      return this.value === direction;\n    },\n\n    /**\n     * Applies direction class to the root HTML element.\n     *\n     * @return {Void}\n     */\n    addClass: function addClass() {\n      Components.Html.root.classList.add(Glide.settings.classes.direction[this.value]);\n    },\n\n    /**\n     * Removes direction class from the root HTML element.\n     *\n     * @return {Void}\n     */\n    removeClass: function removeClass() {\n      Components.Html.root.classList.remove(Glide.settings.classes.direction[this.value]);\n    }\n  };\n  define(Direction, 'value', {\n    /**\n     * Gets value of the direction.\n     *\n     * @returns {Number}\n     */\n    get: function get() {\n      return Direction._v;\n    },\n\n    /**\n     * Sets value of the direction.\n     *\n     * @param {String} value\n     * @return {Void}\n     */\n    set: function set(value) {\n      if (VALID_DIRECTIONS.indexOf(value) > -1) {\n        Direction._v = value;\n      } else {\n        warn('Direction value must be `ltr` or `rtl`');\n      }\n    }\n  });\n  /**\n   * Clear direction class:\n   * - on destroy to bring HTML to its initial state\n   * - on update to remove class before reappling bellow\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Direction.removeClass();\n  });\n  /**\n   * Remount component:\n   * - on update to reflect changes in direction value\n   */\n\n  Events.on('update', function () {\n    Direction.mount();\n  });\n  /**\n   * Apply direction class:\n   * - before building to apply class for the first time\n   * - on updating to reapply direction class that may changed\n   */\n\n  Events.on(['build.before', 'update'], function () {\n    Direction.addClass();\n  });\n  return Direction;\n}\n\n/**\n * Reflects value of glide movement.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Rtl (Glide, Components) {\n  return {\n    /**\n     * Negates the passed translate if glide is in RTL option.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      if (Components.Direction.is('rtl')) {\n        return -translate;\n      }\n\n      return translate;\n    }\n  };\n}\n\n/**\n * Updates glide movement with a `gap` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Gap (Glide, Components) {\n  return {\n    /**\n     * Modifies passed translate value with number in the `gap` settings.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      var multiplier = Math.floor(translate / Components.Sizes.slideWidth);\n      return translate + Components.Gaps.value * multiplier;\n    }\n  };\n}\n\n/**\n * Updates glide movement with width of additional clones width.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Grow (Glide, Components) {\n  return {\n    /**\n     * Adds to the passed translate width of the half of clones.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      return translate + Components.Clones.grow / 2;\n    }\n  };\n}\n\n/**\n * Updates glide movement with a `peek` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\n\nfunction Peeking (Glide, Components) {\n  return {\n    /**\n     * Modifies passed translate value with a `peek` setting.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      if (Glide.settings.focusAt >= 0) {\n        var peek = Components.Peek.value;\n\n        if (isObject(peek)) {\n          return translate - peek.before;\n        }\n\n        return translate - peek;\n      }\n\n      return translate;\n    }\n  };\n}\n\n/**\n * Updates glide movement with a `focusAt` settings.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\nfunction Focusing (Glide, Components) {\n  return {\n    /**\n     * Modifies passed translate value with index in the `focusAt` setting.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    modify: function modify(translate) {\n      var gap = Components.Gaps.value;\n      var width = Components.Sizes.width;\n      var focusAt = Glide.settings.focusAt;\n      var slideWidth = Components.Sizes.slideWidth;\n\n      if (focusAt === 'center') {\n        return translate - (width / 2 - slideWidth / 2);\n      }\n\n      return translate - slideWidth * focusAt - gap * focusAt;\n    }\n  };\n}\n\n/**\n * Applies diffrent transformers on translate value.\n *\n * @param  {Object} Glide\n * @param  {Object} Components\n * @return {Object}\n */\n\nfunction mutator (Glide, Components, Events) {\n  /**\n   * Merge instance transformers with collection of default transformers.\n   * It's important that the Rtl component be last on the list,\n   * so it reflects all previous transformations.\n   *\n   * @type {Array}\n   */\n  var TRANSFORMERS = [Gap, Grow, Peeking, Focusing].concat(Glide._t, [Rtl]);\n  return {\n    /**\n     * Piplines translate value with registered transformers.\n     *\n     * @param  {Number} translate\n     * @return {Number}\n     */\n    mutate: function mutate(translate) {\n      for (var i = 0; i < TRANSFORMERS.length; i++) {\n        var transformer = TRANSFORMERS[i];\n\n        if (isFunction(transformer) && isFunction(transformer().modify)) {\n          translate = transformer(Glide, Components, Events).modify(translate);\n        } else {\n          warn('Transformer should be a function that returns an object with `modify()` method');\n        }\n      }\n\n      return translate;\n    }\n  };\n}\n\nfunction Translate (Glide, Components, Events) {\n  var Translate = {\n    /**\n     * Sets value of translate on HTML element.\n     *\n     * @param {Number} value\n     * @return {Void}\n     */\n    set: function set(value) {\n      var transform = mutator(Glide, Components).mutate(value);\n      var translate3d = \"translate3d(\".concat(-1 * transform, \"px, 0px, 0px)\");\n      Components.Html.wrapper.style.mozTransform = translate3d; // needed for supported Firefox 10-15\n\n      Components.Html.wrapper.style.webkitTransform = translate3d; // needed for supported Chrome 10-35, Safari 5.1-8, and Opera 15-22\n\n      Components.Html.wrapper.style.transform = translate3d;\n    },\n\n    /**\n     * Removes value of translate from HTML element.\n     *\n     * @return {Void}\n     */\n    remove: function remove() {\n      Components.Html.wrapper.style.transform = '';\n    },\n\n    /**\n     * @return {number}\n     */\n    getStartIndex: function getStartIndex() {\n      var length = Components.Sizes.length;\n      var index = Glide.index;\n      var perView = Glide.settings.perView;\n\n      if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {\n        return length + (index - perView);\n      } // \"modulo length\" converts an index that equals length to zero\n\n\n      return (index + perView) % length;\n    },\n\n    /**\n     * @return {number}\n     */\n    getTravelDistance: function getTravelDistance() {\n      var travelDistance = Components.Sizes.slideWidth * Glide.settings.perView;\n\n      if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {\n        // reverse travel distance so that we don't have to change subtract operations\n        return travelDistance * -1;\n      }\n\n      return travelDistance;\n    }\n  };\n  /**\n   * Set new translate value:\n   * - on move to reflect index change\n   * - on updating via API to reflect possible changes in options\n   */\n\n  Events.on('move', function (context) {\n    if (!Glide.isType('carousel') || !Components.Run.isOffset()) {\n      return Translate.set(context.movement);\n    }\n\n    Components.Transition.after(function () {\n      Events.emit('translate.jump');\n      Translate.set(Components.Sizes.slideWidth * Glide.index);\n    });\n    var startWidth = Components.Sizes.slideWidth * Components.Translate.getStartIndex();\n    return Translate.set(startWidth - Components.Translate.getTravelDistance());\n  });\n  /**\n   * Remove translate:\n   * - on destroying to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Translate.remove();\n  });\n  return Translate;\n}\n\nfunction Transition (Glide, Components, Events) {\n  /**\n   * Holds inactivity status of transition.\n   * When true transition is not applied.\n   *\n   * @type {Boolean}\n   */\n  var disabled = false;\n  var Transition = {\n    /**\n     * Composes string of the CSS transition.\n     *\n     * @param {String} property\n     * @return {String}\n     */\n    compose: function compose(property) {\n      var settings = Glide.settings;\n\n      if (disabled) {\n        return \"\".concat(property, \" 0ms \").concat(settings.animationTimingFunc);\n      }\n\n      return \"\".concat(property, \" \").concat(this.duration, \"ms \").concat(settings.animationTimingFunc);\n    },\n\n    /**\n     * Sets value of transition on HTML element.\n     *\n     * @param {String=} property\n     * @return {Void}\n     */\n    set: function set() {\n      var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\n      Components.Html.wrapper.style.transition = this.compose(property);\n    },\n\n    /**\n     * Removes value of transition from HTML element.\n     *\n     * @return {Void}\n     */\n    remove: function remove() {\n      Components.Html.wrapper.style.transition = '';\n    },\n\n    /**\n     * Runs callback after animation.\n     *\n     * @param  {Function} callback\n     * @return {Void}\n     */\n    after: function after(callback) {\n      setTimeout(function () {\n        callback();\n      }, this.duration);\n    },\n\n    /**\n     * Enable transition.\n     *\n     * @return {Void}\n     */\n    enable: function enable() {\n      disabled = false;\n      this.set();\n    },\n\n    /**\n     * Disable transition.\n     *\n     * @return {Void}\n     */\n    disable: function disable() {\n      disabled = true;\n      this.set();\n    }\n  };\n  define(Transition, 'duration', {\n    /**\n     * Gets duration of the transition based\n     * on currently running animation type.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var settings = Glide.settings;\n\n      if (Glide.isType('slider') && Components.Run.offset) {\n        return settings.rewindDuration;\n      }\n\n      return settings.animationDuration;\n    }\n  });\n  /**\n   * Set transition `style` value:\n   * - on each moving, because it may be cleared by offset move\n   */\n\n  Events.on('move', function () {\n    Transition.set();\n  });\n  /**\n   * Disable transition:\n   * - before initial build to avoid transitioning from `0` to `startAt` index\n   * - while resizing window and recalculating dimensions\n   * - on jumping from offset transition at start and end edges in `carousel` type\n   */\n\n  Events.on(['build.before', 'resize', 'translate.jump'], function () {\n    Transition.disable();\n  });\n  /**\n   * Enable transition:\n   * - on each running, because it may be disabled by offset move\n   */\n\n  Events.on('run', function () {\n    Transition.enable();\n  });\n  /**\n   * Remove transition:\n   * - on destroying to bring markup to its inital state\n   */\n\n  Events.on('destroy', function () {\n    Transition.remove();\n  });\n  return Transition;\n}\n\n/**\n * Test via a getter in the options object to see\n * if the passive property is accessed.\n *\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n */\nvar supportsPassive = false;\n\ntry {\n  var opts = Object.defineProperty({}, 'passive', {\n    get: function get() {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener('testPassive', null, opts);\n  window.removeEventListener('testPassive', null, opts);\n} catch (e) {}\n\nvar supportsPassive$1 = supportsPassive;\n\nvar START_EVENTS = ['touchstart', 'mousedown'];\nvar MOVE_EVENTS = ['touchmove', 'mousemove'];\nvar END_EVENTS = ['touchend', 'touchcancel', 'mouseup', 'mouseleave'];\nvar MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseleave'];\nfunction Swipe (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var swipeSin = 0;\n  var swipeStartX = 0;\n  var swipeStartY = 0;\n  var disabled = false;\n  var capture = supportsPassive$1 ? {\n    passive: true\n  } : false;\n  var Swipe = {\n    /**\n     * Initializes swipe bindings.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.bindSwipeStart();\n    },\n\n    /**\n     * Handler for `swipestart` event. Calculates entry points of the user's tap.\n     *\n     * @param {Object} event\n     * @return {Void}\n     */\n    start: function start(event) {\n      if (!disabled && !Glide.disabled) {\n        this.disable();\n        var swipe = this.touches(event);\n        swipeSin = null;\n        swipeStartX = toInt(swipe.pageX);\n        swipeStartY = toInt(swipe.pageY);\n        this.bindSwipeMove();\n        this.bindSwipeEnd();\n        Events.emit('swipe.start');\n      }\n    },\n\n    /**\n     * Handler for `swipemove` event. Calculates user's tap angle and distance.\n     *\n     * @param {Object} event\n     */\n    move: function move(event) {\n      if (!Glide.disabled) {\n        var _Glide$settings = Glide.settings,\n            touchAngle = _Glide$settings.touchAngle,\n            touchRatio = _Glide$settings.touchRatio,\n            classes = _Glide$settings.classes;\n        var swipe = this.touches(event);\n        var subExSx = toInt(swipe.pageX) - swipeStartX;\n        var subEySy = toInt(swipe.pageY) - swipeStartY;\n        var powEX = Math.abs(subExSx << 2);\n        var powEY = Math.abs(subEySy << 2);\n        var swipeHypotenuse = Math.sqrt(powEX + powEY);\n        var swipeCathetus = Math.sqrt(powEY);\n        swipeSin = Math.asin(swipeCathetus / swipeHypotenuse);\n\n        if (swipeSin * 180 / Math.PI < touchAngle) {\n          event.stopPropagation();\n          Components.Move.make(subExSx * toFloat(touchRatio));\n          Components.Html.root.classList.add(classes.dragging);\n          Events.emit('swipe.move');\n        } else {\n          return false;\n        }\n      }\n    },\n\n    /**\n     * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.\n     *\n     * @param {Object} event\n     * @return {Void}\n     */\n    end: function end(event) {\n      if (!Glide.disabled) {\n        var _Glide$settings2 = Glide.settings,\n            perSwipe = _Glide$settings2.perSwipe,\n            touchAngle = _Glide$settings2.touchAngle,\n            classes = _Glide$settings2.classes;\n        var swipe = this.touches(event);\n        var threshold = this.threshold(event);\n        var swipeDistance = swipe.pageX - swipeStartX;\n        var swipeDeg = swipeSin * 180 / Math.PI;\n        this.enable();\n\n        if (swipeDistance > threshold && swipeDeg < touchAngle) {\n          Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \"<\")));\n        } else if (swipeDistance < -threshold && swipeDeg < touchAngle) {\n          Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe, \">\")));\n        } else {\n          // While swipe don't reach distance apply previous transform.\n          Components.Move.make();\n        }\n\n        Components.Html.root.classList.remove(classes.dragging);\n        this.unbindSwipeMove();\n        this.unbindSwipeEnd();\n        Events.emit('swipe.end');\n      }\n    },\n\n    /**\n     * Binds swipe's starting event.\n     *\n     * @return {Void}\n     */\n    bindSwipeStart: function bindSwipeStart() {\n      var _this = this;\n\n      var _Glide$settings3 = Glide.settings,\n          swipeThreshold = _Glide$settings3.swipeThreshold,\n          dragThreshold = _Glide$settings3.dragThreshold;\n\n      if (swipeThreshold) {\n        Binder.on(START_EVENTS[0], Components.Html.wrapper, function (event) {\n          _this.start(event);\n        }, capture);\n      }\n\n      if (dragThreshold) {\n        Binder.on(START_EVENTS[1], Components.Html.wrapper, function (event) {\n          _this.start(event);\n        }, capture);\n      }\n    },\n\n    /**\n     * Unbinds swipe's starting event.\n     *\n     * @return {Void}\n     */\n    unbindSwipeStart: function unbindSwipeStart() {\n      Binder.off(START_EVENTS[0], Components.Html.wrapper, capture);\n      Binder.off(START_EVENTS[1], Components.Html.wrapper, capture);\n    },\n\n    /**\n     * Binds swipe's moving event.\n     *\n     * @return {Void}\n     */\n    bindSwipeMove: function bindSwipeMove() {\n      var _this2 = this;\n\n      Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function (event) {\n        _this2.move(event);\n      }, Glide.settings.throttle), capture);\n    },\n\n    /**\n     * Unbinds swipe's moving event.\n     *\n     * @return {Void}\n     */\n    unbindSwipeMove: function unbindSwipeMove() {\n      Binder.off(MOVE_EVENTS, Components.Html.wrapper, capture);\n    },\n\n    /**\n     * Binds swipe's ending event.\n     *\n     * @return {Void}\n     */\n    bindSwipeEnd: function bindSwipeEnd() {\n      var _this3 = this;\n\n      Binder.on(END_EVENTS, Components.Html.wrapper, function (event) {\n        _this3.end(event);\n      });\n    },\n\n    /**\n     * Unbinds swipe's ending event.\n     *\n     * @return {Void}\n     */\n    unbindSwipeEnd: function unbindSwipeEnd() {\n      Binder.off(END_EVENTS, Components.Html.wrapper);\n    },\n\n    /**\n     * Normalizes event touches points accorting to different types.\n     *\n     * @param {Object} event\n     */\n    touches: function touches(event) {\n      if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n        return event;\n      }\n\n      return event.touches[0] || event.changedTouches[0];\n    },\n\n    /**\n     * Gets value of minimum swipe distance settings based on event type.\n     *\n     * @return {Number}\n     */\n    threshold: function threshold(event) {\n      var settings = Glide.settings;\n\n      if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n        return settings.dragThreshold;\n      }\n\n      return settings.swipeThreshold;\n    },\n\n    /**\n     * Enables swipe event.\n     *\n     * @return {self}\n     */\n    enable: function enable() {\n      disabled = false;\n      Components.Transition.enable();\n      return this;\n    },\n\n    /**\n     * Disables swipe event.\n     *\n     * @return {self}\n     */\n    disable: function disable() {\n      disabled = true;\n      Components.Transition.disable();\n      return this;\n    }\n  };\n  /**\n   * Add component class:\n   * - after initial building\n   */\n\n  Events.on('build.after', function () {\n    Components.Html.root.classList.add(Glide.settings.classes.swipeable);\n  });\n  /**\n   * Remove swiping bindings:\n   * - on destroying, to remove added EventListeners\n   */\n\n  Events.on('destroy', function () {\n    Swipe.unbindSwipeStart();\n    Swipe.unbindSwipeMove();\n    Swipe.unbindSwipeEnd();\n    Binder.destroy();\n  });\n  return Swipe;\n}\n\nfunction Images (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Images = {\n    /**\n     * Binds listener to glide wrapper.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.bind();\n    },\n\n    /**\n     * Binds `dragstart` event on wrapper to prevent dragging images.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('dragstart', Components.Html.wrapper, this.dragstart);\n    },\n\n    /**\n     * Unbinds `dragstart` event on wrapper.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('dragstart', Components.Html.wrapper);\n    },\n\n    /**\n     * Event handler. Prevents dragging.\n     *\n     * @return {Void}\n     */\n    dragstart: function dragstart(event) {\n      event.preventDefault();\n    }\n  };\n  /**\n   * Remove bindings from images:\n   * - on destroying, to remove added EventListeners\n   */\n\n  Events.on('destroy', function () {\n    Images.unbind();\n    Binder.destroy();\n  });\n  return Images;\n}\n\nfunction Anchors (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  /**\n   * Holds detaching status of anchors.\n   * Prevents detaching of already detached anchors.\n   *\n   * @private\n   * @type {Boolean}\n   */\n\n  var detached = false;\n  /**\n   * Holds preventing status of anchors.\n   * If `true` redirection after click will be disabled.\n   *\n   * @private\n   * @type {Boolean}\n   */\n\n  var prevented = false;\n  var Anchors = {\n    /**\n     * Setups a initial state of anchors component.\n     *\n     * @returns {Void}\n     */\n    mount: function mount() {\n      /**\n       * Holds collection of anchors elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */\n      this._a = Components.Html.wrapper.querySelectorAll('a');\n      this.bind();\n    },\n\n    /**\n     * Binds events to anchors inside a track.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('click', Components.Html.wrapper, this.click);\n    },\n\n    /**\n     * Unbinds events attached to anchors inside a track.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('click', Components.Html.wrapper);\n    },\n\n    /**\n     * Handler for click event. Prevents clicks when glide is in `prevent` status.\n     *\n     * @param  {Object} event\n     * @return {Void}\n     */\n    click: function click(event) {\n      if (prevented) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n    },\n\n    /**\n     * Detaches anchors click event inside glide.\n     *\n     * @return {self}\n     */\n    detach: function detach() {\n      prevented = true;\n\n      if (!detached) {\n        for (var i = 0; i < this.items.length; i++) {\n          this.items[i].draggable = false;\n        }\n\n        detached = true;\n      }\n\n      return this;\n    },\n\n    /**\n     * Attaches anchors click events inside glide.\n     *\n     * @return {self}\n     */\n    attach: function attach() {\n      prevented = false;\n\n      if (detached) {\n        for (var i = 0; i < this.items.length; i++) {\n          this.items[i].draggable = true;\n        }\n\n        detached = false;\n      }\n\n      return this;\n    }\n  };\n  define(Anchors, 'items', {\n    /**\n     * Gets collection of the arrows HTML elements.\n     *\n     * @return {HTMLElement[]}\n     */\n    get: function get() {\n      return Anchors._a;\n    }\n  });\n  /**\n   * Detach anchors inside slides:\n   * - on swiping, so they won't redirect to its `href` attributes\n   */\n\n  Events.on('swipe.move', function () {\n    Anchors.detach();\n  });\n  /**\n   * Attach anchors inside slides:\n   * - after swiping and transitions ends, so they can redirect after click again\n   */\n\n  Events.on('swipe.end', function () {\n    Components.Transition.after(function () {\n      Anchors.attach();\n    });\n  });\n  /**\n   * Unbind anchors inside slides:\n   * - on destroying, to bring anchors to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Anchors.attach();\n    Anchors.unbind();\n    Binder.destroy();\n  });\n  return Anchors;\n}\n\nvar NAV_SELECTOR = '[data-glide-el=\"controls[nav]\"]';\nvar CONTROLS_SELECTOR = '[data-glide-el^=\"controls\"]';\nvar PREVIOUS_CONTROLS_SELECTOR = \"\".concat(CONTROLS_SELECTOR, \" [data-glide-dir*=\\\"<\\\"]\");\nvar NEXT_CONTROLS_SELECTOR = \"\".concat(CONTROLS_SELECTOR, \" [data-glide-dir*=\\\">\\\"]\");\nfunction Controls (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var capture = supportsPassive$1 ? {\n    passive: true\n  } : false;\n  var Controls = {\n    /**\n     * Inits arrows. Binds events listeners\n     * to the arrows HTML elements.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      /**\n       * Collection of navigation HTML elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */\n      this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);\n      /**\n       * Collection of controls HTML elements.\n       *\n       * @private\n       * @type {HTMLCollection}\n       */\n\n      this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);\n      /**\n       * Collection of arrow control HTML elements.\n       *\n       * @private\n       * @type {Object}\n       */\n\n      this._arrowControls = {\n        previous: Components.Html.root.querySelectorAll(PREVIOUS_CONTROLS_SELECTOR),\n        next: Components.Html.root.querySelectorAll(NEXT_CONTROLS_SELECTOR)\n      };\n      this.addBindings();\n    },\n\n    /**\n     * Sets active class to current slide.\n     *\n     * @return {Void}\n     */\n    setActive: function setActive() {\n      for (var i = 0; i < this._n.length; i++) {\n        this.addClass(this._n[i].children);\n      }\n    },\n\n    /**\n     * Removes active class to current slide.\n     *\n     * @return {Void}\n     */\n    removeActive: function removeActive() {\n      for (var i = 0; i < this._n.length; i++) {\n        this.removeClass(this._n[i].children);\n      }\n    },\n\n    /**\n     * Toggles active class on items inside navigation.\n     *\n     * @param  {HTMLElement} controls\n     * @return {Void}\n     */\n    addClass: function addClass(controls) {\n      var settings = Glide.settings;\n      var item = controls[Glide.index];\n\n      if (!item) {\n        return;\n      }\n\n      item.classList.add(settings.classes.nav.active);\n      siblings(item).forEach(function (sibling) {\n        sibling.classList.remove(settings.classes.nav.active);\n      });\n    },\n\n    /**\n     * Removes active class from active control.\n     *\n     * @param  {HTMLElement} controls\n     * @return {Void}\n     */\n    removeClass: function removeClass(controls) {\n      var item = controls[Glide.index];\n      item === null || item === void 0 ? void 0 : item.classList.remove(Glide.settings.classes.nav.active);\n    },\n\n    /**\n     * Calculates, removes or adds `Glide.settings.classes.disabledArrow` class on the control arrows\n     */\n    setArrowState: function setArrowState() {\n      if (Glide.settings.rewind) {\n        return;\n      }\n\n      var next = Controls._arrowControls.next;\n      var previous = Controls._arrowControls.previous;\n      this.resetArrowState(next, previous);\n\n      if (Glide.index === 0) {\n        this.disableArrow(previous);\n      }\n\n      if (Glide.index === Components.Run.length) {\n        this.disableArrow(next);\n      }\n    },\n\n    /**\n     * Removes `Glide.settings.classes.disabledArrow` from given NodeList elements\n     *\n     * @param {NodeList[]} lists\n     */\n    resetArrowState: function resetArrowState() {\n      var settings = Glide.settings;\n\n      for (var _len = arguments.length, lists = new Array(_len), _key = 0; _key < _len; _key++) {\n        lists[_key] = arguments[_key];\n      }\n\n      lists.forEach(function (list) {\n        toArray(list).forEach(function (element) {\n          element.classList.remove(settings.classes.arrow.disabled);\n        });\n      });\n    },\n\n    /**\n     * Adds `Glide.settings.classes.disabledArrow` to given NodeList elements\n     *\n     * @param {NodeList[]} lists\n     */\n    disableArrow: function disableArrow() {\n      var settings = Glide.settings;\n\n      for (var _len2 = arguments.length, lists = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        lists[_key2] = arguments[_key2];\n      }\n\n      lists.forEach(function (list) {\n        toArray(list).forEach(function (element) {\n          element.classList.add(settings.classes.arrow.disabled);\n        });\n      });\n    },\n\n    /**\n     * Adds handles to the each group of controls.\n     *\n     * @return {Void}\n     */\n    addBindings: function addBindings() {\n      for (var i = 0; i < this._c.length; i++) {\n        this.bind(this._c[i].children);\n      }\n    },\n\n    /**\n     * Removes handles from the each group of controls.\n     *\n     * @return {Void}\n     */\n    removeBindings: function removeBindings() {\n      for (var i = 0; i < this._c.length; i++) {\n        this.unbind(this._c[i].children);\n      }\n    },\n\n    /**\n     * Binds events to arrows HTML elements.\n     *\n     * @param {HTMLCollection} elements\n     * @return {Void}\n     */\n    bind: function bind(elements) {\n      for (var i = 0; i < elements.length; i++) {\n        Binder.on('click', elements[i], this.click);\n        Binder.on('touchstart', elements[i], this.click, capture);\n      }\n    },\n\n    /**\n     * Unbinds events binded to the arrows HTML elements.\n     *\n     * @param {HTMLCollection} elements\n     * @return {Void}\n     */\n    unbind: function unbind(elements) {\n      for (var i = 0; i < elements.length; i++) {\n        Binder.off(['click', 'touchstart'], elements[i]);\n      }\n    },\n\n    /**\n     * Handles `click` event on the arrows HTML elements.\n     * Moves slider in direction given via the\n     * `data-glide-dir` attribute.\n     *\n     * @param {Object} event\n     * @return {void}\n     */\n    click: function click(event) {\n      if (!supportsPassive$1 && event.type === 'touchstart') {\n        event.preventDefault();\n      }\n\n      var direction = event.currentTarget.getAttribute('data-glide-dir');\n      Components.Run.make(Components.Direction.resolve(direction));\n    }\n  };\n  define(Controls, 'items', {\n    /**\n     * Gets collection of the controls HTML elements.\n     *\n     * @return {HTMLElement[]}\n     */\n    get: function get() {\n      return Controls._c;\n    }\n  });\n  /**\n   * Swap active class of current navigation item:\n   * - after mounting to set it to initial index\n   * - after each move to the new index\n   */\n\n  Events.on(['mount.after', 'move.after'], function () {\n    Controls.setActive();\n  });\n  /**\n   * Add or remove disabled class of arrow elements\n   */\n\n  Events.on(['mount.after', 'run'], function () {\n    Controls.setArrowState();\n  });\n  /**\n   * Remove bindings and HTML Classes:\n   * - on destroying, to bring markup to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Controls.removeBindings();\n    Controls.removeActive();\n    Binder.destroy();\n  });\n  return Controls;\n}\n\nfunction Keyboard (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Keyboard = {\n    /**\n     * Binds keyboard events on component mount.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      if (Glide.settings.keyboard) {\n        this.bind();\n      }\n    },\n\n    /**\n     * Adds keyboard press events.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      Binder.on('keyup', document, this.press);\n    },\n\n    /**\n     * Removes keyboard press events.\n     *\n     * @return {Void}\n     */\n    unbind: function unbind() {\n      Binder.off('keyup', document);\n    },\n\n    /**\n     * Handles keyboard's arrows press and moving glide foward and backward.\n     *\n     * @param  {Object} event\n     * @return {Void}\n     */\n    press: function press(event) {\n      var perSwipe = Glide.settings.perSwipe;\n      var arrowSymbols = {\n        ArrowRight: '>',\n        ArrowLeft: '<'\n      };\n\n      if (['ArrowRight', 'ArrowLeft'].includes(event.code)) {\n        Components.Run.make(Components.Direction.resolve(\"\".concat(perSwipe).concat(arrowSymbols[event.code])));\n      }\n    }\n  };\n  /**\n   * Remove bindings from keyboard:\n   * - on destroying to remove added events\n   * - on updating to remove events before remounting\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Keyboard.unbind();\n  });\n  /**\n   * Remount component\n   * - on updating to reflect potential changes in settings\n   */\n\n  Events.on('update', function () {\n    Keyboard.mount();\n  });\n  /**\n   * Destroy binder:\n   * - on destroying to remove listeners\n   */\n\n  Events.on('destroy', function () {\n    Binder.destroy();\n  });\n  return Keyboard;\n}\n\nfunction Autoplay (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  var Autoplay = {\n    /**\n     * Initializes autoplaying and events.\n     *\n     * @return {Void}\n     */\n    mount: function mount() {\n      this.enable();\n      this.start();\n\n      if (Glide.settings.hoverpause) {\n        this.bind();\n      }\n    },\n\n    /**\n     * Enables autoplaying\n     *\n     * @returns {Void}\n     */\n    enable: function enable() {\n      this._e = true;\n    },\n\n    /**\n     * Disables autoplaying.\n     *\n     * @returns {Void}\n     */\n    disable: function disable() {\n      this._e = false;\n    },\n\n    /**\n     * Starts autoplaying in configured interval.\n     *\n     * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings\n     * @return {Void}\n     */\n    start: function start() {\n      var _this = this;\n\n      if (!this._e) {\n        return;\n      }\n\n      this.enable();\n\n      if (Glide.settings.autoplay) {\n        if (isUndefined(this._i)) {\n          this._i = setInterval(function () {\n            _this.stop();\n\n            Components.Run.make('>');\n\n            _this.start();\n\n            Events.emit('autoplay');\n          }, this.time);\n        }\n      }\n    },\n\n    /**\n     * Stops autorunning of the glide.\n     *\n     * @return {Void}\n     */\n    stop: function stop() {\n      this._i = clearInterval(this._i);\n    },\n\n    /**\n     * Stops autoplaying while mouse is over glide's area.\n     *\n     * @return {Void}\n     */\n    bind: function bind() {\n      var _this2 = this;\n\n      Binder.on('mouseover', Components.Html.root, function () {\n        if (_this2._e) {\n          _this2.stop();\n        }\n      });\n      Binder.on('mouseout', Components.Html.root, function () {\n        if (_this2._e) {\n          _this2.start();\n        }\n      });\n    },\n\n    /**\n     * Unbind mouseover events.\n     *\n     * @returns {Void}\n     */\n    unbind: function unbind() {\n      Binder.off(['mouseover', 'mouseout'], Components.Html.root);\n    }\n  };\n  define(Autoplay, 'time', {\n    /**\n     * Gets time period value for the autoplay interval. Prioritizes\n     * times in `data-glide-autoplay` attrubutes over options.\n     *\n     * @return {Number}\n     */\n    get: function get() {\n      var autoplay = Components.Html.slides[Glide.index].getAttribute('data-glide-autoplay');\n\n      if (autoplay) {\n        return toInt(autoplay);\n      }\n\n      return toInt(Glide.settings.autoplay);\n    }\n  });\n  /**\n   * Stop autoplaying and unbind events:\n   * - on destroying, to clear defined interval\n   * - on updating via API to reset interval that may changed\n   */\n\n  Events.on(['destroy', 'update'], function () {\n    Autoplay.unbind();\n  });\n  /**\n   * Stop autoplaying:\n   * - before each run, to restart autoplaying\n   * - on pausing via API\n   * - on destroying, to clear defined interval\n   * - while starting a swipe\n   * - on updating via API to reset interval that may changed\n   */\n\n  Events.on(['run.before', 'swipe.start', 'update'], function () {\n    Autoplay.stop();\n  });\n  Events.on(['pause', 'destroy'], function () {\n    Autoplay.disable();\n    Autoplay.stop();\n  });\n  /**\n   * Start autoplaying:\n   * - after each run, to restart autoplaying\n   * - on playing via API\n   * - while ending a swipe\n   */\n\n  Events.on(['run.after', 'swipe.end'], function () {\n    Autoplay.start();\n  });\n  /**\n   * Start autoplaying:\n   * - after each run, to restart autoplaying\n   * - on playing via API\n   * - while ending a swipe\n   */\n\n  Events.on(['play'], function () {\n    Autoplay.enable();\n    Autoplay.start();\n  });\n  /**\n   * Remount autoplaying:\n   * - on updating via API to reset interval that may changed\n   */\n\n  Events.on('update', function () {\n    Autoplay.mount();\n  });\n  /**\n   * Destroy a binder:\n   * - on destroying glide instance to clearup listeners\n   */\n\n  Events.on('destroy', function () {\n    Binder.destroy();\n  });\n  return Autoplay;\n}\n\n/**\n * Sorts keys of breakpoint object so they will be ordered from lower to bigger.\n *\n * @param {Object} points\n * @returns {Object}\n */\n\nfunction sortBreakpoints(points) {\n  if (isObject(points)) {\n    return sortKeys(points);\n  } else {\n    warn(\"Breakpoints option must be an object\");\n  }\n\n  return {};\n}\n\nfunction Breakpoints (Glide, Components, Events) {\n  /**\n   * Instance of the binder for DOM Events.\n   *\n   * @type {EventsBinder}\n   */\n  var Binder = new EventsBinder();\n  /**\n   * Holds reference to settings.\n   *\n   * @type {Object}\n   */\n\n  var settings = Glide.settings;\n  /**\n   * Holds reference to breakpoints object in settings. Sorts breakpoints\n   * from smaller to larger. It is required in order to proper\n   * matching currently active breakpoint settings.\n   *\n   * @type {Object}\n   */\n\n  var points = sortBreakpoints(settings.breakpoints);\n  /**\n   * Cache initial settings before overwritting.\n   *\n   * @type {Object}\n   */\n\n  var defaults = Object.assign({}, settings);\n  var Breakpoints = {\n    /**\n     * Matches settings for currectly matching media breakpoint.\n     *\n     * @param {Object} points\n     * @returns {Object}\n     */\n    match: function match(points) {\n      if (typeof window.matchMedia !== 'undefined') {\n        for (var point in points) {\n          if (points.hasOwnProperty(point)) {\n            if (window.matchMedia(\"(max-width: \".concat(point, \"px)\")).matches) {\n              return points[point];\n            }\n          }\n        }\n      }\n\n      return defaults;\n    }\n  };\n  /**\n   * Overwrite instance settings with currently matching breakpoint settings.\n   * This happens right after component initialization.\n   */\n\n  Object.assign(settings, Breakpoints.match(points));\n  /**\n   * Update glide with settings of matched brekpoint:\n   * - window resize to update slider\n   */\n\n  Binder.on('resize', window, throttle(function () {\n    Glide.settings = mergeOptions(settings, Breakpoints.match(points));\n  }, Glide.settings.throttle));\n  /**\n   * Resort and update default settings:\n   * - on reinit via API, so breakpoint matching will be performed with options\n   */\n\n  Events.on('update', function () {\n    points = sortBreakpoints(points);\n    defaults = Object.assign({}, settings);\n  });\n  /**\n   * Unbind resize listener:\n   * - on destroying, to bring markup to its initial state\n   */\n\n  Events.on('destroy', function () {\n    Binder.off('resize', window);\n  });\n  return Breakpoints;\n}\n\nvar COMPONENTS = {\n  // Required\n  Html: Html,\n  Translate: Translate,\n  Transition: Transition,\n  Direction: Direction,\n  Peek: Peek,\n  Sizes: Sizes,\n  Gaps: Gaps,\n  Move: Move,\n  Clones: Clones,\n  Resize: Resize,\n  Build: Build,\n  Run: Run,\n  // Optional\n  Swipe: Swipe,\n  Images: Images,\n  Anchors: Anchors,\n  Controls: Controls,\n  Keyboard: Keyboard,\n  Autoplay: Autoplay,\n  Breakpoints: Breakpoints\n};\n\nvar Glide = /*#__PURE__*/function (_Core) {\n  _inherits(Glide, _Core);\n\n  var _super = _createSuper(Glide);\n\n  function Glide() {\n    _classCallCheck(this, Glide);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Glide, [{\n    key: \"mount\",\n    value: function mount() {\n      var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _get(_getPrototypeOf(Glide.prototype), \"mount\", this).call(this, Object.assign({}, COMPONENTS, extensions));\n    }\n  }]);\n\n  return Glide;\n}(Glide$1);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGdsaWRlanMvZ2xpZGUvZGlzdC9nbGlkZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1tYXJjZWwvLi9ub2RlX21vZHVsZXMvQGdsaWRlanMvZ2xpZGUvZGlzdC9nbGlkZS5lc20uanM/NzgwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEdsaWRlLmpzIHYzLjYuMlxuICogKGMpIDIwMTMtMjAyNCBKxJlkcnplaiBDaGHFgnViZWsgKGh0dHBzOi8vZ2l0aHViLmNvbS9qZWRyemVqY2hhbHViZWsvKVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0O1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIG1vdmVtZW50LlxuICAgKlxuICAgKiBBdmFpbGFibGUgdHlwZXM6XG4gICAqIGBzbGlkZXJgIC0gUmV3aW5kcyBzbGlkZXIgdG8gdGhlIHN0YXJ0L2VuZCB3aGVuIGl0IHJlYWNoZXMgdGhlIGZpcnN0IG9yIGxhc3Qgc2xpZGUuXG4gICAqIGBjYXJvdXNlbGAgLSBDaGFuZ2VzIHNsaWRlcyB3aXRob3V0IHN0YXJ0aW5nIG92ZXIgd2hlbiBpdCByZWFjaGVzIHRoZSBmaXJzdCBvciBsYXN0IHNsaWRlLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ3NsaWRlcicsXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGF0IHNwZWNpZmljIHNsaWRlIG51bWJlciBkZWZpbmVkIHdpdGggemVyby1iYXNlZCBpbmRleC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHN0YXJ0QXQ6IDAsXG5cbiAgLyoqXG4gICAqIEEgbnVtYmVyIG9mIHNsaWRlcyB2aXNpYmxlIG9uIHRoZSBzaW5nbGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBwZXJWaWV3OiAxLFxuXG4gIC8qKlxuICAgKiBGb2N1cyBjdXJyZW50bHkgYWN0aXZlIHNsaWRlIGF0IGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSB0cmFjay5cbiAgICpcbiAgICogQXZhaWxhYmxlIGlucHV0czpcbiAgICogYGNlbnRlcmAgLSBDdXJyZW50IHNsaWRlIHdpbGwgYmUgYWx3YXlzIGZvY3VzZWQgYXQgdGhlIGNlbnRlciBvZiBhIHRyYWNrLlxuICAgKiBgMCwxLDIsMy4uLmAgLSBDdXJyZW50IHNsaWRlIHdpbGwgYmUgZm9jdXNlZCBvbiB0aGUgc3BlY2lmaWVkIHplcm8tYmFzZWQgaW5kZXguXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfVxuICAgKi9cbiAgZm9jdXNBdDogMCxcblxuICAvKipcbiAgICogQSBzaXplIG9mIHRoZSBnYXAgYWRkZWQgYmV0d2VlbiBzbGlkZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnYXA6IDEwLFxuXG4gIC8qKlxuICAgKiBDaGFuZ2Ugc2xpZGVzIGFmdGVyIGEgc3BlY2lmaWVkIGludGVydmFsLiBVc2UgYGZhbHNlYCBmb3IgdHVybmluZyBvZmYgYXV0b3BsYXkuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ8Qm9vbGVhbn1cbiAgICovXG4gIGF1dG9wbGF5OiBmYWxzZSxcblxuICAvKipcbiAgICogU3RvcCBhdXRvcGxheSBvbiBtb3VzZW92ZXIgZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgaG92ZXJwYXVzZTogdHJ1ZSxcblxuICAvKipcbiAgICogQWxsb3cgZm9yIGNoYW5naW5nIHNsaWRlcyB3aXRoIGxlZnQgYW5kIHJpZ2h0IGtleWJvYXJkIGFycm93cy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBrZXlib2FyZDogdHJ1ZSxcblxuICAvKipcbiAgICogU3RvcCBydW5uaW5nIGBwZXJWaWV3YCBudW1iZXIgb2Ygc2xpZGVzIGZyb20gdGhlIGVuZC4gVXNlIHRoaXNcbiAgICogb3B0aW9uIGlmIHlvdSBkb24ndCB3YW50IHRvIGhhdmUgYW4gZW1wdHkgc3BhY2UgYWZ0ZXJcbiAgICogYSBzbGlkZXIuIFdvcmtzIG9ubHkgd2l0aCBgc2xpZGVyYCB0eXBlIGFuZCBhXG4gICAqIG5vbi1jZW50ZXJlZCBgZm9jdXNBdGAgc2V0dGluZy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBib3VuZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1pbmltYWwgc3dpcGUgZGlzdGFuY2UgbmVlZGVkIHRvIGNoYW5nZSB0aGUgc2xpZGUuIFVzZSBgZmFsc2VgIGZvciB0dXJuaW5nIG9mZiBhIHN3aXBpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ8Qm9vbGVhbn1cbiAgICovXG4gIHN3aXBlVGhyZXNob2xkOiA4MCxcblxuICAvKipcbiAgICogTWluaW1hbCBtb3VzZSBkcmFnIGRpc3RhbmNlIG5lZWRlZCB0byBjaGFuZ2UgdGhlIHNsaWRlLiBVc2UgYGZhbHNlYCBmb3IgdHVybmluZyBvZmYgYSBkcmFnZ2luZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcnxCb29sZWFufVxuICAgKi9cbiAgZHJhZ1RocmVzaG9sZDogMTIwLFxuXG4gIC8qKlxuICAgKiBBIG51bWJlciBvZiBzbGlkZXMgbW92ZWQgb24gc2luZ2xlIHN3aXBlLlxuICAgKlxuICAgKiBBdmFpbGFibGUgdHlwZXM6XG4gICAqIGBgIC0gTW92ZXMgc2xpZGVyIGJ5IG9uZSBzbGlkZSBwZXIgc3dpcGVcbiAgICogYHxgIC0gTW92ZXMgc2xpZGVyIGJldHdlZW4gdmlld3MgcGVyIHN3aXBlIChudW1iZXIgb2Ygc2xpZGVzIGRlZmluZWQgaW4gYHBlclZpZXdgIG9wdGlvbnMpXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBwZXJTd2lwZTogJycsXG5cbiAgLyoqXG4gICAqIE1vdmluZyBkaXN0YW5jZSByYXRpbyBvZiB0aGUgc2xpZGVzIG9uIGEgc3dpcGluZyBhbmQgZHJhZ2dpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0b3VjaFJhdGlvOiAwLjUsXG5cbiAgLyoqXG4gICAqIEFuZ2xlIHJlcXVpcmVkIHRvIGFjdGl2YXRlIHNsaWRlcyBtb3Zpbmcgb24gc3dpcGluZyBvciBkcmFnZ2luZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRvdWNoQW5nbGU6IDQ1LFxuXG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA0MDAsXG5cbiAgLyoqXG4gICAqIEFsbG93cyBsb29waW5nIHRoZSBgc2xpZGVyYCB0eXBlLiBTbGlkZXIgd2lsbCByZXdpbmQgdG8gdGhlIGZpcnN0L2xhc3Qgc2xpZGUgd2hlbiBpdCdzIGF0IHRoZSBzdGFydC9lbmQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgcmV3aW5kOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmV3aW5kaW5nIGFuaW1hdGlvbiBvZiB0aGUgYHNsaWRlcmAgdHlwZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICByZXdpbmREdXJhdGlvbjogODAwLFxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb24gZm9yIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBhbmltYXRpb25UaW1pbmdGdW5jOiAnY3ViaWMtYmV6aWVyKC4xNjUsIC44NDAsIC40NDAsIDEpJyxcblxuICAvKipcbiAgICogV2FpdCBmb3IgdGhlIGFuaW1hdGlvbiB0byBmaW5pc2ggdW50aWwgdGhlIG5leHQgdXNlciBpbnB1dCBjYW4gYmUgcHJvY2Vzc2VkXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgd2FpdEZvclRyYW5zaXRpb246IHRydWUsXG5cbiAgLyoqXG4gICAqIFRocm90dGxlIGNvc3RseSBldmVudHMgYXQgbW9zdCBvbmNlIHBlciBldmVyeSB3YWl0IG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRocm90dGxlOiAxMCxcblxuICAvKipcbiAgICogTW92aW5nIGRpcmVjdGlvbiBtb2RlLlxuICAgKlxuICAgKiBBdmFpbGFibGUgaW5wdXRzOlxuICAgKiAtICdsdHInIC0gbGVmdCB0byByaWdodCBtb3ZlbWVudCxcbiAgICogLSAncnRsJyAtIHJpZ2h0IHRvIGxlZnQgbW92ZW1lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBkaXJlY3Rpb246ICdsdHInLFxuXG4gIC8qKlxuICAgKiBUaGUgZGlzdGFuY2UgdmFsdWUgb2YgdGhlIG5leHQgYW5kIHByZXZpb3VzIHZpZXdwb3J0cyB3aGljaFxuICAgKiBoYXZlIHRvIHBlZWsgaW4gdGhlIGN1cnJlbnQgdmlldy4gQWNjZXB0cyBudW1iZXIgYW5kXG4gICAqIHBpeGVscyBhcyBhIHN0cmluZy4gTGVmdCBhbmQgcmlnaHQgcGVla2luZyBjYW4gYmVcbiAgICogc2V0IHVwIHNlcGFyYXRlbHkgd2l0aCBhIGRpcmVjdGlvbnMgb2JqZWN0LlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZTpcbiAgICogYDEwMGAgLSBQZWVrIDEwMHB4IG9uIHRoZSBib3RoIHNpZGVzLlxuICAgKiB7IGJlZm9yZTogMTAwLCBhZnRlcjogNTAgfWAgLSBQZWVrIDEwMHB4IG9uIHRoZSBsZWZ0IHNpZGUgYW5kIDUwcHggb24gdGhlIHJpZ2h0IHNpZGUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ8U3RyaW5nfE9iamVjdH1cbiAgICovXG4gIHBlZWs6IDAsXG5cbiAgLyoqXG4gICAqIERlZmluZXMgaG93IG1hbnkgY2xvbmVzIG9mIGN1cnJlbnQgdmlld3BvcnQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBjbG9uaW5nUmF0aW86IDEsXG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2Ygb3B0aW9ucyBhcHBsaWVkIGF0IHNwZWNpZmllZCBtZWRpYSBicmVha3BvaW50cy5cbiAgICogRm9yIGV4YW1wbGU6IGRpc3BsYXkgdHdvIHNsaWRlcyBwZXIgdmlldyB1bmRlciA4MDBweC5cbiAgICogYHtcbiAgICogICAnODAwcHgnOiB7XG4gICAqICAgICBwZXJWaWV3OiAyXG4gICAqICAgfVxuICAgKiB9YFxuICAgKi9cbiAgYnJlYWtwb2ludHM6IHt9LFxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIGludGVybmFsbHkgdXNlZCBIVE1MIGNsYXNzZXMuXG4gICAqXG4gICAqIEB0b2RvIFJlZmFjdG9yIGBzbGlkZXJgIGFuZCBgY2Fyb3VzZWxgIHByb3BlcnRpZXMgdG8gc2luZ2xlIGB0eXBlOiB7IHNsaWRlcjogJycsIGNhcm91c2VsOiAnJyB9YCBvYmplY3RcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGNsYXNzZXM6IHtcbiAgICBzd2lwZWFibGU6ICdnbGlkZS0tc3dpcGVhYmxlJyxcbiAgICBkcmFnZ2luZzogJ2dsaWRlLS1kcmFnZ2luZycsXG4gICAgZGlyZWN0aW9uOiB7XG4gICAgICBsdHI6ICdnbGlkZS0tbHRyJyxcbiAgICAgIHJ0bDogJ2dsaWRlLS1ydGwnXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBzbGlkZXI6ICdnbGlkZS0tc2xpZGVyJyxcbiAgICAgIGNhcm91c2VsOiAnZ2xpZGUtLWNhcm91c2VsJ1xuICAgIH0sXG4gICAgc2xpZGU6IHtcbiAgICAgIGNsb25lOiAnZ2xpZGVfX3NsaWRlLS1jbG9uZScsXG4gICAgICBhY3RpdmU6ICdnbGlkZV9fc2xpZGUtLWFjdGl2ZSdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBkaXNhYmxlZDogJ2dsaWRlX19hcnJvdy0tZGlzYWJsZWQnXG4gICAgfSxcbiAgICBuYXY6IHtcbiAgICAgIGFjdGl2ZTogJ2dsaWRlX19idWxsZXQtLWFjdGl2ZSdcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogT3V0cHV0cyB3YXJuaW5nIG1lc3NhZ2UgdG8gdGhlIGJvd3NlciBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbXNnXG4gKiBAcmV0dXJuIHtWb2lkfVxuICovXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBjb25zb2xlLmVycm9yKFwiW0dsaWRlIHdhcm5dOiBcIi5jb25jYXQobXNnKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdmFsdWUgZW50ZXJlZCBhcyBudW1iZXJcbiAqIG9yIHN0cmluZyB0byBpbnRlZ2VyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gdG9JbnQodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbn1cbi8qKlxuICogQ29udmVydHMgdmFsdWUgZW50ZXJlZCBhcyBudW1iZXJcbiAqIG9yIHN0cmluZyB0byBmbGF0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHsqfSAgIHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZih2YWx1ZSk7XG5cbiAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbn1cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtICB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtICB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHNwZWNpZmllZCBjb2xsZWN0aW9uIG9mIGV4dGVuc2lvbnMuXG4gKiBFYWNoIGV4dGVuc2lvbiByZWNlaXZlcyBhY2Nlc3MgdG8gaW5zdGFuY2Ugb2YgZ2xpZGUgYW5kIHJlc3Qgb2YgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZ2xpZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBtb3VudChnbGlkZSwgZXh0ZW5zaW9ucywgZXZlbnRzKSB7XG4gIHZhciBjb21wb25lbnRzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBleHRlbnNpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZXh0ZW5zaW9uc1tuYW1lXSkpIHtcbiAgICAgIGNvbXBvbmVudHNbbmFtZV0gPSBleHRlbnNpb25zW25hbWVdKGdsaWRlLCBjb21wb25lbnRzLCBldmVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKCdFeHRlbnNpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX25hbWUgaW4gY29tcG9uZW50cykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbXBvbmVudHNbX25hbWVdLm1vdW50KSkge1xuICAgICAgY29tcG9uZW50c1tfbmFtZV0ubW91bnQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuLyoqXG4gKiBEZWZpbmVzIGdldHRlciBhbmQgc2V0dGVyIHByb3BlcnR5IG9uIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICAgICAgICAgT2JqZWN0IHdoZXJlIHByb3BlcnR5IGhhcyB0byBiZSBkZWZpbmVkLlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wICAgICAgICBOYW1lIG9mIHRoZSBkZWZpbmVkIHByb3BlcnR5LlxuICogQHBhcmFtICB7T2JqZWN0fSBkZWZpbml0aW9uICBHZXQgYW5kIHNldCBkZWZpbml0aW9ucyBmb3IgdGhlIHByb3BlcnR5LlxuICogQHJldHVybiB7Vm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lKG9iaiwgcHJvcCwgZGVmaW5pdGlvbikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZWZpbml0aW9uKTtcbn1cbi8qKlxuICogU29ydHMgYXBoYWJldGljYWxseSBvYmplY3Qga2V5cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHNvcnRLZXlzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uIChyLCBrKSB7XG4gICAgcltrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gcltrXSwgcjtcbiAgfSwge30pO1xufVxuLyoqXG4gKiBNZXJnZXMgcGFzc2VkIHNldHRpbmdzIG9iamVjdCB3aXRoIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRlZmF1bHRzXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKGRlZmF1bHRzLCBzZXR0aW5ncykge1xuICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBzZXR0aW5ncyk7IC8vIGBPYmplY3QuYXNzaWduYCBkbyBub3QgZGVlcGx5IG1lcmdlIG9iamVjdHMsIHNvIHdlXG4gIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkgZm9yIGV2ZXJ5IG5lc3RlZCBvYmplY3RcbiAgLy8gaW4gb3B0aW9ucy4gQWx0aG91Z2ggaXQgZG9lcyBub3QgbG9vayBzbWFydCxcbiAgLy8gaXQncyBzbWFsbGVyIGFuZCBmYXN0ZXIgdGhhbiBzb21lIGZhbmN5XG4gIC8vIG1lcmdpbmcgZGVlcC1tZXJnZSBhbGdvcml0aG0gc2NyaXB0LlxuXG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnY2xhc3NlcycpKSB7XG4gICAgb3B0aW9ucy5jbGFzc2VzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMuY2xhc3Nlcywgc2V0dGluZ3MuY2xhc3Nlcyk7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBbJ2RpcmVjdGlvbicsICd0eXBlJywgJ3NsaWRlJywgJ2Fycm93JywgJ25hdiddO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5jbGFzc2VzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICBvcHRpb25zLmNsYXNzZXNbcHJvcGVydHldID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRzLmNsYXNzZXNbcHJvcGVydHldKSwgc2V0dGluZ3MuY2xhc3Nlc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdicmVha3BvaW50cycpKSB7XG4gICAgb3B0aW9ucy5icmVha3BvaW50cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLmJyZWFrcG9pbnRzLCBzZXR0aW5ncy5icmVha3BvaW50cyk7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxudmFyIEV2ZW50c0J1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBFdmVudEJ1cyBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50c1xuICAgKi9cbiAgZnVuY3Rpb24gRXZlbnRzQnVzKCkge1xuICAgIHZhciBldmVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50c0J1cyk7XG5cbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmhvcCA9IGV2ZW50cy5oYXNPd25Qcm9wZXJ0eTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBsaXN0ZW5lciB0byB0aGUgc3BlY2lmZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50c0J1cywgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChpc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5vbihldmVudFtpXSwgaGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENyZWF0ZSB0aGUgZXZlbnQncyBvYmplY3QgaWYgbm90IHlldCBjcmVhdGVkXG5cblxuICAgICAgaWYgKCF0aGlzLmhvcC5jYWxsKHRoaXMuZXZlbnRzLCBldmVudCkpIHtcbiAgICAgICAgdGhpcy5ldmVudHNbZXZlbnRdID0gW107XG4gICAgICB9IC8vIEFkZCB0aGUgaGFuZGxlciB0byBxdWV1ZVxuXG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZXZlbnRzW2V2ZW50XS5wdXNoKGhhbmRsZXIpIC0gMTsgLy8gUHJvdmlkZSBoYW5kbGUgYmFjayBmb3IgcmVtb3ZhbCBvZiBldmVudFxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyByZWdpc3RlcmVkIGhhbmRsZXJzIGZvciBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVtaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudCwgY29udGV4dCkge1xuICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRbaV0sIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB0aGUgZXZlbnQgZG9lc24ndCBleGlzdCwgb3IgdGhlcmUncyBubyBoYW5kbGVycyBpbiBxdWV1ZSwganVzdCBsZWF2ZVxuXG5cbiAgICAgIGlmICghdGhpcy5ob3AuY2FsbCh0aGlzLmV2ZW50cywgZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ3ljbGUgdGhyb3VnaCBldmVudHMgcXVldWUsIGZpcmUhXG5cblxuICAgICAgdGhpcy5ldmVudHNbZXZlbnRdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbShjb250ZXh0IHx8IHt9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudHNCdXM7XG59KCk7XG5cbnZhciBHbGlkZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGdsaWRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzZWxlY3RvclxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xyXG4gICAqL1xuICBmdW5jdGlvbiBHbGlkZShzZWxlY3Rvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbGlkZSk7XG5cbiAgICB0aGlzLl9jID0ge307XG4gICAgdGhpcy5fdCA9IFtdO1xuICAgIHRoaXMuX2UgPSBuZXcgRXZlbnRzQnVzKCk7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB0aGlzLnNldHRpbmdzID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB0aGlzLmluZGV4ID0gdGhpcy5zZXR0aW5ncy5zdGFydEF0O1xuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIGdsaWRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgQ29sbGVjdGlvbiBvZiBleHRlbnNpb25zIHRvIGluaXRpYWxpemUuXHJcbiAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoR2xpZGUsIFt7XG4gICAga2V5OiBcIm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdW50JDEoKSB7XG4gICAgICB2YXIgZXh0ZW5zaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIHRoaXMuX2UuZW1pdCgnbW91bnQuYmVmb3JlJyk7XG5cbiAgICAgIGlmIChpc09iamVjdChleHRlbnNpb25zKSkge1xuICAgICAgICB0aGlzLl9jID0gbW91bnQodGhpcywgZXh0ZW5zaW9ucywgdGhpcy5fZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdZb3UgbmVlZCB0byBwcm92aWRlIGEgb2JqZWN0IG9uIGBtb3VudCgpYCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lLmVtaXQoJ21vdW50LmFmdGVyJyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIGFuIGluc3RhbmNlIGB0cmFuc2xhdGVgIHRyYW5zZm9ybWVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdHJhbnNmb3JtZXJzIENvbGxlY3Rpb24gb2YgdHJhbnNmb3JtZXJzLlxyXG4gICAgICogQHJldHVybiB7Vm9pZH1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibXV0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11dGF0ZSgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgICBpZiAoaXNBcnJheSh0cmFuc2Zvcm1lcnMpKSB7XG4gICAgICAgIHRoaXMuX3QgPSB0cmFuc2Zvcm1lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdZb3UgbmVlZCB0byBwcm92aWRlIGEgYXJyYXkgb24gYG11dGF0ZSgpYCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGdsaWRlIHdpdGggc3BlY2lmaWVkIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyh0aGlzLnNldHRpbmdzLCBzZXR0aW5ncyk7XG5cbiAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnc3RhcnRBdCcpKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBzZXR0aW5ncy5zdGFydEF0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lLmVtaXQoJ3VwZGF0ZScpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2Ugc2xpZGUgd2l0aCBzcGVjaWZpZWQgcGF0dGVybi4gQSBwYXR0ZXJuIG11c3QgYmUgaW4gdGhlIHNwZWNpYWwgZm9ybWF0OlxyXG4gICAgICogYD5gIC0gTW92ZSBvbmUgZm9yd2FyZFxyXG4gICAgICogYDxgIC0gTW92ZSBvbmUgYmFja3dhcmRcclxuICAgICAqIGA9e2l9YCAtIEdvIHRvIHtpfSB6ZXJvLWJhc2VkIHNsaWRlIChlcS4gJz0xJywgd2lsbCBnbyB0byBzZWNvbmQgc2xpZGUpXHJcbiAgICAgKiBgPj5gIC0gUmV3aW5kcyB0byBlbmQgKGxhc3Qgc2xpZGUpXHJcbiAgICAgKiBgPDxgIC0gUmV3aW5kcyB0byBzdGFydCAoZmlyc3Qgc2xpZGUpXHJcbiAgICAgKiBgfD5gIC0gTW92ZSBvbmUgdmlld3BvcnQgZm9yd2FyZFxyXG4gICAgICogYHw8YCAtIE1vdmUgb25lIHZpZXdwb3J0IGJhY2t3YXJkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm5cclxuICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnbyhwYXR0ZXJuKSB7XG4gICAgICB0aGlzLl9jLlJ1bi5tYWtlKHBhdHRlcm4pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHRyYWNrIGJ5IHNwZWNpZmllZCBkaXN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGlzdGFuY2VcclxuICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2MuVHJhbnNpdGlvbi5kaXNhYmxlKCk7XG5cbiAgICAgIHRoaXMuX2MuTW92ZS5tYWtlKGRpc3RhbmNlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSBpbnN0YW5jZSBhbmQgcmV2ZXJ0IGFsbCBjaGFuZ2VzIGRvbmUgYnkgdGhpcy5fYy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fZS5lbWl0KCdkZXN0cm95Jyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGluc3RhbmNlIGF1dG9wbGF5aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxOdW1iZXJ9IGludGVydmFsIFJ1biBhdXRvcGxheWluZyB3aXRoIHBhc3NlZCBpbnRlcnZhbCByZWdhcmRsZXNzIG9mIGBhdXRvcGxheWAgc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hdXRvcGxheSA9IGludGVydmFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lLmVtaXQoJ3BsYXknKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU3RvcCBpbnN0YW5jZSBhdXRvcGxheWluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICB0aGlzLl9lLmVtaXQoJ3BhdXNlJyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldHMgZ2xpZGUgaW50byBhIGlkbGUgc3RhdHVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldHMgZ2xpZGUgaW50byBhIGFjdGl2ZSBzdGF0dXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGN1dXRvbSBldmVudCBsaXN0ZW5lciB3aXRoIGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBldmVudFxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGhhbmRsZXJcclxuICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlcikge1xuICAgICAgdGhpcy5fZS5vbihldmVudCwgaGFuZGxlcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBnbGlkZSBpcyBhIHByZWNpc2VkIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1R5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNUeXBlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnR5cGUgPT09IG5hbWU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogR2V0cyB2YWx1ZSBvZiB0aGUgY29yZSBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dGluZ3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIGNvcmUgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9cclxuICAgICAqIEByZXR1cm4ge1ZvaWR9XHJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobykge1xuICAgICAgaWYgKGlzT2JqZWN0KG8pKSB7XG4gICAgICAgIHRoaXMuX28gPSBvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybignT3B0aW9ucyBtdXN0IGJlIGFuIGBvYmplY3RgIGluc3RhbmNlLicpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldHMgY3VycmVudCBpbmRleCBvZiB0aGUgc2xpZGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5kZXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldHMgY3VycmVudCBpbmRleCBhIHNsaWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoaSkge1xuICAgICAgdGhpcy5faSA9IHRvSW50KGkpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldHMgdHlwZSBuYW1lIG9mIHRoZSBzbGlkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50eXBlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIGlkbGUgc3RhdHVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHZhbHVlIG9mIHRoZSBpZGxlIHN0YXR1cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXR1cykge1xuICAgICAgdGhpcy5fZCA9ICEhc3RhdHVzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHbGlkZTtcbn0oKTtcblxuZnVuY3Rpb24gUnVuIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIHZhciBSdW4gPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYXV0b3J1bm5pbmcgb2YgdGhlIGdsaWRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLl9vID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGdsaWRlcyBydW5uaW5nIGJhc2VkIG9uIHRoZSBwYXNzZWQgbW92aW5nIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb3ZlXG4gICAgICovXG4gICAgbWFrZTogZnVuY3Rpb24gbWFrZShtb3ZlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIUdsaWRlLmRpc2FibGVkKSB7XG4gICAgICAgICFHbGlkZS5zZXR0aW5ncy53YWl0Rm9yVHJhbnNpdGlvbiB8fCBHbGlkZS5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgICAgIEV2ZW50cy5lbWl0KCdydW4uYmVmb3JlJywgdGhpcy5tb3ZlKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcbiAgICAgICAgRXZlbnRzLmVtaXQoJ3J1bicsIHRoaXMubW92ZSk7XG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNpdGlvbi5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgRXZlbnRzLmVtaXQoJ3J1bi5zdGFydCcsIF90aGlzLm1vdmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5pc0VuZCgpKSB7XG4gICAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLmVuZCcsIF90aGlzLm1vdmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5pc09mZnNldCgpKSB7XG4gICAgICAgICAgICBfdGhpcy5fbyA9IGZhbHNlO1xuICAgICAgICAgICAgRXZlbnRzLmVtaXQoJ3J1bi5vZmZzZXQnLCBfdGhpcy5tb3ZlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLmFmdGVyJywgX3RoaXMubW92ZSk7XG4gICAgICAgICAgR2xpZGUuZW5hYmxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGN1cnJlbnQgaW5kZXggYmFzZWQgb24gZGVmaW5lZCBtb3ZlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfFVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGU6IGZ1bmN0aW9uIGNhbGN1bGF0ZSgpIHtcbiAgICAgIHZhciBtb3ZlID0gdGhpcy5tb3ZlLFxuICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIHN0ZXBzID0gbW92ZS5zdGVwcyxcbiAgICAgICAgICBkaXJlY3Rpb24gPSBtb3ZlLmRpcmVjdGlvbjsgLy8gQnkgZGVmYXVsdCBhc3N1bWUgdGhhdCBzaXplIG9mIHZpZXcgaXMgZXF1YWwgdG8gb25lIHNsaWRlXG5cbiAgICAgIHZhciB2aWV3U2l6ZSA9IDE7IC8vIFdoaWxlIGRpcmVjdGlvbiBpcyBgPWAgd2Ugd2FudCBqdW1wIHRvXG4gICAgICAvLyBhIHNwZWNpZmllZCBpbmRleCBkZXNjcmliZWQgaW4gc3RlcHMuXG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICc9Jykge1xuICAgICAgICAvLyBDaGVjayBpZiBib3VuZCBpcyB0cnVlLCBcbiAgICAgICAgLy8gYXMgd2Ugd2FudCB0byBhdm9pZCB3aGl0ZXNwYWNlcy5cbiAgICAgICAgaWYgKEdsaWRlLnNldHRpbmdzLmJvdW5kICYmIHRvSW50KHN0ZXBzKSA+IGxlbmd0aCkge1xuICAgICAgICAgIEdsaWRlLmluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIEdsaWRlLmluZGV4ID0gc3RlcHM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gV2hlbiBwYXR0ZXJuIGlzIGVxdWFsIHRvIGA+PmAgd2Ugd2FudFxuICAgICAgLy8gZmFzdCBmb3J3YXJkIHRvIHRoZSBsYXN0IHNsaWRlLlxuXG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICc+JyAmJiBzdGVwcyA9PT0gJz4nKSB7XG4gICAgICAgIEdsaWRlLmluZGV4ID0gbGVuZ3RoO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFdoZW4gcGF0dGVybiBpcyBlcXVhbCB0byBgPDxgIHdlIHdhbnRcbiAgICAgIC8vIGZhc3QgZm9yd2FyZCB0byB0aGUgZmlyc3Qgc2xpZGUuXG5cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJzwnICYmIHN0ZXBzID09PSAnPCcpIHtcbiAgICAgICAgR2xpZGUuaW5kZXggPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHBhZ2luYXRpb24gbW92ZW1lbnRcblxuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnfCcpIHtcbiAgICAgICAgdmlld1NpemUgPSBHbGlkZS5zZXR0aW5ncy5wZXJWaWV3IHx8IDE7XG4gICAgICB9IC8vIHdlIGFyZSBtb3ZpbmcgZm9yd2FyZFxuXG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICc+JyB8fCBkaXJlY3Rpb24gPT09ICd8JyAmJiBzdGVwcyA9PT0gJz4nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNhbGN1bGF0ZUZvcndhcmRJbmRleCh2aWV3U2l6ZSk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fbyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBHbGlkZS5pbmRleCA9IG5vcm1hbGl6ZUZvcndhcmRJbmRleChpbmRleCwgdmlld1NpemUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHdlIGFyZSBtb3ZpbmcgYmFja3dhcmRcblxuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnPCcgfHwgZGlyZWN0aW9uID09PSAnfCcgJiYgc3RlcHMgPT09ICc8Jykge1xuICAgICAgICB2YXIgX2luZGV4ID0gY2FsY3VsYXRlQmFja3dhcmRJbmRleCh2aWV3U2l6ZSk7XG5cbiAgICAgICAgaWYgKF9pbmRleCA8IDApIHtcbiAgICAgICAgICB0aGlzLl9vID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEdsaWRlLmluZGV4ID0gbm9ybWFsaXplQmFja3dhcmRJbmRleChfaW5kZXgsIHZpZXdTaXplKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3YXJuKFwiSW52YWxpZCBkaXJlY3Rpb24gcGF0dGVybiBbXCIuY29uY2F0KGRpcmVjdGlvbikuY29uY2F0KHN0ZXBzLCBcIl0gaGFzIGJlZW4gdXNlZFwiKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB3ZSBhcmUgb24gdGhlIGZpcnN0IHNsaWRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1N0YXJ0OiBmdW5jdGlvbiBpc1N0YXJ0KCkge1xuICAgICAgcmV0dXJuIEdsaWRlLmluZGV4IDw9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB3ZSBhcmUgb24gdGhlIGxhc3Qgc2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kOiBmdW5jdGlvbiBpc0VuZCgpIHtcbiAgICAgIHJldHVybiBHbGlkZS5pbmRleCA+PSB0aGlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHdlIGFyZSBtYWtpbmcgYSBvZmZzZXQgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPZmZzZXQ6IGZ1bmN0aW9uIGlzT2Zmc2V0KCkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbztcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9vKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gZGlkIHdlIHZpZXcgdG8gdGhlIHJpZ2h0P1xuXG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd8PicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZS5kaXJlY3Rpb24gPT09ICd8JyAmJiB0aGlzLm1vdmUuc3RlcHMgPT09ICc+JztcbiAgICAgIH0gLy8gZGlkIHdlIHZpZXcgdG8gdGhlIGxlZnQ/XG5cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3w8Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlLmRpcmVjdGlvbiA9PT0gJ3wnICYmIHRoaXMubW92ZS5zdGVwcyA9PT0gJzwnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5tb3ZlLmRpcmVjdGlvbiA9PT0gZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYm91bmQgbW9kZSBpcyBhY3RpdmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNCb3VuZDogZnVuY3Rpb24gaXNCb3VuZCgpIHtcbiAgICAgIHJldHVybiBHbGlkZS5pc1R5cGUoJ3NsaWRlcicpICYmIEdsaWRlLnNldHRpbmdzLmZvY3VzQXQgIT09ICdjZW50ZXInICYmIEdsaWRlLnNldHRpbmdzLmJvdW5kO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgaW5kZXggdmFsdWUgdG8gbW92ZSBmb3J3YXJkL3RvIHRoZSByaWdodFxuICAgKlxuICAgKiBAcGFyYW0gdmlld1NpemVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlRm9yd2FyZEluZGV4KHZpZXdTaXplKSB7XG4gICAgdmFyIGluZGV4ID0gR2xpZGUuaW5kZXg7XG5cbiAgICBpZiAoR2xpZGUuaXNUeXBlKCdjYXJvdXNlbCcpKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyB2aWV3U2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXggKyAodmlld1NpemUgLSBpbmRleCAlIHZpZXdTaXplKTtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gZm9yd2FyZCBpbmRleCBiYXNlZCBvbiBnbGlkZSBzZXR0aW5ncywgcHJldmVudGluZyBpdCB0byBleGNlZWQgY2VydGFpbiBib3VuZGFyaWVzXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcGFyYW0gbGVuZ3RoXG4gICAqIEBwYXJhbSB2aWV3U2l6ZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUZvcndhcmRJbmRleChpbmRleCwgdmlld1NpemUpIHtcbiAgICB2YXIgbGVuZ3RoID0gUnVuLmxlbmd0aDtcblxuICAgIGlmIChpbmRleCA8PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICBpZiAoR2xpZGUuaXNUeXBlKCdjYXJvdXNlbCcpKSB7XG4gICAgICByZXR1cm4gaW5kZXggLSAobGVuZ3RoICsgMSk7XG4gICAgfVxuXG4gICAgaWYgKEdsaWRlLnNldHRpbmdzLnJld2luZCkge1xuICAgICAgLy8gYm91bmQgZG9lcyBmdW5ueSB0aGluZ3Mgd2l0aCB0aGUgbGVuZ3RoLCB0aGVyZWZvciB3ZSBoYXZlIHRvIGJlIGNlcnRhaW5cbiAgICAgIC8vIHRoYXQgd2UgYXJlIG9uIHRoZSBsYXN0IHBvc3NpYmxlIGluZGV4IHZhbHVlIGdpdmVuIGJ5IGJvdW5kXG4gICAgICBpZiAoUnVuLmlzQm91bmQoKSAmJiAhUnVuLmlzRW5kKCkpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKFJ1bi5pc0JvdW5kKCkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IobGVuZ3RoIC8gdmlld1NpemUpICogdmlld1NpemU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgaW5kZXggdmFsdWUgdG8gbW92ZSBiYWNrd2FyZC90byB0aGUgbGVmdFxuICAgKlxuICAgKiBAcGFyYW0gdmlld1NpemVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVCYWNrd2FyZEluZGV4KHZpZXdTaXplKSB7XG4gICAgdmFyIGluZGV4ID0gR2xpZGUuaW5kZXg7XG5cbiAgICBpZiAoR2xpZGUuaXNUeXBlKCdjYXJvdXNlbCcpKSB7XG4gICAgICByZXR1cm4gaW5kZXggLSB2aWV3U2l6ZTtcbiAgICB9IC8vIGVuc3VyZSBvdXIgYmFjayBuYXZpZ2F0aW9uIHJlc3VsdHMgaW4gdGhlIHNhbWUgaW5kZXggYXMgYSBmb3J3YXJkIG5hdmlnYXRpb25cbiAgICAvLyB0byBleHBlcmllbmNlIGEgaG9tb2dlbmVvdXMgcGFnaW5nXG5cblxuICAgIHZhciB2aWV3ID0gTWF0aC5jZWlsKGluZGV4IC8gdmlld1NpemUpO1xuICAgIHJldHVybiAodmlldyAtIDEpICogdmlld1NpemU7XG4gIH1cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIGJhY2t3YXJkIGluZGV4IGJhc2VkIG9uIGdsaWRlIHNldHRpbmdzLCBwcmV2ZW50aW5nIGl0IHRvIGV4Y2VlZCBjZXJ0YWluIGJvdW5kYXJpZXNcbiAgICpcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwYXJhbSBsZW5ndGhcbiAgICogQHBhcmFtIHZpZXdTaXplXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUJhY2t3YXJkSW5kZXgoaW5kZXgsIHZpZXdTaXplKSB7XG4gICAgdmFyIGxlbmd0aCA9IFJ1bi5sZW5ndGg7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIGlmIChHbGlkZS5pc1R5cGUoJ2Nhcm91c2VsJykpIHtcbiAgICAgIHJldHVybiBpbmRleCArIChsZW5ndGggKyAxKTtcbiAgICB9XG5cbiAgICBpZiAoR2xpZGUuc2V0dGluZ3MucmV3aW5kKSB7XG4gICAgICAvLyBib3VuZCBkb2VzIGZ1bm55IHRoaW5ncyB3aXRoIHRoZSBsZW5ndGgsIHRoZXJlZm9yIHdlIGhhdmUgdG8gYmUgY2VydGFpblxuICAgICAgLy8gdGhhdCB3ZSBhcmUgb24gZmlyc3QgcG9zc2libGUgaW5kZXggdmFsdWUgYmVmb3JlIHdlIHRvIHJld2luZCB0byB0aGUgbGVuZ3RoIGdpdmVuIGJ5IGJvdW5kXG4gICAgICBpZiAoUnVuLmlzQm91bmQoKSAmJiBSdW4uaXNTdGFydCgpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGxlbmd0aCAvIHZpZXdTaXplKSAqIHZpZXdTaXplO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZGVmaW5lKFJ1biwgJ21vdmUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiB0aGUgbW92ZSBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIG1vdmUgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIHN0ZXAgPSB2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICB0aGlzLl9tID0ge1xuICAgICAgICBkaXJlY3Rpb246IHZhbHVlLnN1YnN0cigwLCAxKSxcbiAgICAgICAgc3RlcHM6IHN0ZXAgPyB0b0ludChzdGVwKSA/IHRvSW50KHN0ZXApIDogc3RlcCA6IDBcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKFJ1biwgJ2xlbmd0aCcsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIHRoZSBydW5uaW5nIGRpc3RhbmNlIGJhc2VkXG4gICAgICogb24gemVyby1pbmRleGluZyBudW1iZXIgb2Ygc2xpZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG4gICAgICB2YXIgbGVuZ3RoID0gQ29tcG9uZW50cy5IdG1sLnNsaWRlcy5sZW5ndGg7IC8vIElmIHRoZSBgYm91bmRgIG9wdGlvbiBpcyBhY3RpdmUsIGEgbWF4aW11bSBydW5uaW5nIGRpc3RhbmNlIHNob3VsZCBiZVxuICAgICAgLy8gcmVkdWNlZCBieSBgcGVyVmlld2AgYW5kIGBmb2N1c0F0YCBzZXR0aW5ncy4gUnVubmluZyBkaXN0YW5jZVxuICAgICAgLy8gc2hvdWxkIGVuZCBiZWZvcmUgY3JlYXRpbmcgYW4gZW1wdHkgc3BhY2UgYWZ0ZXIgaW5zdGFuY2UuXG5cbiAgICAgIGlmICh0aGlzLmlzQm91bmQoKSkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoIC0gMSAtICh0b0ludChzZXR0aW5ncy5wZXJWaWV3KSAtIDEpICsgdG9JbnQoc2V0dGluZ3MuZm9jdXNBdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZW5ndGggLSAxO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZShSdW4sICdvZmZzZXQnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBzdGF0dXMgb2YgdGhlIG9mZnNldHRpbmcgZmxhZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUnVuO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyZW50IHRpbWUuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZFxuICogYXQgbW9zdCBvbmNlIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlXG4gKi9cblxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB0aW1lb3V0LCBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gIHZhciBwcmV2aW91cyA9IDA7XG5cbiAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5vdygpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uIHRocm90dGxlZCgpIHtcbiAgICB2YXIgYXQgPSBub3coKTtcbiAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gYXQ7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAoYXQgLSBwcmV2aW91cyk7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91cyA9IGF0O1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdGhyb3R0bGVkLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgcHJldmlvdXMgPSAwO1xuICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxudmFyIE1BUkdJTl9UWVBFID0ge1xuICBsdHI6IFsnbWFyZ2luTGVmdCcsICdtYXJnaW5SaWdodCddLFxuICBydGw6IFsnbWFyZ2luUmlnaHQnLCAnbWFyZ2luTGVmdCddXG59O1xuZnVuY3Rpb24gR2FwcyAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICB2YXIgR2FwcyA9IHtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGdhcHMgYmV0d2VlbiBzbGlkZXMuIEZpcnN0IGFuZCBsYXN0XG4gICAgICogc2xpZGVzIGRvIG5vdCByZWNlaXZlIGl0J3MgZWRnZSBtYXJnaW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MQ29sbGVjdGlvbn0gc2xpZGVzXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkoc2xpZGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2xpZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHNsaWRlc1tpXS5zdHlsZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IENvbXBvbmVudHMuRGlyZWN0aW9uLnZhbHVlO1xuXG4gICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgc3R5bGVbTUFSR0lOX1RZUEVbZGlyZWN0aW9uXVswXV0gPSBcIlwiLmNvbmNhdCh0aGlzLnZhbHVlIC8gMiwgXCJweFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtNQVJHSU5fVFlQRVtkaXJlY3Rpb25dWzBdXSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgIT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgc3R5bGVbTUFSR0lOX1RZUEVbZGlyZWN0aW9uXVsxXV0gPSBcIlwiLmNvbmNhdCh0aGlzLnZhbHVlIC8gMiwgXCJweFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtNQVJHSU5fVFlQRVtkaXJlY3Rpb25dWzFdXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZ2FwcyBmcm9tIHRoZSBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxDb2xsZWN0aW9ufSBzbGlkZXNcbiAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKHNsaWRlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNsaWRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgc3R5bGUgPSBzbGlkZXNbaV0uc3R5bGU7XG4gICAgICAgIHN0eWxlLm1hcmdpbkxlZnQgPSAnJztcbiAgICAgICAgc3R5bGUubWFyZ2luUmlnaHQgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGRlZmluZShHYXBzLCAndmFsdWUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiB0aGUgZ2FwLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0b0ludChHbGlkZS5zZXR0aW5ncy5nYXApO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZShHYXBzLCAnZ3JvdycsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIGFkZGl0aW9uYWwgZGltZW5zaW9ucyB2YWx1ZSBjYXVzZWQgYnkgZ2Fwcy5cbiAgICAgKiBVc2VkIHRvIGluY3JlYXNlIHdpZHRoIG9mIHRoZSBzbGlkZXMgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gR2Fwcy52YWx1ZSAqIENvbXBvbmVudHMuU2l6ZXMubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZShHYXBzLCAncmVkdWN0b3InLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyByZWR1Y3Rpb24gdmFsdWUgY2F1c2VkIGJ5IGdhcHMuXG4gICAgICogVXNlZCB0byBzdWJ0cmFjdCB3aWR0aCBvZiB0aGUgc2xpZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwZXJWaWV3ID0gR2xpZGUuc2V0dGluZ3MucGVyVmlldztcbiAgICAgIHJldHVybiBHYXBzLnZhbHVlICogKHBlclZpZXcgLSAxKSAvIHBlclZpZXc7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEFwcGx5IGNhbGN1bGF0ZWQgZ2FwczpcbiAgICogLSBhZnRlciBidWlsZGluZywgc28gc2xpZGVzIChpbmNsdWRpbmcgY2xvbmVzKSB3aWxsIHJlY2VpdmUgcHJvcGVyIG1hcmdpbnNcbiAgICogLSBvbiB1cGRhdGluZyB2aWEgQVBJLCB0byByZWNhbGN1bGF0ZSBnYXBzIHdpdGggbmV3IG9wdGlvbnNcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnYnVpbGQuYWZ0ZXInLCAndXBkYXRlJ10sIHRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICBHYXBzLmFwcGx5KENvbXBvbmVudHMuSHRtbC53cmFwcGVyLmNoaWxkcmVuKTtcbiAgfSwgMzApKTtcbiAgLyoqXG4gICAqIFJlbW92ZSBnYXBzOlxuICAgKiAtIG9uIGRlc3Ryb3lpbmcgdG8gYnJpbmcgbWFya3VwIHRvIGl0cyBpbml0YWwgc3RhdGVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIEdhcHMucmVtb3ZlKENvbXBvbmVudHMuSHRtbC53cmFwcGVyLmNoaWxkcmVuKTtcbiAgfSk7XG4gIHJldHVybiBHYXBzO1xufVxuXG4vKipcbiAqIEZpbmRzIHNpYmxpbmdzIG5vZGVzIG9mIHRoZSBwYXNzZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gc2libGluZ3Mobm9kZSkge1xuICBpZiAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICB2YXIgbiA9IG5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgIHZhciBtYXRjaGVkID0gW107XG5cbiAgICBmb3IgKDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IG5vZGUpIHtcbiAgICAgICAgbWF0Y2hlZC5wdXNoKG4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuLyoqXG4gKiBDb2VyY2VzIGEgTm9kZUxpc3QgdG8gYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtICB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiB0b0FycmF5KG5vZGVMaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCk7XG59XG5cbnZhciBUUkFDS19TRUxFQ1RPUiA9ICdbZGF0YS1nbGlkZS1lbD1cInRyYWNrXCJdJztcbmZ1bmN0aW9uIEh0bWwgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIEh0bWwgPSB7XG4gICAgLyoqXG4gICAgICogU2V0dXAgc2xpZGVyIEhUTUwgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dsaWRlfSBnbGlkZVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMucm9vdCA9IEdsaWRlLnNlbGVjdG9yO1xuICAgICAgdGhpcy50cmFjayA9IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKFRSQUNLX1NFTEVDVE9SKTtcbiAgICAgIHRoaXMuY29sbGVjdFNsaWRlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0IHNsaWRlc1xuICAgICAqL1xuICAgIGNvbGxlY3RTbGlkZXM6IGZ1bmN0aW9uIGNvbGxlY3RTbGlkZXMoKSB7XG4gICAgICB0aGlzLnNsaWRlcyA9IHRvQXJyYXkodGhpcy53cmFwcGVyLmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgIHJldHVybiAhc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEdsaWRlLnNldHRpbmdzLmNsYXNzZXMuc2xpZGUuY2xvbmUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBkZWZpbmUoSHRtbCwgJ3Jvb3QnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBub2RlIG9mIHRoZSBnbGlkZSBtYWluIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSHRtbC5fcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBub2RlIG9mIHRoZSBnbGlkZSBtYWluIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocikge1xuICAgICAgaWYgKGlzU3RyaW5nKHIpKSB7XG4gICAgICAgIHIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAociAhPT0gbnVsbCkge1xuICAgICAgICBIdG1sLl9yID0gcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ1Jvb3QgZWxlbWVudCBtdXN0IGJlIGEgZXhpc3RpbmcgSHRtbCBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKEh0bWwsICd0cmFjaycsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIG5vZGUgb2YgdGhlIGdsaWRlIHRyYWNrIHdpdGggc2xpZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEh0bWwuX3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgbm9kZSBvZiB0aGUgZ2xpZGUgdHJhY2sgd2l0aCBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgSHRtbC5fdCA9IHQ7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKEh0bWwsICd3cmFwcGVyJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgbm9kZSBvZiB0aGUgc2xpZGVzIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSHRtbC50cmFjay5jaGlsZHJlblswXTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQWRkL3JlbW92ZS9yZW9yZGVyIGR5bmFtaWMgc2xpZGVzXG4gICAqL1xuXG4gIEV2ZW50cy5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgIEh0bWwuY29sbGVjdFNsaWRlcygpO1xuICB9KTtcbiAgcmV0dXJuIEh0bWw7XG59XG5cbmZ1bmN0aW9uIFBlZWsgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIFBlZWsgPSB7XG4gICAgLyoqXG4gICAgICogU2V0dXBzIGhvdyBtdWNoIHRvIHBlZWsgYmFzZWQgb24gc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBHbGlkZS5zZXR0aW5ncy5wZWVrO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lKFBlZWssICd2YWx1ZScsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIHRoZSBwZWVrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcnxPYmplY3R9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gUGVlay5fdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2YWx1ZSBvZiB0aGUgcGVlay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmJlZm9yZSA9IHRvSW50KHZhbHVlLmJlZm9yZSk7XG4gICAgICAgIHZhbHVlLmFmdGVyID0gdG9JbnQodmFsdWUuYWZ0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIFBlZWsuX3YgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoUGVlaywgJ3JlZHVjdG9yJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgcmVkdWN0aW9uIHZhbHVlIGNhdXNlZCBieSBwZWVrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IFBlZWsudmFsdWU7XG4gICAgICB2YXIgcGVyVmlldyA9IEdsaWRlLnNldHRpbmdzLnBlclZpZXc7XG5cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmJlZm9yZSAvIHBlclZpZXcgKyB2YWx1ZS5hZnRlciAvIHBlclZpZXc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZSAqIDIgLyBwZXJWaWV3O1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZSBwZWVraW5nIHNpemVzIG9uOlxuICAgKiAtIHdoZW4gcmVzaXppbmcgd2luZG93IHRvIHVwZGF0ZSB0byBwcm9wZXIgcGVyY2VudHNcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsncmVzaXplJywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgUGVlay5tb3VudCgpO1xuICB9KTtcbiAgcmV0dXJuIFBlZWs7XG59XG5cbmZ1bmN0aW9uIE1vdmUgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIE1vdmUgPSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBtb3ZlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMuX28gPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGEgbW92ZW1lbnQgdmFsdWUgYmFzZWQgb24gcGFzc2VkIG9mZnNldCBhbmQgY3VycmVudGx5IGFjdGl2ZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gb2Zmc2V0XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBtYWtlOiBmdW5jdGlvbiBtYWtlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgRXZlbnRzLmVtaXQoJ21vdmUnLCB7XG4gICAgICAgIG1vdmVtZW50OiB0aGlzLnZhbHVlXG4gICAgICB9KTtcbiAgICAgIENvbXBvbmVudHMuVHJhbnNpdGlvbi5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIEV2ZW50cy5lbWl0KCdtb3ZlLmFmdGVyJywge1xuICAgICAgICAgIG1vdmVtZW50OiBfdGhpcy52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lKE1vdmUsICdvZmZzZXQnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvZmZzZXQgdmFsdWUgdXNlZCB0byBtb2RpZnkgY3VycmVudCB0cmFuc2xhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTW92ZS5fbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBvZmZzZXQgdmFsdWUgdXNlZCB0byBtb2RpZnkgY3VycmVudCB0cmFuc2xhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIE1vdmUuX28gPSAhaXNVbmRlZmluZWQodmFsdWUpID8gdG9JbnQodmFsdWUpIDogMDtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoTW92ZSwgJ3RyYW5zbGF0ZScsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmF3IG1vdmVtZW50IHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCAqIEdsaWRlLmluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZShNb3ZlLCAndmFsdWUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBhY3R1YWwgbW92ZW1lbnQgdmFsdWUgY29ycmVjdGVkIGJ5IG9mZnNldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZTtcblxuICAgICAgaWYgKENvbXBvbmVudHMuRGlyZWN0aW9uLmlzKCdydGwnKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlICsgb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhbnNsYXRlIC0gb2Zmc2V0O1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBNYWtlIG1vdmVtZW50IHRvIHByb3BlciBzbGlkZSBvbjpcbiAgICogLSBiZWZvcmUgYnVpbGQsIHNvIGdsaWRlIHdpbGwgc3RhcnQgYXQgYHN0YXJ0QXRgIGluZGV4XG4gICAqIC0gb24gZWFjaCBzdGFuZGFyZCBydW4gdG8gbW92ZSB0byBuZXdseSBjYWxjdWxhdGVkIGluZGV4XG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2J1aWxkLmJlZm9yZScsICdydW4nXSwgZnVuY3Rpb24gKCkge1xuICAgIE1vdmUubWFrZSgpO1xuICB9KTtcbiAgcmV0dXJuIE1vdmU7XG59XG5cbmZ1bmN0aW9uIFNpemVzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIHZhciBTaXplcyA9IHtcbiAgICAvKipcbiAgICAgKiBTZXR1cHMgZGltZW5zaW9ucyBvZiBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldHVwU2xpZGVzOiBmdW5jdGlvbiBzZXR1cFNsaWRlcygpIHtcbiAgICAgIHZhciB3aWR0aCA9IFwiXCIuY29uY2F0KHRoaXMuc2xpZGVXaWR0aCwgXCJweFwiKTtcbiAgICAgIHZhciBzbGlkZXMgPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzbGlkZXNbaV0uc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXBzIGRpbWVuc2lvbnMgb2Ygc2xpZGVzIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldHVwV3JhcHBlcjogZnVuY3Rpb24gc2V0dXBXcmFwcGVyKCkge1xuICAgICAgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh0aGlzLndyYXBwZXJTaXplLCBcInB4XCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFwcGxpZWQgc3R5bGVzIGZyb20gSFRNTCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIHNsaWRlcyA9IENvbXBvbmVudHMuSHRtbC5zbGlkZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNsaWRlc1tpXS5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS53aWR0aCA9ICcnO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lKFNpemVzLCAnbGVuZ3RoJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgY291bnQgbnVtYmVyIG9mIHRoZSBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50cy5IdG1sLnNsaWRlcy5sZW5ndGg7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKFNpemVzLCAnd2lkdGgnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aWR0aCB2YWx1ZSBvZiB0aGUgc2xpZGVyICh2aXNpYmxlIGFyZWEpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIENvbXBvbmVudHMuSHRtbC50cmFjay5vZmZzZXRXaWR0aDtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmUoU2l6ZXMsICd3cmFwcGVyU2l6ZScsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHNpemUgb2YgdGhlIHNsaWRlcyB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFNpemVzLnNsaWRlV2lkdGggKiBTaXplcy5sZW5ndGggKyBDb21wb25lbnRzLkdhcHMuZ3JvdyArIENvbXBvbmVudHMuQ2xvbmVzLmdyb3c7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lKFNpemVzLCAnc2xpZGVXaWR0aCcsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdpZHRoIHZhbHVlIG9mIGEgc2luZ2xlIHNsaWRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFNpemVzLndpZHRoIC8gR2xpZGUuc2V0dGluZ3MucGVyVmlldyAtIENvbXBvbmVudHMuUGVlay5yZWR1Y3RvciAtIENvbXBvbmVudHMuR2Fwcy5yZWR1Y3RvcjtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQXBwbHkgY2FsY3VsYXRlZCBnbGlkZSdzIGRpbWVuc2lvbnM6XG4gICAqIC0gYmVmb3JlIGJ1aWxkaW5nLCBzbyBvdGhlciBkaW1lbnNpb25zIChlLmcuIHRyYW5zbGF0ZSkgd2lsbCBiZSBjYWxjdWxhdGVkIHByb3BlcnRseVxuICAgKiAtIHdoZW4gcmVzaXppbmcgd2luZG93IHRvIHJlY2FsY3VsYXRlIHNpbGRlcyBkaW1lbnNpb25zXG4gICAqIC0gb24gdXBkYXRpbmcgdmlhIEFQSSwgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbnMgYmFzZWQgb24gbmV3IG9wdGlvbnNcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnYnVpbGQuYmVmb3JlJywgJ3Jlc2l6ZScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIFNpemVzLnNldHVwU2xpZGVzKCk7XG4gICAgU2l6ZXMuc2V0dXBXcmFwcGVyKCk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3ZlIGNhbGN1bGF0ZWQgZ2xpZGUncyBkaW1lbnNpb25zOlxuICAgKiAtIG9uIGRlc3RvdGluZyB0byBicmluZyBtYXJrdXAgdG8gaXRzIGluaXRhbCBzdGF0ZVxuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgU2l6ZXMucmVtb3ZlKCk7XG4gIH0pO1xuICByZXR1cm4gU2l6ZXM7XG59XG5cbmZ1bmN0aW9uIEJ1aWxkIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIHZhciBCdWlsZCA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0IGdsaWRlIGJ1aWxkaW5nLiBBZGRzIGNsYXNzZXMsIHNldHNcbiAgICAgKiBkaW1lbnNpb25zIGFuZCBzZXR1cHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgRXZlbnRzLmVtaXQoJ2J1aWxkLmJlZm9yZScpO1xuICAgICAgdGhpcy50eXBlQ2xhc3MoKTtcbiAgICAgIHRoaXMuYWN0aXZlQ2xhc3MoKTtcbiAgICAgIEV2ZW50cy5lbWl0KCdidWlsZC5hZnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB0eXBlYCBjbGFzcyB0byB0aGUgZ2xpZGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdHlwZUNsYXNzOiBmdW5jdGlvbiB0eXBlQ2xhc3MoKSB7XG4gICAgICBDb21wb25lbnRzLkh0bWwucm9vdC5jbGFzc0xpc3QuYWRkKEdsaWRlLnNldHRpbmdzLmNsYXNzZXMudHlwZVtHbGlkZS5zZXR0aW5ncy50eXBlXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYWN0aXZlIGNsYXNzIHRvIGN1cnJlbnQgc2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGFjdGl2ZUNsYXNzOiBmdW5jdGlvbiBhY3RpdmVDbGFzcygpIHtcbiAgICAgIHZhciBjbGFzc2VzID0gR2xpZGUuc2V0dGluZ3MuY2xhc3NlcztcbiAgICAgIHZhciBzbGlkZSA9IENvbXBvbmVudHMuSHRtbC5zbGlkZXNbR2xpZGUuaW5kZXhdO1xuXG4gICAgICBpZiAoc2xpZGUpIHtcbiAgICAgICAgc2xpZGUuY2xhc3NMaXN0LmFkZChjbGFzc2VzLnNsaWRlLmFjdGl2ZSk7XG4gICAgICAgIHNpYmxpbmdzKHNsaWRlKS5mb3JFYWNoKGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgICAgc2libGluZy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzZXMuc2xpZGUuYWN0aXZlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgSFRNTCBjbGFzc2VzIGFwcGxpZWQgYXQgYnVpbGRpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUNsYXNzZXM6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoKSB7XG4gICAgICB2YXIgX0dsaWRlJHNldHRpbmdzJGNsYXNzID0gR2xpZGUuc2V0dGluZ3MuY2xhc3NlcyxcbiAgICAgICAgICB0eXBlID0gX0dsaWRlJHNldHRpbmdzJGNsYXNzLnR5cGUsXG4gICAgICAgICAgc2xpZGUgPSBfR2xpZGUkc2V0dGluZ3MkY2xhc3Muc2xpZGU7XG4gICAgICBDb21wb25lbnRzLkh0bWwucm9vdC5jbGFzc0xpc3QucmVtb3ZlKHR5cGVbR2xpZGUuc2V0dGluZ3MudHlwZV0pO1xuICAgICAgQ29tcG9uZW50cy5IdG1sLnNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgIHNpYmxpbmcuY2xhc3NMaXN0LnJlbW92ZShzbGlkZS5hY3RpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ2xlYXIgYnVpbGRpbmcgY2xhc3NlczpcbiAgICogLSBvbiBkZXN0cm95aW5nIHRvIGJyaW5nIEhUTUwgdG8gaXRzIGluaXRpYWwgc3RhdGVcbiAgICogLSBvbiB1cGRhdGluZyB0byByZW1vdmUgY2xhc3NlcyBiZWZvcmUgcmVtb3VudGluZyBjb21wb25lbnRcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnZGVzdHJveScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIEJ1aWxkLnJlbW92ZUNsYXNzZXMoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBSZW1vdW50IGNvbXBvbmVudDpcbiAgICogLSBvbiByZXNpemluZyBvZiB0aGUgd2luZG93IHRvIGNhbGN1bGF0ZSBuZXcgZGltZW5zaW9uc1xuICAgKiAtIG9uIHVwZGF0aW5nIHNldHRpbmdzIHZpYSBBUElcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsncmVzaXplJywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgQnVpbGQubW91bnQoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBTd2FwIGFjdGl2ZSBjbGFzcyBvZiBjdXJyZW50IHNsaWRlOlxuICAgKiAtIGFmdGVyIGVhY2ggbW92ZSB0byB0aGUgbmV3IGluZGV4XG4gICAqL1xuXG4gIEV2ZW50cy5vbignbW92ZS5hZnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBCdWlsZC5hY3RpdmVDbGFzcygpO1xuICB9KTtcbiAgcmV0dXJuIEJ1aWxkO1xufVxuXG5mdW5jdGlvbiBDbG9uZXMgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIENsb25lcyA9IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcGF0dGVybiBtYXAgYW5kIGNvbGxlY3Qgc2xpZGVzIHRvIGJlIGNsb25lZC5cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLml0ZW1zID0gW107XG5cbiAgICAgIGlmIChHbGlkZS5pc1R5cGUoJ2Nhcm91c2VsJykpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHRoaXMuY29sbGVjdCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0IGNsb25lcyB3aXRoIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtbXX1cbiAgICAgKi9cbiAgICBjb2xsZWN0OiBmdW5jdGlvbiBjb2xsZWN0KCkge1xuICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgIHZhciBzbGlkZXMgPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzO1xuICAgICAgdmFyIF9HbGlkZSRzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzLFxuICAgICAgICAgIHBlclZpZXcgPSBfR2xpZGUkc2V0dGluZ3MucGVyVmlldyxcbiAgICAgICAgICBjbGFzc2VzID0gX0dsaWRlJHNldHRpbmdzLmNsYXNzZXMsXG4gICAgICAgICAgY2xvbmluZ1JhdGlvID0gX0dsaWRlJHNldHRpbmdzLmNsb25pbmdSYXRpbztcblxuICAgICAgaWYgKHNsaWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwZWVrSW5jcmVtZW50ZXIgPSArISFHbGlkZS5zZXR0aW5ncy5wZWVrO1xuICAgICAgICB2YXIgY2xvbmVDb3VudCA9IHBlclZpZXcgKyBwZWVrSW5jcmVtZW50ZXIgKyBNYXRoLnJvdW5kKHBlclZpZXcgLyAyKTtcbiAgICAgICAgdmFyIGFwcGVuZCA9IHNsaWRlcy5zbGljZSgwLCBjbG9uZUNvdW50KS5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBwcmVwZW5kID0gc2xpZGVzLnNsaWNlKGNsb25lQ291bnQgKiAtMSk7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBNYXRoLm1heChjbG9uaW5nUmF0aW8sIE1hdGguZmxvb3IocGVyVmlldyAvIHNsaWRlcy5sZW5ndGgpKTsgcisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGFwcGVuZFtpXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBjbG9uZS5jbGFzc0xpc3QuYWRkKGNsYXNzZXMuc2xpZGUuY2xvbmUpO1xuICAgICAgICAgICAgaXRlbXMucHVzaChjbG9uZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByZXBlbmQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2Nsb25lID0gcHJlcGVuZFtfaV0uY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgICAgICBfY2xvbmUuY2xhc3NMaXN0LmFkZChjbGFzc2VzLnNsaWRlLmNsb25lKTtcblxuICAgICAgICAgICAgaXRlbXMudW5zaGlmdChfY2xvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBjbG9uZWQgc2xpZGVzIHdpdGggZ2VuZXJhdGVkIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgIHZhciBfQ29tcG9uZW50cyRIdG1sID0gQ29tcG9uZW50cy5IdG1sLFxuICAgICAgICAgIHdyYXBwZXIgPSBfQ29tcG9uZW50cyRIdG1sLndyYXBwZXIsXG4gICAgICAgICAgc2xpZGVzID0gX0NvbXBvbmVudHMkSHRtbC5zbGlkZXM7XG4gICAgICB2YXIgaGFsZiA9IE1hdGguZmxvb3IoaXRlbXMubGVuZ3RoIC8gMik7XG4gICAgICB2YXIgcHJlcGVuZCA9IGl0ZW1zLnNsaWNlKDAsIGhhbGYpLnJldmVyc2UoKTtcbiAgICAgIHZhciBhcHBlbmQgPSBpdGVtcy5zbGljZShoYWxmICogLTEpLnJldmVyc2UoKTtcbiAgICAgIHZhciB3aWR0aCA9IFwiXCIuY29uY2F0KENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCwgXCJweFwiKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChhcHBlbmRbaV0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcmVwZW5kLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgd3JhcHBlci5pbnNlcnRCZWZvcmUocHJlcGVuZFtfaTJdLCBzbGlkZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBpdGVtcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIGl0ZW1zW19pM10uc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjbG9uZWQgc2xpZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIucmVtb3ZlQ2hpbGQoaXRlbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZGVmaW5lKENsb25lcywgJ2dyb3cnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyBhZGRpdGlvbmFsIGRpbWVuc2lvbnMgdmFsdWUgY2F1c2VkIGJ5IGNsb25lcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAoQ29tcG9uZW50cy5TaXplcy5zbGlkZVdpZHRoICsgQ29tcG9uZW50cy5HYXBzLnZhbHVlKSAqIENsb25lcy5pdGVtcy5sZW5ndGg7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEFwcGVuZCBhZGRpdGlvbmFsIHNsaWRlJ3MgY2xvbmVzOlxuICAgKiAtIHdoaWxlIGdsaWRlJ3MgdHlwZSBpcyBgY2Fyb3VzZWxgXG4gICAqL1xuXG4gIEV2ZW50cy5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgIENsb25lcy5yZW1vdmUoKTtcbiAgICBDbG9uZXMubW91bnQoKTtcbiAgICBDbG9uZXMuYXBwZW5kKCk7XG4gIH0pO1xuICAvKipcbiAgICogQXBwZW5kIGFkZGl0aW9uYWwgc2xpZGUncyBjbG9uZXM6XG4gICAqIC0gd2hpbGUgZ2xpZGUncyB0eXBlIGlzIGBjYXJvdXNlbGBcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdidWlsZC5iZWZvcmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKEdsaWRlLmlzVHlwZSgnY2Fyb3VzZWwnKSkge1xuICAgICAgQ2xvbmVzLmFwcGVuZCgpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBSZW1vdmUgY2xvbmVzIEhUTUxFbGVtZW50czpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byBicmluZyBIVE1MIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBDbG9uZXMucmVtb3ZlKCk7XG4gIH0pO1xuICByZXR1cm4gQ2xvbmVzO1xufVxuXG52YXIgRXZlbnRzQmluZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIEV2ZW50c0JpbmRlciBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIEV2ZW50c0JpbmRlcigpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudHNCaW5kZXIpO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgZXZlbnRzIGxpc3RlbmVycyB0byBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBldmVudHNcbiAgICogQHBhcmFtICB7RWxlbWVudHxXaW5kb3d8RG9jdW1lbnR9IGVsXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjbG9zdXJlXG4gICAqIEBwYXJhbSAge0Jvb2xlYW58T2JqZWN0fSBjYXB0dXJlXG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEV2ZW50c0JpbmRlciwgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnRzLCBlbCwgY2xvc3VyZSkge1xuICAgICAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoaXNTdHJpbmcoZXZlbnRzKSkge1xuICAgICAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRzW2ldXSA9IGNsb3N1cmU7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzW2ldLCB0aGlzLmxpc3RlbmVyc1tldmVudHNbaV1dLCBjYXB0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gZXZlbnRzXG4gICAgICogQHBhcmFtICB7RWxlbWVudHxXaW5kb3d8RG9jdW1lbnR9IGVsXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbnxPYmplY3R9IGNhcHR1cmVcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudHMsIGVsKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIGlmIChpc1N0cmluZyhldmVudHMpKSB7XG4gICAgICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50c1tpXSwgdGhpcy5saXN0ZW5lcnNbZXZlbnRzW2ldXSwgY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgY29sbGVjdGVkIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudHNCaW5kZXI7XG59KCk7XG5cbmZ1bmN0aW9uIFJlc2l6ZSAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50c0JpbmRlcn1cbiAgICovXG4gIHZhciBCaW5kZXIgPSBuZXcgRXZlbnRzQmluZGVyKCk7XG4gIHZhciBSZXNpemUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgd2luZG93IGJpbmRpbmdzLlxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMuYmluZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBgcmV6c2l6ZWAgbGlzdGVuZXIgdG8gdGhlIHdpbmRvdy5cbiAgICAgKiBJdCdzIGEgY29zdGx5IGV2ZW50LCBzbyB3ZSBhcmUgZGVib3VuY2luZyBpdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIEJpbmRlci5vbigncmVzaXplJywgd2luZG93LCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIEV2ZW50cy5lbWl0KCdyZXNpemUnKTtcbiAgICAgIH0sIEdsaWRlLnNldHRpbmdzLnRocm90dGxlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgbGlzdGVuZXJzIGZyb20gdGhlIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBCaW5kZXIub2ZmKCdyZXNpemUnLCB3aW5kb3cpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBiaW5kaW5ncyBmcm9tIHdpbmRvdzpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byByZW1vdmUgYWRkZWQgRXZlbnRMaXN0ZW5lclxuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgUmVzaXplLnVuYmluZCgpO1xuICAgIEJpbmRlci5kZXN0cm95KCk7XG4gIH0pO1xuICByZXR1cm4gUmVzaXplO1xufVxuXG52YXIgVkFMSURfRElSRUNUSU9OUyA9IFsnbHRyJywgJ3J0bCddO1xudmFyIEZMSVBFRF9NT1ZFTUVOVFMgPSB7XG4gICc+JzogJzwnLFxuICAnPCc6ICc+JyxcbiAgJz0nOiAnPSdcbn07XG5mdW5jdGlvbiBEaXJlY3Rpb24gKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIERpcmVjdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiBTZXR1cHMgZ2FwIHZhbHVlIGJhc2VkIG9uIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB0aGlzLnZhbHVlID0gR2xpZGUuc2V0dGluZ3MuZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBwYXR0ZXJuIGJhc2VkIG9uIGRpcmVjdGlvbiB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUocGF0dGVybikge1xuICAgICAgdmFyIHRva2VuID0gcGF0dGVybi5zbGljZSgwLCAxKTtcblxuICAgICAgaWYgKHRoaXMuaXMoJ3J0bCcpKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KHRva2VuKS5qb2luKEZMSVBFRF9NT1ZFTUVOVFNbdG9rZW5dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB2YWx1ZSBvZiBkaXJlY3Rpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpczogZnVuY3Rpb24gaXMoZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGRpcmVjdGlvbiBjbGFzcyB0byB0aGUgcm9vdCBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcygpIHtcbiAgICAgIENvbXBvbmVudHMuSHRtbC5yb290LmNsYXNzTGlzdC5hZGQoR2xpZGUuc2V0dGluZ3MuY2xhc3Nlcy5kaXJlY3Rpb25bdGhpcy52YWx1ZV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGRpcmVjdGlvbiBjbGFzcyBmcm9tIHRoZSByb290IEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKCkge1xuICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLmRpcmVjdGlvblt0aGlzLnZhbHVlXSk7XG4gICAgfVxuICB9O1xuICBkZWZpbmUoRGlyZWN0aW9uLCAndmFsdWUnLCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiB0aGUgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEaXJlY3Rpb24uX3Y7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmIChWQUxJRF9ESVJFQ1RJT05TLmluZGV4T2YodmFsdWUpID4gLTEpIHtcbiAgICAgICAgRGlyZWN0aW9uLl92ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdEaXJlY3Rpb24gdmFsdWUgbXVzdCBiZSBgbHRyYCBvciBgcnRsYCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBDbGVhciBkaXJlY3Rpb24gY2xhc3M6XG4gICAqIC0gb24gZGVzdHJveSB0byBicmluZyBIVE1MIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqIC0gb24gdXBkYXRlIHRvIHJlbW92ZSBjbGFzcyBiZWZvcmUgcmVhcHBsaW5nIGJlbGxvd1xuICAgKi9cblxuICBFdmVudHMub24oWydkZXN0cm95JywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgRGlyZWN0aW9uLnJlbW92ZUNsYXNzKCk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3VudCBjb21wb25lbnQ6XG4gICAqIC0gb24gdXBkYXRlIHRvIHJlZmxlY3QgY2hhbmdlcyBpbiBkaXJlY3Rpb24gdmFsdWVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgRGlyZWN0aW9uLm1vdW50KCk7XG4gIH0pO1xuICAvKipcbiAgICogQXBwbHkgZGlyZWN0aW9uIGNsYXNzOlxuICAgKiAtIGJlZm9yZSBidWlsZGluZyB0byBhcHBseSBjbGFzcyBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICogLSBvbiB1cGRhdGluZyB0byByZWFwcGx5IGRpcmVjdGlvbiBjbGFzcyB0aGF0IG1heSBjaGFuZ2VkXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2J1aWxkLmJlZm9yZScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIERpcmVjdGlvbi5hZGRDbGFzcygpO1xuICB9KTtcbiAgcmV0dXJuIERpcmVjdGlvbjtcbn1cblxuLyoqXG4gKiBSZWZsZWN0cyB2YWx1ZSBvZiBnbGlkZSBtb3ZlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IEdsaWRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IENvbXBvbmVudHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gUnRsIChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhlIHBhc3NlZCB0cmFuc2xhdGUgaWYgZ2xpZGUgaXMgaW4gUlRMIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KHRyYW5zbGF0ZSkge1xuICAgICAgaWYgKENvbXBvbmVudHMuRGlyZWN0aW9uLmlzKCdydGwnKSkge1xuICAgICAgICByZXR1cm4gLXRyYW5zbGF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlcyBnbGlkZSBtb3ZlbWVudCB3aXRoIGEgYGdhcGAgc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBHbGlkZVxuICogQHBhcmFtICB7T2JqZWN0fSBDb21wb25lbnRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIEdhcCAoR2xpZGUsIENvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyBwYXNzZWQgdHJhbnNsYXRlIHZhbHVlIHdpdGggbnVtYmVyIGluIHRoZSBgZ2FwYCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KHRyYW5zbGF0ZSkge1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLmZsb29yKHRyYW5zbGF0ZSAvIENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCk7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlICsgQ29tcG9uZW50cy5HYXBzLnZhbHVlICogbXVsdGlwbGllcjtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlcyBnbGlkZSBtb3ZlbWVudCB3aXRoIHdpZHRoIG9mIGFkZGl0aW9uYWwgY2xvbmVzIHdpZHRoLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gR2xpZGVcbiAqIEBwYXJhbSAge09iamVjdH0gQ29tcG9uZW50c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBHcm93IChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEFkZHMgdG8gdGhlIHBhc3NlZCB0cmFuc2xhdGUgd2lkdGggb2YgdGhlIGhhbGYgb2YgY2xvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0cmFuc2xhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkodHJhbnNsYXRlKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlICsgQ29tcG9uZW50cy5DbG9uZXMuZ3JvdyAvIDI7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgZ2xpZGUgbW92ZW1lbnQgd2l0aCBhIGBwZWVrYCBzZXR0aW5ncy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IEdsaWRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IENvbXBvbmVudHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBQZWVraW5nIChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHBhc3NlZCB0cmFuc2xhdGUgdmFsdWUgd2l0aCBhIGBwZWVrYCBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0cmFuc2xhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkodHJhbnNsYXRlKSB7XG4gICAgICBpZiAoR2xpZGUuc2V0dGluZ3MuZm9jdXNBdCA+PSAwKSB7XG4gICAgICAgIHZhciBwZWVrID0gQ29tcG9uZW50cy5QZWVrLnZhbHVlO1xuXG4gICAgICAgIGlmIChpc09iamVjdChwZWVrKSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGUgLSBwZWVrLmJlZm9yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGUgLSBwZWVrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGdsaWRlIG1vdmVtZW50IHdpdGggYSBgZm9jdXNBdGAgc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBHbGlkZVxuICogQHBhcmFtICB7T2JqZWN0fSBDb21wb25lbnRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIEZvY3VzaW5nIChHbGlkZSwgQ29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIHBhc3NlZCB0cmFuc2xhdGUgdmFsdWUgd2l0aCBpbmRleCBpbiB0aGUgYGZvY3VzQXRgIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRyYW5zbGF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBtb2RpZnk6IGZ1bmN0aW9uIG1vZGlmeSh0cmFuc2xhdGUpIHtcbiAgICAgIHZhciBnYXAgPSBDb21wb25lbnRzLkdhcHMudmFsdWU7XG4gICAgICB2YXIgd2lkdGggPSBDb21wb25lbnRzLlNpemVzLndpZHRoO1xuICAgICAgdmFyIGZvY3VzQXQgPSBHbGlkZS5zZXR0aW5ncy5mb2N1c0F0O1xuICAgICAgdmFyIHNsaWRlV2lkdGggPSBDb21wb25lbnRzLlNpemVzLnNsaWRlV2lkdGg7XG5cbiAgICAgIGlmIChmb2N1c0F0ID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlIC0gKHdpZHRoIC8gMiAtIHNsaWRlV2lkdGggLyAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZSAtIHNsaWRlV2lkdGggKiBmb2N1c0F0IC0gZ2FwICogZm9jdXNBdDtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQXBwbGllcyBkaWZmcmVudCB0cmFuc2Zvcm1lcnMgb24gdHJhbnNsYXRlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gR2xpZGVcbiAqIEBwYXJhbSAge09iamVjdH0gQ29tcG9uZW50c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIG11dGF0b3IgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgLyoqXG4gICAqIE1lcmdlIGluc3RhbmNlIHRyYW5zZm9ybWVycyB3aXRoIGNvbGxlY3Rpb24gb2YgZGVmYXVsdCB0cmFuc2Zvcm1lcnMuXG4gICAqIEl0J3MgaW1wb3J0YW50IHRoYXQgdGhlIFJ0bCBjb21wb25lbnQgYmUgbGFzdCBvbiB0aGUgbGlzdCxcbiAgICogc28gaXQgcmVmbGVjdHMgYWxsIHByZXZpb3VzIHRyYW5zZm9ybWF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIFRSQU5TRk9STUVSUyA9IFtHYXAsIEdyb3csIFBlZWtpbmcsIEZvY3VzaW5nXS5jb25jYXQoR2xpZGUuX3QsIFtSdGxdKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBQaXBsaW5lcyB0cmFuc2xhdGUgdmFsdWUgd2l0aCByZWdpc3RlcmVkIHRyYW5zZm9ybWVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKHRyYW5zbGF0ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBUUkFOU0ZPUk1FUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gVFJBTlNGT1JNRVJTW2ldO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKSAmJiBpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKCkubW9kaWZ5KSkge1xuICAgICAgICAgIHRyYW5zbGF0ZSA9IHRyYW5zZm9ybWVyKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpLm1vZGlmeSh0cmFuc2xhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ1RyYW5zZm9ybWVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgbW9kaWZ5KClgIG1ldGhvZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBUcmFuc2xhdGUgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgdmFyIFRyYW5zbGF0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIHRyYW5zbGF0ZSBvbiBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gbXV0YXRvcihHbGlkZSwgQ29tcG9uZW50cykubXV0YXRlKHZhbHVlKTtcbiAgICAgIHZhciB0cmFuc2xhdGUzZCA9IFwidHJhbnNsYXRlM2QoXCIuY29uY2F0KC0xICogdHJhbnNmb3JtLCBcInB4LCAwcHgsIDBweClcIik7XG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS5tb3pUcmFuc2Zvcm0gPSB0cmFuc2xhdGUzZDsgLy8gbmVlZGVkIGZvciBzdXBwb3J0ZWQgRmlyZWZveCAxMC0xNVxuXG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2xhdGUzZDsgLy8gbmVlZGVkIGZvciBzdXBwb3J0ZWQgQ2hyb21lIDEwLTM1LCBTYWZhcmkgNS4xLTgsIGFuZCBPcGVyYSAxNS0yMlxuXG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUzZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB2YWx1ZSBvZiB0cmFuc2xhdGUgZnJvbSBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTdGFydEluZGV4OiBmdW5jdGlvbiBnZXRTdGFydEluZGV4KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IENvbXBvbmVudHMuU2l6ZXMubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gR2xpZGUuaW5kZXg7XG4gICAgICB2YXIgcGVyVmlldyA9IEdsaWRlLnNldHRpbmdzLnBlclZpZXc7XG5cbiAgICAgIGlmIChDb21wb25lbnRzLlJ1bi5pc09mZnNldCgnPicpIHx8IENvbXBvbmVudHMuUnVuLmlzT2Zmc2V0KCd8PicpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggKyAoaW5kZXggLSBwZXJWaWV3KTtcbiAgICAgIH0gLy8gXCJtb2R1bG8gbGVuZ3RoXCIgY29udmVydHMgYW4gaW5kZXggdGhhdCBlcXVhbHMgbGVuZ3RoIHRvIHplcm9cblxuXG4gICAgICByZXR1cm4gKGluZGV4ICsgcGVyVmlldykgJSBsZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRUcmF2ZWxEaXN0YW5jZTogZnVuY3Rpb24gZ2V0VHJhdmVsRGlzdGFuY2UoKSB7XG4gICAgICB2YXIgdHJhdmVsRGlzdGFuY2UgPSBDb21wb25lbnRzLlNpemVzLnNsaWRlV2lkdGggKiBHbGlkZS5zZXR0aW5ncy5wZXJWaWV3O1xuXG4gICAgICBpZiAoQ29tcG9uZW50cy5SdW4uaXNPZmZzZXQoJz4nKSB8fCBDb21wb25lbnRzLlJ1bi5pc09mZnNldCgnfD4nKSkge1xuICAgICAgICAvLyByZXZlcnNlIHRyYXZlbCBkaXN0YW5jZSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIHN1YnRyYWN0IG9wZXJhdGlvbnNcbiAgICAgICAgcmV0dXJuIHRyYXZlbERpc3RhbmNlICogLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmF2ZWxEaXN0YW5jZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgbmV3IHRyYW5zbGF0ZSB2YWx1ZTpcbiAgICogLSBvbiBtb3ZlIHRvIHJlZmxlY3QgaW5kZXggY2hhbmdlXG4gICAqIC0gb24gdXBkYXRpbmcgdmlhIEFQSSB0byByZWZsZWN0IHBvc3NpYmxlIGNoYW5nZXMgaW4gb3B0aW9uc1xuICAgKi9cblxuICBFdmVudHMub24oJ21vdmUnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghR2xpZGUuaXNUeXBlKCdjYXJvdXNlbCcpIHx8ICFDb21wb25lbnRzLlJ1bi5pc09mZnNldCgpKSB7XG4gICAgICByZXR1cm4gVHJhbnNsYXRlLnNldChjb250ZXh0Lm1vdmVtZW50KTtcbiAgICB9XG5cbiAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uYWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgRXZlbnRzLmVtaXQoJ3RyYW5zbGF0ZS5qdW1wJyk7XG4gICAgICBUcmFuc2xhdGUuc2V0KENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCAqIEdsaWRlLmluZGV4KTtcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRXaWR0aCA9IENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCAqIENvbXBvbmVudHMuVHJhbnNsYXRlLmdldFN0YXJ0SW5kZXgoKTtcbiAgICByZXR1cm4gVHJhbnNsYXRlLnNldChzdGFydFdpZHRoIC0gQ29tcG9uZW50cy5UcmFuc2xhdGUuZ2V0VHJhdmVsRGlzdGFuY2UoKSk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3ZlIHRyYW5zbGF0ZTpcbiAgICogLSBvbiBkZXN0cm95aW5nIHRvIGJyaW5nIG1hcmt1cCB0byBpdHMgaW5pdGFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBUcmFuc2xhdGUucmVtb3ZlKCk7XG4gIH0pO1xuICByZXR1cm4gVHJhbnNsYXRlO1xufVxuXG5mdW5jdGlvbiBUcmFuc2l0aW9uIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBIb2xkcyBpbmFjdGl2aXR5IHN0YXR1cyBvZiB0cmFuc2l0aW9uLlxuICAgKiBXaGVuIHRydWUgdHJhbnNpdGlvbiBpcyBub3QgYXBwbGllZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcbiAgdmFyIFRyYW5zaXRpb24gPSB7XG4gICAgLyoqXG4gICAgICogQ29tcG9zZXMgc3RyaW5nIG9mIHRoZSBDU1MgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb21wb3NlOiBmdW5jdGlvbiBjb21wb3NlKHByb3BlcnR5KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcblxuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcm9wZXJ0eSwgXCIgMG1zIFwiKS5jb25jYXQoc2V0dGluZ3MuYW5pbWF0aW9uVGltaW5nRnVuYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcm9wZXJ0eSwgXCIgXCIpLmNvbmNhdCh0aGlzLmR1cmF0aW9uLCBcIm1zIFwiKS5jb25jYXQoc2V0dGluZ3MuYW5pbWF0aW9uVGltaW5nRnVuYyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgdHJhbnNpdGlvbiBvbiBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IHByb3BlcnR5XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3RyYW5zZm9ybSc7XG4gICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS50cmFuc2l0aW9uID0gdGhpcy5jb21wb3NlKHByb3BlcnR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB2YWx1ZSBvZiB0cmFuc2l0aW9uIGZyb20gSFRNTCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUnVucyBjYWxsYmFjayBhZnRlciBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9LCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0KCk7XG4gICAgfVxuICB9O1xuICBkZWZpbmUoVHJhbnNpdGlvbiwgJ2R1cmF0aW9uJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gYmFzZWRcbiAgICAgKiBvbiBjdXJyZW50bHkgcnVubmluZyBhbmltYXRpb24gdHlwZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzO1xuXG4gICAgICBpZiAoR2xpZGUuaXNUeXBlKCdzbGlkZXInKSAmJiBDb21wb25lbnRzLlJ1bi5vZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLnJld2luZER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0dGluZ3MuYW5pbWF0aW9uRHVyYXRpb247XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIFNldCB0cmFuc2l0aW9uIGBzdHlsZWAgdmFsdWU6XG4gICAqIC0gb24gZWFjaCBtb3ZpbmcsIGJlY2F1c2UgaXQgbWF5IGJlIGNsZWFyZWQgYnkgb2Zmc2V0IG1vdmVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgIFRyYW5zaXRpb24uc2V0KCk7XG4gIH0pO1xuICAvKipcbiAgICogRGlzYWJsZSB0cmFuc2l0aW9uOlxuICAgKiAtIGJlZm9yZSBpbml0aWFsIGJ1aWxkIHRvIGF2b2lkIHRyYW5zaXRpb25pbmcgZnJvbSBgMGAgdG8gYHN0YXJ0QXRgIGluZGV4XG4gICAqIC0gd2hpbGUgcmVzaXppbmcgd2luZG93IGFuZCByZWNhbGN1bGF0aW5nIGRpbWVuc2lvbnNcbiAgICogLSBvbiBqdW1waW5nIGZyb20gb2Zmc2V0IHRyYW5zaXRpb24gYXQgc3RhcnQgYW5kIGVuZCBlZGdlcyBpbiBgY2Fyb3VzZWxgIHR5cGVcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnYnVpbGQuYmVmb3JlJywgJ3Jlc2l6ZScsICd0cmFuc2xhdGUuanVtcCddLCBmdW5jdGlvbiAoKSB7XG4gICAgVHJhbnNpdGlvbi5kaXNhYmxlKCk7XG4gIH0pO1xuICAvKipcbiAgICogRW5hYmxlIHRyYW5zaXRpb246XG4gICAqIC0gb24gZWFjaCBydW5uaW5nLCBiZWNhdXNlIGl0IG1heSBiZSBkaXNhYmxlZCBieSBvZmZzZXQgbW92ZVxuICAgKi9cblxuICBFdmVudHMub24oJ3J1bicsIGZ1bmN0aW9uICgpIHtcbiAgICBUcmFuc2l0aW9uLmVuYWJsZSgpO1xuICB9KTtcbiAgLyoqXG4gICAqIFJlbW92ZSB0cmFuc2l0aW9uOlxuICAgKiAtIG9uIGRlc3Ryb3lpbmcgdG8gYnJpbmcgbWFya3VwIHRvIGl0cyBpbml0YWwgc3RhdGVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIFRyYW5zaXRpb24ucmVtb3ZlKCk7XG4gIH0pO1xuICByZXR1cm4gVHJhbnNpdGlvbjtcbn1cblxuLyoqXG4gKiBUZXN0IHZpYSBhIGdldHRlciBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdG8gc2VlXG4gKiBpZiB0aGUgcGFzc2l2ZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4gKi9cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XG59IGNhdGNoIChlKSB7fVxuXG52YXIgc3VwcG9ydHNQYXNzaXZlJDEgPSBzdXBwb3J0c1Bhc3NpdmU7XG5cbnZhciBTVEFSVF9FVkVOVFMgPSBbJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ107XG52YXIgTU9WRV9FVkVOVFMgPSBbJ3RvdWNobW92ZScsICdtb3VzZW1vdmUnXTtcbnZhciBFTkRfRVZFTlRTID0gWyd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcsICdtb3VzZXVwJywgJ21vdXNlbGVhdmUnXTtcbnZhciBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdtb3VzZWxlYXZlJ107XG5mdW5jdGlvbiBTd2lwZSAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICpcbiAgICogQHR5cGUge0V2ZW50c0JpbmRlcn1cbiAgICovXG4gIHZhciBCaW5kZXIgPSBuZXcgRXZlbnRzQmluZGVyKCk7XG4gIHZhciBzd2lwZVNpbiA9IDA7XG4gIHZhciBzd2lwZVN0YXJ0WCA9IDA7XG4gIHZhciBzd2lwZVN0YXJ0WSA9IDA7XG4gIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuICB2YXIgY2FwdHVyZSA9IHN1cHBvcnRzUGFzc2l2ZSQxID8ge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSA6IGZhbHNlO1xuICB2YXIgU3dpcGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgc3dpcGUgYmluZGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMuYmluZFN3aXBlU3RhcnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgYHN3aXBlc3RhcnRgIGV2ZW50LiBDYWxjdWxhdGVzIGVudHJ5IHBvaW50cyBvZiB0aGUgdXNlcidzIHRhcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGV2ZW50KSB7XG4gICAgICBpZiAoIWRpc2FibGVkICYmICFHbGlkZS5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgdmFyIHN3aXBlID0gdGhpcy50b3VjaGVzKGV2ZW50KTtcbiAgICAgICAgc3dpcGVTaW4gPSBudWxsO1xuICAgICAgICBzd2lwZVN0YXJ0WCA9IHRvSW50KHN3aXBlLnBhZ2VYKTtcbiAgICAgICAgc3dpcGVTdGFydFkgPSB0b0ludChzd2lwZS5wYWdlWSk7XG4gICAgICAgIHRoaXMuYmluZFN3aXBlTW92ZSgpO1xuICAgICAgICB0aGlzLmJpbmRTd2lwZUVuZCgpO1xuICAgICAgICBFdmVudHMuZW1pdCgnc3dpcGUuc3RhcnQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgYHN3aXBlbW92ZWAgZXZlbnQuIENhbGN1bGF0ZXMgdXNlcidzIHRhcCBhbmdsZSBhbmQgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAoIUdsaWRlLmRpc2FibGVkKSB7XG4gICAgICAgIHZhciBfR2xpZGUkc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncyxcbiAgICAgICAgICAgIHRvdWNoQW5nbGUgPSBfR2xpZGUkc2V0dGluZ3MudG91Y2hBbmdsZSxcbiAgICAgICAgICAgIHRvdWNoUmF0aW8gPSBfR2xpZGUkc2V0dGluZ3MudG91Y2hSYXRpbyxcbiAgICAgICAgICAgIGNsYXNzZXMgPSBfR2xpZGUkc2V0dGluZ3MuY2xhc3NlcztcbiAgICAgICAgdmFyIHN3aXBlID0gdGhpcy50b3VjaGVzKGV2ZW50KTtcbiAgICAgICAgdmFyIHN1YkV4U3ggPSB0b0ludChzd2lwZS5wYWdlWCkgLSBzd2lwZVN0YXJ0WDtcbiAgICAgICAgdmFyIHN1YkV5U3kgPSB0b0ludChzd2lwZS5wYWdlWSkgLSBzd2lwZVN0YXJ0WTtcbiAgICAgICAgdmFyIHBvd0VYID0gTWF0aC5hYnMoc3ViRXhTeCA8PCAyKTtcbiAgICAgICAgdmFyIHBvd0VZID0gTWF0aC5hYnMoc3ViRXlTeSA8PCAyKTtcbiAgICAgICAgdmFyIHN3aXBlSHlwb3RlbnVzZSA9IE1hdGguc3FydChwb3dFWCArIHBvd0VZKTtcbiAgICAgICAgdmFyIHN3aXBlQ2F0aGV0dXMgPSBNYXRoLnNxcnQocG93RVkpO1xuICAgICAgICBzd2lwZVNpbiA9IE1hdGguYXNpbihzd2lwZUNhdGhldHVzIC8gc3dpcGVIeXBvdGVudXNlKTtcblxuICAgICAgICBpZiAoc3dpcGVTaW4gKiAxODAgLyBNYXRoLlBJIDwgdG91Y2hBbmdsZSkge1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIENvbXBvbmVudHMuTW92ZS5tYWtlKHN1YkV4U3ggKiB0b0Zsb2F0KHRvdWNoUmF0aW8pKTtcbiAgICAgICAgICBDb21wb25lbnRzLkh0bWwucm9vdC5jbGFzc0xpc3QuYWRkKGNsYXNzZXMuZHJhZ2dpbmcpO1xuICAgICAgICAgIEV2ZW50cy5lbWl0KCdzd2lwZS5tb3ZlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIGBzd2lwZWVuZGAgZXZlbnQuIEZpbml0aWFsaXplcyB1c2VyJ3MgdGFwIGFuZCBkZWNpZGVzIGFib3V0IGdsaWRlIG1vdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGVuZDogZnVuY3Rpb24gZW5kKGV2ZW50KSB7XG4gICAgICBpZiAoIUdsaWRlLmRpc2FibGVkKSB7XG4gICAgICAgIHZhciBfR2xpZGUkc2V0dGluZ3MyID0gR2xpZGUuc2V0dGluZ3MsXG4gICAgICAgICAgICBwZXJTd2lwZSA9IF9HbGlkZSRzZXR0aW5nczIucGVyU3dpcGUsXG4gICAgICAgICAgICB0b3VjaEFuZ2xlID0gX0dsaWRlJHNldHRpbmdzMi50b3VjaEFuZ2xlLFxuICAgICAgICAgICAgY2xhc3NlcyA9IF9HbGlkZSRzZXR0aW5nczIuY2xhc3NlcztcbiAgICAgICAgdmFyIHN3aXBlID0gdGhpcy50b3VjaGVzKGV2ZW50KTtcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkKGV2ZW50KTtcbiAgICAgICAgdmFyIHN3aXBlRGlzdGFuY2UgPSBzd2lwZS5wYWdlWCAtIHN3aXBlU3RhcnRYO1xuICAgICAgICB2YXIgc3dpcGVEZWcgPSBzd2lwZVNpbiAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XG5cbiAgICAgICAgaWYgKHN3aXBlRGlzdGFuY2UgPiB0aHJlc2hvbGQgJiYgc3dpcGVEZWcgPCB0b3VjaEFuZ2xlKSB7XG4gICAgICAgICAgQ29tcG9uZW50cy5SdW4ubWFrZShDb21wb25lbnRzLkRpcmVjdGlvbi5yZXNvbHZlKFwiXCIuY29uY2F0KHBlclN3aXBlLCBcIjxcIikpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzd2lwZURpc3RhbmNlIDwgLXRocmVzaG9sZCAmJiBzd2lwZURlZyA8IHRvdWNoQW5nbGUpIHtcbiAgICAgICAgICBDb21wb25lbnRzLlJ1bi5tYWtlKENvbXBvbmVudHMuRGlyZWN0aW9uLnJlc29sdmUoXCJcIi5jb25jYXQocGVyU3dpcGUsIFwiPlwiKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdoaWxlIHN3aXBlIGRvbid0IHJlYWNoIGRpc3RhbmNlIGFwcGx5IHByZXZpb3VzIHRyYW5zZm9ybS5cbiAgICAgICAgICBDb21wb25lbnRzLk1vdmUubWFrZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzLmRyYWdnaW5nKTtcbiAgICAgICAgdGhpcy51bmJpbmRTd2lwZU1vdmUoKTtcbiAgICAgICAgdGhpcy51bmJpbmRTd2lwZUVuZCgpO1xuICAgICAgICBFdmVudHMuZW1pdCgnc3dpcGUuZW5kJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIHN3aXBlJ3Mgc3RhcnRpbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGJpbmRTd2lwZVN0YXJ0OiBmdW5jdGlvbiBiaW5kU3dpcGVTdGFydCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBfR2xpZGUkc2V0dGluZ3MzID0gR2xpZGUuc2V0dGluZ3MsXG4gICAgICAgICAgc3dpcGVUaHJlc2hvbGQgPSBfR2xpZGUkc2V0dGluZ3MzLnN3aXBlVGhyZXNob2xkLFxuICAgICAgICAgIGRyYWdUaHJlc2hvbGQgPSBfR2xpZGUkc2V0dGluZ3MzLmRyYWdUaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChzd2lwZVRocmVzaG9sZCkge1xuICAgICAgICBCaW5kZXIub24oU1RBUlRfRVZFTlRTWzBdLCBDb21wb25lbnRzLkh0bWwud3JhcHBlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgX3RoaXMuc3RhcnQoZXZlbnQpO1xuICAgICAgICB9LCBjYXB0dXJlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgQmluZGVyLm9uKFNUQVJUX0VWRU5UU1sxXSwgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSwgY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgc3dpcGUncyBzdGFydGluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kU3dpcGVTdGFydDogZnVuY3Rpb24gdW5iaW5kU3dpcGVTdGFydCgpIHtcbiAgICAgIEJpbmRlci5vZmYoU1RBUlRfRVZFTlRTWzBdLCBDb21wb25lbnRzLkh0bWwud3JhcHBlciwgY2FwdHVyZSk7XG4gICAgICBCaW5kZXIub2ZmKFNUQVJUX0VWRU5UU1sxXSwgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGNhcHR1cmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBzd2lwZSdzIG1vdmluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZFN3aXBlTW92ZTogZnVuY3Rpb24gYmluZFN3aXBlTW92ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBCaW5kZXIub24oTU9WRV9FVkVOVFMsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCB0aHJvdHRsZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMyLm1vdmUoZXZlbnQpO1xuICAgICAgfSwgR2xpZGUuc2V0dGluZ3MudGhyb3R0bGUpLCBjYXB0dXJlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kcyBzd2lwZSdzIG1vdmluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kU3dpcGVNb3ZlOiBmdW5jdGlvbiB1bmJpbmRTd2lwZU1vdmUoKSB7XG4gICAgICBCaW5kZXIub2ZmKE1PVkVfRVZFTlRTLCBDb21wb25lbnRzLkh0bWwud3JhcHBlciwgY2FwdHVyZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIHN3aXBlJ3MgZW5kaW5nIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBiaW5kU3dpcGVFbmQ6IGZ1bmN0aW9uIGJpbmRTd2lwZUVuZCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBCaW5kZXIub24oRU5EX0VWRU5UUywgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuZW5kKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIHN3aXBlJ3MgZW5kaW5nIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICB1bmJpbmRTd2lwZUVuZDogZnVuY3Rpb24gdW5iaW5kU3dpcGVFbmQoKSB7XG4gICAgICBCaW5kZXIub2ZmKEVORF9FVkVOVFMsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBldmVudCB0b3VjaGVzIHBvaW50cyBhY2NvcnRpbmcgdG8gZGlmZmVyZW50IHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgdG91Y2hlczogZnVuY3Rpb24gdG91Y2hlcyhldmVudCkge1xuICAgICAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKGV2ZW50LnR5cGUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQudG91Y2hlc1swXSB8fCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiBtaW5pbXVtIHN3aXBlIGRpc3RhbmNlIHNldHRpbmdzIGJhc2VkIG9uIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhyZXNob2xkOiBmdW5jdGlvbiB0aHJlc2hvbGQoZXZlbnQpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzO1xuXG4gICAgICBpZiAoTU9VU0VfRVZFTlRTLmluZGV4T2YoZXZlbnQudHlwZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MuZHJhZ1RocmVzaG9sZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldHRpbmdzLnN3aXBlVGhyZXNob2xkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHN3aXBlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c2VsZn1cbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uZW5hYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgc3dpcGUgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzZWxmfVxuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQWRkIGNvbXBvbmVudCBjbGFzczpcbiAgICogLSBhZnRlciBpbml0aWFsIGJ1aWxkaW5nXG4gICAqL1xuXG4gIEV2ZW50cy5vbignYnVpbGQuYWZ0ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LmFkZChHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLnN3aXBlYWJsZSk7XG4gIH0pO1xuICAvKipcbiAgICogUmVtb3ZlIHN3aXBpbmcgYmluZGluZ3M6XG4gICAqIC0gb24gZGVzdHJveWluZywgdG8gcmVtb3ZlIGFkZGVkIEV2ZW50TGlzdGVuZXJzXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBTd2lwZS51bmJpbmRTd2lwZVN0YXJ0KCk7XG4gICAgU3dpcGUudW5iaW5kU3dpcGVNb3ZlKCk7XG4gICAgU3dpcGUudW5iaW5kU3dpcGVFbmQoKTtcbiAgICBCaW5kZXIuZGVzdHJveSgpO1xuICB9KTtcbiAgcmV0dXJuIFN3aXBlO1xufVxuXG5mdW5jdGlvbiBJbWFnZXMgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIHRoZSBiaW5kZXIgZm9yIERPTSBFdmVudHMuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAqL1xuICB2YXIgQmluZGVyID0gbmV3IEV2ZW50c0JpbmRlcigpO1xuICB2YXIgSW1hZ2VzID0ge1xuICAgIC8qKlxuICAgICAqIEJpbmRzIGxpc3RlbmVyIHRvIGdsaWRlIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMuYmluZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBgZHJhZ3N0YXJ0YCBldmVudCBvbiB3cmFwcGVyIHRvIHByZXZlbnQgZHJhZ2dpbmcgaW1hZ2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgQmluZGVyLm9uKCdkcmFnc3RhcnQnLCBDb21wb25lbnRzLkh0bWwud3JhcHBlciwgdGhpcy5kcmFnc3RhcnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIGBkcmFnc3RhcnRgIGV2ZW50IG9uIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgQmluZGVyLm9mZignZHJhZ3N0YXJ0JywgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyLiBQcmV2ZW50cyBkcmFnZ2luZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiBkcmFnc3RhcnQoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmVtb3ZlIGJpbmRpbmdzIGZyb20gaW1hZ2VzOlxuICAgKiAtIG9uIGRlc3Ryb3lpbmcsIHRvIHJlbW92ZSBhZGRlZCBFdmVudExpc3RlbmVyc1xuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgSW1hZ2VzLnVuYmluZCgpO1xuICAgIEJpbmRlci5kZXN0cm95KCk7XG4gIH0pO1xuICByZXR1cm4gSW1hZ2VzO1xufVxuXG5mdW5jdGlvbiBBbmNob3JzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgKi9cbiAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcbiAgLyoqXG4gICAqIEhvbGRzIGRldGFjaGluZyBzdGF0dXMgb2YgYW5jaG9ycy5cbiAgICogUHJldmVudHMgZGV0YWNoaW5nIG9mIGFscmVhZHkgZGV0YWNoZWQgYW5jaG9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuXG4gIHZhciBkZXRhY2hlZCA9IGZhbHNlO1xuICAvKipcbiAgICogSG9sZHMgcHJldmVudGluZyBzdGF0dXMgb2YgYW5jaG9ycy5cbiAgICogSWYgYHRydWVgIHJlZGlyZWN0aW9uIGFmdGVyIGNsaWNrIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICB2YXIgcHJldmVudGVkID0gZmFsc2U7XG4gIHZhciBBbmNob3JzID0ge1xuICAgIC8qKlxuICAgICAqIFNldHVwcyBhIGluaXRpYWwgc3RhdGUgb2YgYW5jaG9ycyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEhvbGRzIGNvbGxlY3Rpb24gb2YgYW5jaG9ycyBlbGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxDb2xsZWN0aW9ufVxuICAgICAgICovXG4gICAgICB0aGlzLl9hID0gQ29tcG9uZW50cy5IdG1sLndyYXBwZXIucXVlcnlTZWxlY3RvckFsbCgnYScpO1xuICAgICAgdGhpcy5iaW5kKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGV2ZW50cyB0byBhbmNob3JzIGluc2lkZSBhIHRyYWNrLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgQmluZGVyLm9uKCdjbGljaycsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCB0aGlzLmNsaWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kcyBldmVudHMgYXR0YWNoZWQgdG8gYW5jaG9ycyBpbnNpZGUgYSB0cmFjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBCaW5kZXIub2ZmKCdjbGljaycsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgY2xpY2sgZXZlbnQuIFByZXZlbnRzIGNsaWNrcyB3aGVuIGdsaWRlIGlzIGluIGBwcmV2ZW50YCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICAgIGlmIChwcmV2ZW50ZWQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGFjaGVzIGFuY2hvcnMgY2xpY2sgZXZlbnQgaW5zaWRlIGdsaWRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c2VsZn1cbiAgICAgKi9cbiAgICBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHByZXZlbnRlZCA9IHRydWU7XG5cbiAgICAgIGlmICghZGV0YWNoZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5pdGVtc1tpXS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGFjaGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuY2hvcnMgY2xpY2sgZXZlbnRzIGluc2lkZSBnbGlkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3NlbGZ9XG4gICAgICovXG4gICAgYXR0YWNoOiBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgICBwcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGRldGFjaGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuaXRlbXNbaV0uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGFjaGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lKEFuY2hvcnMsICdpdGVtcycsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbGxlY3Rpb24gb2YgdGhlIGFycm93cyBIVE1MIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBBbmNob3JzLl9hO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBEZXRhY2ggYW5jaG9ycyBpbnNpZGUgc2xpZGVzOlxuICAgKiAtIG9uIHN3aXBpbmcsIHNvIHRoZXkgd29uJ3QgcmVkaXJlY3QgdG8gaXRzIGBocmVmYCBhdHRyaWJ1dGVzXG4gICAqL1xuXG4gIEV2ZW50cy5vbignc3dpcGUubW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBBbmNob3JzLmRldGFjaCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIEF0dGFjaCBhbmNob3JzIGluc2lkZSBzbGlkZXM6XG4gICAqIC0gYWZ0ZXIgc3dpcGluZyBhbmQgdHJhbnNpdGlvbnMgZW5kcywgc28gdGhleSBjYW4gcmVkaXJlY3QgYWZ0ZXIgY2xpY2sgYWdhaW5cbiAgICovXG5cbiAgRXZlbnRzLm9uKCdzd2lwZS5lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgQ29tcG9uZW50cy5UcmFuc2l0aW9uLmFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIEFuY2hvcnMuYXR0YWNoKCk7XG4gICAgfSk7XG4gIH0pO1xuICAvKipcbiAgICogVW5iaW5kIGFuY2hvcnMgaW5zaWRlIHNsaWRlczpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byBicmluZyBhbmNob3JzIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBBbmNob3JzLmF0dGFjaCgpO1xuICAgIEFuY2hvcnMudW5iaW5kKCk7XG4gICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgfSk7XG4gIHJldHVybiBBbmNob3JzO1xufVxuXG52YXIgTkFWX1NFTEVDVE9SID0gJ1tkYXRhLWdsaWRlLWVsPVwiY29udHJvbHNbbmF2XVwiXSc7XG52YXIgQ09OVFJPTFNfU0VMRUNUT1IgPSAnW2RhdGEtZ2xpZGUtZWxePVwiY29udHJvbHNcIl0nO1xudmFyIFBSRVZJT1VTX0NPTlRST0xTX1NFTEVDVE9SID0gXCJcIi5jb25jYXQoQ09OVFJPTFNfU0VMRUNUT1IsIFwiIFtkYXRhLWdsaWRlLWRpcio9XFxcIjxcXFwiXVwiKTtcbnZhciBORVhUX0NPTlRST0xTX1NFTEVDVE9SID0gXCJcIi5jb25jYXQoQ09OVFJPTFNfU0VMRUNUT1IsIFwiIFtkYXRhLWdsaWRlLWRpcio9XFxcIj5cXFwiXVwiKTtcbmZ1bmN0aW9uIENvbnRyb2xzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgKi9cbiAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcbiAgdmFyIGNhcHR1cmUgPSBzdXBwb3J0c1Bhc3NpdmUkMSA/IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0gOiBmYWxzZTtcbiAgdmFyIENvbnRyb2xzID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRzIGFycm93cy4gQmluZHMgZXZlbnRzIGxpc3RlbmVyc1xuICAgICAqIHRvIHRoZSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgLyoqXG4gICAgICAgKiBDb2xsZWN0aW9uIG9mIG5hdmlnYXRpb24gSFRNTCBlbGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxDb2xsZWN0aW9ufVxuICAgICAgICovXG4gICAgICB0aGlzLl9uID0gQ29tcG9uZW50cy5IdG1sLnJvb3QucXVlcnlTZWxlY3RvckFsbChOQVZfU0VMRUNUT1IpO1xuICAgICAgLyoqXG4gICAgICAgKiBDb2xsZWN0aW9uIG9mIGNvbnRyb2xzIEhUTUwgZWxlbWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtIVE1MQ29sbGVjdGlvbn1cbiAgICAgICAqL1xuXG4gICAgICB0aGlzLl9jID0gQ29tcG9uZW50cy5IdG1sLnJvb3QucXVlcnlTZWxlY3RvckFsbChDT05UUk9MU19TRUxFQ1RPUik7XG4gICAgICAvKipcbiAgICAgICAqIENvbGxlY3Rpb24gb2YgYXJyb3cgY29udHJvbCBIVE1MIGVsZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG5cbiAgICAgIHRoaXMuX2Fycm93Q29udHJvbHMgPSB7XG4gICAgICAgIHByZXZpb3VzOiBDb21wb25lbnRzLkh0bWwucm9vdC5xdWVyeVNlbGVjdG9yQWxsKFBSRVZJT1VTX0NPTlRST0xTX1NFTEVDVE9SKSxcbiAgICAgICAgbmV4dDogQ29tcG9uZW50cy5IdG1sLnJvb3QucXVlcnlTZWxlY3RvckFsbChORVhUX0NPTlRST0xTX1NFTEVDVE9SKVxuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkQmluZGluZ3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhY3RpdmUgY2xhc3MgdG8gY3VycmVudCBzbGlkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2V0QWN0aXZlOiBmdW5jdGlvbiBzZXRBY3RpdmUoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcyh0aGlzLl9uW2ldLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhY3RpdmUgY2xhc3MgdG8gY3VycmVudCBzbGlkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlQWN0aXZlOiBmdW5jdGlvbiByZW1vdmVBY3RpdmUoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcyh0aGlzLl9uW2ldLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhY3RpdmUgY2xhc3Mgb24gaXRlbXMgaW5zaWRlIG5hdmlnYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gY29udHJvbHNcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhjb250cm9scykge1xuICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG4gICAgICB2YXIgaXRlbSA9IGNvbnRyb2xzW0dsaWRlLmluZGV4XTtcblxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKHNldHRpbmdzLmNsYXNzZXMubmF2LmFjdGl2ZSk7XG4gICAgICBzaWJsaW5ncyhpdGVtKS5mb3JFYWNoKGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgIHNpYmxpbmcuY2xhc3NMaXN0LnJlbW92ZShzZXR0aW5ncy5jbGFzc2VzLm5hdi5hY3RpdmUpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWN0aXZlIGNsYXNzIGZyb20gYWN0aXZlIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gY29udHJvbHNcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhjb250cm9scykge1xuICAgICAgdmFyIGl0ZW0gPSBjb250cm9sc1tHbGlkZS5pbmRleF07XG4gICAgICBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0uY2xhc3NMaXN0LnJlbW92ZShHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLm5hdi5hY3RpdmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzLCByZW1vdmVzIG9yIGFkZHMgYEdsaWRlLnNldHRpbmdzLmNsYXNzZXMuZGlzYWJsZWRBcnJvd2AgY2xhc3Mgb24gdGhlIGNvbnRyb2wgYXJyb3dzXG4gICAgICovXG4gICAgc2V0QXJyb3dTdGF0ZTogZnVuY3Rpb24gc2V0QXJyb3dTdGF0ZSgpIHtcbiAgICAgIGlmIChHbGlkZS5zZXR0aW5ncy5yZXdpbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dCA9IENvbnRyb2xzLl9hcnJvd0NvbnRyb2xzLm5leHQ7XG4gICAgICB2YXIgcHJldmlvdXMgPSBDb250cm9scy5fYXJyb3dDb250cm9scy5wcmV2aW91cztcbiAgICAgIHRoaXMucmVzZXRBcnJvd1N0YXRlKG5leHQsIHByZXZpb3VzKTtcblxuICAgICAgaWYgKEdsaWRlLmluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZUFycm93KHByZXZpb3VzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEdsaWRlLmluZGV4ID09PSBDb21wb25lbnRzLlJ1bi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlQXJyb3cobmV4dCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYEdsaWRlLnNldHRpbmdzLmNsYXNzZXMuZGlzYWJsZWRBcnJvd2AgZnJvbSBnaXZlbiBOb2RlTGlzdCBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlTGlzdFtdfSBsaXN0c1xuICAgICAqL1xuICAgIHJlc2V0QXJyb3dTdGF0ZTogZnVuY3Rpb24gcmVzZXRBcnJvd1N0YXRlKCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBsaXN0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgbGlzdHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGxpc3RzLmZvckVhY2goZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgdG9BcnJheShsaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHNldHRpbmdzLmNsYXNzZXMuYXJyb3cuZGlzYWJsZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGBHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLmRpc2FibGVkQXJyb3dgIHRvIGdpdmVuIE5vZGVMaXN0IGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGVMaXN0W119IGxpc3RzXG4gICAgICovXG4gICAgZGlzYWJsZUFycm93OiBmdW5jdGlvbiBkaXNhYmxlQXJyb3coKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBsaXN0cyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBsaXN0c1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBsaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHRvQXJyYXkobGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChzZXR0aW5ncy5jbGFzc2VzLmFycm93LmRpc2FibGVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBoYW5kbGVzIHRvIHRoZSBlYWNoIGdyb3VwIG9mIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBhZGRCaW5kaW5nczogZnVuY3Rpb24gYWRkQmluZGluZ3MoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5iaW5kKHRoaXMuX2NbaV0uY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGhhbmRsZXMgZnJvbSB0aGUgZWFjaCBncm91cCBvZiBjb250cm9scy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlQmluZGluZ3M6IGZ1bmN0aW9uIHJlbW92ZUJpbmRpbmdzKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudW5iaW5kKHRoaXMuX2NbaV0uY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBldmVudHMgdG8gYXJyb3dzIEhUTUwgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxDb2xsZWN0aW9ufSBlbGVtZW50c1xuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24gYmluZChlbGVtZW50cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBCaW5kZXIub24oJ2NsaWNrJywgZWxlbWVudHNbaV0sIHRoaXMuY2xpY2spO1xuICAgICAgICBCaW5kZXIub24oJ3RvdWNoc3RhcnQnLCBlbGVtZW50c1tpXSwgdGhpcy5jbGljaywgY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgZXZlbnRzIGJpbmRlZCB0byB0aGUgYXJyb3dzIEhUTUwgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxDb2xsZWN0aW9ufSBlbGVtZW50c1xuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWxlbWVudHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQmluZGVyLm9mZihbJ2NsaWNrJywgJ3RvdWNoc3RhcnQnXSwgZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGBjbGlja2AgZXZlbnQgb24gdGhlIGFycm93cyBIVE1MIGVsZW1lbnRzLlxuICAgICAqIE1vdmVzIHNsaWRlciBpbiBkaXJlY3Rpb24gZ2l2ZW4gdmlhIHRoZVxuICAgICAqIGBkYXRhLWdsaWRlLWRpcmAgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICAgIGlmICghc3VwcG9ydHNQYXNzaXZlJDEgJiYgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1nbGlkZS1kaXInKTtcbiAgICAgIENvbXBvbmVudHMuUnVuLm1ha2UoQ29tcG9uZW50cy5EaXJlY3Rpb24ucmVzb2x2ZShkaXJlY3Rpb24pKTtcbiAgICB9XG4gIH07XG4gIGRlZmluZShDb250cm9scywgJ2l0ZW1zJywge1xuICAgIC8qKlxuICAgICAqIEdldHMgY29sbGVjdGlvbiBvZiB0aGUgY29udHJvbHMgSFRNTCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gQ29udHJvbHMuX2M7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIFN3YXAgYWN0aXZlIGNsYXNzIG9mIGN1cnJlbnQgbmF2aWdhdGlvbiBpdGVtOlxuICAgKiAtIGFmdGVyIG1vdW50aW5nIHRvIHNldCBpdCB0byBpbml0aWFsIGluZGV4XG4gICAqIC0gYWZ0ZXIgZWFjaCBtb3ZlIHRvIHRoZSBuZXcgaW5kZXhcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnbW91bnQuYWZ0ZXInLCAnbW92ZS5hZnRlciddLCBmdW5jdGlvbiAoKSB7XG4gICAgQ29udHJvbHMuc2V0QWN0aXZlKCk7XG4gIH0pO1xuICAvKipcbiAgICogQWRkIG9yIHJlbW92ZSBkaXNhYmxlZCBjbGFzcyBvZiBhcnJvdyBlbGVtZW50c1xuICAgKi9cblxuICBFdmVudHMub24oWydtb3VudC5hZnRlcicsICdydW4nXSwgZnVuY3Rpb24gKCkge1xuICAgIENvbnRyb2xzLnNldEFycm93U3RhdGUoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBSZW1vdmUgYmluZGluZ3MgYW5kIEhUTUwgQ2xhc3NlczpcbiAgICogLSBvbiBkZXN0cm95aW5nLCB0byBicmluZyBtYXJrdXAgdG8gaXRzIGluaXRpYWwgc3RhdGVcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIENvbnRyb2xzLnJlbW92ZUJpbmRpbmdzKCk7XG4gICAgQ29udHJvbHMucmVtb3ZlQWN0aXZlKCk7XG4gICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgfSk7XG4gIHJldHVybiBDb250cm9scztcbn1cblxuZnVuY3Rpb24gS2V5Ym9hcmQgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIHRoZSBiaW5kZXIgZm9yIERPTSBFdmVudHMuXG4gICAqXG4gICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAqL1xuICB2YXIgQmluZGVyID0gbmV3IEV2ZW50c0JpbmRlcigpO1xuICB2YXIgS2V5Ym9hcmQgPSB7XG4gICAgLyoqXG4gICAgICogQmluZHMga2V5Ym9hcmQgZXZlbnRzIG9uIGNvbXBvbmVudCBtb3VudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgaWYgKEdsaWRlLnNldHRpbmdzLmtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGtleWJvYXJkIHByZXNzIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIEJpbmRlci5vbigna2V5dXAnLCBkb2N1bWVudCwgdGhpcy5wcmVzcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMga2V5Ym9hcmQgcHJlc3MgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIEJpbmRlci5vZmYoJ2tleXVwJywgZG9jdW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGtleWJvYXJkJ3MgYXJyb3dzIHByZXNzIGFuZCBtb3ZpbmcgZ2xpZGUgZm93YXJkIGFuZCBiYWNrd2FyZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHByZXNzOiBmdW5jdGlvbiBwcmVzcyhldmVudCkge1xuICAgICAgdmFyIHBlclN3aXBlID0gR2xpZGUuc2V0dGluZ3MucGVyU3dpcGU7XG4gICAgICB2YXIgYXJyb3dTeW1ib2xzID0ge1xuICAgICAgICBBcnJvd1JpZ2h0OiAnPicsXG4gICAgICAgIEFycm93TGVmdDogJzwnXG4gICAgICB9O1xuXG4gICAgICBpZiAoWydBcnJvd1JpZ2h0JywgJ0Fycm93TGVmdCddLmluY2x1ZGVzKGV2ZW50LmNvZGUpKSB7XG4gICAgICAgIENvbXBvbmVudHMuUnVuLm1ha2UoQ29tcG9uZW50cy5EaXJlY3Rpb24ucmVzb2x2ZShcIlwiLmNvbmNhdChwZXJTd2lwZSkuY29uY2F0KGFycm93U3ltYm9sc1tldmVudC5jb2RlXSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmUgYmluZGluZ3MgZnJvbSBrZXlib2FyZDpcbiAgICogLSBvbiBkZXN0cm95aW5nIHRvIHJlbW92ZSBhZGRlZCBldmVudHNcbiAgICogLSBvbiB1cGRhdGluZyB0byByZW1vdmUgZXZlbnRzIGJlZm9yZSByZW1vdW50aW5nXG4gICAqL1xuXG4gIEV2ZW50cy5vbihbJ2Rlc3Ryb3knLCAndXBkYXRlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICBLZXlib2FyZC51bmJpbmQoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBSZW1vdW50IGNvbXBvbmVudFxuICAgKiAtIG9uIHVwZGF0aW5nIHRvIHJlZmxlY3QgcG90ZW50aWFsIGNoYW5nZXMgaW4gc2V0dGluZ3NcbiAgICovXG5cbiAgRXZlbnRzLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgS2V5Ym9hcmQubW91bnQoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBEZXN0cm95IGJpbmRlcjpcbiAgICogLSBvbiBkZXN0cm95aW5nIHRvIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICovXG5cbiAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIEJpbmRlci5kZXN0cm95KCk7XG4gIH0pO1xuICByZXR1cm4gS2V5Ym9hcmQ7XG59XG5cbmZ1bmN0aW9uIEF1dG9wbGF5IChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgKi9cbiAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcbiAgdmFyIEF1dG9wbGF5ID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGF1dG9wbGF5aW5nIGFuZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG5cbiAgICAgIGlmIChHbGlkZS5zZXR0aW5ncy5ob3ZlcnBhdXNlKSB7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGF1dG9wbGF5aW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuX2UgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBhdXRvcGxheWluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB0aGlzLl9lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhdXRvcGxheWluZyBpbiBjb25maWd1cmVkIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gZm9yY2UgUnVuIGF1dG9wbGF5aW5nIHdpdGggcGFzc2VkIGludGVydmFsIHJlZ2FyZGxlc3Mgb2YgYGF1dG9wbGF5YCBzZXR0aW5nc1xuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLl9lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbmFibGUoKTtcblxuICAgICAgaWYgKEdsaWRlLnNldHRpbmdzLmF1dG9wbGF5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLl9pKSkge1xuICAgICAgICAgIHRoaXMuX2kgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgICAgIENvbXBvbmVudHMuUnVuLm1ha2UoJz4nKTtcblxuICAgICAgICAgICAgX3RoaXMuc3RhcnQoKTtcblxuICAgICAgICAgICAgRXZlbnRzLmVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgICAgfSwgdGhpcy50aW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhdXRvcnVubmluZyBvZiB0aGUgZ2xpZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLl9pID0gY2xlYXJJbnRlcnZhbCh0aGlzLl9pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYXV0b3BsYXlpbmcgd2hpbGUgbW91c2UgaXMgb3ZlciBnbGlkZSdzIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgQmluZGVyLm9uKCdtb3VzZW92ZXInLCBDb21wb25lbnRzLkh0bWwucm9vdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLl9lKSB7XG4gICAgICAgICAgX3RoaXMyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBCaW5kZXIub24oJ21vdXNlb3V0JywgQ29tcG9uZW50cy5IdG1sLnJvb3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5fZSkge1xuICAgICAgICAgIF90aGlzMi5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kIG1vdXNlb3ZlciBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgKi9cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIEJpbmRlci5vZmYoWydtb3VzZW92ZXInLCAnbW91c2VvdXQnXSwgQ29tcG9uZW50cy5IdG1sLnJvb3QpO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lKEF1dG9wbGF5LCAndGltZScsIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRpbWUgcGVyaW9kIHZhbHVlIGZvciB0aGUgYXV0b3BsYXkgaW50ZXJ2YWwuIFByaW9yaXRpemVzXG4gICAgICogdGltZXMgaW4gYGRhdGEtZ2xpZGUtYXV0b3BsYXlgIGF0dHJ1YnV0ZXMgb3ZlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGF1dG9wbGF5ID0gQ29tcG9uZW50cy5IdG1sLnNsaWRlc1tHbGlkZS5pbmRleF0uZ2V0QXR0cmlidXRlKCdkYXRhLWdsaWRlLWF1dG9wbGF5Jyk7XG5cbiAgICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgICByZXR1cm4gdG9JbnQoYXV0b3BsYXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9JbnQoR2xpZGUuc2V0dGluZ3MuYXV0b3BsYXkpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBTdG9wIGF1dG9wbGF5aW5nIGFuZCB1bmJpbmQgZXZlbnRzOlxuICAgKiAtIG9uIGRlc3Ryb3lpbmcsIHRvIGNsZWFyIGRlZmluZWQgaW50ZXJ2YWxcbiAgICogLSBvbiB1cGRhdGluZyB2aWEgQVBJIHRvIHJlc2V0IGludGVydmFsIHRoYXQgbWF5IGNoYW5nZWRcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsnZGVzdHJveScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIEF1dG9wbGF5LnVuYmluZCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIFN0b3AgYXV0b3BsYXlpbmc6XG4gICAqIC0gYmVmb3JlIGVhY2ggcnVuLCB0byByZXN0YXJ0IGF1dG9wbGF5aW5nXG4gICAqIC0gb24gcGF1c2luZyB2aWEgQVBJXG4gICAqIC0gb24gZGVzdHJveWluZywgdG8gY2xlYXIgZGVmaW5lZCBpbnRlcnZhbFxuICAgKiAtIHdoaWxlIHN0YXJ0aW5nIGEgc3dpcGVcbiAgICogLSBvbiB1cGRhdGluZyB2aWEgQVBJIHRvIHJlc2V0IGludGVydmFsIHRoYXQgbWF5IGNoYW5nZWRcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsncnVuLmJlZm9yZScsICdzd2lwZS5zdGFydCcsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgIEF1dG9wbGF5LnN0b3AoKTtcbiAgfSk7XG4gIEV2ZW50cy5vbihbJ3BhdXNlJywgJ2Rlc3Ryb3knXSwgZnVuY3Rpb24gKCkge1xuICAgIEF1dG9wbGF5LmRpc2FibGUoKTtcbiAgICBBdXRvcGxheS5zdG9wKCk7XG4gIH0pO1xuICAvKipcbiAgICogU3RhcnQgYXV0b3BsYXlpbmc6XG4gICAqIC0gYWZ0ZXIgZWFjaCBydW4sIHRvIHJlc3RhcnQgYXV0b3BsYXlpbmdcbiAgICogLSBvbiBwbGF5aW5nIHZpYSBBUElcbiAgICogLSB3aGlsZSBlbmRpbmcgYSBzd2lwZVxuICAgKi9cblxuICBFdmVudHMub24oWydydW4uYWZ0ZXInLCAnc3dpcGUuZW5kJ10sIGZ1bmN0aW9uICgpIHtcbiAgICBBdXRvcGxheS5zdGFydCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIFN0YXJ0IGF1dG9wbGF5aW5nOlxuICAgKiAtIGFmdGVyIGVhY2ggcnVuLCB0byByZXN0YXJ0IGF1dG9wbGF5aW5nXG4gICAqIC0gb24gcGxheWluZyB2aWEgQVBJXG4gICAqIC0gd2hpbGUgZW5kaW5nIGEgc3dpcGVcbiAgICovXG5cbiAgRXZlbnRzLm9uKFsncGxheSddLCBmdW5jdGlvbiAoKSB7XG4gICAgQXV0b3BsYXkuZW5hYmxlKCk7XG4gICAgQXV0b3BsYXkuc3RhcnQoKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBSZW1vdW50IGF1dG9wbGF5aW5nOlxuICAgKiAtIG9uIHVwZGF0aW5nIHZpYSBBUEkgdG8gcmVzZXQgaW50ZXJ2YWwgdGhhdCBtYXkgY2hhbmdlZFxuICAgKi9cblxuICBFdmVudHMub24oJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBBdXRvcGxheS5tb3VudCgpO1xuICB9KTtcbiAgLyoqXG4gICAqIERlc3Ryb3kgYSBiaW5kZXI6XG4gICAqIC0gb24gZGVzdHJveWluZyBnbGlkZSBpbnN0YW5jZSB0byBjbGVhcnVwIGxpc3RlbmVyc1xuICAgKi9cblxuICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgfSk7XG4gIHJldHVybiBBdXRvcGxheTtcbn1cblxuLyoqXG4gKiBTb3J0cyBrZXlzIG9mIGJyZWFrcG9pbnQgb2JqZWN0IHNvIHRoZXkgd2lsbCBiZSBvcmRlcmVkIGZyb20gbG93ZXIgdG8gYmlnZ2VyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gc29ydEJyZWFrcG9pbnRzKHBvaW50cykge1xuICBpZiAoaXNPYmplY3QocG9pbnRzKSkge1xuICAgIHJldHVybiBzb3J0S2V5cyhwb2ludHMpO1xuICB9IGVsc2Uge1xuICAgIHdhcm4oXCJCcmVha3BvaW50cyBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIEJyZWFrcG9pbnRzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgKlxuICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgKi9cbiAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcbiAgLyoqXG4gICAqIEhvbGRzIHJlZmVyZW5jZSB0byBzZXR0aW5ncy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG4gIC8qKlxuICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gYnJlYWtwb2ludHMgb2JqZWN0IGluIHNldHRpbmdzLiBTb3J0cyBicmVha3BvaW50c1xuICAgKiBmcm9tIHNtYWxsZXIgdG8gbGFyZ2VyLiBJdCBpcyByZXF1aXJlZCBpbiBvcmRlciB0byBwcm9wZXJcbiAgICogbWF0Y2hpbmcgY3VycmVudGx5IGFjdGl2ZSBicmVha3BvaW50IHNldHRpbmdzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB2YXIgcG9pbnRzID0gc29ydEJyZWFrcG9pbnRzKHNldHRpbmdzLmJyZWFrcG9pbnRzKTtcbiAgLyoqXG4gICAqIENhY2hlIGluaXRpYWwgc2V0dGluZ3MgYmVmb3JlIG92ZXJ3cml0dGluZy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdmFyIGRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MpO1xuICB2YXIgQnJlYWtwb2ludHMgPSB7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBzZXR0aW5ncyBmb3IgY3VycmVjdGx5IG1hdGNoaW5nIG1lZGlhIGJyZWFrcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBtYXRjaDogZnVuY3Rpb24gbWF0Y2gocG9pbnRzKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5tYXRjaE1lZGlhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmb3IgKHZhciBwb2ludCBpbiBwb2ludHMpIHtcbiAgICAgICAgICBpZiAocG9pbnRzLmhhc093blByb3BlcnR5KHBvaW50KSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKFwiKG1heC13aWR0aDogXCIuY29uY2F0KHBvaW50LCBcInB4KVwiKSkubWF0Y2hlcykge1xuICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzW3BvaW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIE92ZXJ3cml0ZSBpbnN0YW5jZSBzZXR0aW5ncyB3aXRoIGN1cnJlbnRseSBtYXRjaGluZyBicmVha3BvaW50IHNldHRpbmdzLlxuICAgKiBUaGlzIGhhcHBlbnMgcmlnaHQgYWZ0ZXIgY29tcG9uZW50IGluaXRpYWxpemF0aW9uLlxuICAgKi9cblxuICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBCcmVha3BvaW50cy5tYXRjaChwb2ludHMpKTtcbiAgLyoqXG4gICAqIFVwZGF0ZSBnbGlkZSB3aXRoIHNldHRpbmdzIG9mIG1hdGNoZWQgYnJla3BvaW50OlxuICAgKiAtIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIHNsaWRlclxuICAgKi9cblxuICBCaW5kZXIub24oJ3Jlc2l6ZScsIHdpbmRvdywgdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgIEdsaWRlLnNldHRpbmdzID0gbWVyZ2VPcHRpb25zKHNldHRpbmdzLCBCcmVha3BvaW50cy5tYXRjaChwb2ludHMpKTtcbiAgfSwgR2xpZGUuc2V0dGluZ3MudGhyb3R0bGUpKTtcbiAgLyoqXG4gICAqIFJlc29ydCBhbmQgdXBkYXRlIGRlZmF1bHQgc2V0dGluZ3M6XG4gICAqIC0gb24gcmVpbml0IHZpYSBBUEksIHNvIGJyZWFrcG9pbnQgbWF0Y2hpbmcgd2lsbCBiZSBwZXJmb3JtZWQgd2l0aCBvcHRpb25zXG4gICAqL1xuXG4gIEV2ZW50cy5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgIHBvaW50cyA9IHNvcnRCcmVha3BvaW50cyhwb2ludHMpO1xuICAgIGRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MpO1xuICB9KTtcbiAgLyoqXG4gICAqIFVuYmluZCByZXNpemUgbGlzdGVuZXI6XG4gICAqIC0gb24gZGVzdHJveWluZywgdG8gYnJpbmcgbWFya3VwIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAqL1xuXG4gIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICBCaW5kZXIub2ZmKCdyZXNpemUnLCB3aW5kb3cpO1xuICB9KTtcbiAgcmV0dXJuIEJyZWFrcG9pbnRzO1xufVxuXG52YXIgQ09NUE9ORU5UUyA9IHtcbiAgLy8gUmVxdWlyZWRcbiAgSHRtbDogSHRtbCxcbiAgVHJhbnNsYXRlOiBUcmFuc2xhdGUsXG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIERpcmVjdGlvbjogRGlyZWN0aW9uLFxuICBQZWVrOiBQZWVrLFxuICBTaXplczogU2l6ZXMsXG4gIEdhcHM6IEdhcHMsXG4gIE1vdmU6IE1vdmUsXG4gIENsb25lczogQ2xvbmVzLFxuICBSZXNpemU6IFJlc2l6ZSxcbiAgQnVpbGQ6IEJ1aWxkLFxuICBSdW46IFJ1bixcbiAgLy8gT3B0aW9uYWxcbiAgU3dpcGU6IFN3aXBlLFxuICBJbWFnZXM6IEltYWdlcyxcbiAgQW5jaG9yczogQW5jaG9ycyxcbiAgQ29udHJvbHM6IENvbnRyb2xzLFxuICBLZXlib2FyZDogS2V5Ym9hcmQsXG4gIEF1dG9wbGF5OiBBdXRvcGxheSxcbiAgQnJlYWtwb2ludHM6IEJyZWFrcG9pbnRzXG59O1xuXG52YXIgR2xpZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db3JlKSB7XG4gIF9pbmhlcml0cyhHbGlkZSwgX0NvcmUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoR2xpZGUpO1xuXG4gIGZ1bmN0aW9uIEdsaWRlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbGlkZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR2xpZGUsIFt7XG4gICAga2V5OiBcIm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIGV4dGVuc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEdsaWRlLnByb3RvdHlwZSksIFwibW91bnRcIiwgdGhpcykuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKHt9LCBDT01QT05FTlRTLCBleHRlbnNpb25zKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdsaWRlO1xufShHbGlkZSQxKTtcblxuZXhwb3J0IHsgR2xpZGUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@glidejs/glide/dist/glide.esm.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;